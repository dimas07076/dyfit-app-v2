
===== ./client/dev-dist/sw.js =====
/**
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// If the loader is already loaded, just stop.
if (!self.define) {
  let registry = {};

  // Used for `eval` and `importScripts` where we can't get script URL by other means.
  // In both cases, it's safe to use a global var because those functions are synchronous.
  let nextDefineUri;

  const singleRequire = (uri, parentUri) => {
    uri = new URL(uri + ".js", parentUri).href;
    return registry[uri] || (
      
        new Promise(resolve => {
          if ("document" in self) {
            const script = document.createElement("script");
            script.src = uri;
            script.onload = resolve;
            document.head.appendChild(script);
          } else {
            nextDefineUri = uri;
            importScripts(uri);
            resolve();
          }
        })
      
      .then(() => {
        let promise = registry[uri];
        if (!promise) {
          throw new Error(`Module ${uri} didn’t register its module`);
        }
        return promise;
      })
    );
  };

  self.define = (depsNames, factory) => {
    const uri = nextDefineUri || ("document" in self ? document.currentScript.src : "") || location.href;
    if (registry[uri]) {
      // Module is already loading or loaded.
      return;
    }
    let exports = {};
    const require = depUri => singleRequire(depUri, uri);
    const specialDeps = {
      module: { uri },
      exports,
      require
    };
    registry[uri] = Promise.all(depsNames.map(
      depName => specialDeps[depName] || require(depName)
    )).then(deps => {
      factory(...deps);
      return exports;
    });
  };
}
define(['./workbox-de99a589'], (function (workbox) { 'use strict';

  self.addEventListener('message', event => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
      self.skipWaiting();
    }
  });

  /**
   * The precacheAndRoute() method efficiently caches and responds to
   * requests for URLs in the manifest.
   * See https://goo.gl/S9QRab
   */
  workbox.precacheAndRoute([{
    "url": "/index.html",
    "revision": "0.spn4i45dt2"
  }], {});
  workbox.cleanupOutdatedCaches();
  workbox.registerRoute(new workbox.NavigationRoute(workbox.createHandlerBoundToURL("/index.html"), {
    allowlist: [/^\/$/],
    denylist: [/^\/api\//]
  }));
  workbox.registerRoute(({
    url
  }) => url.pathname.startsWith("/api/"), new workbox.NetworkOnly({
    "cacheName": "api-cache",
    plugins: [new workbox.BackgroundSyncPlugin("api-queue", {
      maxRetentionTime: 1440
    })]
  }), 'GET');
  workbox.registerRoute(({
    url
  }) => url.origin === self.location.origin && !url.pathname.startsWith("/api/"), new workbox.NetworkFirst({
    "cacheName": "app-assets",
    "matchOptions": {
      "ignoreVary": true
    },
    plugins: [new workbox.ExpirationPlugin({
      maxEntries: 50,
      maxAgeSeconds: 604800
    }), new workbox.CacheableResponsePlugin({
      statuses: [0, 200]
    })]
  }), 'GET');

}));

===== ./client/dev-dist/workbox-de99a589.js =====
define(['exports'], (function (exports) { 'use strict';

    // @ts-ignore
    try {
      self['workbox:core:7.2.0'] && _();
    } catch (e) {}

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const logger = (() => {
      // Don't overwrite this value if it's already set.
      // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923
      if (!('__WB_DISABLE_DEV_LOGS' in globalThis)) {
        self.__WB_DISABLE_DEV_LOGS = false;
      }
      let inGroup = false;
      const methodToColorMap = {
        debug: `#7f8c8d`,
        log: `#2ecc71`,
        warn: `#f39c12`,
        error: `#c0392b`,
        groupCollapsed: `#3498db`,
        groupEnd: null // No colored prefix on groupEnd
      };
      const print = function (method, args) {
        if (self.__WB_DISABLE_DEV_LOGS) {
          return;
        }
        if (method === 'groupCollapsed') {
          // Safari doesn't print all console.groupCollapsed() arguments:
          // https://bugs.webkit.org/show_bug.cgi?id=182754
          if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            console[method](...args);
            return;
          }
        }
        const styles = [`background: ${methodToColorMap[method]}`, `border-radius: 0.5em`, `color: white`, `font-weight: bold`, `padding: 2px 0.5em`];
        // When in a group, the workbox prefix is not displayed.
        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];
        console[method](...logPrefix, ...args);
        if (method === 'groupCollapsed') {
          inGroup = true;
        }
        if (method === 'groupEnd') {
          inGroup = false;
        }
      };
      // eslint-disable-next-line @typescript-eslint/ban-types
      const api = {};
      const loggerMethods = Object.keys(methodToColorMap);
      for (const key of loggerMethods) {
        const method = key;
        api[method] = (...args) => {
          print(method, args);
        };
      }
      return api;
    })();

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const messages$1 = {
      'invalid-value': ({
        paramName,
        validValueDescription,
        value
      }) => {
        if (!paramName || !validValueDescription) {
          throw new Error(`Unexpected input to 'invalid-value' error.`);
        }
        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;
      },
      'not-an-array': ({
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        if (!moduleName || !className || !funcName || !paramName) {
          throw new Error(`Unexpected input to 'not-an-array' error.`);
        }
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;
      },
      'incorrect-type': ({
        expectedType,
        paramName,
        moduleName,
        className,
        funcName
      }) => {
        if (!expectedType || !paramName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'incorrect-type' error.`);
        }
        const classNameStr = className ? `${className}.` : '';
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;
      },
      'incorrect-class': ({
        expectedClassName,
        paramName,
        moduleName,
        className,
        funcName,
        isReturnValueProblem
      }) => {
        if (!expectedClassName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'incorrect-class' error.`);
        }
        const classNameStr = className ? `${className}.` : '';
        if (isReturnValueProblem) {
          return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
        }
        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;
      },
      'missing-a-method': ({
        expectedMethod,
        paramName,
        moduleName,
        className,
        funcName
      }) => {
        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {
          throw new Error(`Unexpected input to 'missing-a-method' error.`);
        }
        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;
      },
      'add-to-cache-list-unexpected-type': ({
        entry
      }) => {
        return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;
      },
      'add-to-cache-list-conflicting-entries': ({
        firstEntry,
        secondEntry
      }) => {
        if (!firstEntry || !secondEntry) {
          throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);
        }
        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;
      },
      'plugin-error-request-will-fetch': ({
        thrownErrorMessage
      }) => {
        if (!thrownErrorMessage) {
          throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);
        }
        return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;
      },
      'invalid-cache-name': ({
        cacheNameId,
        value
      }) => {
        if (!cacheNameId) {
          throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);
        }
        return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;
      },
      'unregister-route-but-not-found-with-method': ({
        method
      }) => {
        if (!method) {
          throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);
        }
        return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;
      },
      'unregister-route-route-not-registered': () => {
        return `The route you're trying to unregister was not previously ` + `registered.`;
      },
      'queue-replay-failed': ({
        name
      }) => {
        return `Replaying the background sync queue '${name}' failed.`;
      },
      'duplicate-queue-name': ({
        name
      }) => {
        return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;
      },
      'expired-test-without-max-age': ({
        methodName,
        paramName
      }) => {
        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;
      },
      'unsupported-route-type': ({
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;
      },
      'not-array-of-class': ({
        value,
        expectedClass,
        moduleName,
        className,
        funcName,
        paramName
      }) => {
        return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;
      },
      'max-entries-or-age-required': ({
        moduleName,
        className,
        funcName
      }) => {
        return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;
      },
      'statuses-or-headers-required': ({
        moduleName,
        className,
        funcName
      }) => {
        return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;
      },
      'invalid-string': ({
        moduleName,
        funcName,
        paramName
      }) => {
        if (!paramName || !moduleName || !funcName) {
          throw new Error(`Unexpected input to 'invalid-string' error.`);
        }
        return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;
      },
      'channel-name-required': () => {
        return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;
      },
      'invalid-responses-are-same-args': () => {
        return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;
      },
      'expire-custom-caches-only': () => {
        return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;
      },
      'unit-must-be-bytes': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);
        }
        return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was "${normalizedRangeHeader}"`;
      },
      'single-range-only': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'single-range-only' error.`);
        }
        return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `"${normalizedRangeHeader}"`;
      },
      'invalid-range-values': ({
        normalizedRangeHeader
      }) => {
        if (!normalizedRangeHeader) {
          throw new Error(`Unexpected input to 'invalid-range-values' error.`);
        }
        return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `"${normalizedRangeHeader}"`;
      },
      'no-range-header': () => {
        return `No Range header was found in the Request provided.`;
      },
      'range-not-satisfiable': ({
        size,
        start,
        end
      }) => {
        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;
      },
      'attempt-to-cache-non-get-request': ({
        url,
        method
      }) => {
        return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;
      },
      'cache-put-with-no-response': ({
        url
      }) => {
        return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;
      },
      'no-response': ({
        url,
        error
      }) => {
        let message = `The strategy could not generate a response for '${url}'.`;
        if (error) {
          message += ` The underlying error is ${error}.`;
        }
        return message;
      },
      'bad-precaching-response': ({
        url,
        status
      }) => {
        return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);
      },
      'non-precached-url': ({
        url
      }) => {
        return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;
      },
      'add-to-cache-list-conflicting-integrities': ({
        url
      }) => {
        return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;
      },
      'missing-precache-entry': ({
        cacheName,
        url
      }) => {
        return `Unable to find a precached response in ${cacheName} for ${url}.`;
      },
      'cross-origin-copy-response': ({
        origin
      }) => {
        return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;
      },
      'opaque-streams-source': ({
        type
      }) => {
        const message = `One of the workbox-streams sources resulted in an ` + `'${type}' response.`;
        if (type === 'opaqueredirect') {
          return `${message} Please do not use a navigation request that results ` + `in a redirect as a source.`;
        }
        return `${message} Please ensure your sources are CORS-enabled.`;
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const generatorFunction = (code, details = {}) => {
      const message = messages$1[code];
      if (!message) {
        throw new Error(`Unable to find message for code '${code}'.`);
      }
      return message(details);
    };
    const messageGenerator = generatorFunction;

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Workbox errors should be thrown with this class.
     * This allows use to ensure the type easily in tests,
     * helps developers identify errors from workbox
     * easily and allows use to optimise error
     * messages correctly.
     *
     * @private
     */
    class WorkboxError extends Error {
      /**
       *
       * @param {string} errorCode The error code that
       * identifies this particular error.
       * @param {Object=} details Any relevant arguments
       * that will help developers identify issues should
       * be added as a key on the context object.
       */
      constructor(errorCode, details) {
        const message = messageGenerator(errorCode, details);
        super(message);
        this.name = errorCode;
        this.details = details;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /*
     * This method throws if the supplied value is not an array.
     * The destructed values are required to produce a meaningful error for users.
     * The destructed and restructured object is so it's clear what is
     * needed.
     */
    const isArray = (value, details) => {
      if (!Array.isArray(value)) {
        throw new WorkboxError('not-an-array', details);
      }
    };
    const hasMethod = (object, expectedMethod, details) => {
      const type = typeof object[expectedMethod];
      if (type !== 'function') {
        details['expectedMethod'] = expectedMethod;
        throw new WorkboxError('missing-a-method', details);
      }
    };
    const isType = (object, expectedType, details) => {
      if (typeof object !== expectedType) {
        details['expectedType'] = expectedType;
        throw new WorkboxError('incorrect-type', details);
      }
    };
    const isInstance = (object,
    // Need the general type to do the check later.
    // eslint-disable-next-line @typescript-eslint/ban-types
    expectedClass, details) => {
      if (!(object instanceof expectedClass)) {
        details['expectedClassName'] = expectedClass.name;
        throw new WorkboxError('incorrect-class', details);
      }
    };
    const isOneOf = (value, validValues, details) => {
      if (!validValues.includes(value)) {
        details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;
        throw new WorkboxError('invalid-value', details);
      }
    };
    const isArrayOfClass = (value,
    // Need general type to do check later.
    expectedClass,
    // eslint-disable-line
    details) => {
      const error = new WorkboxError('not-array-of-class', details);
      if (!Array.isArray(value)) {
        throw error;
      }
      for (const item of value) {
        if (!(item instanceof expectedClass)) {
          throw error;
        }
      }
    };
    const finalAssertExports = {
      hasMethod,
      isArray,
      isInstance,
      isOneOf,
      isType,
      isArrayOfClass
    };

    // @ts-ignore
    try {
      self['workbox:routing:7.2.0'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The default HTTP method, 'GET', used when there's no specific method
     * configured for a route.
     *
     * @type {string}
     *
     * @private
     */
    const defaultMethod = 'GET';
    /**
     * The list of valid HTTP methods associated with requests that could be routed.
     *
     * @type {Array<string>}
     *
     * @private
     */
    const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * @param {function()|Object} handler Either a function, or an object with a
     * 'handle' method.
     * @return {Object} An object with a handle method.
     *
     * @private
     */
    const normalizeHandler = handler => {
      if (handler && typeof handler === 'object') {
        {
          finalAssertExports.hasMethod(handler, 'handle', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'handler'
          });
        }
        return handler;
      } else {
        {
          finalAssertExports.isType(handler, 'function', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'handler'
          });
        }
        return {
          handle: handler
        };
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A `Route` consists of a pair of callback functions, "match" and "handler".
     * The "match" callback determine if a route should be used to "handle" a
     * request by returning a non-falsy value if it can. The "handler" callback
     * is called when there is a match and should return a Promise that resolves
     * to a `Response`.
     *
     * @memberof workbox-routing
     */
    class Route {
      /**
       * Constructor for Route class.
       *
       * @param {workbox-routing~matchCallback} match
       * A callback function that determines whether the route matches a given
       * `fetch` event by returning a non-falsy value.
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resolving to a Response.
       * @param {string} [method='GET'] The HTTP method to match the Route
       * against.
       */
      constructor(match, handler, method = defaultMethod) {
        {
          finalAssertExports.isType(match, 'function', {
            moduleName: 'workbox-routing',
            className: 'Route',
            funcName: 'constructor',
            paramName: 'match'
          });
          if (method) {
            finalAssertExports.isOneOf(method, validMethods, {
              paramName: 'method'
            });
          }
        }
        // These values are referenced directly by Router so cannot be
        // altered by minificaton.
        this.handler = normalizeHandler(handler);
        this.match = match;
        this.method = method;
      }
      /**
       *
       * @param {workbox-routing-handlerCallback} handler A callback
       * function that returns a Promise resolving to a Response
       */
      setCatchHandler(handler) {
        this.catchHandler = normalizeHandler(handler);
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * RegExpRoute makes it easy to create a regular expression based
     * {@link workbox-routing.Route}.
     *
     * For same-origin requests the RegExp only needs to match part of the URL. For
     * requests against third-party servers, you must define a RegExp that matches
     * the start of the URL.
     *
     * @memberof workbox-routing
     * @extends workbox-routing.Route
     */
    class RegExpRoute extends Route {
      /**
       * If the regular expression contains
       * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},
       * the captured values will be passed to the
       * {@link workbox-routing~handlerCallback} `params`
       * argument.
       *
       * @param {RegExp} regExp The regular expression to match against URLs.
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {string} [method='GET'] The HTTP method to match the Route
       * against.
       */
      constructor(regExp, handler, method) {
        {
          finalAssertExports.isInstance(regExp, RegExp, {
            moduleName: 'workbox-routing',
            className: 'RegExpRoute',
            funcName: 'constructor',
            paramName: 'pattern'
          });
        }
        const match = ({
          url
        }) => {
          const result = regExp.exec(url.href);
          // Return immediately if there's no match.
          if (!result) {
            return;
          }
          // Require that the match start at the first character in the URL string
          // if it's a cross-origin request.
          // See https://github.com/GoogleChrome/workbox/issues/281 for the context
          // behind this behavior.
          if (url.origin !== location.origin && result.index !== 0) {
            {
              logger.debug(`The regular expression '${regExp.toString()}' only partially matched ` + `against the cross-origin URL '${url.toString()}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);
            }
            return;
          }
          // If the route matches, but there aren't any capture groups defined, then
          // this will return [], which is truthy and therefore sufficient to
          // indicate a match.
          // If there are capture groups, then it will return their values.
          return result.slice(1);
        };
        super(match, handler, method);
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const getFriendlyURL = url => {
      const urlObj = new URL(String(url), location.href);
      // See https://github.com/GoogleChrome/workbox/issues/2323
      // We want to include everything, except for the origin if it's same-origin.
      return urlObj.href.replace(new RegExp(`^${location.origin}`), '');
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The Router can be used to process a `FetchEvent` using one or more
     * {@link workbox-routing.Route}, responding with a `Response` if
     * a matching route exists.
     *
     * If no route matches a given a request, the Router will use a "default"
     * handler if one is defined.
     *
     * Should the matching Route throw an error, the Router will use a "catch"
     * handler if one is defined to gracefully deal with issues and respond with a
     * Request.
     *
     * If a request matches multiple routes, the **earliest** registered route will
     * be used to respond to the request.
     *
     * @memberof workbox-routing
     */
    class Router {
      /**
       * Initializes a new Router.
       */
      constructor() {
        this._routes = new Map();
        this._defaultHandlerMap = new Map();
      }
      /**
       * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP
       * method name ('GET', etc.) to an array of all the corresponding `Route`
       * instances that are registered.
       */
      get routes() {
        return this._routes;
      }
      /**
       * Adds a fetch event listener to respond to events when a route matches
       * the event's request.
       */
      addFetchListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('fetch', event => {
          const {
            request
          } = event;
          const responsePromise = this.handleRequest({
            request,
            event
          });
          if (responsePromise) {
            event.respondWith(responsePromise);
          }
        });
      }
      /**
       * Adds a message event listener for URLs to cache from the window.
       * This is useful to cache resources loaded on the page prior to when the
       * service worker started controlling it.
       *
       * The format of the message data sent from the window should be as follows.
       * Where the `urlsToCache` array may consist of URL strings or an array of
       * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
       *
       * ```
       * {
       *   type: 'CACHE_URLS',
       *   payload: {
       *     urlsToCache: [
       *       './script1.js',
       *       './script2.js',
       *       ['./script3.js', {mode: 'no-cors'}],
       *     ],
       *   },
       * }
       * ```
       */
      addCacheListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('message', event => {
          // event.data is type 'any'
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (event.data && event.data.type === 'CACHE_URLS') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const {
              payload
            } = event.data;
            {
              logger.debug(`Caching URLs from the window`, payload.urlsToCache);
            }
            const requestPromises = Promise.all(payload.urlsToCache.map(entry => {
              if (typeof entry === 'string') {
                entry = [entry];
              }
              const request = new Request(...entry);
              return this.handleRequest({
                request,
                event
              });
              // TODO(philipwalton): TypeScript errors without this typecast for
              // some reason (probably a bug). The real type here should work but
              // doesn't: `Array<Promise<Response> | undefined>`.
            })); // TypeScript
            event.waitUntil(requestPromises);
            // If a MessageChannel was used, reply to the message on success.
            if (event.ports && event.ports[0]) {
              void requestPromises.then(() => event.ports[0].postMessage(true));
            }
          }
        });
      }
      /**
       * Apply the routing rules to a FetchEvent object to get a Response from an
       * appropriate Route's handler.
       *
       * @param {Object} options
       * @param {Request} options.request The request to handle.
       * @param {ExtendableEvent} options.event The event that triggered the
       *     request.
       * @return {Promise<Response>|undefined} A promise is returned if a
       *     registered route can handle the request. If there is no matching
       *     route and there's no `defaultHandler`, `undefined` is returned.
       */
      handleRequest({
        request,
        event
      }) {
        {
          finalAssertExports.isInstance(request, Request, {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'handleRequest',
            paramName: 'options.request'
          });
        }
        const url = new URL(request.url, location.href);
        if (!url.protocol.startsWith('http')) {
          {
            logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
          }
          return;
        }
        const sameOrigin = url.origin === location.origin;
        const {
          params,
          route
        } = this.findMatchingRoute({
          event,
          request,
          sameOrigin,
          url
        });
        let handler = route && route.handler;
        const debugMessages = [];
        {
          if (handler) {
            debugMessages.push([`Found a route to handle this request:`, route]);
            if (params) {
              debugMessages.push([`Passing the following params to the route's handler:`, params]);
            }
          }
        }
        // If we don't have a handler because there was no matching route, then
        // fall back to defaultHandler if that's defined.
        const method = request.method;
        if (!handler && this._defaultHandlerMap.has(method)) {
          {
            debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler for ${method}.`);
          }
          handler = this._defaultHandlerMap.get(method);
        }
        if (!handler) {
          {
            // No handler so Workbox will do nothing. If logs is set of debug
            // i.e. verbose, we should print out this information.
            logger.debug(`No route found for: ${getFriendlyURL(url)}`);
          }
          return;
        }
        {
          // We have a handler, meaning Workbox is going to handle the route.
          // print the routing details to the console.
          logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);
          debugMessages.forEach(msg => {
            if (Array.isArray(msg)) {
              logger.log(...msg);
            } else {
              logger.log(msg);
            }
          });
          logger.groupEnd();
        }
        // Wrap in try and catch in case the handle method throws a synchronous
        // error. It should still callback to the catch handler.
        let responsePromise;
        try {
          responsePromise = handler.handle({
            url,
            request,
            event,
            params
          });
        } catch (err) {
          responsePromise = Promise.reject(err);
        }
        // Get route's catch handler, if it exists
        const catchHandler = route && route.catchHandler;
        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {
          responsePromise = responsePromise.catch(async err => {
            // If there's a route catch handler, process that first
            if (catchHandler) {
              {
                // Still include URL here as it will be async from the console group
                // and may not make sense without the URL
                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);
                logger.error(`Error thrown by:`, route);
                logger.error(err);
                logger.groupEnd();
              }
              try {
                return await catchHandler.handle({
                  url,
                  request,
                  event,
                  params
                });
              } catch (catchErr) {
                if (catchErr instanceof Error) {
                  err = catchErr;
                }
              }
            }
            if (this._catchHandler) {
              {
                // Still include URL here as it will be async from the console group
                // and may not make sense without the URL
                logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);
                logger.error(`Error thrown by:`, route);
                logger.error(err);
                logger.groupEnd();
              }
              return this._catchHandler.handle({
                url,
                request,
                event
              });
            }
            throw err;
          });
        }
        return responsePromise;
      }
      /**
       * Checks a request and URL (and optionally an event) against the list of
       * registered routes, and if there's a match, returns the corresponding
       * route along with any params generated by the match.
       *
       * @param {Object} options
       * @param {URL} options.url
       * @param {boolean} options.sameOrigin The result of comparing `url.origin`
       *     against the current origin.
       * @param {Request} options.request The request to match.
       * @param {Event} options.event The corresponding event.
       * @return {Object} An object with `route` and `params` properties.
       *     They are populated if a matching route was found or `undefined`
       *     otherwise.
       */
      findMatchingRoute({
        url,
        sameOrigin,
        request,
        event
      }) {
        const routes = this._routes.get(request.method) || [];
        for (const route of routes) {
          let params;
          // route.match returns type any, not possible to change right now.
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          const matchResult = route.match({
            url,
            sameOrigin,
            request,
            event
          });
          if (matchResult) {
            {
              // Warn developers that using an async matchCallback is almost always
              // not the right thing to do.
              if (matchResult instanceof Promise) {
                logger.warn(`While routing ${getFriendlyURL(url)}, an async ` + `matchCallback function was used. Please convert the ` + `following route to use a synchronous matchCallback function:`, route);
              }
            }
            // See https://github.com/GoogleChrome/workbox/issues/2079
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            params = matchResult;
            if (Array.isArray(params) && params.length === 0) {
              // Instead of passing an empty array in as params, use undefined.
              params = undefined;
            } else if (matchResult.constructor === Object &&
            // eslint-disable-line
            Object.keys(matchResult).length === 0) {
              // Instead of passing an empty object in as params, use undefined.
              params = undefined;
            } else if (typeof matchResult === 'boolean') {
              // For the boolean value true (rather than just something truth-y),
              // don't set params.
              // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
              params = undefined;
            }
            // Return early if have a match.
            return {
              route,
              params
            };
          }
        }
        // If no match was found above, return and empty object.
        return {};
      }
      /**
       * Define a default `handler` that's called when no routes explicitly
       * match the incoming request.
       *
       * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
       *
       * Without a default handler, unmatched requests will go against the
       * network as if there were no service worker present.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {string} [method='GET'] The HTTP method to associate with this
       * default handler. Each method has its own default.
       */
      setDefaultHandler(handler, method = defaultMethod) {
        this._defaultHandlerMap.set(method, normalizeHandler(handler));
      }
      /**
       * If a Route throws an error while handling a request, this `handler`
       * will be called and given a chance to provide a response.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       */
      setCatchHandler(handler) {
        this._catchHandler = normalizeHandler(handler);
      }
      /**
       * Registers a route with the router.
       *
       * @param {workbox-routing.Route} route The route to register.
       */
      registerRoute(route) {
        {
          finalAssertExports.isType(route, 'object', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.hasMethod(route, 'match', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.isType(route.handler, 'object', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route'
          });
          finalAssertExports.hasMethod(route.handler, 'handle', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route.handler'
          });
          finalAssertExports.isType(route.method, 'string', {
            moduleName: 'workbox-routing',
            className: 'Router',
            funcName: 'registerRoute',
            paramName: 'route.method'
          });
        }
        if (!this._routes.has(route.method)) {
          this._routes.set(route.method, []);
        }
        // Give precedence to all of the earlier routes by adding this additional
        // route to the end of the array.
        this._routes.get(route.method).push(route);
      }
      /**
       * Unregisters a route with the router.
       *
       * @param {workbox-routing.Route} route The route to unregister.
       */
      unregisterRoute(route) {
        if (!this._routes.has(route.method)) {
          throw new WorkboxError('unregister-route-but-not-found-with-method', {
            method: route.method
          });
        }
        const routeIndex = this._routes.get(route.method).indexOf(route);
        if (routeIndex > -1) {
          this._routes.get(route.method).splice(routeIndex, 1);
        } else {
          throw new WorkboxError('unregister-route-route-not-registered');
        }
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    let defaultRouter;
    /**
     * Creates a new, singleton Router instance if one does not exist. If one
     * does already exist, that instance is returned.
     *
     * @private
     * @return {Router}
     */
    const getOrCreateDefaultRouter = () => {
      if (!defaultRouter) {
        defaultRouter = new Router();
        // The helpers that use the default Router assume these listeners exist.
        defaultRouter.addFetchListener();
        defaultRouter.addCacheListener();
      }
      return defaultRouter;
    };

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Easily register a RegExp, string, or function with a caching
     * strategy to a singleton Router instance.
     *
     * This method will generate a Route for you if needed and
     * call {@link workbox-routing.Router#registerRoute}.
     *
     * @param {RegExp|string|workbox-routing.Route~matchCallback|workbox-routing.Route} capture
     * If the capture param is a `Route`, all other arguments will be ignored.
     * @param {workbox-routing~handlerCallback} [handler] A callback
     * function that returns a Promise resulting in a Response. This parameter
     * is required if `capture` is not a `Route` object.
     * @param {string} [method='GET'] The HTTP method to match the Route
     * against.
     * @return {workbox-routing.Route} The generated `Route`.
     *
     * @memberof workbox-routing
     */
    function registerRoute(capture, handler, method) {
      let route;
      if (typeof capture === 'string') {
        const captureUrl = new URL(capture, location.href);
        {
          if (!(capture.startsWith('/') || capture.startsWith('http'))) {
            throw new WorkboxError('invalid-string', {
              moduleName: 'workbox-routing',
              funcName: 'registerRoute',
              paramName: 'capture'
            });
          }
          // We want to check if Express-style wildcards are in the pathname only.
          // TODO: Remove this log message in v4.
          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture;
          // See https://github.com/pillarjs/path-to-regexp#parameters
          const wildcards = '[*:?+]';
          if (new RegExp(`${wildcards}`).exec(valueToCheck)) {
            logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);
          }
        }
        const matchCallback = ({
          url
        }) => {
          {
            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {
              logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url.toString()}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);
            }
          }
          return url.href === captureUrl.href;
        };
        // If `capture` is a string then `handler` and `method` must be present.
        route = new Route(matchCallback, handler, method);
      } else if (capture instanceof RegExp) {
        // If `capture` is a `RegExp` then `handler` and `method` must be present.
        route = new RegExpRoute(capture, handler, method);
      } else if (typeof capture === 'function') {
        // If `capture` is a function then `handler` and `method` must be present.
        route = new Route(capture, handler, method);
      } else if (capture instanceof Route) {
        route = capture;
      } else {
        throw new WorkboxError('unsupported-route-type', {
          moduleName: 'workbox-routing',
          funcName: 'registerRoute',
          paramName: 'capture'
        });
      }
      const defaultRouter = getOrCreateDefaultRouter();
      defaultRouter.registerRoute(route);
      return route;
    }

    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends.apply(null, arguments);
    }

    const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);
    let idbProxyableTypes;
    let cursorAdvanceMethods;
    // This is a function to prevent it throwing up in node environments.
    function getIdbProxyableTypes() {
      return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
    }
    // This is a function to prevent it throwing up in node environments.
    function getCursorAdvanceMethods() {
      return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);
    }
    const cursorRequestMap = new WeakMap();
    const transactionDoneMap = new WeakMap();
    const transactionStoreNamesMap = new WeakMap();
    const transformCache = new WeakMap();
    const reverseTransformCache = new WeakMap();
    function promisifyRequest(request) {
      const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
          request.removeEventListener('success', success);
          request.removeEventListener('error', error);
        };
        const success = () => {
          resolve(wrap(request.result));
          unlisten();
        };
        const error = () => {
          reject(request.error);
          unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
      });
      promise.then(value => {
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) {
          cursorRequestMap.set(value, request);
        }
        // Catching to avoid "Uncaught Promise exceptions"
      }).catch(() => {});
      // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
      // is because we create many promises from a single IDBRequest.
      reverseTransformCache.set(promise, request);
      return promise;
    }
    function cacheDonePromiseForTransaction(tx) {
      // Early bail if we've already created a done promise for this transaction.
      if (transactionDoneMap.has(tx)) return;
      const done = new Promise((resolve, reject) => {
        const unlisten = () => {
          tx.removeEventListener('complete', complete);
          tx.removeEventListener('error', error);
          tx.removeEventListener('abort', error);
        };
        const complete = () => {
          resolve();
          unlisten();
        };
        const error = () => {
          reject(tx.error || new DOMException('AbortError', 'AbortError'));
          unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
      });
      // Cache it for later retrieval.
      transactionDoneMap.set(tx, done);
    }
    let idbProxyTraps = {
      get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
          // Special handling for transaction.done.
          if (prop === 'done') return transactionDoneMap.get(target);
          // Polyfill for objectStoreNames because of Edge.
          if (prop === 'objectStoreNames') {
            return target.objectStoreNames || transactionStoreNamesMap.get(target);
          }
          // Make tx.store return the only store in the transaction, or undefined if there are many.
          if (prop === 'store') {
            return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);
          }
        }
        // Else transform whatever we get back.
        return wrap(target[prop]);
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      },
      has(target, prop) {
        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {
          return true;
        }
        return prop in target;
      }
    };
    function replaceTraps(callback) {
      idbProxyTraps = callback(idbProxyTraps);
    }
    function wrapFunction(func) {
      // Due to expected object equality (which is enforced by the caching in `wrap`), we
      // only create one new func per func.
      // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
      if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {
        return function (storeNames, ...args) {
          const tx = func.call(unwrap(this), storeNames, ...args);
          transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
          return wrap(tx);
        };
      }
      // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
      // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
      // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
      // with real promises, so each advance methods returns a new promise for the cursor object, or
      // undefined if the end of the cursor has been reached.
      if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
          // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
          // the original object.
          func.apply(unwrap(this), args);
          return wrap(cursorRequestMap.get(this));
        };
      }
      return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
      };
    }
    function transformCachableValue(value) {
      if (typeof value === 'function') return wrapFunction(value);
      // This doesn't return, it just creates a 'done' promise for the transaction,
      // which is later returned for transaction.done (see idbObjectHandler).
      if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);
      if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps);
      // Return the same value back if we're not going to transform it.
      return value;
    }
    function wrap(value) {
      // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
      // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
      if (value instanceof IDBRequest) return promisifyRequest(value);
      // If we've already transformed this value before, reuse the transformed value.
      // This is faster, but it also provides object equality.
      if (transformCache.has(value)) return transformCache.get(value);
      const newValue = transformCachableValue(value);
      // Not all types are transformed.
      // These may be primitive types, so they can't be WeakMap keys.
      if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
      }
      return newValue;
    }
    const unwrap = value => reverseTransformCache.get(value);

    /**
     * Open a database.
     *
     * @param name Name of the database.
     * @param version Schema version.
     * @param callbacks Additional callbacks.
     */
    function openDB(name, version, {
      blocked,
      upgrade,
      blocking,
      terminated
    } = {}) {
      const request = indexedDB.open(name, version);
      const openPromise = wrap(request);
      if (upgrade) {
        request.addEventListener('upgradeneeded', event => {
          upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
        });
      }
      if (blocked) {
        request.addEventListener('blocked', event => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event.newVersion, event));
      }
      openPromise.then(db => {
        if (terminated) db.addEventListener('close', () => terminated());
        if (blocking) {
          db.addEventListener('versionchange', event => blocking(event.oldVersion, event.newVersion, event));
        }
      }).catch(() => {});
      return openPromise;
    }
    /**
     * Delete a database.
     *
     * @param name Name of the database.
     */
    function deleteDB(name, {
      blocked
    } = {}) {
      const request = indexedDB.deleteDatabase(name);
      if (blocked) {
        request.addEventListener('blocked', event => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion, event));
      }
      return wrap(request).then(() => undefined);
    }
    const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
    const writeMethods = ['put', 'add', 'delete', 'clear'];
    const cachedMethods = new Map();
    function getMethod(target, prop) {
      if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {
        return;
      }
      if (cachedMethods.get(prop)) return cachedMethods.get(prop);
      const targetFuncName = prop.replace(/FromIndex$/, '');
      const useIndex = prop !== targetFuncName;
      const isWrite = writeMethods.includes(targetFuncName);
      if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
        return;
      }
      const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex) target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];
      };
      cachedMethods.set(prop, method);
      return method;
    }
    replaceTraps(oldTraps => _extends({}, oldTraps, {
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
    }));

    // @ts-ignore
    try {
      self['workbox:background-sync:7.2.0'] && _();
    } catch (e) {}

    /*
      Copyright 2021 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const DB_VERSION = 3;
    const DB_NAME$1 = 'workbox-background-sync';
    const REQUEST_OBJECT_STORE_NAME = 'requests';
    const QUEUE_NAME_INDEX = 'queueName';
    /**
     * A class to interact directly an IndexedDB created specifically to save and
     * retrieve QueueStoreEntries. This class encapsulates all the schema details
     * to store the representation of a Queue.
     *
     * @private
     */
    class QueueDb {
      constructor() {
        this._db = null;
      }
      /**
       * Add QueueStoreEntry to underlying db.
       *
       * @param {UnidentifiedQueueStoreEntry} entry
       */
      async addEntry(entry) {
        const db = await this.getDb();
        const tx = db.transaction(REQUEST_OBJECT_STORE_NAME, 'readwrite', {
          durability: 'relaxed'
        });
        await tx.store.add(entry);
        await tx.done;
      }
      /**
       * Returns the first entry id in the ObjectStore.
       *
       * @return {number | undefined}
       */
      async getFirstEntryId() {
        const db = await this.getDb();
        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.openCursor();
        return cursor === null || cursor === void 0 ? void 0 : cursor.value.id;
      }
      /**
       * Get all the entries filtered by index
       *
       * @param queueName
       * @return {Promise<QueueStoreEntry[]>}
       */
      async getAllEntriesByQueueName(queueName) {
        const db = await this.getDb();
        const results = await db.getAllFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));
        return results ? results : new Array();
      }
      /**
       * Returns the number of entries filtered by index
       *
       * @param queueName
       * @return {Promise<number>}
       */
      async getEntryCountByQueueName(queueName) {
        const db = await this.getDb();
        return db.countFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));
      }
      /**
       * Deletes a single entry by id.
       *
       * @param {number} id the id of the entry to be deleted
       */
      async deleteEntry(id) {
        const db = await this.getDb();
        await db.delete(REQUEST_OBJECT_STORE_NAME, id);
      }
      /**
       *
       * @param queueName
       * @returns {Promise<QueueStoreEntry | undefined>}
       */
      async getFirstEntryByQueueName(queueName) {
        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), 'next');
      }
      /**
       *
       * @param queueName
       * @returns {Promise<QueueStoreEntry | undefined>}
       */
      async getLastEntryByQueueName(queueName) {
        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), 'prev');
      }
      /**
       * Returns either the first or the last entries, depending on direction.
       * Filtered by index.
       *
       * @param {IDBCursorDirection} direction
       * @param {IDBKeyRange} query
       * @return {Promise<QueueStoreEntry | undefined>}
       * @private
       */
      async getEndEntryFromIndex(query, direction) {
        const db = await this.getDb();
        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.index(QUEUE_NAME_INDEX).openCursor(query, direction);
        return cursor === null || cursor === void 0 ? void 0 : cursor.value;
      }
      /**
       * Returns an open connection to the database.
       *
       * @private
       */
      async getDb() {
        if (!this._db) {
          this._db = await openDB(DB_NAME$1, DB_VERSION, {
            upgrade: this._upgradeDb
          });
        }
        return this._db;
      }
      /**
       * Upgrades QueueDB
       *
       * @param {IDBPDatabase<QueueDBSchema>} db
       * @param {number} oldVersion
       * @private
       */
      _upgradeDb(db, oldVersion) {
        if (oldVersion > 0 && oldVersion < DB_VERSION) {
          if (db.objectStoreNames.contains(REQUEST_OBJECT_STORE_NAME)) {
            db.deleteObjectStore(REQUEST_OBJECT_STORE_NAME);
          }
        }
        const objStore = db.createObjectStore(REQUEST_OBJECT_STORE_NAME, {
          autoIncrement: true,
          keyPath: 'id'
        });
        objStore.createIndex(QUEUE_NAME_INDEX, QUEUE_NAME_INDEX, {
          unique: false
        });
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A class to manage storing requests from a Queue in IndexedDB,
     * indexed by their queue name for easier access.
     *
     * Most developers will not need to access this class directly;
     * it is exposed for advanced use cases.
     */
    class QueueStore {
      /**
       * Associates this instance with a Queue instance, so entries added can be
       * identified by their queue name.
       *
       * @param {string} queueName
       */
      constructor(queueName) {
        this._queueName = queueName;
        this._queueDb = new QueueDb();
      }
      /**
       * Append an entry last in the queue.
       *
       * @param {Object} entry
       * @param {Object} entry.requestData
       * @param {number} [entry.timestamp]
       * @param {Object} [entry.metadata]
       */
      async pushEntry(entry) {
        {
          finalAssertExports.isType(entry, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'pushEntry',
            paramName: 'entry'
          });
          finalAssertExports.isType(entry.requestData, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'pushEntry',
            paramName: 'entry.requestData'
          });
        }
        // Don't specify an ID since one is automatically generated.
        delete entry.id;
        entry.queueName = this._queueName;
        await this._queueDb.addEntry(entry);
      }
      /**
       * Prepend an entry first in the queue.
       *
       * @param {Object} entry
       * @param {Object} entry.requestData
       * @param {number} [entry.timestamp]
       * @param {Object} [entry.metadata]
       */
      async unshiftEntry(entry) {
        {
          finalAssertExports.isType(entry, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'unshiftEntry',
            paramName: 'entry'
          });
          finalAssertExports.isType(entry.requestData, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'QueueStore',
            funcName: 'unshiftEntry',
            paramName: 'entry.requestData'
          });
        }
        const firstId = await this._queueDb.getFirstEntryId();
        if (firstId) {
          // Pick an ID one less than the lowest ID in the object store.
          entry.id = firstId - 1;
        } else {
          // Otherwise let the auto-incrementor assign the ID.
          delete entry.id;
        }
        entry.queueName = this._queueName;
        await this._queueDb.addEntry(entry);
      }
      /**
       * Removes and returns the last entry in the queue matching the `queueName`.
       *
       * @return {Promise<QueueStoreEntry|undefined>}
       */
      async popEntry() {
        return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName));
      }
      /**
       * Removes and returns the first entry in the queue matching the `queueName`.
       *
       * @return {Promise<QueueStoreEntry|undefined>}
       */
      async shiftEntry() {
        return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName));
      }
      /**
       * Returns all entries in the store matching the `queueName`.
       *
       * @param {Object} options See {@link workbox-background-sync.Queue~getAll}
       * @return {Promise<Array<Object>>}
       */
      async getAll() {
        return await this._queueDb.getAllEntriesByQueueName(this._queueName);
      }
      /**
       * Returns the number of entries in the store matching the `queueName`.
       *
       * @param {Object} options See {@link workbox-background-sync.Queue~size}
       * @return {Promise<number>}
       */
      async size() {
        return await this._queueDb.getEntryCountByQueueName(this._queueName);
      }
      /**
       * Deletes the entry for the given ID.
       *
       * WARNING: this method does not ensure the deleted entry belongs to this
       * queue (i.e. matches the `queueName`). But this limitation is acceptable
       * as this class is not publicly exposed. An additional check would make
       * this method slower than it needs to be.
       *
       * @param {number} id
       */
      async deleteEntry(id) {
        await this._queueDb.deleteEntry(id);
      }
      /**
       * Removes and returns the first or last entry in the queue (based on the
       * `direction` argument) matching the `queueName`.
       *
       * @return {Promise<QueueStoreEntry|undefined>}
       * @private
       */
      async _removeEntry(entry) {
        if (entry) {
          await this.deleteEntry(entry.id);
        }
        return entry;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const serializableProperties = ['method', 'referrer', 'referrerPolicy', 'mode', 'credentials', 'cache', 'redirect', 'integrity', 'keepalive'];
    /**
     * A class to make it easier to serialize and de-serialize requests so they
     * can be stored in IndexedDB.
     *
     * Most developers will not need to access this class directly;
     * it is exposed for advanced use cases.
     */
    class StorableRequest {
      /**
       * Converts a Request object to a plain object that can be structured
       * cloned or JSON-stringified.
       *
       * @param {Request} request
       * @return {Promise<StorableRequest>}
       */
      static async fromRequest(request) {
        const requestData = {
          url: request.url,
          headers: {}
        };
        // Set the body if present.
        if (request.method !== 'GET') {
          // Use ArrayBuffer to support non-text request bodies.
          // NOTE: we can't use Blobs becuse Safari doesn't support storing
          // Blobs in IndexedDB in some cases:
          // https://github.com/dfahlander/Dexie.js/issues/618#issuecomment-398348457
          requestData.body = await request.clone().arrayBuffer();
        }
        // Convert the headers from an iterable to an object.
        for (const [key, value] of request.headers.entries()) {
          requestData.headers[key] = value;
        }
        // Add all other serializable request properties
        for (const prop of serializableProperties) {
          if (request[prop] !== undefined) {
            requestData[prop] = request[prop];
          }
        }
        return new StorableRequest(requestData);
      }
      /**
       * Accepts an object of request data that can be used to construct a
       * `Request` but can also be stored in IndexedDB.
       *
       * @param {Object} requestData An object of request data that includes the
       *     `url` plus any relevant properties of
       *     [requestInit]{@link https://fetch.spec.whatwg.org/#requestinit}.
       */
      constructor(requestData) {
        {
          finalAssertExports.isType(requestData, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'StorableRequest',
            funcName: 'constructor',
            paramName: 'requestData'
          });
          finalAssertExports.isType(requestData.url, 'string', {
            moduleName: 'workbox-background-sync',
            className: 'StorableRequest',
            funcName: 'constructor',
            paramName: 'requestData.url'
          });
        }
        // If the request's mode is `navigate`, convert it to `same-origin` since
        // navigation requests can't be constructed via script.
        if (requestData['mode'] === 'navigate') {
          requestData['mode'] = 'same-origin';
        }
        this._requestData = requestData;
      }
      /**
       * Returns a deep clone of the instances `_requestData` object.
       *
       * @return {Object}
       */
      toObject() {
        const requestData = Object.assign({}, this._requestData);
        requestData.headers = Object.assign({}, this._requestData.headers);
        if (requestData.body) {
          requestData.body = requestData.body.slice(0);
        }
        return requestData;
      }
      /**
       * Converts this instance to a Request.
       *
       * @return {Request}
       */
      toRequest() {
        return new Request(this._requestData.url, this._requestData);
      }
      /**
       * Creates and returns a deep clone of the instance.
       *
       * @return {StorableRequest}
       */
      clone() {
        return new StorableRequest(this.toObject());
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const TAG_PREFIX = 'workbox-background-sync';
    const MAX_RETENTION_TIME = 60 * 24 * 7; // 7 days in minutes
    const queueNames = new Set();
    /**
     * Converts a QueueStore entry into the format exposed by Queue. This entails
     * converting the request data into a real request and omitting the `id` and
     * `queueName` properties.
     *
     * @param {UnidentifiedQueueStoreEntry} queueStoreEntry
     * @return {Queue}
     * @private
     */
    const convertEntry = queueStoreEntry => {
      const queueEntry = {
        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),
        timestamp: queueStoreEntry.timestamp
      };
      if (queueStoreEntry.metadata) {
        queueEntry.metadata = queueStoreEntry.metadata;
      }
      return queueEntry;
    };
    /**
     * A class to manage storing failed requests in IndexedDB and retrying them
     * later. All parts of the storing and replaying process are observable via
     * callbacks.
     *
     * @memberof workbox-background-sync
     */
    class Queue {
      /**
       * Creates an instance of Queue with the given options
       *
       * @param {string} name The unique name for this queue. This name must be
       *     unique as it's used to register sync events and store requests
       *     in IndexedDB specific to this instance. An error will be thrown if
       *     a duplicate name is detected.
       * @param {Object} [options]
       * @param {Function} [options.onSync] A function that gets invoked whenever
       *     the 'sync' event fires. The function is invoked with an object
       *     containing the `queue` property (referencing this instance), and you
       *     can use the callback to customize the replay behavior of the queue.
       *     When not set the `replayRequests()` method is called.
       *     Note: if the replay fails after a sync event, make sure you throw an
       *     error, so the browser knows to retry the sync event later.
       * @param {number} [options.maxRetentionTime=7 days] The amount of time (in
       *     minutes) a request may be retried. After this amount of time has
       *     passed, the request will be deleted from the queue.
       * @param {boolean} [options.forceSyncFallback=false] If `true`, instead
       *     of attempting to use background sync events, always attempt to replay
       *     queued request at service worker startup. Most folks will not need
       *     this, unless you explicitly target a runtime like Electron that
       *     exposes the interfaces for background sync, but does not have a working
       *     implementation.
       */
      constructor(name, {
        forceSyncFallback,
        onSync,
        maxRetentionTime
      } = {}) {
        this._syncInProgress = false;
        this._requestsAddedDuringSync = false;
        // Ensure the store name is not already being used
        if (queueNames.has(name)) {
          throw new WorkboxError('duplicate-queue-name', {
            name
          });
        } else {
          queueNames.add(name);
        }
        this._name = name;
        this._onSync = onSync || this.replayRequests;
        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;
        this._forceSyncFallback = Boolean(forceSyncFallback);
        this._queueStore = new QueueStore(this._name);
        this._addSyncListener();
      }
      /**
       * @return {string}
       */
      get name() {
        return this._name;
      }
      /**
       * Stores the passed request in IndexedDB (with its timestamp and any
       * metadata) at the end of the queue.
       *
       * @param {QueueEntry} entry
       * @param {Request} entry.request The request to store in the queue.
       * @param {Object} [entry.metadata] Any metadata you want associated with the
       *     stored request. When requests are replayed you'll have access to this
       *     metadata object in case you need to modify the request beforehand.
       * @param {number} [entry.timestamp] The timestamp (Epoch time in
       *     milliseconds) when the request was first added to the queue. This is
       *     used along with `maxRetentionTime` to remove outdated requests. In
       *     general you don't need to set this value, as it's automatically set
       *     for you (defaulting to `Date.now()`), but you can update it if you
       *     don't want particular requests to expire.
       */
      async pushRequest(entry) {
        {
          finalAssertExports.isType(entry, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'Queue',
            funcName: 'pushRequest',
            paramName: 'entry'
          });
          finalAssertExports.isInstance(entry.request, Request, {
            moduleName: 'workbox-background-sync',
            className: 'Queue',
            funcName: 'pushRequest',
            paramName: 'entry.request'
          });
        }
        await this._addRequest(entry, 'push');
      }
      /**
       * Stores the passed request in IndexedDB (with its timestamp and any
       * metadata) at the beginning of the queue.
       *
       * @param {QueueEntry} entry
       * @param {Request} entry.request The request to store in the queue.
       * @param {Object} [entry.metadata] Any metadata you want associated with the
       *     stored request. When requests are replayed you'll have access to this
       *     metadata object in case you need to modify the request beforehand.
       * @param {number} [entry.timestamp] The timestamp (Epoch time in
       *     milliseconds) when the request was first added to the queue. This is
       *     used along with `maxRetentionTime` to remove outdated requests. In
       *     general you don't need to set this value, as it's automatically set
       *     for you (defaulting to `Date.now()`), but you can update it if you
       *     don't want particular requests to expire.
       */
      async unshiftRequest(entry) {
        {
          finalAssertExports.isType(entry, 'object', {
            moduleName: 'workbox-background-sync',
            className: 'Queue',
            funcName: 'unshiftRequest',
            paramName: 'entry'
          });
          finalAssertExports.isInstance(entry.request, Request, {
            moduleName: 'workbox-background-sync',
            className: 'Queue',
            funcName: 'unshiftRequest',
            paramName: 'entry.request'
          });
        }
        await this._addRequest(entry, 'unshift');
      }
      /**
       * Removes and returns the last request in the queue (along with its
       * timestamp and any metadata). The returned object takes the form:
       * `{request, timestamp, metadata}`.
       *
       * @return {Promise<QueueEntry | undefined>}
       */
      async popRequest() {
        return this._removeRequest('pop');
      }
      /**
       * Removes and returns the first request in the queue (along with its
       * timestamp and any metadata). The returned object takes the form:
       * `{request, timestamp, metadata}`.
       *
       * @return {Promise<QueueEntry | undefined>}
       */
      async shiftRequest() {
        return this._removeRequest('shift');
      }
      /**
       * Returns all the entries that have not expired (per `maxRetentionTime`).
       * Any expired entries are removed from the queue.
       *
       * @return {Promise<Array<QueueEntry>>}
       */
      async getAll() {
        const allEntries = await this._queueStore.getAll();
        const now = Date.now();
        const unexpiredEntries = [];
        for (const entry of allEntries) {
          // Ignore requests older than maxRetentionTime. Call this function
          // recursively until an unexpired request is found.
          const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;
          if (now - entry.timestamp > maxRetentionTimeInMs) {
            await this._queueStore.deleteEntry(entry.id);
          } else {
            unexpiredEntries.push(convertEntry(entry));
          }
        }
        return unexpiredEntries;
      }
      /**
       * Returns the number of entries present in the queue.
       * Note that expired entries (per `maxRetentionTime`) are also included in this count.
       *
       * @return {Promise<number>}
       */
      async size() {
        return await this._queueStore.size();
      }
      /**
       * Adds the entry to the QueueStore and registers for a sync event.
       *
       * @param {Object} entry
       * @param {Request} entry.request
       * @param {Object} [entry.metadata]
       * @param {number} [entry.timestamp=Date.now()]
       * @param {string} operation ('push' or 'unshift')
       * @private
       */
      async _addRequest({
        request,
        metadata,
        timestamp = Date.now()
      }, operation) {
        const storableRequest = await StorableRequest.fromRequest(request.clone());
        const entry = {
          requestData: storableRequest.toObject(),
          timestamp
        };
        // Only include metadata if it's present.
        if (metadata) {
          entry.metadata = metadata;
        }
        switch (operation) {
          case 'push':
            await this._queueStore.pushEntry(entry);
            break;
          case 'unshift':
            await this._queueStore.unshiftEntry(entry);
            break;
        }
        {
          logger.log(`Request for '${getFriendlyURL(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);
        }
        // Don't register for a sync if we're in the middle of a sync. Instead,
        // we wait until the sync is complete and call register if
        // `this._requestsAddedDuringSync` is true.
        if (this._syncInProgress) {
          this._requestsAddedDuringSync = true;
        } else {
          await this.registerSync();
        }
      }
      /**
       * Removes and returns the first or last (depending on `operation`) entry
       * from the QueueStore that's not older than the `maxRetentionTime`.
       *
       * @param {string} operation ('pop' or 'shift')
       * @return {Object|undefined}
       * @private
       */
      async _removeRequest(operation) {
        const now = Date.now();
        let entry;
        switch (operation) {
          case 'pop':
            entry = await this._queueStore.popEntry();
            break;
          case 'shift':
            entry = await this._queueStore.shiftEntry();
            break;
        }
        if (entry) {
          // Ignore requests older than maxRetentionTime. Call this function
          // recursively until an unexpired request is found.
          const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;
          if (now - entry.timestamp > maxRetentionTimeInMs) {
            return this._removeRequest(operation);
          }
          return convertEntry(entry);
        } else {
          return undefined;
        }
      }
      /**
       * Loops through each request in the queue and attempts to re-fetch it.
       * If any request fails to re-fetch, it's put back in the same position in
       * the queue (which registers a retry for the next sync event).
       */
      async replayRequests() {
        let entry;
        while (entry = await this.shiftRequest()) {
          try {
            await fetch(entry.request.clone());
            if ("development" !== 'production') {
              logger.log(`Request for '${getFriendlyURL(entry.request.url)}' ` + `has been replayed in queue '${this._name}'`);
            }
          } catch (error) {
            await this.unshiftRequest(entry);
            {
              logger.log(`Request for '${getFriendlyURL(entry.request.url)}' ` + `failed to replay, putting it back in queue '${this._name}'`);
            }
            throw new WorkboxError('queue-replay-failed', {
              name: this._name
            });
          }
        }
        {
          logger.log(`All requests in queue '${this.name}' have successfully ` + `replayed; the queue is now empty!`);
        }
      }
      /**
       * Registers a sync event with a tag unique to this instance.
       */
      async registerSync() {
        // See https://github.com/GoogleChrome/workbox/issues/2393
        if ('sync' in self.registration && !this._forceSyncFallback) {
          try {
            await self.registration.sync.register(`${TAG_PREFIX}:${this._name}`);
          } catch (err) {
            // This means the registration failed for some reason, possibly due to
            // the user disabling it.
            {
              logger.warn(`Unable to register sync event for '${this._name}'.`, err);
            }
          }
        }
      }
      /**
       * In sync-supporting browsers, this adds a listener for the sync event.
       * In non-sync-supporting browsers, or if _forceSyncFallback is true, this
       * will retry the queue on service worker startup.
       *
       * @private
       */
      _addSyncListener() {
        // See https://github.com/GoogleChrome/workbox/issues/2393
        if ('sync' in self.registration && !this._forceSyncFallback) {
          self.addEventListener('sync', event => {
            if (event.tag === `${TAG_PREFIX}:${this._name}`) {
              {
                logger.log(`Background sync for tag '${event.tag}' ` + `has been received`);
              }
              const syncComplete = async () => {
                this._syncInProgress = true;
                let syncError;
                try {
                  await this._onSync({
                    queue: this
                  });
                } catch (error) {
                  if (error instanceof Error) {
                    syncError = error;
                    // Rethrow the error. Note: the logic in the finally clause
                    // will run before this gets rethrown.
                    throw syncError;
                  }
                } finally {
                  // New items may have been added to the queue during the sync,
                  // so we need to register for a new sync if that's happened...
                  // Unless there was an error during the sync, in which
                  // case the browser will automatically retry later, as long
                  // as `event.lastChance` is not true.
                  if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {
                    await this.registerSync();
                  }
                  this._syncInProgress = false;
                  this._requestsAddedDuringSync = false;
                }
              };
              event.waitUntil(syncComplete());
            }
          });
        } else {
          {
            logger.log(`Background sync replaying without background sync event`);
          }
          // If the browser doesn't support background sync, or the developer has
          // opted-in to not using it, retry every time the service worker starts up
          // as a fallback.
          void this._onSync({
            queue: this
          });
        }
      }
      /**
       * Returns the set of queue names. This is primarily used to reset the list
       * of queue names in tests.
       *
       * @return {Set<string>}
       *
       * @private
       */
      static get _queueNames() {
        return queueNames;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A class implementing the `fetchDidFail` lifecycle callback. This makes it
     * easier to add failed requests to a background sync Queue.
     *
     * @memberof workbox-background-sync
     */
    class BackgroundSyncPlugin {
      /**
       * @param {string} name See the {@link workbox-background-sync.Queue}
       *     documentation for parameter details.
       * @param {Object} [options] See the
       *     {@link workbox-background-sync.Queue} documentation for
       *     parameter details.
       */
      constructor(name, options) {
        /**
         * @param {Object} options
         * @param {Request} options.request
         * @private
         */
        this.fetchDidFail = async ({
          request
        }) => {
          await this._queue.pushRequest({
            request
          });
        };
        this._queue = new Queue(name, options);
      }
    }

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Returns a promise that resolves and the passed number of milliseconds.
     * This utility is an async/await-friendly version of `setTimeout`.
     *
     * @param {number} ms
     * @return {Promise}
     * @private
     */
    function timeout(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const _cacheNameDetails = {
      googleAnalytics: 'googleAnalytics',
      precache: 'precache-v2',
      prefix: 'workbox',
      runtime: 'runtime',
      suffix: typeof registration !== 'undefined' ? registration.scope : ''
    };
    const _createCacheName = cacheName => {
      return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');
    };
    const eachCacheNameDetail = fn => {
      for (const key of Object.keys(_cacheNameDetails)) {
        fn(key);
      }
    };
    const cacheNames = {
      updateDetails: details => {
        eachCacheNameDetail(key => {
          if (typeof details[key] === 'string') {
            _cacheNameDetails[key] = details[key];
          }
        });
      },
      getGoogleAnalyticsName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);
      },
      getPrecacheName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.precache);
      },
      getPrefix: () => {
        return _cacheNameDetails.prefix;
      },
      getRuntimeName: userCacheName => {
        return userCacheName || _createCacheName(_cacheNameDetails.runtime);
      },
      getSuffix: () => {
        return _cacheNameDetails.suffix;
      }
    };

    /*
      Copyright 2020 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    function stripParams(fullURL, ignoreParams) {
      const strippedURL = new URL(fullURL);
      for (const param of ignoreParams) {
        strippedURL.searchParams.delete(param);
      }
      return strippedURL.href;
    }
    /**
     * Matches an item in the cache, ignoring specific URL params. This is similar
     * to the `ignoreSearch` option, but it allows you to ignore just specific
     * params (while continuing to match on the others).
     *
     * @private
     * @param {Cache} cache
     * @param {Request} request
     * @param {Object} matchOptions
     * @param {Array<string>} ignoreParams
     * @return {Promise<Response|undefined>}
     */
    async function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {
      const strippedRequestURL = stripParams(request.url, ignoreParams);
      // If the request doesn't include any ignored params, match as normal.
      if (request.url === strippedRequestURL) {
        return cache.match(request, matchOptions);
      }
      // Otherwise, match by comparing keys
      const keysOptions = Object.assign(Object.assign({}, matchOptions), {
        ignoreSearch: true
      });
      const cacheKeys = await cache.keys(request, keysOptions);
      for (const cacheKey of cacheKeys) {
        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);
        if (strippedRequestURL === strippedCacheKeyURL) {
          return cache.match(cacheKey, matchOptions);
        }
      }
      return;
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The Deferred class composes Promises in a way that allows for them to be
     * resolved or rejected from outside the constructor. In most cases promises
     * should be used directly, but Deferreds can be necessary when the logic to
     * resolve a promise must be separate.
     *
     * @private
     */
    class Deferred {
      /**
       * Creates a promise and exposes its resolve and reject functions as methods.
       */
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    // Callbacks to be executed whenever there's a quota error.
    // Can't change Function type right now.
    // eslint-disable-next-line @typescript-eslint/ban-types
    const quotaErrorCallbacks = new Set();

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Runs all of the callback functions, one at a time sequentially, in the order
     * in which they were registered.
     *
     * @memberof workbox-core
     * @private
     */
    async function executeQuotaErrorCallbacks() {
      {
        logger.log(`About to run ${quotaErrorCallbacks.size} ` + `callbacks to clean up caches.`);
      }
      for (const callback of quotaErrorCallbacks) {
        await callback();
        {
          logger.log(callback, 'is complete.');
        }
      }
      {
        logger.log('Finished running callbacks.');
      }
    }

    // @ts-ignore
    try {
      self['workbox:strategies:7.2.0'] && _();
    } catch (e) {}

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    function toRequest(input) {
      return typeof input === 'string' ? new Request(input) : input;
    }
    /**
     * A class created every time a Strategy instance instance calls
     * {@link workbox-strategies.Strategy~handle} or
     * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and
     * cache actions around plugin callbacks and keeps track of when the strategy
     * is "done" (i.e. all added `event.waitUntil()` promises have resolved).
     *
     * @memberof workbox-strategies
     */
    class StrategyHandler {
      /**
       * Creates a new instance associated with the passed strategy and event
       * that's handling the request.
       *
       * The constructor also initializes the state that will be passed to each of
       * the plugins handling this request.
       *
       * @param {workbox-strategies.Strategy} strategy
       * @param {Object} options
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params] The return value from the
       *     {@link workbox-routing~matchCallback} (if applicable).
       */
      constructor(strategy, options) {
        this._cacheKeys = {};
        /**
         * The request the strategy is performing (passed to the strategy's
         * `handle()` or `handleAll()` method).
         * @name request
         * @instance
         * @type {Request}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * The event associated with this request.
         * @name event
         * @instance
         * @type {ExtendableEvent}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * A `URL` instance of `request.url` (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `url` param will be present if the strategy was invoked
         * from a workbox `Route` object.
         * @name url
         * @instance
         * @type {URL|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */
        /**
         * A `param` value (if passed to the strategy's
         * `handle()` or `handleAll()` method).
         * Note: the `param` param will be present if the strategy was invoked
         * from a workbox `Route` object and the
         * {@link workbox-routing~matchCallback} returned
         * a truthy value (it will be that value).
         * @name params
         * @instance
         * @type {*|undefined}
         * @memberof workbox-strategies.StrategyHandler
         */
        {
          finalAssertExports.isInstance(options.event, ExtendableEvent, {
            moduleName: 'workbox-strategies',
            className: 'StrategyHandler',
            funcName: 'constructor',
            paramName: 'options.event'
          });
        }
        Object.assign(this, options);
        this.event = options.event;
        this._strategy = strategy;
        this._handlerDeferred = new Deferred();
        this._extendLifetimePromises = [];
        // Copy the plugins list (since it's mutable on the strategy),
        // so any mutations don't affect this handler instance.
        this._plugins = [...strategy.plugins];
        this._pluginStateMap = new Map();
        for (const plugin of this._plugins) {
          this._pluginStateMap.set(plugin, {});
        }
        this.event.waitUntil(this._handlerDeferred.promise);
      }
      /**
       * Fetches a given request (and invokes any applicable plugin callback
       * methods) using the `fetchOptions` (for non-navigation requests) and
       * `plugins` defined on the `Strategy` object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - `requestWillFetch()`
       * - `fetchDidSucceed()`
       * - `fetchDidFail()`
       *
       * @param {Request|string} input The URL or request to fetch.
       * @return {Promise<Response>}
       */
      async fetch(input) {
        const {
          event
        } = this;
        let request = toRequest(input);
        if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {
          const possiblePreloadResponse = await event.preloadResponse;
          if (possiblePreloadResponse) {
            {
              logger.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);
            }
            return possiblePreloadResponse;
          }
        }
        // If there is a fetchDidFail plugin, we need to save a clone of the
        // original request before it's either modified by a requestWillFetch
        // plugin or before the original request's body is consumed via fetch().
        const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;
        try {
          for (const cb of this.iterateCallbacks('requestWillFetch')) {
            request = await cb({
              request: request.clone(),
              event
            });
          }
        } catch (err) {
          if (err instanceof Error) {
            throw new WorkboxError('plugin-error-request-will-fetch', {
              thrownErrorMessage: err.message
            });
          }
        }
        // The request can be altered by plugins with `requestWillFetch` making
        // the original request (most likely from a `fetch` event) different
        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.
        const pluginFilteredRequest = request.clone();
        try {
          let fetchResponse;
          // See https://github.com/GoogleChrome/workbox/issues/1796
          fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);
          if ("development" !== 'production') {
            logger.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);
          }
          for (const callback of this.iterateCallbacks('fetchDidSucceed')) {
            fetchResponse = await callback({
              event,
              request: pluginFilteredRequest,
              response: fetchResponse
            });
          }
          return fetchResponse;
        } catch (error) {
          {
            logger.log(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);
          }
          // `originalRequest` will only exist if a `fetchDidFail` callback
          // is being used (see above).
          if (originalRequest) {
            await this.runCallbacks('fetchDidFail', {
              error: error,
              event,
              originalRequest: originalRequest.clone(),
              request: pluginFilteredRequest.clone()
            });
          }
          throw error;
        }
      }
      /**
       * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on
       * the response generated by `this.fetch()`.
       *
       * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,
       * so you do not have to manually call `waitUntil()` on the event.
       *
       * @param {Request|string} input The request or URL to fetch and cache.
       * @return {Promise<Response>}
       */
      async fetchAndCachePut(input) {
        const response = await this.fetch(input);
        const responseClone = response.clone();
        void this.waitUntil(this.cachePut(input, responseClone));
        return response;
      }
      /**
       * Matches a request from the cache (and invokes any applicable plugin
       * callback methods) using the `cacheName`, `matchOptions`, and `plugins`
       * defined on the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillBeUsed()
       * - cachedResponseWillBeUsed()
       *
       * @param {Request|string} key The Request or URL to use as the cache key.
       * @return {Promise<Response|undefined>} A matching response, if found.
       */
      async cacheMatch(key) {
        const request = toRequest(key);
        let cachedResponse;
        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const effectiveRequest = await this.getCacheKey(request, 'read');
        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {
          cacheName
        });
        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);
        {
          if (cachedResponse) {
            logger.debug(`Found a cached response in '${cacheName}'.`);
          } else {
            logger.debug(`No cached response found in '${cacheName}'.`);
          }
        }
        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {
          cachedResponse = (await callback({
            cacheName,
            matchOptions,
            cachedResponse,
            request: effectiveRequest,
            event: this.event
          })) || undefined;
        }
        return cachedResponse;
      }
      /**
       * Puts a request/response pair in the cache (and invokes any applicable
       * plugin callback methods) using the `cacheName` and `plugins` defined on
       * the strategy object.
       *
       * The following plugin lifecycle methods are invoked when using this method:
       * - cacheKeyWillBeUsed()
       * - cacheWillUpdate()
       * - cacheDidUpdate()
       *
       * @param {Request|string} key The request or URL to use as the cache key.
       * @param {Response} response The response to cache.
       * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response
       * not be cached, and `true` otherwise.
       */
      async cachePut(key, response) {
        const request = toRequest(key);
        // Run in the next task to avoid blocking other cache reads.
        // https://github.com/w3c/ServiceWorker/issues/1397
        await timeout(0);
        const effectiveRequest = await this.getCacheKey(request, 'write');
        {
          if (effectiveRequest.method && effectiveRequest.method !== 'GET') {
            throw new WorkboxError('attempt-to-cache-non-get-request', {
              url: getFriendlyURL(effectiveRequest.url),
              method: effectiveRequest.method
            });
          }
          // See https://github.com/GoogleChrome/workbox/issues/2818
          const vary = response.headers.get('Vary');
          if (vary) {
            logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` + `has a 'Vary: ${vary}' header. ` + `Consider setting the {ignoreVary: true} option on your strategy ` + `to ensure cache matching and deletion works as expected.`);
          }
        }
        if (!response) {
          {
            logger.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(effectiveRequest.url)}'.`);
          }
          throw new WorkboxError('cache-put-with-no-response', {
            url: getFriendlyURL(effectiveRequest.url)
          });
        }
        const responseToCache = await this._ensureResponseSafeToCache(response);
        if (!responseToCache) {
          {
            logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` + `will not be cached.`, responseToCache);
          }
          return false;
        }
        const {
          cacheName,
          matchOptions
        } = this._strategy;
        const cache = await self.caches.open(cacheName);
        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');
        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(
        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching
        // feature. Consider into ways to only add this behavior if using
        // precaching.
        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;
        {
          logger.debug(`Updating the '${cacheName}' cache with a new Response ` + `for ${getFriendlyURL(effectiveRequest.url)}.`);
        }
        try {
          await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);
        } catch (error) {
          if (error instanceof Error) {
            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError
            if (error.name === 'QuotaExceededError') {
              await executeQuotaErrorCallbacks();
            }
            throw error;
          }
        }
        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {
          await callback({
            cacheName,
            oldResponse,
            newResponse: responseToCache.clone(),
            request: effectiveRequest,
            event: this.event
          });
        }
        return true;
      }
      /**
       * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and
       * executes any of those callbacks found in sequence. The final `Request`
       * object returned by the last plugin is treated as the cache key for cache
       * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have
       * been registered, the passed request is returned unmodified
       *
       * @param {Request} request
       * @param {string} mode
       * @return {Promise<Request>}
       */
      async getCacheKey(request, mode) {
        const key = `${request.url} | ${mode}`;
        if (!this._cacheKeys[key]) {
          let effectiveRequest = request;
          for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {
            effectiveRequest = toRequest(await callback({
              mode,
              request: effectiveRequest,
              event: this.event,
              // params has a type any can't change right now.
              params: this.params // eslint-disable-line
            }));
          }
          this._cacheKeys[key] = effectiveRequest;
        }
        return this._cacheKeys[key];
      }
      /**
       * Returns true if the strategy has at least one plugin with the given
       * callback.
       *
       * @param {string} name The name of the callback to check for.
       * @return {boolean}
       */
      hasCallback(name) {
        for (const plugin of this._strategy.plugins) {
          if (name in plugin) {
            return true;
          }
        }
        return false;
      }
      /**
       * Runs all plugin callbacks matching the given name, in order, passing the
       * given param object (merged ith the current plugin state) as the only
       * argument.
       *
       * Note: since this method runs all plugins, it's not suitable for cases
       * where the return value of a callback needs to be applied prior to calling
       * the next callback. See
       * {@link workbox-strategies.StrategyHandler#iterateCallbacks}
       * below for how to handle that case.
       *
       * @param {string} name The name of the callback to run within each plugin.
       * @param {Object} param The object to pass as the first (and only) param
       *     when executing each callback. This object will be merged with the
       *     current plugin state prior to callback execution.
       */
      async runCallbacks(name, param) {
        for (const callback of this.iterateCallbacks(name)) {
          // TODO(philipwalton): not sure why `any` is needed. It seems like
          // this should work with `as WorkboxPluginCallbackParam[C]`.
          await callback(param);
        }
      }
      /**
       * Accepts a callback and returns an iterable of matching plugin callbacks,
       * where each callback is wrapped with the current handler state (i.e. when
       * you call each callback, whatever object parameter you pass it will
       * be merged with the plugin's current state).
       *
       * @param {string} name The name fo the callback to run
       * @return {Array<Function>}
       */
      *iterateCallbacks(name) {
        for (const plugin of this._strategy.plugins) {
          if (typeof plugin[name] === 'function') {
            const state = this._pluginStateMap.get(plugin);
            const statefulCallback = param => {
              const statefulParam = Object.assign(Object.assign({}, param), {
                state
              });
              // TODO(philipwalton): not sure why `any` is needed. It seems like
              // this should work with `as WorkboxPluginCallbackParam[C]`.
              return plugin[name](statefulParam);
            };
            yield statefulCallback;
          }
        }
      }
      /**
       * Adds a promise to the
       * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}
       * of the event event associated with the request being handled (usually a
       * `FetchEvent`).
       *
       * Note: you can await
       * {@link workbox-strategies.StrategyHandler~doneWaiting}
       * to know when all added promises have settled.
       *
       * @param {Promise} promise A promise to add to the extend lifetime promises
       *     of the event that triggered the request.
       */
      waitUntil(promise) {
        this._extendLifetimePromises.push(promise);
        return promise;
      }
      /**
       * Returns a promise that resolves once all promises passed to
       * {@link workbox-strategies.StrategyHandler~waitUntil}
       * have settled.
       *
       * Note: any work done after `doneWaiting()` settles should be manually
       * passed to an event's `waitUntil()` method (not this handler's
       * `waitUntil()` method), otherwise the service worker thread my be killed
       * prior to your work completing.
       */
      async doneWaiting() {
        let promise;
        while (promise = this._extendLifetimePromises.shift()) {
          await promise;
        }
      }
      /**
       * Stops running the strategy and immediately resolves any pending
       * `waitUntil()` promises.
       */
      destroy() {
        this._handlerDeferred.resolve(null);
      }
      /**
       * This method will call cacheWillUpdate on the available plugins (or use
       * status === 200) to determine if the Response is safe and valid to cache.
       *
       * @param {Request} options.request
       * @param {Response} options.response
       * @return {Promise<Response|undefined>}
       *
       * @private
       */
      async _ensureResponseSafeToCache(response) {
        let responseToCache = response;
        let pluginsUsed = false;
        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {
          responseToCache = (await callback({
            request: this.request,
            response: responseToCache,
            event: this.event
          })) || undefined;
          pluginsUsed = true;
          if (!responseToCache) {
            break;
          }
        }
        if (!pluginsUsed) {
          if (responseToCache && responseToCache.status !== 200) {
            responseToCache = undefined;
          }
          {
            if (responseToCache) {
              if (responseToCache.status !== 200) {
                if (responseToCache.status === 0) {
                  logger.warn(`The response for '${this.request.url}' ` + `is an opaque response. The caching strategy that you're ` + `using will not cache opaque responses by default.`);
                } else {
                  logger.debug(`The response for '${this.request.url}' ` + `returned a status code of '${response.status}' and won't ` + `be cached as a result.`);
                }
              }
            }
          }
        }
        return responseToCache;
      }
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An abstract base class that all other strategy classes must extend from:
     *
     * @memberof workbox-strategies
     */
    class Strategy {
      /**
       * Creates a new instance of the strategy and sets all documented option
       * properties as public instance properties.
       *
       * Note: if a custom strategy class extends the base Strategy class and does
       * not need more than these properties, it does not need to define its own
       * constructor.
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to the cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] The
       * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
       * for any `cache.match()` or `cache.put()` calls made by this strategy.
       */
      constructor(options = {}) {
        /**
         * Cache name to store and retrieve
         * requests. Defaults to the cache names provided by
         * {@link workbox-core.cacheNames}.
         *
         * @type {string}
         */
        this.cacheName = cacheNames.getRuntimeName(options.cacheName);
        /**
         * The list
         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
         * used by this strategy.
         *
         * @type {Array<Object>}
         */
        this.plugins = options.plugins || [];
        /**
         * Values passed along to the
         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}
         * of all fetch() requests made by this strategy.
         *
         * @type {Object}
         */
        this.fetchOptions = options.fetchOptions;
        /**
         * The
         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}
         * for any `cache.match()` or `cache.put()` calls made by this strategy.
         *
         * @type {Object}
         */
        this.matchOptions = options.matchOptions;
      }
      /**
       * Perform a request strategy and returns a `Promise` that will resolve with
       * a `Response`, invoking all relevant plugin callbacks.
       *
       * When a strategy instance is registered with a Workbox
       * {@link workbox-routing.Route}, this method is automatically
       * called when the route matches.
       *
       * Alternatively, this method can be used in a standalone `FetchEvent`
       * listener by passing it to `event.respondWith()`.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       */
      handle(options) {
        const [responseDone] = this.handleAll(options);
        return responseDone;
      }
      /**
       * Similar to {@link workbox-strategies.Strategy~handle}, but
       * instead of just returning a `Promise` that resolves to a `Response` it
       * it will return an tuple of `[response, done]` promises, where the former
       * (`response`) is equivalent to what `handle()` returns, and the latter is a
       * Promise that will resolve once any promises that were added to
       * `event.waitUntil()` as part of performing the strategy have completed.
       *
       * You can await the `done` promise to ensure any extra work performed by
       * the strategy (usually caching responses) completes successfully.
       *
       * @param {FetchEvent|Object} options A `FetchEvent` or an object with the
       *     properties listed below.
       * @param {Request|string} options.request A request to run this strategy for.
       * @param {ExtendableEvent} options.event The event associated with the
       *     request.
       * @param {URL} [options.url]
       * @param {*} [options.params]
       * @return {Array<Promise>} A tuple of [response, done]
       *     promises that can be used to determine when the response resolves as
       *     well as when the handler has completed all its work.
       */
      handleAll(options) {
        // Allow for flexible options to be passed.
        if (options instanceof FetchEvent) {
          options = {
            event: options,
            request: options.request
          };
        }
        const event = options.event;
        const request = typeof options.request === 'string' ? new Request(options.request) : options.request;
        const params = 'params' in options ? options.params : undefined;
        const handler = new StrategyHandler(this, {
          event,
          request,
          params
        });
        const responseDone = this._getResponse(handler, request, event);
        const handlerDone = this._awaitComplete(responseDone, handler, request, event);
        // Return an array of promises, suitable for use with Promise.all().
        return [responseDone, handlerDone];
      }
      async _getResponse(handler, request, event) {
        await handler.runCallbacks('handlerWillStart', {
          event,
          request
        });
        let response = undefined;
        try {
          response = await this._handle(request, handler);
          // The "official" Strategy subclasses all throw this error automatically,
          // but in case a third-party Strategy doesn't, ensure that we have a
          // consistent failure when there's no response or an error response.
          if (!response || response.type === 'error') {
            throw new WorkboxError('no-response', {
              url: request.url
            });
          }
        } catch (error) {
          if (error instanceof Error) {
            for (const callback of handler.iterateCallbacks('handlerDidError')) {
              response = await callback({
                error,
                event,
                request
              });
              if (response) {
                break;
              }
            }
          }
          if (!response) {
            throw error;
          } else {
            logger.log(`While responding to '${getFriendlyURL(request.url)}', ` + `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` + `a handlerDidError plugin.`);
          }
        }
        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {
          response = await callback({
            event,
            request,
            response
          });
        }
        return response;
      }
      async _awaitComplete(responseDone, handler, request, event) {
        let response;
        let error;
        try {
          response = await responseDone;
        } catch (error) {
          // Ignore errors, as response errors should be caught via the `response`
          // promise above. The `done` promise will only throw for errors in
          // promises passed to `handler.waitUntil()`.
        }
        try {
          await handler.runCallbacks('handlerDidRespond', {
            event,
            request,
            response
          });
          await handler.doneWaiting();
        } catch (waitUntilError) {
          if (waitUntilError instanceof Error) {
            error = waitUntilError;
          }
        }
        await handler.runCallbacks('handlerDidComplete', {
          event,
          request,
          response,
          error: error
        });
        handler.destroy();
        if (error) {
          throw error;
        }
      }
    }
    /**
     * Classes extending the `Strategy` based class should implement this method,
     * and leverage the {@link workbox-strategies.StrategyHandler}
     * arg to perform all fetching and cache logic, which will ensure all relevant
     * cache, cache options, fetch options and plugins are used (per the current
     * strategy instance).
     *
     * @name _handle
     * @instance
     * @abstract
     * @function
     * @param {Request} request
     * @param {workbox-strategies.StrategyHandler} handler
     * @return {Promise<Response>}
     *
     * @memberof workbox-strategies.Strategy
     */

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const messages = {
      strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,
      printFinalResponse: response => {
        if (response) {
          logger.groupCollapsed(`View the final response here.`);
          logger.log(response || '[No response returned]');
          logger.groupEnd();
        }
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a
     * [network-only](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-only)
     * request strategy.
     *
     * This class is useful if you want to take advantage of any
     * [Workbox plugins](https://developer.chrome.com/docs/workbox/using-plugins/).
     *
     * If the network request fails, this will throw a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */
    class NetworkOnly extends Strategy {
      /**
       * @param {Object} [options]
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {number} [options.networkTimeoutSeconds] If set, any network requests
       * that fail to respond within the timeout will result in a network error.
       */
      constructor(options = {}) {
        super(options);
        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        {
          finalAssertExports.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
            funcName: '_handle',
            paramName: 'request'
          });
        }
        let error = undefined;
        let response;
        try {
          const promises = [handler.fetch(request)];
          if (this._networkTimeoutSeconds) {
            const timeoutPromise = timeout(this._networkTimeoutSeconds * 1000);
            promises.push(timeoutPromise);
          }
          response = await Promise.race(promises);
          if (!response) {
            throw new Error(`Timed out the network response after ` + `${this._networkTimeoutSeconds} seconds.`);
          }
        } catch (err) {
          if (err instanceof Error) {
            error = err;
          }
        }
        {
          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));
          if (response) {
            logger.log(`Got response from network.`);
          } else {
            logger.log(`Unable to get a response from the network.`);
          }
          messages.printFinalResponse(response);
          logger.groupEnd();
        }
        if (!response) {
          throw new WorkboxError('no-response', {
            url: request.url,
            error
          });
        }
        return response;
      }
    }

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A helper function that prevents a promise from being flagged as unused.
     *
     * @private
     **/
    function dontWaitFor(promise) {
      // Effective no-op.
      void promise.then(() => {});
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Adds a function to the set of quotaErrorCallbacks that will be executed if
     * there's a quota error.
     *
     * @param {Function} callback
     * @memberof workbox-core
     */
    // Can't change Function type
    // eslint-disable-next-line @typescript-eslint/ban-types
    function registerQuotaErrorCallback(callback) {
      {
        finalAssertExports.isType(callback, 'function', {
          moduleName: 'workbox-core',
          funcName: 'register',
          paramName: 'callback'
        });
      }
      quotaErrorCallbacks.add(callback);
      {
        logger.log('Registered a callback to respond to quota errors.', callback);
      }
    }

    // @ts-ignore
    try {
      self['workbox:expiration:7.2.0'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const DB_NAME = 'workbox-expiration';
    const CACHE_OBJECT_STORE = 'cache-entries';
    const normalizeURL = unNormalizedUrl => {
      const url = new URL(unNormalizedUrl, location.href);
      url.hash = '';
      return url.href;
    };
    /**
     * Returns the timestamp model.
     *
     * @private
     */
    class CacheTimestampsModel {
      /**
       *
       * @param {string} cacheName
       *
       * @private
       */
      constructor(cacheName) {
        this._db = null;
        this._cacheName = cacheName;
      }
      /**
       * Performs an upgrade of indexedDB.
       *
       * @param {IDBPDatabase<CacheDbSchema>} db
       *
       * @private
       */
      _upgradeDb(db) {
        // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we
        // have to use the `id` keyPath here and create our own values (a
        // concatenation of `url + cacheName`) instead of simply using
        // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.
        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {
          keyPath: 'id'
        });
        // TODO(philipwalton): once we don't have to support EdgeHTML, we can
        // create a single index with the keyPath `['cacheName', 'timestamp']`
        // instead of doing both these indexes.
        objStore.createIndex('cacheName', 'cacheName', {
          unique: false
        });
        objStore.createIndex('timestamp', 'timestamp', {
          unique: false
        });
      }
      /**
       * Performs an upgrade of indexedDB and deletes deprecated DBs.
       *
       * @param {IDBPDatabase<CacheDbSchema>} db
       *
       * @private
       */
      _upgradeDbAndDeleteOldDbs(db) {
        this._upgradeDb(db);
        if (this._cacheName) {
          void deleteDB(this._cacheName);
        }
      }
      /**
       * @param {string} url
       * @param {number} timestamp
       *
       * @private
       */
      async setTimestamp(url, timestamp) {
        url = normalizeURL(url);
        const entry = {
          url,
          timestamp,
          cacheName: this._cacheName,
          // Creating an ID from the URL and cache name won't be necessary once
          // Edge switches to Chromium and all browsers we support work with
          // array keyPaths.
          id: this._getId(url)
        };
        const db = await this.getDb();
        const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {
          durability: 'relaxed'
        });
        await tx.store.put(entry);
        await tx.done;
      }
      /**
       * Returns the timestamp stored for a given URL.
       *
       * @param {string} url
       * @return {number | undefined}
       *
       * @private
       */
      async getTimestamp(url) {
        const db = await this.getDb();
        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));
        return entry === null || entry === void 0 ? void 0 : entry.timestamp;
      }
      /**
       * Iterates through all the entries in the object store (from newest to
       * oldest) and removes entries once either `maxCount` is reached or the
       * entry's timestamp is less than `minTimestamp`.
       *
       * @param {number} minTimestamp
       * @param {number} maxCount
       * @return {Array<string>}
       *
       * @private
       */
      async expireEntries(minTimestamp, maxCount) {
        const db = await this.getDb();
        let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index('timestamp').openCursor(null, 'prev');
        const entriesToDelete = [];
        let entriesNotDeletedCount = 0;
        while (cursor) {
          const result = cursor.value;
          // TODO(philipwalton): once we can use a multi-key index, we
          // won't have to check `cacheName` here.
          if (result.cacheName === this._cacheName) {
            // Delete an entry if it's older than the max age or
            // if we already have the max number allowed.
            if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {
              // TODO(philipwalton): we should be able to delete the
              // entry right here, but doing so causes an iteration
              // bug in Safari stable (fixed in TP). Instead we can
              // store the keys of the entries to delete, and then
              // delete the separate transactions.
              // https://github.com/GoogleChrome/workbox/issues/1978
              // cursor.delete();
              // We only need to return the URL, not the whole entry.
              entriesToDelete.push(cursor.value);
            } else {
              entriesNotDeletedCount++;
            }
          }
          cursor = await cursor.continue();
        }
        // TODO(philipwalton): once the Safari bug in the following issue is fixed,
        // we should be able to remove this loop and do the entry deletion in the
        // cursor loop above:
        // https://github.com/GoogleChrome/workbox/issues/1978
        const urlsDeleted = [];
        for (const entry of entriesToDelete) {
          await db.delete(CACHE_OBJECT_STORE, entry.id);
          urlsDeleted.push(entry.url);
        }
        return urlsDeleted;
      }
      /**
       * Takes a URL and returns an ID that will be unique in the object store.
       *
       * @param {string} url
       * @return {string}
       *
       * @private
       */
      _getId(url) {
        // Creating an ID from the URL and cache name won't be necessary once
        // Edge switches to Chromium and all browsers we support work with
        // array keyPaths.
        return this._cacheName + '|' + normalizeURL(url);
      }
      /**
       * Returns an open connection to the database.
       *
       * @private
       */
      async getDb() {
        if (!this._db) {
          this._db = await openDB(DB_NAME, 1, {
            upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)
          });
        }
        return this._db;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * The `CacheExpiration` class allows you define an expiration and / or
     * limit on the number of responses stored in a
     * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).
     *
     * @memberof workbox-expiration
     */
    class CacheExpiration {
      /**
       * To construct a new CacheExpiration instance you must provide at least
       * one of the `config` properties.
       *
       * @param {string} cacheName Name of the cache to apply restrictions to.
       * @param {Object} config
       * @param {number} [config.maxEntries] The maximum number of entries to cache.
       * Entries used the least will be removed as the maximum is reached.
       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
       * it's treated as stale and removed.
       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
       * that will be used when calling `delete()` on the cache.
       */
      constructor(cacheName, config = {}) {
        this._isRunning = false;
        this._rerunRequested = false;
        {
          finalAssertExports.isType(cacheName, 'string', {
            moduleName: 'workbox-expiration',
            className: 'CacheExpiration',
            funcName: 'constructor',
            paramName: 'cacheName'
          });
          if (!(config.maxEntries || config.maxAgeSeconds)) {
            throw new WorkboxError('max-entries-or-age-required', {
              moduleName: 'workbox-expiration',
              className: 'CacheExpiration',
              funcName: 'constructor'
            });
          }
          if (config.maxEntries) {
            finalAssertExports.isType(config.maxEntries, 'number', {
              moduleName: 'workbox-expiration',
              className: 'CacheExpiration',
              funcName: 'constructor',
              paramName: 'config.maxEntries'
            });
          }
          if (config.maxAgeSeconds) {
            finalAssertExports.isType(config.maxAgeSeconds, 'number', {
              moduleName: 'workbox-expiration',
              className: 'CacheExpiration',
              funcName: 'constructor',
              paramName: 'config.maxAgeSeconds'
            });
          }
        }
        this._maxEntries = config.maxEntries;
        this._maxAgeSeconds = config.maxAgeSeconds;
        this._matchOptions = config.matchOptions;
        this._cacheName = cacheName;
        this._timestampModel = new CacheTimestampsModel(cacheName);
      }
      /**
       * Expires entries for the given cache and given criteria.
       */
      async expireEntries() {
        if (this._isRunning) {
          this._rerunRequested = true;
          return;
        }
        this._isRunning = true;
        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;
        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);
        // Delete URLs from the cache
        const cache = await self.caches.open(this._cacheName);
        for (const url of urlsExpired) {
          await cache.delete(url, this._matchOptions);
        }
        {
          if (urlsExpired.length > 0) {
            logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? 'entry' : 'entries'} and removed ` + `${urlsExpired.length === 1 ? 'it' : 'them'} from the ` + `'${this._cacheName}' cache.`);
            logger.log(`Expired the following ${urlsExpired.length === 1 ? 'URL' : 'URLs'}:`);
            urlsExpired.forEach(url => logger.log(`    ${url}`));
            logger.groupEnd();
          } else {
            logger.debug(`Cache expiration ran and found no entries to remove.`);
          }
        }
        this._isRunning = false;
        if (this._rerunRequested) {
          this._rerunRequested = false;
          dontWaitFor(this.expireEntries());
        }
      }
      /**
       * Update the timestamp for the given URL. This ensures the when
       * removing entries based on maximum entries, most recently used
       * is accurate or when expiring, the timestamp is up-to-date.
       *
       * @param {string} url
       */
      async updateTimestamp(url) {
        {
          finalAssertExports.isType(url, 'string', {
            moduleName: 'workbox-expiration',
            className: 'CacheExpiration',
            funcName: 'updateTimestamp',
            paramName: 'url'
          });
        }
        await this._timestampModel.setTimestamp(url, Date.now());
      }
      /**
       * Can be used to check if a URL has expired or not before it's used.
       *
       * This requires a look up from IndexedDB, so can be slow.
       *
       * Note: This method will not remove the cached entry, call
       * `expireEntries()` to remove indexedDB and Cache entries.
       *
       * @param {string} url
       * @return {boolean}
       */
      async isURLExpired(url) {
        if (!this._maxAgeSeconds) {
          {
            throw new WorkboxError(`expired-test-without-max-age`, {
              methodName: 'isURLExpired',
              paramName: 'maxAgeSeconds'
            });
          }
        } else {
          const timestamp = await this._timestampModel.getTimestamp(url);
          const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;
          return timestamp !== undefined ? timestamp < expireOlderThan : true;
        }
      }
      /**
       * Removes the IndexedDB object store used to keep track of cache expiration
       * metadata.
       */
      async delete() {
        // Make sure we don't attempt another rerun if we're called in the middle of
        // a cache expiration.
        this._rerunRequested = false;
        await this._timestampModel.expireEntries(Infinity); // Expires all.
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * This plugin can be used in a `workbox-strategy` to regularly enforce a
     * limit on the age and / or the number of cached requests.
     *
     * It can only be used with `workbox-strategy` instances that have a
     * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).
     * In other words, it can't be used to expire entries in strategy that uses the
     * default runtime cache name.
     *
     * Whenever a cached response is used or updated, this plugin will look
     * at the associated cache and remove any old or extra responses.
     *
     * When using `maxAgeSeconds`, responses may be used *once* after expiring
     * because the expiration clean up will not have occurred until *after* the
     * cached response has been used. If the response has a "Date" header, then
     * a light weight expiration check is performed and the response will not be
     * used immediately.
     *
     * When using `maxEntries`, the entry least-recently requested will be removed
     * from the cache first.
     *
     * @memberof workbox-expiration
     */
    class ExpirationPlugin {
      /**
       * @param {ExpirationPluginOptions} config
       * @param {number} [config.maxEntries] The maximum number of entries to cache.
       * Entries used the least will be removed as the maximum is reached.
       * @param {number} [config.maxAgeSeconds] The maximum age of an entry before
       * it's treated as stale and removed.
       * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)
       * that will be used when calling `delete()` on the cache.
       * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to
       * automatic deletion if the available storage quota has been exceeded.
       */
      constructor(config = {}) {
        /**
         * A "lifecycle" callback that will be triggered automatically by the
         * `workbox-strategies` handlers when a `Response` is about to be returned
         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to
         * the handler. It allows the `Response` to be inspected for freshness and
         * prevents it from being used if the `Response`'s `Date` header value is
         * older than the configured `maxAgeSeconds`.
         *
         * @param {Object} options
         * @param {string} options.cacheName Name of the cache the response is in.
         * @param {Response} options.cachedResponse The `Response` object that's been
         *     read from a cache and whose freshness should be checked.
         * @return {Response} Either the `cachedResponse`, if it's
         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.
         *
         * @private
         */
        this.cachedResponseWillBeUsed = async ({
          event,
          request,
          cacheName,
          cachedResponse
        }) => {
          if (!cachedResponse) {
            return null;
          }
          const isFresh = this._isResponseDateFresh(cachedResponse);
          // Expire entries to ensure that even if the expiration date has
          // expired, it'll only be used once.
          const cacheExpiration = this._getCacheExpiration(cacheName);
          dontWaitFor(cacheExpiration.expireEntries());
          // Update the metadata for the request URL to the current timestamp,
          // but don't `await` it as we don't want to block the response.
          const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);
          if (event) {
            try {
              event.waitUntil(updateTimestampDone);
            } catch (error) {
              {
                // The event may not be a fetch event; only log the URL if it is.
                if ('request' in event) {
                  logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache entry for ` + `'${getFriendlyURL(event.request.url)}'.`);
                }
              }
            }
          }
          return isFresh ? cachedResponse : null;
        };
        /**
         * A "lifecycle" callback that will be triggered automatically by the
         * `workbox-strategies` handlers when an entry is added to a cache.
         *
         * @param {Object} options
         * @param {string} options.cacheName Name of the cache that was updated.
         * @param {string} options.request The Request for the cached entry.
         *
         * @private
         */
        this.cacheDidUpdate = async ({
          cacheName,
          request
        }) => {
          {
            finalAssertExports.isType(cacheName, 'string', {
              moduleName: 'workbox-expiration',
              className: 'Plugin',
              funcName: 'cacheDidUpdate',
              paramName: 'cacheName'
            });
            finalAssertExports.isInstance(request, Request, {
              moduleName: 'workbox-expiration',
              className: 'Plugin',
              funcName: 'cacheDidUpdate',
              paramName: 'request'
            });
          }
          const cacheExpiration = this._getCacheExpiration(cacheName);
          await cacheExpiration.updateTimestamp(request.url);
          await cacheExpiration.expireEntries();
        };
        {
          if (!(config.maxEntries || config.maxAgeSeconds)) {
            throw new WorkboxError('max-entries-or-age-required', {
              moduleName: 'workbox-expiration',
              className: 'Plugin',
              funcName: 'constructor'
            });
          }
          if (config.maxEntries) {
            finalAssertExports.isType(config.maxEntries, 'number', {
              moduleName: 'workbox-expiration',
              className: 'Plugin',
              funcName: 'constructor',
              paramName: 'config.maxEntries'
            });
          }
          if (config.maxAgeSeconds) {
            finalAssertExports.isType(config.maxAgeSeconds, 'number', {
              moduleName: 'workbox-expiration',
              className: 'Plugin',
              funcName: 'constructor',
              paramName: 'config.maxAgeSeconds'
            });
          }
        }
        this._config = config;
        this._maxAgeSeconds = config.maxAgeSeconds;
        this._cacheExpirations = new Map();
        if (config.purgeOnQuotaError) {
          registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());
        }
      }
      /**
       * A simple helper method to return a CacheExpiration instance for a given
       * cache name.
       *
       * @param {string} cacheName
       * @return {CacheExpiration}
       *
       * @private
       */
      _getCacheExpiration(cacheName) {
        if (cacheName === cacheNames.getRuntimeName()) {
          throw new WorkboxError('expire-custom-caches-only');
        }
        let cacheExpiration = this._cacheExpirations.get(cacheName);
        if (!cacheExpiration) {
          cacheExpiration = new CacheExpiration(cacheName, this._config);
          this._cacheExpirations.set(cacheName, cacheExpiration);
        }
        return cacheExpiration;
      }
      /**
       * @param {Response} cachedResponse
       * @return {boolean}
       *
       * @private
       */
      _isResponseDateFresh(cachedResponse) {
        if (!this._maxAgeSeconds) {
          // We aren't expiring by age, so return true, it's fresh
          return true;
        }
        // Check if the 'date' header will suffice a quick expiration check.
        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for
        // discussion.
        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);
        if (dateHeaderTimestamp === null) {
          // Unable to parse date, so assume it's fresh.
          return true;
        }
        // If we have a valid headerTime, then our response is fresh iff the
        // headerTime plus maxAgeSeconds is greater than the current time.
        const now = Date.now();
        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;
      }
      /**
       * This method will extract the data header and parse it into a useful
       * value.
       *
       * @param {Response} cachedResponse
       * @return {number|null}
       *
       * @private
       */
      _getDateHeaderTimestamp(cachedResponse) {
        if (!cachedResponse.headers.has('date')) {
          return null;
        }
        const dateHeader = cachedResponse.headers.get('date');
        const parsedDate = new Date(dateHeader);
        const headerTime = parsedDate.getTime();
        // If the Date header was invalid for some reason, parsedDate.getTime()
        // will return NaN.
        if (isNaN(headerTime)) {
          return null;
        }
        return headerTime;
      }
      /**
       * This is a helper method that performs two operations:
       *
       * - Deletes *all* the underlying Cache instances associated with this plugin
       * instance, by calling caches.delete() on your behalf.
       * - Deletes the metadata from IndexedDB used to keep track of expiration
       * details for each Cache instance.
       *
       * When using cache expiration, calling this method is preferable to calling
       * `caches.delete()` directly, since this will ensure that the IndexedDB
       * metadata is also cleanly removed and open IndexedDB instances are deleted.
       *
       * Note that if you're *not* using cache expiration for a given cache, calling
       * `caches.delete()` and passing in the cache's name should be sufficient.
       * There is no Workbox-specific method needed for cleanup in that case.
       */
      async deleteCacheAndMetadata() {
        // Do this one at a time instead of all at once via `Promise.all()` to
        // reduce the chance of inconsistency if a promise rejects.
        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {
          await self.caches.delete(cacheName);
          await cacheExpiration.delete();
        }
        // Reset this._cacheExpirations to its initial state.
        this._cacheExpirations = new Map();
      }
    }

    // @ts-ignore
    try {
      self['workbox:cacheable-response:7.2.0'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * This class allows you to set up rules determining what
     * status codes and/or headers need to be present in order for a
     * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)
     * to be considered cacheable.
     *
     * @memberof workbox-cacheable-response
     */
    class CacheableResponse {
      /**
       * To construct a new CacheableResponse instance you must provide at least
       * one of the `config` properties.
       *
       * If both `statuses` and `headers` are specified, then both conditions must
       * be met for the `Response` to be considered cacheable.
       *
       * @param {Object} config
       * @param {Array<number>} [config.statuses] One or more status codes that a
       * `Response` can have and be considered cacheable.
       * @param {Object<string,string>} [config.headers] A mapping of header names
       * and expected values that a `Response` can have and be considered cacheable.
       * If multiple headers are provided, only one needs to be present.
       */
      constructor(config = {}) {
        {
          if (!(config.statuses || config.headers)) {
            throw new WorkboxError('statuses-or-headers-required', {
              moduleName: 'workbox-cacheable-response',
              className: 'CacheableResponse',
              funcName: 'constructor'
            });
          }
          if (config.statuses) {
            finalAssertExports.isArray(config.statuses, {
              moduleName: 'workbox-cacheable-response',
              className: 'CacheableResponse',
              funcName: 'constructor',
              paramName: 'config.statuses'
            });
          }
          if (config.headers) {
            finalAssertExports.isType(config.headers, 'object', {
              moduleName: 'workbox-cacheable-response',
              className: 'CacheableResponse',
              funcName: 'constructor',
              paramName: 'config.headers'
            });
          }
        }
        this._statuses = config.statuses;
        this._headers = config.headers;
      }
      /**
       * Checks a response to see whether it's cacheable or not, based on this
       * object's configuration.
       *
       * @param {Response} response The response whose cacheability is being
       * checked.
       * @return {boolean} `true` if the `Response` is cacheable, and `false`
       * otherwise.
       */
      isResponseCacheable(response) {
        {
          finalAssertExports.isInstance(response, Response, {
            moduleName: 'workbox-cacheable-response',
            className: 'CacheableResponse',
            funcName: 'isResponseCacheable',
            paramName: 'response'
          });
        }
        let cacheable = true;
        if (this._statuses) {
          cacheable = this._statuses.includes(response.status);
        }
        if (this._headers && cacheable) {
          cacheable = Object.keys(this._headers).some(headerName => {
            return response.headers.get(headerName) === this._headers[headerName];
          });
        }
        {
          if (!cacheable) {
            logger.groupCollapsed(`The request for ` + `'${getFriendlyURL(response.url)}' returned a response that does ` + `not meet the criteria for being cached.`);
            logger.groupCollapsed(`View cacheability criteria here.`);
            logger.log(`Cacheable statuses: ` + JSON.stringify(this._statuses));
            logger.log(`Cacheable headers: ` + JSON.stringify(this._headers, null, 2));
            logger.groupEnd();
            const logFriendlyHeaders = {};
            response.headers.forEach((value, key) => {
              logFriendlyHeaders[key] = value;
            });
            logger.groupCollapsed(`View response status and headers here.`);
            logger.log(`Response status: ${response.status}`);
            logger.log(`Response headers: ` + JSON.stringify(logFriendlyHeaders, null, 2));
            logger.groupEnd();
            logger.groupCollapsed(`View full response details here.`);
            logger.log(response.headers);
            logger.log(response);
            logger.groupEnd();
            logger.groupEnd();
          }
        }
        return cacheable;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it
     * easier to add in cacheability checks to requests made via Workbox's built-in
     * strategies.
     *
     * @memberof workbox-cacheable-response
     */
    class CacheableResponsePlugin {
      /**
       * To construct a new CacheableResponsePlugin instance you must provide at
       * least one of the `config` properties.
       *
       * If both `statuses` and `headers` are specified, then both conditions must
       * be met for the `Response` to be considered cacheable.
       *
       * @param {Object} config
       * @param {Array<number>} [config.statuses] One or more status codes that a
       * `Response` can have and be considered cacheable.
       * @param {Object<string,string>} [config.headers] A mapping of header names
       * and expected values that a `Response` can have and be considered cacheable.
       * If multiple headers are provided, only one needs to be present.
       */
      constructor(config) {
        /**
         * @param {Object} options
         * @param {Response} options.response
         * @return {Response|null}
         * @private
         */
        this.cacheWillUpdate = async ({
          response
        }) => {
          if (this._cacheableResponse.isResponseCacheable(response)) {
            return response;
          }
          return null;
        };
        this._cacheableResponse = new CacheableResponse(config);
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const cacheOkAndOpaquePlugin = {
      /**
       * Returns a valid response (to allow caching) if the status is 200 (OK) or
       * 0 (opaque).
       *
       * @param {Object} options
       * @param {Response} options.response
       * @return {Response|null}
       *
       * @private
       */
      cacheWillUpdate: async ({
        response
      }) => {
        if (response.status === 200 || response.status === 0) {
          return response;
        }
        return null;
      }
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * An implementation of a
     * [network first](https://developer.chrome.com/docs/workbox/caching-strategies-overview/#network-first-falling-back-to-cache)
     * request strategy.
     *
     * By default, this strategy will cache responses with a 200 status code as
     * well as [opaque responses](https://developer.chrome.com/docs/workbox/caching-resources-during-runtime/#opaque-responses).
     * Opaque responses are are cross-origin requests where the response doesn't
     * support [CORS](https://enable-cors.org/).
     *
     * If the network request fails, and there is no cache match, this will throw
     * a `WorkboxError` exception.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-strategies
     */
    class NetworkFirst extends Strategy {
      /**
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)
       * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)
       * `fetch()` requests made by this strategy.
       * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)
       * @param {number} [options.networkTimeoutSeconds] If set, any network requests
       * that fail to respond within the timeout will fallback to the cache.
       *
       * This option can be used to combat
       * "[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}"
       * scenarios.
       */
      constructor(options = {}) {
        super(options);
        // If this instance contains no plugins with a 'cacheWillUpdate' callback,
        // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.
        if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {
          this.plugins.unshift(cacheOkAndOpaquePlugin);
        }
        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;
        {
          if (this._networkTimeoutSeconds) {
            finalAssertExports.isType(this._networkTimeoutSeconds, 'number', {
              moduleName: 'workbox-strategies',
              className: this.constructor.name,
              funcName: 'constructor',
              paramName: 'networkTimeoutSeconds'
            });
          }
        }
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        const logs = [];
        {
          finalAssertExports.isInstance(request, Request, {
            moduleName: 'workbox-strategies',
            className: this.constructor.name,
            funcName: 'handle',
            paramName: 'makeRequest'
          });
        }
        const promises = [];
        let timeoutId;
        if (this._networkTimeoutSeconds) {
          const {
            id,
            promise
          } = this._getTimeoutPromise({
            request,
            logs,
            handler
          });
          timeoutId = id;
          promises.push(promise);
        }
        const networkPromise = this._getNetworkPromise({
          timeoutId,
          request,
          logs,
          handler
        });
        promises.push(networkPromise);
        const response = await handler.waitUntil((async () => {
          // Promise.race() will resolve as soon as the first promise resolves.
          return (await handler.waitUntil(Promise.race(promises))) || (
          // If Promise.race() resolved with null, it might be due to a network
          // timeout + a cache miss. If that were to happen, we'd rather wait until
          // the networkPromise resolves instead of returning null.
          // Note that it's fine to await an already-resolved promise, so we don't
          // have to check to see if it's still "in flight".
          await networkPromise);
        })());
        {
          logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));
          for (const log of logs) {
            logger.log(log);
          }
          messages.printFinalResponse(response);
          logger.groupEnd();
        }
        if (!response) {
          throw new WorkboxError('no-response', {
            url: request.url
          });
        }
        return response;
      }
      /**
       * @param {Object} options
       * @param {Request} options.request
       * @param {Array} options.logs A reference to the logs array
       * @param {Event} options.event
       * @return {Promise<Response>}
       *
       * @private
       */
      _getTimeoutPromise({
        request,
        logs,
        handler
      }) {
        let timeoutId;
        const timeoutPromise = new Promise(resolve => {
          const onNetworkTimeout = async () => {
            {
              logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);
            }
            resolve(await handler.cacheMatch(request));
          };
          timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);
        });
        return {
          promise: timeoutPromise,
          id: timeoutId
        };
      }
      /**
       * @param {Object} options
       * @param {number|undefined} options.timeoutId
       * @param {Request} options.request
       * @param {Array} options.logs A reference to the logs Array.
       * @param {Event} options.event
       * @return {Promise<Response>}
       *
       * @private
       */
      async _getNetworkPromise({
        timeoutId,
        request,
        logs,
        handler
      }) {
        let error;
        let response;
        try {
          response = await handler.fetchAndCachePut(request);
        } catch (fetchError) {
          if (fetchError instanceof Error) {
            error = fetchError;
          }
        }
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        {
          if (response) {
            logs.push(`Got response from network.`);
          } else {
            logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);
          }
        }
        if (error || !response) {
          response = await handler.cacheMatch(request);
          {
            if (response) {
              logs.push(`Found a cached response in the '${this.cacheName}'` + ` cache.`);
            } else {
              logs.push(`No response found in the '${this.cacheName}' cache.`);
            }
          }
        }
        return response;
      }
    }

    /*
      Copyright 2020 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A utility method that makes it easier to use `event.waitUntil` with
     * async functions and return the result.
     *
     * @param {ExtendableEvent} event
     * @param {Function} asyncFn
     * @return {Function}
     * @private
     */
    function waitUntil(event, asyncFn) {
      const returnPromise = asyncFn();
      event.waitUntil(returnPromise);
      return returnPromise;
    }

    // @ts-ignore
    try {
      self['workbox:precaching:7.2.0'] && _();
    } catch (e) {}

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    // Name of the search parameter used to store revision info.
    const REVISION_SEARCH_PARAM = '__WB_REVISION__';
    /**
     * Converts a manifest entry into a versioned URL suitable for precaching.
     *
     * @param {Object|string} entry
     * @return {string} A URL with versioning info.
     *
     * @private
     * @memberof workbox-precaching
     */
    function createCacheKey(entry) {
      if (!entry) {
        throw new WorkboxError('add-to-cache-list-unexpected-type', {
          entry
        });
      }
      // If a precache manifest entry is a string, it's assumed to be a versioned
      // URL, like '/app.abcd1234.js'. Return as-is.
      if (typeof entry === 'string') {
        const urlObject = new URL(entry, location.href);
        return {
          cacheKey: urlObject.href,
          url: urlObject.href
        };
      }
      const {
        revision,
        url
      } = entry;
      if (!url) {
        throw new WorkboxError('add-to-cache-list-unexpected-type', {
          entry
        });
      }
      // If there's just a URL and no revision, then it's also assumed to be a
      // versioned URL.
      if (!revision) {
        const urlObject = new URL(url, location.href);
        return {
          cacheKey: urlObject.href,
          url: urlObject.href
        };
      }
      // Otherwise, construct a properly versioned URL using the custom Workbox
      // search parameter along with the revision info.
      const cacheKeyURL = new URL(url, location.href);
      const originalURL = new URL(url, location.href);
      cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);
      return {
        cacheKey: cacheKeyURL.href,
        url: originalURL.href
      };
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A plugin, designed to be used with PrecacheController, to determine the
     * of assets that were updated (or not updated) during the install event.
     *
     * @private
     */
    class PrecacheInstallReportPlugin {
      constructor() {
        this.updatedURLs = [];
        this.notUpdatedURLs = [];
        this.handlerWillStart = async ({
          request,
          state
        }) => {
          // TODO: `state` should never be undefined...
          if (state) {
            state.originalRequest = request;
          }
        };
        this.cachedResponseWillBeUsed = async ({
          event,
          state,
          cachedResponse
        }) => {
          if (event.type === 'install') {
            if (state && state.originalRequest && state.originalRequest instanceof Request) {
              // TODO: `state` should never be undefined...
              const url = state.originalRequest.url;
              if (cachedResponse) {
                this.notUpdatedURLs.push(url);
              } else {
                this.updatedURLs.push(url);
              }
            }
          }
          return cachedResponse;
        };
      }
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A plugin, designed to be used with PrecacheController, to translate URLs into
     * the corresponding cache key, based on the current revision info.
     *
     * @private
     */
    class PrecacheCacheKeyPlugin {
      constructor({
        precacheController
      }) {
        this.cacheKeyWillBeUsed = async ({
          request,
          params
        }) => {
          // Params is type any, can't change right now.
          /* eslint-disable */
          const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);
          /* eslint-enable */
          return cacheKey ? new Request(cacheKey, {
            headers: request.headers
          }) : request;
        };
        this._precacheController = precacheController;
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * @param {string} groupTitle
     * @param {Array<string>} deletedURLs
     *
     * @private
     */
    const logGroup = (groupTitle, deletedURLs) => {
      logger.groupCollapsed(groupTitle);
      for (const url of deletedURLs) {
        logger.log(url);
      }
      logger.groupEnd();
    };
    /**
     * @param {Array<string>} deletedURLs
     *
     * @private
     * @memberof workbox-precaching
     */
    function printCleanupDetails(deletedURLs) {
      const deletionCount = deletedURLs.length;
      if (deletionCount > 0) {
        logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);
        logGroup('Deleted Cache Requests', deletedURLs);
        logger.groupEnd();
      }
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * @param {string} groupTitle
     * @param {Array<string>} urls
     *
     * @private
     */
    function _nestedGroup(groupTitle, urls) {
      if (urls.length === 0) {
        return;
      }
      logger.groupCollapsed(groupTitle);
      for (const url of urls) {
        logger.log(url);
      }
      logger.groupEnd();
    }
    /**
     * @param {Array<string>} urlsToPrecache
     * @param {Array<string>} urlsAlreadyPrecached
     *
     * @private
     * @memberof workbox-precaching
     */
    function printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {
      const precachedCount = urlsToPrecache.length;
      const alreadyPrecachedCount = urlsAlreadyPrecached.length;
      if (precachedCount || alreadyPrecachedCount) {
        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;
        if (alreadyPrecachedCount > 0) {
          message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;
        }
        logger.groupCollapsed(message);
        _nestedGroup(`View newly precached URLs.`, urlsToPrecache);
        _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);
        logger.groupEnd();
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    let supportStatus;
    /**
     * A utility function that determines whether the current browser supports
     * constructing a new `Response` from a `response.body` stream.
     *
     * @return {boolean} `true`, if the current browser can successfully
     *     construct a `Response` from a `response.body` stream, `false` otherwise.
     *
     * @private
     */
    function canConstructResponseFromBodyStream() {
      if (supportStatus === undefined) {
        const testResponse = new Response('');
        if ('body' in testResponse) {
          try {
            new Response(testResponse.body);
            supportStatus = true;
          } catch (error) {
            supportStatus = false;
          }
        }
        supportStatus = false;
      }
      return supportStatus;
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Allows developers to copy a response and modify its `headers`, `status`,
     * or `statusText` values (the values settable via a
     * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}
     * object in the constructor).
     * To modify these values, pass a function as the second argument. That
     * function will be invoked with a single object with the response properties
     * `{headers, status, statusText}`. The return value of this function will
     * be used as the `ResponseInit` for the new `Response`. To change the values
     * either modify the passed parameter(s) and return it, or return a totally
     * new object.
     *
     * This method is intentionally limited to same-origin responses, regardless of
     * whether CORS was used or not.
     *
     * @param {Response} response
     * @param {Function} modifier
     * @memberof workbox-core
     */
    async function copyResponse(response, modifier) {
      let origin = null;
      // If response.url isn't set, assume it's cross-origin and keep origin null.
      if (response.url) {
        const responseURL = new URL(response.url);
        origin = responseURL.origin;
      }
      if (origin !== self.location.origin) {
        throw new WorkboxError('cross-origin-copy-response', {
          origin
        });
      }
      const clonedResponse = response.clone();
      // Create a fresh `ResponseInit` object by cloning the headers.
      const responseInit = {
        headers: new Headers(clonedResponse.headers),
        status: clonedResponse.status,
        statusText: clonedResponse.statusText
      };
      // Apply any user modifications.
      const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;
      // Create the new response from the body stream and `ResponseInit`
      // modifications. Note: not all browsers support the Response.body stream,
      // so fall back to reading the entire body into memory as a blob.
      const body = canConstructResponseFromBodyStream() ? clonedResponse.body : await clonedResponse.blob();
      return new Response(body, modifiedResponseInit);
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A {@link workbox-strategies.Strategy} implementation
     * specifically designed to work with
     * {@link workbox-precaching.PrecacheController}
     * to both cache and fetch precached assets.
     *
     * Note: an instance of this class is created automatically when creating a
     * `PrecacheController`; it's generally not necessary to create this yourself.
     *
     * @extends workbox-strategies.Strategy
     * @memberof workbox-precaching
     */
    class PrecacheStrategy extends Strategy {
      /**
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] Cache name to store and retrieve
       * requests. Defaults to the cache names provided by
       * {@link workbox-core.cacheNames}.
       * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}
       * to use in conjunction with this caching strategy.
       * @param {Object} [options.fetchOptions] Values passed along to the
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}
       * of all fetch() requests made by this strategy.
       * @param {Object} [options.matchOptions] The
       * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}
       * for any `cache.match()` or `cache.put()` calls made by this strategy.
       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
       * get the response from the network if there's a precache miss.
       */
      constructor(options = {}) {
        options.cacheName = cacheNames.getPrecacheName(options.cacheName);
        super(options);
        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;
        // Redirected responses cannot be used to satisfy a navigation request, so
        // any redirected response must be "copied" rather than cloned, so the new
        // response doesn't contain the `redirected` flag. See:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1
        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);
      }
      /**
       * @private
       * @param {Request|string} request A request to run this strategy for.
       * @param {workbox-strategies.StrategyHandler} handler The event that
       *     triggered the request.
       * @return {Promise<Response>}
       */
      async _handle(request, handler) {
        const response = await handler.cacheMatch(request);
        if (response) {
          return response;
        }
        // If this is an `install` event for an entry that isn't already cached,
        // then populate the cache.
        if (handler.event && handler.event.type === 'install') {
          return await this._handleInstall(request, handler);
        }
        // Getting here means something went wrong. An entry that should have been
        // precached wasn't found in the cache.
        return await this._handleFetch(request, handler);
      }
      async _handleFetch(request, handler) {
        let response;
        const params = handler.params || {};
        // Fall back to the network if we're configured to do so.
        if (this._fallbackToNetwork) {
          {
            logger.warn(`The precached response for ` + `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` + `found. Falling back to the network.`);
          }
          const integrityInManifest = params.integrity;
          const integrityInRequest = request.integrity;
          const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;
          // Do not add integrity if the original request is no-cors
          // See https://github.com/GoogleChrome/workbox/issues/3096
          response = await handler.fetch(new Request(request, {
            integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined
          }));
          // It's only "safe" to repair the cache if we're using SRI to guarantee
          // that the response matches the precache manifest's expectations,
          // and there's either a) no integrity property in the incoming request
          // or b) there is an integrity, and it matches the precache manifest.
          // See https://github.com/GoogleChrome/workbox/issues/2858
          // Also if the original request users no-cors we don't use integrity.
          // See https://github.com/GoogleChrome/workbox/issues/3096
          if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {
            this._useDefaultCacheabilityPluginIfNeeded();
            const wasCached = await handler.cachePut(request, response.clone());
            {
              if (wasCached) {
                logger.log(`A response for ${getFriendlyURL(request.url)} ` + `was used to "repair" the precache.`);
              }
            }
          }
        } else {
          // This shouldn't normally happen, but there are edge cases:
          // https://github.com/GoogleChrome/workbox/issues/1441
          throw new WorkboxError('missing-precache-entry', {
            cacheName: this.cacheName,
            url: request.url
          });
        }
        {
          const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));
          // Workbox is going to handle the route.
          // print the routing details to the console.
          logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));
          logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);
          logger.groupCollapsed(`View request details here.`);
          logger.log(request);
          logger.groupEnd();
          logger.groupCollapsed(`View response details here.`);
          logger.log(response);
          logger.groupEnd();
          logger.groupEnd();
        }
        return response;
      }
      async _handleInstall(request, handler) {
        this._useDefaultCacheabilityPluginIfNeeded();
        const response = await handler.fetch(request);
        // Make sure we defer cachePut() until after we know the response
        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737
        const wasCached = await handler.cachePut(request, response.clone());
        if (!wasCached) {
          // Throwing here will lead to the `install` handler failing, which
          // we want to do if *any* of the responses aren't safe to cache.
          throw new WorkboxError('bad-precaching-response', {
            url: request.url,
            status: response.status
          });
        }
        return response;
      }
      /**
       * This method is complex, as there a number of things to account for:
       *
       * The `plugins` array can be set at construction, and/or it might be added to
       * to at any time before the strategy is used.
       *
       * At the time the strategy is used (i.e. during an `install` event), there
       * needs to be at least one plugin that implements `cacheWillUpdate` in the
       * array, other than `copyRedirectedCacheableResponsesPlugin`.
       *
       * - If this method is called and there are no suitable `cacheWillUpdate`
       * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.
       *
       * - If this method is called and there is exactly one `cacheWillUpdate`, then
       * we don't have to do anything (this might be a previously added
       * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).
       *
       * - If this method is called and there is more than one `cacheWillUpdate`,
       * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,
       * we need to remove it. (This situation is unlikely, but it could happen if
       * the strategy is used multiple times, the first without a `cacheWillUpdate`,
       * and then later on after manually adding a custom `cacheWillUpdate`.)
       *
       * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.
       *
       * @private
       */
      _useDefaultCacheabilityPluginIfNeeded() {
        let defaultPluginIndex = null;
        let cacheWillUpdatePluginCount = 0;
        for (const [index, plugin] of this.plugins.entries()) {
          // Ignore the copy redirected plugin when determining what to do.
          if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {
            continue;
          }
          // Save the default plugin's index, in case it needs to be removed.
          if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {
            defaultPluginIndex = index;
          }
          if (plugin.cacheWillUpdate) {
            cacheWillUpdatePluginCount++;
          }
        }
        if (cacheWillUpdatePluginCount === 0) {
          this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);
        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {
          // Only remove the default plugin; multiple custom plugins are allowed.
          this.plugins.splice(defaultPluginIndex, 1);
        }
        // Nothing needs to be done if cacheWillUpdatePluginCount is 1
      }
    }
    PrecacheStrategy.defaultPrecacheCacheabilityPlugin = {
      async cacheWillUpdate({
        response
      }) {
        if (!response || response.status >= 400) {
          return null;
        }
        return response;
      }
    };
    PrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {
      async cacheWillUpdate({
        response
      }) {
        return response.redirected ? await copyResponse(response) : response;
      }
    };

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Performs efficient precaching of assets.
     *
     * @memberof workbox-precaching
     */
    class PrecacheController {
      /**
       * Create a new PrecacheController.
       *
       * @param {Object} [options]
       * @param {string} [options.cacheName] The cache to use for precaching.
       * @param {string} [options.plugins] Plugins to use when precaching as well
       * as responding to fetch events for precached assets.
       * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to
       * get the response from the network if there's a precache miss.
       */
      constructor({
        cacheName,
        plugins = [],
        fallbackToNetwork = true
      } = {}) {
        this._urlsToCacheKeys = new Map();
        this._urlsToCacheModes = new Map();
        this._cacheKeysToIntegrities = new Map();
        this._strategy = new PrecacheStrategy({
          cacheName: cacheNames.getPrecacheName(cacheName),
          plugins: [...plugins, new PrecacheCacheKeyPlugin({
            precacheController: this
          })],
          fallbackToNetwork
        });
        // Bind the install and activate methods to the instance.
        this.install = this.install.bind(this);
        this.activate = this.activate.bind(this);
      }
      /**
       * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and
       * used to cache assets and respond to fetch events.
       */
      get strategy() {
        return this._strategy;
      }
      /**
       * Adds items to the precache list, removing any duplicates and
       * stores the files in the
       * {@link workbox-core.cacheNames|"precache cache"} when the service
       * worker installs.
       *
       * This method can be called multiple times.
       *
       * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
       */
      precache(entries) {
        this.addToCacheList(entries);
        if (!this._installAndActiveListenersAdded) {
          self.addEventListener('install', this.install);
          self.addEventListener('activate', this.activate);
          this._installAndActiveListenersAdded = true;
        }
      }
      /**
       * This method will add items to the precache list, removing duplicates
       * and ensuring the information is valid.
       *
       * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries
       *     Array of entries to precache.
       */
      addToCacheList(entries) {
        {
          finalAssertExports.isArray(entries, {
            moduleName: 'workbox-precaching',
            className: 'PrecacheController',
            funcName: 'addToCacheList',
            paramName: 'entries'
          });
        }
        const urlsToWarnAbout = [];
        for (const entry of entries) {
          // See https://github.com/GoogleChrome/workbox/issues/2259
          if (typeof entry === 'string') {
            urlsToWarnAbout.push(entry);
          } else if (entry && entry.revision === undefined) {
            urlsToWarnAbout.push(entry.url);
          }
          const {
            cacheKey,
            url
          } = createCacheKey(entry);
          const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';
          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {
            throw new WorkboxError('add-to-cache-list-conflicting-entries', {
              firstEntry: this._urlsToCacheKeys.get(url),
              secondEntry: cacheKey
            });
          }
          if (typeof entry !== 'string' && entry.integrity) {
            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {
              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {
                url
              });
            }
            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);
          }
          this._urlsToCacheKeys.set(url, cacheKey);
          this._urlsToCacheModes.set(url, cacheMode);
          if (urlsToWarnAbout.length > 0) {
            const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;
            {
              logger.warn(warningMessage);
            }
          }
        }
      }
      /**
       * Precaches new and updated assets. Call this method from the service worker
       * install event.
       *
       * Note: this method calls `event.waitUntil()` for you, so you do not need
       * to call it yourself in your event handlers.
       *
       * @param {ExtendableEvent} event
       * @return {Promise<workbox-precaching.InstallResult>}
       */
      install(event) {
        // waitUntil returns Promise<any>
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return waitUntil(event, async () => {
          const installReportPlugin = new PrecacheInstallReportPlugin();
          this.strategy.plugins.push(installReportPlugin);
          // Cache entries one at a time.
          // See https://github.com/GoogleChrome/workbox/issues/2528
          for (const [url, cacheKey] of this._urlsToCacheKeys) {
            const integrity = this._cacheKeysToIntegrities.get(cacheKey);
            const cacheMode = this._urlsToCacheModes.get(url);
            const request = new Request(url, {
              integrity,
              cache: cacheMode,
              credentials: 'same-origin'
            });
            await Promise.all(this.strategy.handleAll({
              params: {
                cacheKey
              },
              request,
              event
            }));
          }
          const {
            updatedURLs,
            notUpdatedURLs
          } = installReportPlugin;
          {
            printInstallDetails(updatedURLs, notUpdatedURLs);
          }
          return {
            updatedURLs,
            notUpdatedURLs
          };
        });
      }
      /**
       * Deletes assets that are no longer present in the current precache manifest.
       * Call this method from the service worker activate event.
       *
       * Note: this method calls `event.waitUntil()` for you, so you do not need
       * to call it yourself in your event handlers.
       *
       * @param {ExtendableEvent} event
       * @return {Promise<workbox-precaching.CleanupResult>}
       */
      activate(event) {
        // waitUntil returns Promise<any>
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return waitUntil(event, async () => {
          const cache = await self.caches.open(this.strategy.cacheName);
          const currentlyCachedRequests = await cache.keys();
          const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());
          const deletedURLs = [];
          for (const request of currentlyCachedRequests) {
            if (!expectedCacheKeys.has(request.url)) {
              await cache.delete(request);
              deletedURLs.push(request.url);
            }
          }
          {
            printCleanupDetails(deletedURLs);
          }
          return {
            deletedURLs
          };
        });
      }
      /**
       * Returns a mapping of a precached URL to the corresponding cache key, taking
       * into account the revision information for the URL.
       *
       * @return {Map<string, string>} A URL to cache key mapping.
       */
      getURLsToCacheKeys() {
        return this._urlsToCacheKeys;
      }
      /**
       * Returns a list of all the URLs that have been precached by the current
       * service worker.
       *
       * @return {Array<string>} The precached URLs.
       */
      getCachedURLs() {
        return [...this._urlsToCacheKeys.keys()];
      }
      /**
       * Returns the cache key used for storing a given URL. If that URL is
       * unversioned, like `/index.html', then the cache key will be the original
       * URL with a search parameter appended to it.
       *
       * @param {string} url A URL whose cache key you want to look up.
       * @return {string} The versioned URL that corresponds to a cache key
       * for the original URL, or undefined if that URL isn't precached.
       */
      getCacheKeyForURL(url) {
        const urlObject = new URL(url, location.href);
        return this._urlsToCacheKeys.get(urlObject.href);
      }
      /**
       * @param {string} url A cache key whose SRI you want to look up.
       * @return {string} The subresource integrity associated with the cache key,
       * or undefined if it's not set.
       */
      getIntegrityForCacheKey(cacheKey) {
        return this._cacheKeysToIntegrities.get(cacheKey);
      }
      /**
       * This acts as a drop-in replacement for
       * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)
       * with the following differences:
       *
       * - It knows what the name of the precache is, and only checks in that cache.
       * - It allows you to pass in an "original" URL without versioning parameters,
       * and it will automatically look up the correct cache key for the currently
       * active revision of that URL.
       *
       * E.g., `matchPrecache('index.html')` will find the correct precached
       * response for the currently active service worker, even if the actual cache
       * key is `'/index.html?__WB_REVISION__=1234abcd'`.
       *
       * @param {string|Request} request The key (without revisioning parameters)
       * to look up in the precache.
       * @return {Promise<Response|undefined>}
       */
      async matchPrecache(request) {
        const url = request instanceof Request ? request.url : request;
        const cacheKey = this.getCacheKeyForURL(url);
        if (cacheKey) {
          const cache = await self.caches.open(this.strategy.cacheName);
          return cache.match(cacheKey);
        }
        return undefined;
      }
      /**
       * Returns a function that looks up `url` in the precache (taking into
       * account revision information), and returns the corresponding `Response`.
       *
       * @param {string} url The precached URL which will be used to lookup the
       * `Response`.
       * @return {workbox-routing~handlerCallback}
       */
      createHandlerBoundToURL(url) {
        const cacheKey = this.getCacheKeyForURL(url);
        if (!cacheKey) {
          throw new WorkboxError('non-precached-url', {
            url
          });
        }
        return options => {
          options.request = new Request(url);
          options.params = Object.assign({
            cacheKey
          }, options.params);
          return this.strategy.handle(options);
        };
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    let precacheController;
    /**
     * @return {PrecacheController}
     * @private
     */
    const getOrCreatePrecacheController = () => {
      if (!precacheController) {
        precacheController = new PrecacheController();
      }
      return precacheController;
    };

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Removes any URL search parameters that should be ignored.
     *
     * @param {URL} urlObject The original URL.
     * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against
     * each search parameter name. Matches mean that the search parameter should be
     * ignored.
     * @return {URL} The URL with any ignored search parameters removed.
     *
     * @private
     * @memberof workbox-precaching
     */
    function removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {
      // Convert the iterable into an array at the start of the loop to make sure
      // deletion doesn't mess up iteration.
      for (const paramName of [...urlObject.searchParams.keys()]) {
        if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {
          urlObject.searchParams.delete(paramName);
        }
      }
      return urlObject;
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Generator function that yields possible variations on the original URL to
     * check, one at a time.
     *
     * @param {string} url
     * @param {Object} options
     *
     * @private
     * @memberof workbox-precaching
     */
    function* generateURLVariations(url, {
      ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],
      directoryIndex = 'index.html',
      cleanURLs = true,
      urlManipulation
    } = {}) {
      const urlObject = new URL(url, location.href);
      urlObject.hash = '';
      yield urlObject.href;
      const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);
      yield urlWithoutIgnoredParams.href;
      if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {
        const directoryURL = new URL(urlWithoutIgnoredParams.href);
        directoryURL.pathname += directoryIndex;
        yield directoryURL.href;
      }
      if (cleanURLs) {
        const cleanURL = new URL(urlWithoutIgnoredParams.href);
        cleanURL.pathname += '.html';
        yield cleanURL.href;
      }
      if (urlManipulation) {
        const additionalURLs = urlManipulation({
          url: urlObject
        });
        for (const urlToAttempt of additionalURLs) {
          yield urlToAttempt.href;
        }
      }
    }

    /*
      Copyright 2020 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * A subclass of {@link workbox-routing.Route} that takes a
     * {@link workbox-precaching.PrecacheController}
     * instance and uses it to match incoming requests and handle fetching
     * responses from the precache.
     *
     * @memberof workbox-precaching
     * @extends workbox-routing.Route
     */
    class PrecacheRoute extends Route {
      /**
       * @param {PrecacheController} precacheController A `PrecacheController`
       * instance used to both match requests and respond to fetch events.
       * @param {Object} [options] Options to control how requests are matched
       * against the list of precached URLs.
       * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will
       * check cache entries for a URLs ending with '/' to see if there is a hit when
       * appending the `directoryIndex` value.
       * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An
       * array of regex's to remove search params when looking for a cache match.
       * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will
       * check the cache for the URL with a `.html` added to the end of the end.
       * @param {workbox-precaching~urlManipulation} [options.urlManipulation]
       * This is a function that should take a URL and return an array of
       * alternative URLs that should be checked for precache matches.
       */
      constructor(precacheController, options) {
        const match = ({
          request
        }) => {
          const urlsToCacheKeys = precacheController.getURLsToCacheKeys();
          for (const possibleURL of generateURLVariations(request.url, options)) {
            const cacheKey = urlsToCacheKeys.get(possibleURL);
            if (cacheKey) {
              const integrity = precacheController.getIntegrityForCacheKey(cacheKey);
              return {
                cacheKey,
                integrity
              };
            }
          }
          {
            logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));
          }
          return;
        };
        super(match, precacheController.strategy);
      }
    }

    /*
      Copyright 2019 Google LLC
      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Add a `fetch` listener to the service worker that will
     * respond to
     * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}
     * with precached assets.
     *
     * Requests for assets that aren't precached, the `FetchEvent` will not be
     * responded to, allowing the event to fall through to other `fetch` event
     * listeners.
     *
     * @param {Object} [options] See the {@link workbox-precaching.PrecacheRoute}
     * options.
     *
     * @memberof workbox-precaching
     */
    function addRoute(options) {
      const precacheController = getOrCreatePrecacheController();
      const precacheRoute = new PrecacheRoute(precacheController, options);
      registerRoute(precacheRoute);
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Adds items to the precache list, removing any duplicates and
     * stores the files in the
     * {@link workbox-core.cacheNames|"precache cache"} when the service
     * worker installs.
     *
     * This method can be called multiple times.
     *
     * Please note: This method **will not** serve any of the cached files for you.
     * It only precaches files. To respond to a network request you call
     * {@link workbox-precaching.addRoute}.
     *
     * If you have a single array of files to precache, you can just call
     * {@link workbox-precaching.precacheAndRoute}.
     *
     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.
     *
     * @memberof workbox-precaching
     */
    function precache(entries) {
      const precacheController = getOrCreatePrecacheController();
      precacheController.precache(entries);
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * This method will add entries to the precache list and add a route to
     * respond to fetch events.
     *
     * This is a convenience method that will call
     * {@link workbox-precaching.precache} and
     * {@link workbox-precaching.addRoute} in a single call.
     *
     * @param {Array<Object|string>} entries Array of entries to precache.
     * @param {Object} [options] See the
     * {@link workbox-precaching.PrecacheRoute} options.
     *
     * @memberof workbox-precaching
     */
    function precacheAndRoute(entries, options) {
      precache(entries);
      addRoute(options);
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    const SUBSTRING_TO_FIND = '-precache-';
    /**
     * Cleans up incompatible precaches that were created by older versions of
     * Workbox, by a service worker registered under the current scope.
     *
     * This is meant to be called as part of the `activate` event.
     *
     * This should be safe to use as long as you don't include `substringToFind`
     * (defaulting to `-precache-`) in your non-precache cache names.
     *
     * @param {string} currentPrecacheName The cache name currently in use for
     * precaching. This cache won't be deleted.
     * @param {string} [substringToFind='-precache-'] Cache names which include this
     * substring will be deleted (excluding `currentPrecacheName`).
     * @return {Array<string>} A list of all the cache names that were deleted.
     *
     * @private
     * @memberof workbox-precaching
     */
    const deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {
      const cacheNames = await self.caches.keys();
      const cacheNamesToDelete = cacheNames.filter(cacheName => {
        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;
      });
      await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));
      return cacheNamesToDelete;
    };

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Adds an `activate` event listener which will clean up incompatible
     * precaches that were created by older versions of Workbox.
     *
     * @memberof workbox-precaching
     */
    function cleanupOutdatedCaches() {
      // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
      self.addEventListener('activate', event => {
        const cacheName = cacheNames.getPrecacheName();
        event.waitUntil(deleteOutdatedCaches(cacheName).then(cachesDeleted => {
          {
            if (cachesDeleted.length > 0) {
              logger.log(`The following out-of-date precaches were cleaned up ` + `automatically:`, cachesDeleted);
            }
          }
        }));
      });
    }

    /*
      Copyright 2018 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * NavigationRoute makes it easy to create a
     * {@link workbox-routing.Route} that matches for browser
     * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.
     *
     * It will only match incoming Requests whose
     * {@link https://fetch.spec.whatwg.org/#concept-request-mode|mode}
     * is set to `navigate`.
     *
     * You can optionally only apply this route to a subset of navigation requests
     * by using one or both of the `denylist` and `allowlist` parameters.
     *
     * @memberof workbox-routing
     * @extends workbox-routing.Route
     */
    class NavigationRoute extends Route {
      /**
       * If both `denylist` and `allowlist` are provided, the `denylist` will
       * take precedence and the request will not match this route.
       *
       * The regular expressions in `allowlist` and `denylist`
       * are matched against the concatenated
       * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}
       * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}
       * portions of the requested URL.
       *
       * *Note*: These RegExps may be evaluated against every destination URL during
       * a navigation. Avoid using
       * [complex RegExps](https://github.com/GoogleChrome/workbox/issues/3077),
       * or else your users may see delays when navigating your site.
       *
       * @param {workbox-routing~handlerCallback} handler A callback
       * function that returns a Promise resulting in a Response.
       * @param {Object} options
       * @param {Array<RegExp>} [options.denylist] If any of these patterns match,
       * the route will not handle the request (even if a allowlist RegExp matches).
       * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns
       * match the URL's pathname and search parameter, the route will handle the
       * request (assuming the denylist doesn't match).
       */
      constructor(handler, {
        allowlist = [/./],
        denylist = []
      } = {}) {
        {
          finalAssertExports.isArrayOfClass(allowlist, RegExp, {
            moduleName: 'workbox-routing',
            className: 'NavigationRoute',
            funcName: 'constructor',
            paramName: 'options.allowlist'
          });
          finalAssertExports.isArrayOfClass(denylist, RegExp, {
            moduleName: 'workbox-routing',
            className: 'NavigationRoute',
            funcName: 'constructor',
            paramName: 'options.denylist'
          });
        }
        super(options => this._match(options), handler);
        this._allowlist = allowlist;
        this._denylist = denylist;
      }
      /**
       * Routes match handler.
       *
       * @param {Object} options
       * @param {URL} options.url
       * @param {Request} options.request
       * @return {boolean}
       *
       * @private
       */
      _match({
        url,
        request
      }) {
        if (request && request.mode !== 'navigate') {
          return false;
        }
        const pathnameAndSearch = url.pathname + url.search;
        for (const regExp of this._denylist) {
          if (regExp.test(pathnameAndSearch)) {
            {
              logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL matches this denylist pattern: ` + `${regExp.toString()}`);
            }
            return false;
          }
        }
        if (this._allowlist.some(regExp => regExp.test(pathnameAndSearch))) {
          {
            logger.debug(`The navigation route ${pathnameAndSearch} ` + `is being used.`);
          }
          return true;
        }
        {
          logger.log(`The navigation route ${pathnameAndSearch} is not ` + `being used, since the URL being navigated to doesn't ` + `match the allowlist.`);
        }
        return false;
      }
    }

    /*
      Copyright 2019 Google LLC

      Use of this source code is governed by an MIT-style
      license that can be found in the LICENSE file or at
      https://opensource.org/licenses/MIT.
    */
    /**
     * Helper function that calls
     * {@link PrecacheController#createHandlerBoundToURL} on the default
     * {@link PrecacheController} instance.
     *
     * If you are creating your own {@link PrecacheController}, then call the
     * {@link PrecacheController#createHandlerBoundToURL} on that instance,
     * instead of using this function.
     *
     * @param {string} url The precached URL which will be used to lookup the
     * `Response`.
     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the
     * response from the network if there's a precache miss.
     * @return {workbox-routing~handlerCallback}
     *
     * @memberof workbox-precaching
     */
    function createHandlerBoundToURL(url) {
      const precacheController = getOrCreatePrecacheController();
      return precacheController.createHandlerBoundToURL(url);
    }

    exports.BackgroundSyncPlugin = BackgroundSyncPlugin;
    exports.CacheableResponsePlugin = CacheableResponsePlugin;
    exports.ExpirationPlugin = ExpirationPlugin;
    exports.NavigationRoute = NavigationRoute;
    exports.NetworkFirst = NetworkFirst;
    exports.NetworkOnly = NetworkOnly;
    exports.cleanupOutdatedCaches = cleanupOutdatedCaches;
    exports.createHandlerBoundToURL = createHandlerBoundToURL;
    exports.precacheAndRoute = precacheAndRoute;
    exports.registerRoute = registerRoute;

}));

===== ./client/postcss.config.js =====
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

===== ./client/src/App.tsx =====
// client/src/App.tsx
import React, { Suspense, lazy, useContext, useEffect } from 'react';
import { Switch, Route, Redirect, useLocation, RouteProps } from "wouter";
import { QueryClientProvider } from "@tanstack/react-query";
import { ThemeProvider } from "next-themes";
import { Loader2 } from "lucide-react";

import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import MainLayout from "@/components/layout/main-layout";
import { UserProvider , UserContext } from "@/context/UserContext";
import { AlunoProvider, useAluno } from "@/context/AlunoContext";
// <<< INÍCIO DA CORREÇÃO >>>
import { WorkoutPlayerProvider } from "@/context/WorkoutPlayerContext";
// <<< FIM DA CORREÇÃO >>>
import { queryClient } from "@/lib/queryClient";
import NotFound from "@/pages/not-found";
import { PWAInstallProvider } from '@/context/PWAInstallContext';
import { useToast } from '@/hooks/use-toast';
// ⬇️ Usado na checagem assíncrona do restaurador de rota
import { fetchWithAuth } from "@/lib/apiClient";

// Unified PWA updates manager
import { AppUpdatesManager } from '@/components/AppUpdatesManager';

// --- Páginas ---
const RenovarPlanoPage = React.lazy(() => import("@/pages/renovar-plano"));
const SolicitarRenovacao = React.lazy(() => import("@/pages/solicitar-renovacao"));
const AdminRenewalRequests = React.lazy(() => import("@/pages/admin/renewal-requests"));

const Dashboard = lazy(() => import("@/pages/dashboard"));
const StudentsIndex = lazy(() => import("@/pages/alunos/index"));
const NewStudent = lazy(() => import("@/pages/alunos/new"));
const EditStudentPage = lazy(() => import("@/pages/alunos/edit"));
const ExercisesIndex = lazy(() => import("@/pages/exercises/index"));
const SessionsPage = lazy(() => import("@/pages/sessoes/index"));
const TreinosPage = lazy(() => import("@/pages/treinos/index"));
const MeuPlanoPage = lazy(() => import("@/pages/meu-plano"));
const ProfileEditPage = lazy(() => import('@/pages/perfil/editar'));
const PersonalLoginPage = lazy(() => import("@/pages/login")); 
const LandingLoginPage = lazy(() => import("@/pages/public/LandingLoginPage")); 
const CadastroPersonalPorConvitePage = lazy(() => import("@/pages/public/CadastroPersonalPorConvitePage"));
const CadastroAlunoPorConvitePage = lazy(() => import("@/pages/public/CadastroAlunoPorConvitePage"));
const AlunoLoginPage = lazy(() => import("@/pages/public/AlunoLoginPage"));
const AlunoDashboardPage = lazy(() => import('@/pages/alunos/AlunoDashboardPage'));
const AlunoFichaDetalhePage = lazy(() => import('@/pages/alunos/AlunoFichaDetalhePage'));
const AlunoHistoricoPage = lazy(() => import('@/pages/alunos/AlunoHistoricoPage'));
const MeusTreinosPage = lazy(() => import('@/pages/alunos/MeusTreinosPage'));
const ListarPersonaisPage = lazy(() => import('@/pages/admin/ListarPersonaisPage'));
const CriarPersonalPage = lazy(() => import('@/pages/admin/CriarPersonalPage'));
const EditarPersonalPage = lazy(() => import('@/pages/admin/EditarPersonalPage'));
const GerenciarConvitesPage = lazy(() => import('@/pages/admin/GerenciarConvitesPage'));
const AdminDashboardPage = lazy(() => import('@/pages/admin/AdminDashboardPage'));
const GerenciarPlanosPersonalPage = lazy(() => import('@/pages/admin/GerenciarPlanosPersonalPage'));
const DemoDashboard = lazy(() => import("@/pages/demo-dashboard"));

interface CustomRouteProps extends Omit<RouteProps, 'component'> { component: React.ComponentType<any>; }

const ProtectedRoute: React.FC<CustomRouteProps> = ({ component: Component, ...rest }) => {
  const { user, isLoading: isUserContextLoading } = useContext(UserContext);
  if (isUserContextLoading) return <div className="flex h-screen w-full items-center justify-center"><Loader2 className="h-10 w-10 animate-spin text-primary" /></div>;
  if (!user) return <Redirect to="/login" />;
  return <Route {...rest} component={Component} />;
};

const AdminProtectedRoute: React.FC<CustomRouteProps> = ({ component: Component, ...rest }) => {
  const { user, isLoading: isUserContextLoading } = useContext(UserContext);
  if (isUserContextLoading) return <div className="flex h-screen w-full items-center justify-center"><Loader2 className="h-10 w-10 animate-spin text-primary" /></div>;
  if (!user) return <Redirect to="/login" />;
  if (user.role.toLowerCase() !== 'admin') return <Redirect to="/" />;
  return <Route {...rest} component={Component} />;
};

const AlunoProtectedRoute: React.FC<CustomRouteProps> = ({ component: Component, ...rest }) => {
  const { aluno, isLoadingAluno } = useAluno();
  if (isLoadingAluno) return <div className="flex h-screen w-full items-center justify-center"><Loader2 className="h-10 w-10 animate-spin text-primary" /> Carregando...</div>;
  if (!aluno) return <Redirect to="/login/aluno" />;
  return <Route {...rest} component={Component} />;
};

interface AuthFailedEventDetail {
  status: number;
  forAluno: boolean;
  forPersonalAdmin: boolean;
  code?: string;
}

function AppContent() {
  const { user, isLoading: isUserLoading } = useContext(UserContext);
  const { aluno, isLoadingAluno } = useAluno();
  const [location, navigate] = useLocation();
  const { toast } = useToast();

  const isDebugMode = import.meta.env.VITE_DEBUG_INVITATIONS === 'true';
  
  React.useEffect(() => {
    if (isDebugMode || import.meta.env.DEV) {
      console.log('[AppContent] Location changed:', location);
      console.log('[AppContent] User:', user ? 'authenticated' : 'not authenticated');
      console.log('[AppContent] Aluno:', aluno ? 'authenticated' : 'not authenticated');
    }
  }, [location, user, aluno, isDebugMode]);

  useEffect(() => {
    if ((user || aluno) && !location.startsWith("/login") && !location.startsWith("/convite/") && !location.startsWith("/cadastrar-personal/convite/")) {
      localStorage.setItem("rotaAtual", location);
    }
  }, [user, aluno, location]);

  useEffect(() => {
    // ⬇️ Checa se deve restaurar /renovar-plano – só se houver approved pendente
    const hasApprovedPending = async (): Promise<boolean> => {
      try {
        const list = await fetchWithAuth<any[]>("/api/personal/renewal-requests?status=approved,APPROVED");
        return Array.isArray(list) && list.length > 0;
      } catch {
        return false;
      }
    };

    const restabelecerRota = async () => {
      const rotaSalva = localStorage.getItem("rotaAtual");
      const rotaAtual = window.location.pathname;
      
      const temTokenPersonal = localStorage.getItem("authToken") !== null;
      const temTokenAluno = localStorage.getItem("alunoAuthToken") !== null;
      const usuarioLogado = temTokenPersonal || temTokenAluno;
      const rotaProtegida = rotaSalva && !rotaSalva.includes("/login");
      
      if (usuarioLogado && rotaProtegida && rotaAtual !== rotaSalva) {
        console.log("[Route Restoration] Tentando restaurar rota:", rotaSalva, "atual:", rotaAtual);
        
        let rotaValida = false;
        if (temTokenPersonal && !rotaSalva!.startsWith("/aluno/")) {
          rotaValida = true;
        } else if (temTokenAluno && rotaSalva!.startsWith("/aluno/")) {
          rotaValida = true;
        }
        
        if (!rotaValida) {
          console.log("[Route Restoration] Rota inválida para tipo de usuário atual:", rotaSalva);
          return false;
        }

        // ✅ Regra específica: /renovar-plano só pode ser restaurada se houver approved
        if (rotaSalva!.startsWith("/renovar-plano")) {
          const ok = await hasApprovedPending();
          if (!ok) {
            console.log("[Route Restoration] Bloqueando restauração de /renovar-plano (sem approved). Redirecionando para /solicitar-renovacao.");
            localStorage.setItem("rotaAtual", "/solicitar-renovacao");
            localStorage.setItem("restaurandoRota", "true");
            navigate("/solicitar-renovacao", { replace: true });
            setTimeout(() => localStorage.removeItem("restaurandoRota"), 200);
            return true;
          }
        }

        console.log("[Route Restoration] Restaurando rota válida:", rotaSalva);
        localStorage.setItem("restaurandoRota", "true");
        navigate(rotaSalva!, { replace: true });
        setTimeout(() => localStorage.removeItem("restaurandoRota"), 200);
        return true;
      }
      return false;
    };

    const handleAppFocus = () => {
      console.log("[Route Restoration] App focado/visível, executando restauração imediata");
      void restabelecerRota();
    };

    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        handleAppFocus();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    window.addEventListener("focus", handleAppFocus);

    void restabelecerRota();

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("focus", handleAppFocus);
    };
  }, [navigate]);

  useEffect(() => {
    const handleAuthFailed = (event: Event) => {
      const customEvent = event as CustomEvent<AuthFailedEventDetail>;
      const { status, forAluno, forPersonalAdmin, code } = customEvent.detail;

      console.log(`[Global Auth Handler] Evento 'auth-failed' recebido:`, customEvent.detail);

      const shouldProcessAlunoEvent = forAluno && aluno;
      const shouldProcessPersonalEvent = forPersonalAdmin && user;
      
      if (!shouldProcessAlunoEvent && !shouldProcessPersonalEvent) {
        console.log(`[Global Auth Handler] Evento não aplicável ao contexto atual. ForAluno: ${forAluno}, AlunoLogado: ${!!aluno}, ForPersonalAdmin: ${forPersonalAdmin}, UserLogado: ${!!user}`);
        return;
      }

      let redirectPath = '/';
      let message = 'Sua sessão expirou ou é inválida. Por favor, faça login novamente.';

      if (forAluno && shouldProcessAlunoEvent) {
        localStorage.removeItem('alunoAuthToken');
        localStorage.removeItem('alunoRefreshToken');
        localStorage.removeItem('alunoData');
        redirectPath = '/login/aluno';
      }
      if (forPersonalAdmin && shouldProcessPersonalEvent) {
        localStorage.removeItem('authToken');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('userData');
        redirectPath = '/login';
      }

      if (shouldProcessAlunoEvent || shouldProcessPersonalEvent) {
        queryClient.clear();
      }

      switch (code) {
        case 'TOKEN_NOT_PROVIDED':
          message = 'Você não está autenticado. Por favor, faça login.';
          break;
        case 'TOKEN_EXPIRED':
          message = 'Sua sessão expirou. Por favor, faça login novamente.';
          break;
        case 'INVALID_TOKEN':
          message = 'Seu token de acesso é inválido. Por favor, faça login novamente.';
          break;
        case 'UNAUTHORIZED_ROLE':
          message = 'Você não tem permissão para acessar este recurso.';
          redirectPath = forPersonalAdmin ? '/' : '/aluno/dashboard';
          break;
        case 'INVALID_CREDENTIALS':
          console.log("[Global Auth Handler] Erro de credenciais inválidas, tratado no componente de login.");
          return;
        case 'ACCOUNT_INACTIVE':
          message = 'Sua conta está inativa. Fale com seu personal trainer.';
          redirectPath = forAluno ? '/login/aluno' : '/login';
          break;
        default:
          if (status === 401 || status === 403) {
            message = 'Ocorreu um problema de autenticação. Por favor, faça login novamente.';
          } else {
            message = 'Ocorreu um erro inesperado. Por favor, tente novamente.';
          }
          break;
      }

      if (code !== 'INVALID_CREDENTIALS') {
        toast({
          title: "Atenção!",
          description: message,
          variant: "destructive",
        });
      }
      
      if (window.location.pathname !== redirectPath && !location.startsWith(redirectPath)) {
        console.log(`[Global Auth Handler] Redirecionando para: ${redirectPath}`);
        navigate(redirectPath);
      }
    };

    window.addEventListener('auth-failed', handleAuthFailed as EventListener);

    return () => {
      window.removeEventListener('auth-failed', handleAuthFailed as EventListener);
    };
  }, [location, navigate, toast, user, aluno]);

  if (isUserLoading || isLoadingAluno) {
    return <div className="flex h-screen w-full items-center justify-center"><Loader2 className="h-10 w-10 animate-spin text-primary" /></div>;
  }

  const restaurandoRota = localStorage.getItem("restaurandoRota");
  if (restaurandoRota) {
    console.log("[AppContent] Route restoration in progress, blocking default redirects");
    return <div className="flex h-screen w-full items-center justify-center"><Loader2 className="h-10 w-10 animate-spin text-primary" /></div>;
  }
  
  if (user) {
    if (location.startsWith("/login")) {
      const rotaSalva = localStorage.getItem("rotaAtual");
      if (rotaSalva && !rotaSalva.includes("/login") && !rotaSalva.startsWith("/aluno/")) {
        return <Redirect to={rotaSalva} />;
      }
      const redirectTo = user.role.toLowerCase() === 'admin' ? "/admin" : "/";
      return <Redirect to={redirectTo} />;
    }
    
    if (user.role.toLowerCase() === 'admin') return <AdminApp />;
    return <PersonalApp />;
  } 
  
  if (aluno) {
    if (location.startsWith("/aluno/")) return <AlunoApp />;
    const rotaSalva = localStorage.getItem("rotaAtual");
    if (rotaSalva && rotaSalva.startsWith("/aluno/")) {
      return <Redirect to={rotaSalva} />;
    }
    return <Redirect to="/aluno/dashboard" />;
  } 
  
  if (location.startsWith("/convite/") || location.startsWith("/cadastrar-personal/convite/")) {
    if (isDebugMode || import.meta.env.DEV) {
      console.log('[AppContent] Accessing invitation route:', location);
    }
    return <PublicRoutes />;
  }
  
  return <PublicRoutes />;
}

function AdminApp() { 
  return ( 
    <MainLayout> 
      <Suspense fallback={<div className="flex h-full flex-1 items-center justify-center"><Loader2 className="h-8 w-8 animate-spin text-primary" /></div>}> 
        <Switch> 
          <AdminProtectedRoute path="/admin" component={AdminDashboardPage} /> 
          <AdminProtectedRoute path="/admin/personais" component={ListarPersonaisPage} /> 
          <AdminProtectedRoute path="/admin/planos" component={GerenciarPlanosPersonalPage} /> 
          <AdminProtectedRoute path="/admin/criar-personal" component={CriarPersonalPage} /> 
          <AdminProtectedRoute path="/admin/personais/editar/:id" component={EditarPersonalPage} /> 
          <AdminProtectedRoute path="/admin/convites" component={GerenciarConvitesPage} />
          <AdminProtectedRoute path="/admin/solicitacoes-renovacao" component={AdminRenewalRequests} />
          <AdminProtectedRoute path="/exercises" component={ExercisesIndex} /> 
          <AdminProtectedRoute path="/perfil/editar" component={ProfileEditPage} /> 
          <Route path="/admin/:rest*"><Redirect to="/admin" /></Route> 
          <Route component={NotFound} /> 
        </Switch> 
      </Suspense> 
    </MainLayout> 
  );
}

function PersonalApp() { 
  return ( 
    <MainLayout> 
      <Suspense fallback={<div className="flex h-full flex-1 items-center justify-center"><Loader2 className="h-8 w-8 animate-spin text-primary" /></div>}> 
        <Switch> 
          <ProtectedRoute path="/" component={Dashboard} /> 
          <ProtectedRoute path="/meu-plano" component={MeuPlanoPage} /> 
          <ProtectedRoute path="/renovar-plano" component={RenovarPlanoPage} />
          <ProtectedRoute path="/solicitar-renovacao" component={SolicitarRenovacao} />
          <ProtectedRoute path="/alunos" component={StudentsIndex} /> 
          <ProtectedRoute path="/alunos/novo" component={NewStudent} /> 
          <ProtectedRoute path="/alunos/editar/:id" component={EditStudentPage} /> 
          <ProtectedRoute path="/treinos" component={TreinosPage} /> 
          <ProtectedRoute path="/exercises" component={ExercisesIndex} /> 
          <ProtectedRoute path="/sessoes" component={SessionsPage} /> 
          <ProtectedRoute path="/perfil/editar" component={ProfileEditPage} /> 
          <Route path="/admin/:rest*"><Redirect to="/" /></Route> 
          <Route component={NotFound} /> 
        </Switch> 
      </Suspense> 
    </MainLayout> 
  );
}

function AlunoApp() { 
  return ( 
    <MainLayout> 
      <Suspense fallback={<div className="flex h-full flex-1 items-center justify-center"><Loader2 className="h-8 w-8 animate-spin text-primary" /></div>}> 
        <Switch> 
          <AlunoProtectedRoute path="/aluno/dashboard" component={AlunoDashboardPage} /> 
          <AlunoProtectedRoute path="/aluno/ficha/:fichaId" component={AlunoFichaDetalhePage} /> 
          <AlunoProtectedRoute path="/aluno/historico" component={AlunoHistoricoPage} /> 
          <AlunoProtectedRoute path="/aluno/meus-treinos" component={MeusTreinosPage} /> 
          <Route><Redirect to="/aluno/dashboard" /></Route> 
        </Switch> 
      </Suspense> 
    </MainLayout> 
  );
}

function PublicRoutes() {
  const isDebugMode = import.meta.env.VITE_DEBUG_INVITATIONS === 'true';
  
  React.useEffect(() => {
    if (isDebugMode || import.meta.env.DEV) {
      console.log('[PublicRoutes] Rotas públicas carregadas');
      console.log('[PublicRoutes] URL atual:', window.location.href);
      console.log('[PublicRoutes] Pathname:', window.location.pathname);
    }
  }, [isDebugMode]);

  return (
    <Suspense fallback={<div className="flex h-screen w-full items-center justify-center"><Loader2 className="h-10 w-10 animate-spin text-primary" /></div>}>
      <Switch>
        <Route path="/login" component={LandingLoginPage} />
        <Route path="/login/personal" component={PersonalLoginPage} />
        <Route path="/login/aluno" component={AlunoLoginPage} />
        <Route path="/demo-dashboard" component={DemoDashboard} />

        <Route path="/cadastrar-personal/convite/:tokenDeConvite" component={CadastroPersonalPorConvitePage} />
        <Route path="/convite/aluno/:token" component={CadastroAlunoPorConvitePage} />
        
        <Route><Redirect to="/login" /></Route>
      </Switch>
    </Suspense>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider attribute="class" defaultTheme="light" enableSystem>
        <TooltipProvider>
          <PWAInstallProvider>
            <UserProvider>
              <AlunoProvider>
                <WorkoutPlayerProvider>
                  <Toaster />
                  <AppUpdatesManager />
                  <AppContent />
                </WorkoutPlayerProvider>
              </AlunoProvider>
            </UserProvider>
          </PWAInstallProvider>
        </TooltipProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;

===== ./client/src/components/AppUpdatesManager.tsx =====
import { useEffect, useRef } from 'react';
import { useAppUpdates } from '@/hooks/useAppUpdates';
import { useToast } from '@/hooks/use-toast';
import { Button } from '@/components/ui/button';
import { RefreshCw, Download, Wifi } from 'lucide-react';

/**
 * AppUpdatesManager - Unified component for handling all PWA update notifications
 * 
 * This component replaces the conflicting ReloadPrompt.tsx and UpdateNotification.tsx
 * components to eliminate rendering loops and duplicate notifications.
 * 
 * Features:
 * - Shows update notifications only once when needed
 * - Shows offline ready notifications only when appropriate
 * - Prevents notification conflicts and loops
 * - Non-intrusive, professional notifications via toast
 */
export function AppUpdatesManager() {
  const {
    needRefresh,
    offlineReady,
    isUpdating,
    notificationShown,
    handleUpdate,
    handleOfflineReady,
    markUpdateNotificationShown,
    markOfflineNotificationShown,
  } = useAppUpdates();

  const { toast, dismiss } = useToast();
  const toastIds = useRef<{ update?: string; offline?: string }>({});

  // Show update notification (only once)
  useEffect(() => {
    if (needRefresh && !notificationShown.update) {
      markUpdateNotificationShown();
      
      // Dismiss any existing offline toast first
      if (toastIds.current.offline) {
        dismiss(toastIds.current.offline);
        toastIds.current.offline = undefined;
      }

      const { id } = toast({
        title: '🚀 Nova versão disponível!',
        description: 'DyFit foi atualizado com melhorias e correções.',
        action: (
          <Button
            onClick={handleUpdate}
            disabled={isUpdating}
            size="sm"
            className="bg-blue-600 hover:bg-blue-700 text-white shadow-md"
          >
            {isUpdating ? (
              <RefreshCw className="mr-2 h-4 w-4 animate-spin" />
            ) : (
              <Download className="mr-2 h-4 w-4" />
            )}
            {isUpdating ? 'Atualizando...' : 'Atualizar'}
          </Button>
        ),
        duration: 0, // Don't auto-dismiss
        className: "border-blue-200 bg-blue-50 text-blue-900",
      });
      
      toastIds.current.update = id;
    }
  }, [needRefresh, isUpdating, notificationShown.update, toast, dismiss, handleUpdate, markUpdateNotificationShown]);

  // Show offline ready notification (only once, and only if no update is shown)
  useEffect(() => {
    if (offlineReady && !notificationShown.offline && !needRefresh) {
      markOfflineNotificationShown();
      
      const { id } = toast({
        title: '📱 App pronto para offline!',
        description: 'DyFit já pode ser usado sem internet.',
        action: (
          <Button
            onClick={handleOfflineReady}
            variant="outline"
            size="sm"
            className="border-green-200 text-green-700 hover:bg-green-50"
          >
            <Wifi className="mr-2 h-4 w-4" />
            OK
          </Button>
        ),
        duration: 5000, // Auto-dismiss after 5 seconds
        className: "border-green-200 bg-green-50 text-green-900",
      });
      
      toastIds.current.offline = id;
    }
  }, [offlineReady, needRefresh, notificationShown.offline, toast, handleOfflineReady, markOfflineNotificationShown]);

  // This component renders nothing visible - all notifications are handled via toasts
  return null;
}
===== ./client/src/components/ErrorBoundary.tsx =====
// client/src/components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw } from 'lucide-react';
import { Button } from './ui/button';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  private handleRetry = () => {
    this.setState({ hasError: false, error: undefined });
  };

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <Card className="max-w-md mx-auto mt-8 border-red-200 bg-red-50 dark:bg-red-900/20 dark:border-red-800">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-red-700 dark:text-red-400">
              <AlertTriangle className="w-5 h-5" />
              Oops! Algo deu errado
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-sm text-red-600 dark:text-red-300">
              Ocorreu um erro inesperado. Tente recarregar a página ou entre em contato com o suporte se o problema persistir.
            </p>
            {process.env.NODE_ENV === 'development' && this.state.error && (
              <details className="text-xs text-red-500 bg-red-100 dark:bg-red-900/40 p-2 rounded">
                <summary className="cursor-pointer font-medium">Detalhes do erro (dev)</summary>
                <pre className="mt-2 whitespace-pre-wrap break-words">
                  {this.state.error.message}
                  {this.state.error.stack}
                </pre>
              </details>
            )}
            <div className="flex gap-2">
              <Button 
                onClick={this.handleRetry}
                size="sm"
                className="bg-red-600 hover:bg-red-700 text-white"
              >
                <RefreshCw className="w-4 h-4 mr-2" />
                Tentar Novamente
              </Button>
              <Button 
                onClick={() => window.location.reload()}
                variant="outline"
                size="sm"
              >
                Recarregar Página
              </Button>
            </div>
          </CardContent>
        </Card>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
===== ./client/src/components/ErrorMessage.tsx =====
// client/src/components/ErrorMessage.tsx
import { AlertTriangle } from "lucide-react";

interface ErrorMessageProps {
  title?: string;
  message: string;
}

export default function ErrorMessage({ title = "Erro", message }: ErrorMessageProps) {
  return (
    <div className="bg-red-100 border border-red-300 text-red-800 p-4 rounded-md flex items-start space-x-2">
      <AlertTriangle className="w-5 h-5 mt-0.5 text-red-600" />
      <div>
        <p className="font-semibold">{title}</p>
        <p className="text-sm">{message}</p>
      </div>
    </div>
  );
}

===== ./client/src/components/ExerciseFilters.tsx =====
// client/src/components/ExerciseFilters.tsx
import React from 'react';
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { FilterX } from "lucide-react";

interface FilterValues {
  searchTerm: string;
  grupo: string;
  categoria: string;
}

interface ExerciseFiltersProps {
  grupos: string[];
  categorias: string[];
  filters: FilterValues;
  onFilterChange: (filters: Partial<FilterValues>) => void;
  onClearFilters: () => void;
}

const ALL_FILTER_VALUE = "all";

const ExerciseFilters: React.FC<ExerciseFiltersProps> = ({
  grupos,
  categorias,
  filters,
  onFilterChange,
  onClearFilters,
}) => {
  return (
    <div className="space-y-4">
      <Input
        placeholder="Buscar por nome..."
        value={filters.searchTerm}
        onChange={(e) => onFilterChange({ searchTerm: e.target.value })}
        className="w-full bg-background dark:bg-input"
      />
      <Select
        onValueChange={(value) => onFilterChange({ grupo: value })}
        value={filters.grupo}
      >
        <SelectTrigger className="w-full bg-background dark:bg-input">
          <SelectValue placeholder="Grupo muscular" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value={ALL_FILTER_VALUE}>Todos os Grupos</SelectItem>
          {grupos.map((g) => <SelectItem key={g} value={g}>{g}</SelectItem>)}
        </SelectContent>
      </Select>
      <Select
        onValueChange={(value) => onFilterChange({ categoria: value })}
        value={filters.categoria}
      >
        <SelectTrigger className="w-full bg-background dark:bg-input">
          <SelectValue placeholder="Tipo/Categoria" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value={ALL_FILTER_VALUE}>Todos os Tipos</SelectItem>
          {categorias.map((c) => <SelectItem key={c} value={c}>{c}</SelectItem>)}
        </SelectContent>
      </Select>
      <Button variant="ghost" onClick={onClearFilters} className="w-full justify-center text-muted-foreground hover:text-foreground">
        <FilterX className="w-4 h-4 mr-2" />
        Limpar Filtros
      </Button>
    </div>
  );
};

export default ExerciseFilters;
===== ./client/src/components/LiteGoogleDriveEmbed.tsx =====
// client/src/components/LiteGoogleDriveEmbed.tsx
import { useState, useRef, useEffect } from 'react';
import { PlayCircle } from 'lucide-react';

interface LiteGoogleDriveEmbedProps {
  id: string; // O ID do arquivo do Google Drive
  title: string;
}

const LiteGoogleDriveEmbed = ({ id, title }: LiteGoogleDriveEmbedProps) => {
  const [shouldLoad, setShouldLoad] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setShouldLoad(true);
          observer.disconnect();
        }
      },
      {
        rootMargin: '200px',
      }
    );
    
    observer.observe(ref.current);

    return () => observer.disconnect();
  }, []);
  
  const embedUrl = `https://drive.google.com/file/d/${id}/preview`;

  return (
    <div ref={ref} className="w-full h-full bg-slate-800">
      {shouldLoad ? (
        <iframe
          className="w-full h-full"
          title={title}
          src={embedUrl}
          allow="autoplay"
          allowFullScreen
        ></iframe>
      ) : (
        <div className="w-full h-full relative group flex items-center justify-center cursor-pointer">
            <div className="absolute inset-0 bg-black bg-opacity-20 group-hover:bg-opacity-40 transition-all duration-300"></div>
            <PlayCircle className="w-12 h-12 text-white opacity-0 group-hover:opacity-80 transition-opacity duration-300 drop-shadow-lg z-10" />
        </div>
      )}
    </div>
  );
};

export default LiteGoogleDriveEmbed;
===== ./client/src/components/LiteYouTubeEmbed.tsx =====
// client/src/components/LiteYouTubeEmbed.tsx
import { useState, useRef, useEffect } from 'react';
import { PlayCircle } from 'lucide-react';

interface LiteYouTubeEmbedProps {
  id: string;
  title: string;
}

const LiteYouTubeEmbed = ({ id, title }: LiteYouTubeEmbedProps) => {
  const [shouldLoad, setShouldLoad] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!ref.current) return;

    const observer = new IntersectionObserver(
      ([entry]) => {
        // Se o componente estiver visível na tela
        if (entry.isIntersecting) {
          setShouldLoad(true);
          // Uma vez carregado, não precisa mais observar
          observer.disconnect();
        }
      },
      {
        // Começa a carregar um pouco antes de entrar na tela para uma experiência mais suave
        rootMargin: '200px', 
      }
    );

    observer.observe(ref.current);

    // Função de limpeza para desconectar o observador quando o componente for desmontado
    return () => observer.disconnect();
  }, []);

  const videoId = (() => {
    try {
        if (id.includes("youtube.com/embed/")) {
            return id.split("/embed/")[1].split("?")[0];
        }
        return id;
    } catch {
        return id;
    }
  })();
  
  const posterUrl = `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`;

  return (
    <div ref={ref} className="w-full h-full bg-black">
      {shouldLoad ? (
        <iframe
          className="w-full h-full"
          title={title}
          src={`https://www.youtube.com/embed/${videoId}?autoplay=1`}
          allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
          allowFullScreen
        ></iframe>
      ) : (
        <div className="w-full h-full relative group cursor-pointer">
            <img
                src={posterUrl}
                alt={`Thumbnail para o vídeo: ${title}`}
                className="w-full h-full object-cover"
                loading="lazy"
            />
            <div className="absolute inset-0 bg-black bg-opacity-20 group-hover:bg-opacity-40 transition-all duration-300 flex items-center justify-center">
                <PlayCircle className="w-12 h-12 text-white opacity-80 drop-shadow-lg" />
            </div>
        </div>
      )}
    </div>
  );
};

export default LiteYouTubeEmbed;
===== ./client/src/components/LoadingSpinner.tsx =====
import { Loader2 } from "lucide-react";

// 1. Definir uma interface para as props
interface LoadingSpinnerProps {
  text?: string; // A prop 'text' é opcional (pode usar só o ícone)
}

// 2. Usar a interface de props e desestruturar 'text'
export default function LoadingSpinner({ text }: LoadingSpinnerProps) {
  return (
    // 3. Ajustar o layout para acomodar o texto (flex-col) e adicionar o texto
    <div className="flex flex-col justify-center items-center h-32 gap-3"> {/* Adicionado flex-col e gap */}
      <Loader2 className="h-6 w-6 animate-spin text-primary" />
      {/* 4. Renderizar o texto apenas se ele for fornecido */}
      {text && <p className="text-sm text-muted-foreground">{text}</p>}
    </div>
  );
}
===== ./client/src/components/PageLoader.tsx =====
import React from 'react';

interface PageLoaderProps {
  message?: string;
  submessage?: string;
}

export function PageLoader({ 
  message = "Carregando...", 
  submessage = "Organizando seus dados..." 
}: PageLoaderProps) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[400px] text-muted-foreground animate-fade-in">
      {/* Dual Ring Spinner with DyFit Colors */}
      <div className="relative mb-6">
        {/* Primary ring */}
        <div className="w-16 h-16 border-4 border-primary/20 border-t-primary rounded-full animate-spin" />
        {/* Secondary ring with offset */}
        <div 
          className="absolute inset-0 w-16 h-16 border-4 border-transparent border-t-secondary/50 rounded-full animate-spin" 
          style={{ 
            animationDelay: '0.3s', 
            animationDuration: '1.5s',
            animationDirection: 'reverse' 
          }} 
        />
        {/* Accent ring with different timing */}
        <div 
          className="absolute inset-2 w-12 h-12 border-3 border-transparent border-t-accent/40 rounded-full animate-spin" 
          style={{ 
            animationDelay: '0.6s', 
            animationDuration: '2s' 
          }} 
        />
      </div>

      {/* Main message with gradient */}
      <div className="text-xl font-semibold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent animate-pulse mb-2">
        {message}
      </div>

      {/* Submessage with staggered animation */}
      <div 
        className="text-sm opacity-70 animate-pulse text-center max-w-xs" 
        style={{ animationDelay: '0.5s' }}
      >
        {submessage}
      </div>

      {/* Decorative dots */}
      <div className="flex space-x-1 mt-4">
        <div 
          className="w-2 h-2 bg-primary rounded-full animate-bounce" 
          style={{ animationDelay: '0s' }}
        />
        <div 
          className="w-2 h-2 bg-secondary rounded-full animate-bounce" 
          style={{ animationDelay: '0.2s' }}
        />
        <div 
          className="w-2 h-2 bg-accent rounded-full animate-bounce" 
          style={{ animationDelay: '0.4s' }}
        />
      </div>
    </div>
  );
}

export default PageLoader;
===== ./client/src/components/WorkoutMiniPlayer.tsx =====
// client/src/components/WorkoutMiniPlayer.tsx
import React from 'react';
import { useLocation } from 'wouter';
import { useWorkoutPlayer } from '@/context/WorkoutPlayerContext';
import { Timer } from 'lucide-react';

const WorkoutMiniPlayer: React.FC = () => {
  const [location, navigate] = useLocation();
  const { 
    isWorkoutActive, 
    currentWorkoutSession, 
    elapsedTime, 
    completedExercises
  } = useWorkoutPlayer();

  // Hide mini-player if not active or if on workout execution page
  const shouldHide = !isWorkoutActive || 
    !currentWorkoutSession || 
    (currentWorkoutSession.rotinaId && 
     currentWorkoutSession.diaDeTreinoId && 
     location.includes(`/aluno/ficha/${currentWorkoutSession.rotinaId}`) &&
     location.includes(`diaId=${currentWorkoutSession.diaDeTreinoId}`));

  // Format elapsed time
  const formatTime = (seconds: number): string => {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    
    if (h > 0) {
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
  };

  // Handle click to continue workout
  const handleContinueWorkout = () => {
    if (!currentWorkoutSession?.rotinaId || !currentWorkoutSession?.diaDeTreinoId) {
      console.error('Missing routing data for workout session');
      return;
    }

    // Navigate to correct route: /aluno/ficha/{rotinaId}?dia={diaDeTreinoId}
    navigate(`/aluno/ficha/${currentWorkoutSession.rotinaId}?diaId=${currentWorkoutSession.diaDeTreinoId}`);
  };

  if (shouldHide) {
    return null;
  }

  // Calculate progress
  const totalExercises = currentWorkoutSession?.exercises.length || 0;
  const completedCount = completedExercises.size;
  const progressPercentage = totalExercises > 0 ? (completedCount / totalExercises) * 100 : 0;

  return (
    <button
      className="flex flex-col items-center justify-center flex-1 py-1 px-1 text-xs text-indigo-600 hover:text-indigo-700 transition-colors border-l border-r border-gray-200"
      onClick={handleContinueWorkout}
    >
      <div className="flex items-center space-x-0.5">
        <Timer className="w-2.5 h-2.5" />
        <span className="font-mono font-bold text-[10px] leading-none">
          {formatTime(elapsedTime)}
        </span>
      </div>
      <div className="flex items-center space-x-0.5 mt-0.5">
        <div className="bg-indigo-200 rounded-full h-0.5 w-6 overflow-hidden">
          <div 
            className="bg-indigo-600 h-full transition-all duration-300 ease-out"
            style={{ width: `${progressPercentage}%` }}
          />
        </div>
        <span className="text-[9px] font-medium">
          {completedCount}/{totalExercises}
        </span>
      </div>
    </button>
  );
};

export default WorkoutMiniPlayer;
===== ./client/src/components/WorkoutMiniPlayerHeader.tsx =====
// client/src/components/WorkoutMiniPlayerHeader.tsx
import React from 'react';
import { useLocation } from 'wouter';
import { useWorkoutPlayer } from '@/context/WorkoutPlayerContext';
import { Timer } from 'lucide-react';
import { cn } from '@/lib/utils';

interface WorkoutMiniPlayerHeaderProps {
  isScrolled: boolean;
  isAluno: boolean;
}

const WorkoutMiniPlayerHeader: React.FC<WorkoutMiniPlayerHeaderProps> = ({ 
  isScrolled, 
  isAluno 
}) => {
  const [location, navigate] = useLocation();
  const { 
    isWorkoutActive, 
    currentWorkoutSession, 
    elapsedTime, 
    completedExercises
  } = useWorkoutPlayer();

  // Only show for aluno users
  if (!isAluno) {
    return null;
  }

  // Hide mini-player if not active or if on workout execution page
  const shouldHide = !isWorkoutActive || 
    !currentWorkoutSession || 
    (currentWorkoutSession.rotinaId && 
     currentWorkoutSession.diaDeTreinoId && 
     location.includes(`/aluno/ficha/${currentWorkoutSession.rotinaId}`) &&
     location.includes(`diaId=${currentWorkoutSession.diaDeTreinoId}`));

  // Only show when header is scrolled (visible)
  if (shouldHide || !isScrolled) {
    return null;
  }

  // Format elapsed time
  const formatTime = (seconds: number): string => {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    
    if (h > 0) {
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
  };

  // Handle click to continue workout
  const handleContinueWorkout = () => {
    if (!currentWorkoutSession?.rotinaId || !currentWorkoutSession?.diaDeTreinoId) {
      console.error('Missing routing data for workout session');
      return;
    }

    // Navigate to correct route: /aluno/ficha/{rotinaId}?dia={diaDeTreinoId}
    navigate(`/aluno/ficha/${currentWorkoutSession.rotinaId}?diaId=${currentWorkoutSession.diaDeTreinoId}`);
  };

  // Calculate progress
  const totalExercises = currentWorkoutSession?.exercises.length || 0;
  const completedCount = completedExercises.size;
  const progressPercentage = totalExercises > 0 ? (completedCount / totalExercises) * 100 : 0;

  return (
    <button
      className={cn(
        "flex items-center space-x-2 px-3 py-1.5 rounded-full text-sm transition-all duration-200 hover:scale-105",
        "bg-indigo-500/20 backdrop-blur-sm border border-white/30 text-white hover:bg-indigo-500/30"
      )}
      onClick={handleContinueWorkout}
      title="Continuar Treino"
    >
      <div className="flex items-center space-x-1">
        <Timer className="w-4 h-4" />
        <span className="font-mono font-bold text-sm">
          {formatTime(elapsedTime)}
        </span>
      </div>
      <div className="flex items-center space-x-1">
        <div className="bg-white/30 rounded-full h-1 w-8 overflow-hidden">
          <div 
            className="bg-white h-full transition-all duration-300 ease-out"
            style={{ width: `${progressPercentage}%` }}
          />
        </div>
        <span className="text-xs font-medium opacity-90">
          {completedCount}/{totalExercises}
        </span>
      </div>
    </button>
  );
};

export default WorkoutMiniPlayerHeader;
===== ./client/src/components/alunos/CombinedExerciseCard.tsx =====
// client/src/components/alunos/CombinedExerciseCard.tsx
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Check, PlayCircle, Clock, Weight, ChevronDown, RotateCcw, Info, Link } from 'lucide-react';
import { useWorkoutPlayer } from '@/context/WorkoutPlayerContext';
import { cn } from '@/lib/utils';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";

// Interface for exercises compatible with the existing type
interface ExercicioRenderizavel {
  _id: string;
  exercicioDetalhes: {
    nome: string;
    urlVideo?: string;
  } | null;
  descanso?: string;
  series?: string;
  repeticoes?: string;
  carga?: string;
  observacoes?: string;
  grupoCombinado?: string;
}

interface CombinedExerciseCardProps {
  exercises: ExercicioRenderizavel[];
  isActive: boolean;
  allCompleted: boolean;
  onOpenVideo: (url: string) => void;
  groupId: string;
}

export const CombinedExerciseCard: React.FC<CombinedExerciseCardProps> = ({
  exercises,
  isActive,
  allCompleted,
  onOpenVideo,
  groupId,
}) => {
  const { completeMultipleExercises, uncompleteMultipleExercises, updateExerciseLoad, getExerciseLoad, completedExercises } = useWorkoutPlayer();
  
  const [loads, setLoads] = useState<Record<string, string>>(() => {
    const initialLoads: Record<string, string> = {};
    exercises.forEach(ex => {
      initialLoads[ex._id] = getExerciseLoad(ex._id) || ex.carga || '';
    });
    return initialLoads;
  });
  
  const [isExpanded, setIsExpanded] = useState(isActive);
  const [editingExerciseId, setEditingExerciseId] = useState<string | null>(null);
  const [currentLoadInput, setCurrentLoadInput] = useState('');
  const [isReopenConfirmOpen, setIsReopenConfirmOpen] = useState(false);

  useEffect(() => {
    setIsExpanded(isActive);
  }, [isActive]);

  // Auto-collapse when all exercises are completed
  useEffect(() => {
    if (allCompleted) {
      setIsExpanded(false);
    }
  }, [allCompleted]);
  
  const handleUpdateLoad = (exerciseId: string, newLoadValue: string) => {
    setLoads(prev => ({ ...prev, [exerciseId]: newLoadValue }));
    updateExerciseLoad(exerciseId, newLoadValue);
  };
  
  const handleCompleteAllExercises = () => {
    const exerciseIds = exercises.map(exercise => exercise._id);
    completeMultipleExercises(exerciseIds);
  };

  const handleUncompleteAllExercises = () => {
    const exerciseIds = exercises.map(exercise => exercise._id);
    uncompleteMultipleExercises(exerciseIds);
    // Expand the card when reopening
    setIsExpanded(true);
  };

  const openEditModal = (exerciseId: string) => {
    setCurrentLoadInput(loads[exerciseId] || '');
    setEditingExerciseId(exerciseId);
  };

  const closeEditModal = () => {
    setEditingExerciseId(null);
  };

  const handleSaveLoad = () => {
    if (editingExerciseId) {
      handleUpdateLoad(editingExerciseId, currentLoadInput);
      closeEditModal();
    }
  };

  const editingExercise = editingExerciseId ? exercises.find(ex => ex._id === editingExerciseId) : null;
  
  return (
    <Card
      className={cn(
        "transition-all duration-300 ease-in-out overflow-hidden shadow-md border",
        allCompleted ? 'bg-green-50 border-green-300 shadow-green-100' : 'bg-white border-slate-200',
        isActive ? 'border-indigo-500 shadow-indigo-200 shadow-lg' : '',
        !allCompleted ? 'border-l-4 border-l-blue-500 bg-blue-50/30' : ''
      )}
    >
      {/* Combined exercise header banner */}
      <div className="bg-blue-100 border-b border-blue-200 px-4 py-2">
        <div className="flex items-center gap-2 text-sm text-blue-700">
          <Link size={16} />
          <span className="font-medium">
            Exercícios Conjugados ({exercises.length} exercícios)
          </span>
          <span className="text-xs bg-blue-200 px-2 py-1 rounded-full">
            Executar em sequência
          </span>
        </div>
      </div>
      
      <CardHeader 
        className="flex flex-row items-center justify-between p-4 cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center gap-3 flex-1 min-w-0">
          <p className="font-semibold text-gray-800">
            Exercícios Conjugados
          </p>
          <span className="text-sm text-gray-500 bg-gray-100 px-2 py-1 rounded-full">
            {exercises.length} exercícios
          </span>
        </div>
        <div className="flex items-center gap-2">
          <ChevronDown className={cn("transition-transform", isExpanded && "rotate-180")} />
        </div>
      </CardHeader>

      {isExpanded && (
        <CardContent className="p-4 pt-0">
          <div className="border-t pt-4 space-y-6">
            {/* Render each exercise in the group */}
            {exercises.map((exercise, index) => {
              const exerciseName = exercise.exercicioDetalhes?.nome || 'Exercício Removido';
              const isCompleted = completedExercises.has(exercise._id);
              
              return (
                <div key={exercise._id} className={cn(
                  "p-4 rounded-lg border",
                  isCompleted ? "bg-green-50 border-green-200" : "bg-gray-50 border-gray-200",
                  index < exercises.length - 1 && "mb-4"
                )}>
                  {/* Exercise header */}
                  <div className="flex items-center justify-between mb-3">
                    <div className="flex items-center gap-3 flex-1 min-w-0">
                      <span className="text-sm bg-blue-100 text-blue-700 px-2 py-1 rounded-full font-medium">
                        {index + 1}
                      </span>
                      <p className="font-semibold text-gray-800" title={exerciseName}>
                        {exerciseName}
                      </p>
                    </div>
                    {exercise.exercicioDetalhes?.urlVideo && (
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        className="h-8 w-8 text-red-500 hover:bg-red-100" 
                        onClick={() => onOpenVideo(exercise.exercicioDetalhes!.urlVideo!)}
                      >
                        <PlayCircle size={20} />
                      </Button>
                    )}
                  </div>

                  {/* Exercise details */}
                  <div className="flex justify-around text-center mb-4">
                    <div>
                      <p className="text-sm text-gray-500">Séries</p>
                      <p className="font-bold text-lg">{exercise.series || '-'}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Repetições</p>
                      <p className="font-bold text-lg">{exercise.repeticoes || '-'}</p>
                    </div>
                    <div>
                      <p className="text-sm text-gray-500">Descanso</p>
                      <div className='flex items-center justify-center gap-1'>
                        <Clock size={16} className="text-gray-500" />
                        <p className="font-bold text-lg">{exercise.descanso && exercise.descanso.trim() !== '' ? exercise.descanso : '-'}</p>
                      </div>
                    </div>
                  </div>

                  {/* Exercise observations */}
                  {exercise.observacoes && (
                    <div className="space-y-2 pt-4 border-t mt-4">
                      <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                        <Info size={16} /> Observações do Personal
                      </label>
                      <p className="text-sm text-gray-600 bg-gray-50 p-3 rounded-md border">
                        {exercise.observacoes}
                      </p>
                    </div>
                  )}
                  
                  {/* Exercise load */}
                  <div className="space-y-2 pt-4 border-t mt-4">
                    <div className="flex items-center justify-between">
                      <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                        <Weight size={16} /> Carga Utilizada (kg)
                      </label>
                      <div className="flex items-center gap-2">
                        <p className="font-bold text-lg text-gray-800">{loads[exercise._id] || '-'}</p>
                        {!allCompleted && (
                          <Button 
                            variant="link" 
                            className="text-blue-600 hover:text-blue-800 p-0 h-auto underline" 
                            onClick={() => openEditModal(exercise._id)}
                          >
                            Editar
                          </Button>
                        )}
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
            
            {/* Combined action button */}
            <div className="mt-6 pt-4 border-t">
              {!allCompleted ? (
                <Button 
                  className="w-full bg-green-600 hover:bg-green-700" 
                  onClick={handleCompleteAllExercises}
                >
                  <Check className="mr-2" size={18} /> Concluir Exercícios
                </Button>
              ) : (
                <Button 
                  variant="outline" 
                  className="w-full border-green-600 text-green-700 hover:bg-green-50" 
                  onClick={() => setIsReopenConfirmOpen(true)}
                >
                  <RotateCcw className="mr-2" size={18} /> Reabrir Exercícios
                </Button>
              )}
            </div>
          </div>
        </CardContent>
      )}

      {/* Load edit modal */}
      <Dialog open={!!editingExerciseId} onOpenChange={() => setEditingExerciseId(null)}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Atualizar Carga Utilizada</DialogTitle>
            <DialogDescription>
              Insira a carga utilizada para: {editingExercise?.exercicioDetalhes?.nome}
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <label htmlFor="currentLoad" className="text-right">
                Carga (kg)
              </label>
              <Input
                id="currentLoad"
                type="number"
                placeholder="Ex: 20"
                value={currentLoadInput}
                onChange={(e) => setCurrentLoadInput(e.target.value)}
                className="col-span-3"
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={closeEditModal}>Cancelar</Button>
            <Button onClick={handleSaveLoad}>Atualizar</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Reopen confirmation dialog */}
      <Dialog open={isReopenConfirmOpen} onOpenChange={setIsReopenConfirmOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Reabrir Exercícios</DialogTitle>
            <DialogDescription>
              Tem certeza que deseja reabrir todos os exercícios deste grupo? Isso irá marcá-los como não concluídos.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsReopenConfirmOpen(false)}>
              Cancelar
            </Button>
            <Button 
              onClick={() => {
                handleUncompleteAllExercises();
                setIsReopenConfirmOpen(false);
              }}
            >
              Reabrir
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </Card>
  );
};
===== ./client/src/components/alunos/FrequenciaSemanal.tsx =====
// Caminho: ./client/src/components/alunos/FrequenciaSemanal.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { CheckCircle2, AlertCircle, CalendarDays } from 'lucide-react';
import { format, getDay, isSameDay, startOfWeek, addDays, isToday as dateIsToday } from 'date-fns';
import { ptBR } from 'date-fns/locale';

// Interface para a sessão como recebida da API (apenas os campos que usaremos)
interface SessaoConcluida {
  _id: string;
  sessionDate: string | Date; // Pode vir como string ISO ou já como objeto Date
  tipoCompromisso?: string; // Opcional, caso queira diferenciar tipos de sessão no futuro
}

interface FrequenciaSemanalProps {
  sessoesConcluidasNaSemana: SessaoConcluida[];
  isLoading?: boolean;
  error?: Error | null;
}

const DIAS_DA_SEMANA_ABREVIADOS = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
// Para a lógica de 'weekStartsOn: 1' (Segunda como início)
const DIAS_DA_SEMANA_LABEL_ORDENADO = ['Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb', 'Dom'];

const FrequenciaSemanal: React.FC<FrequenciaSemanalProps> = ({ 
  sessoesConcluidasNaSemana,
  isLoading = false,
  error = null 
}) => {
  
  const hoje = new Date();
  // Segunda-feira como início da semana
  const inicioDaSemanaAtual = startOfWeek(hoje, { weekStartsOn: 1 });

  const diasParaRenderizar = DIAS_DA_SEMANA_LABEL_ORDENADO.map((_, index) => {
    // Se o início da semana é Segunda (index 0 do nosso array ordenado),
    // e addDays(inicioDaSemanaAtual, 0) é Segunda,
    // addDays(inicioDaSemanaAtual, 1) é Terça, etc.
    return addDays(inicioDaSemanaAtual, index);
  });

  const foiDiaTreinado = (dia: Date): boolean => {
    return sessoesConcluidasNaSemana.some(sessao => 
      isSameDay(new Date(sessao.sessionDate), dia)
    );
  };

  if (isLoading) {
    return (
      <Card className="shadow">
        <CardHeader>
          <CardTitle className="flex items-center text-lg">
            <CalendarDays className="w-5 h-5 mr-2 text-primary" />
            Frequência Semanal
          </CardTitle>
        </CardHeader>
        <CardContent className="text-center py-6">
          <p className="text-sm text-muted-foreground">Carregando frequência...</p>
        </CardContent>
      </Card>
    );
  }

  if (error) {
    return (
      <Card className="shadow border-destructive/50">
        <CardHeader>
          <CardTitle className="flex items-center text-lg text-destructive">
            <AlertCircle className="w-5 h-5 mr-2" />
            Frequência Semanal
          </CardTitle>
        </CardHeader>
        <CardContent className="text-center py-6">
          <p className="text-sm text-destructive">Erro ao carregar frequência.</p>
          {/* <p className="text-xs text-muted-foreground">{error.message}</p> */}
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="shadow-md">
      <CardHeader>
        <CardTitle className="flex items-center text-lg">
          <CalendarDays className="w-5 h-5 mr-2 text-primary" />
          Frequência Semanal
        </CardTitle>
        <CardDescription>Seus treinos concluídos nesta semana.</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex justify-around items-center py-2">
          {diasParaRenderizar.map((dia, index) => {
            const treinou = foiDiaTreinado(dia);
            const ehHoje = dateIsToday(dia);
            const diaLabel = DIAS_DA_SEMANA_LABEL_ORDENADO[index];

            return (
              <div key={diaLabel} className="flex flex-col items-center space-y-1">
                <span className={`text-xs font-medium ${ehHoje ? 'text-primary dark:text-sky-400' : 'text-muted-foreground'}`}>
                  {diaLabel}
                </span>
                <div 
                  className={`
                    w-8 h-8 rounded-full flex items-center justify-center border-2
                    ${treinou 
                      ? 'bg-green-500 border-green-600 dark:bg-green-600 dark:border-green-700' 
                      : 'bg-gray-100 border-gray-300 dark:bg-gray-700 dark:border-gray-600'}
                    ${ehHoje && !treinou ? 'border-primary dark:border-sky-500 ring-2 ring-primary/50 dark:ring-sky-500/50' : ''}
                    ${ehHoje && treinou ? 'ring-2 ring-green-500/50 dark:ring-green-600/50' : ''}
                  `}
                  title={treinou ? `Treino concluído em ${format(dia, 'dd/MM')}` : `Sem treino concluído em ${format(dia, 'dd/MM')}`}
                >
                  {treinou && <CheckCircle2 className="w-4 h-4 text-white" />}
                </div>
                <span className={`text-xs font-bold ${ehHoje ? 'text-primary dark:text-sky-400' : 'text-foreground'}`}>
                  {format(dia, 'dd')}
                </span>
              </div>
            );
          })}
        </div>
        {sessoesConcluidasNaSemana.length === 0 && (
          <p className="text-center text-sm text-muted-foreground mt-3">
            Nenhum treino concluído esta semana ainda. Vamos lá!
          </p>
        )}
      </CardContent>
    </Card>
  );
};

export default FrequenciaSemanal;
===== ./client/src/components/alunos/WorkoutExerciseCard.tsx =====
// client/src/components/alunos/WorkoutExerciseCard.tsx
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Check, PlayCircle, Clock, Weight, ChevronDown, RotateCcw, Info, Link } from 'lucide-react';
import { useWorkoutPlayer } from '@/context/WorkoutPlayerContext';
import { cn } from '@/lib/utils';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";

// Interface final com o campo 'observacoes' (plural)
interface ExercicioRenderizavel {
  _id: string;
  exercicioDetalhes: {
    nome: string;
    urlVideo?: string;
  } | null;
  descanso?: string;
  series?: string;
  repeticoes?: string;
  carga?: string;
  observacoes?: string; // NOME CORRETO DO CAMPO
  grupoCombinado?: string; // ID do grupo para exercícios combinados
}

interface WorkoutExerciseCardProps {
  exercise: ExercicioRenderizavel;
  isActive: boolean;
  isCompleted: boolean;
  onOpenVideo: (url: string) => void;
  isInGroup?: boolean; // Indica se o exercício faz parte de um grupo
  groupInfo?: {
    totalInGroup: number;
    positionInGroup: number;
    groupId: string;
  };
}

export const WorkoutExerciseCard: React.FC<WorkoutExerciseCardProps> = ({
  exercise,
  isActive,
  isCompleted,
  onOpenVideo,
  isInGroup = false,
  groupInfo,
}) => {
  const { completeExercise, uncompleteExercise, updateExerciseLoad, getExerciseLoad } = useWorkoutPlayer();
  
  const [load, setLoad] = useState(() => getExerciseLoad(exercise._id) || exercise.carga || '');
  const [isExpanded, setIsExpanded] = useState(isActive);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [currentLoadInput, setCurrentLoadInput] = useState(load);
  const [isReopenConfirmOpen, setIsReopenConfirmOpen] = useState(false);

  useEffect(() => {
    setIsExpanded(isActive);
  }, [isActive]);
  
  const handleUpdateLoad = (newLoadValue: string) => {
    setLoad(newLoadValue);
    updateExerciseLoad(exercise._id, newLoadValue);
  };
  
  const handleCompleteClick = () => {
    completeExercise(exercise._id);
  };

  const handleUncompleteClick = () => {
    uncompleteExercise(exercise._id);
  }

  const exerciseName = exercise.exercicioDetalhes?.nome || 'Exercício Removido';

  const openEditModal = () => {
    setCurrentLoadInput(load);
    setIsEditModalOpen(true);
  };

  const closeEditModal = () => {
    setIsEditModalOpen(false);
  };

  const handleSaveLoad = () => {
    handleUpdateLoad(currentLoadInput);
    closeEditModal();
  };
  
  return (
    <Card
      className={cn(
        "transition-all duration-300 ease-in-out overflow-hidden shadow-md border",
        isCompleted ? 'bg-green-50 border-green-300 shadow-green-100' : 'bg-white border-slate-200',
        isActive ? 'border-indigo-500 shadow-indigo-200 shadow-lg' : '',
        isInGroup ? 'border-l-4 border-l-blue-500 bg-blue-50/50' : ''
      )}
    >
      {/* Group indicator banner */}
      {isInGroup && groupInfo && (
        <div className="bg-blue-100 border-b border-blue-200 px-4 py-2">
          <div className="flex items-center gap-2 text-sm text-blue-700">
            <Link size={16} />
            <span className="font-medium">
              Exercício Conjugado ({groupInfo.positionInGroup}/{groupInfo.totalInGroup})
            </span>
            <span className="text-xs bg-blue-200 px-2 py-1 rounded-full">
              Executar em sequência
            </span>
          </div>
        </div>
      )}
      
      <CardHeader 
        className="flex flex-row items-center justify-between p-4 cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center gap-3 flex-1 min-w-0">
          <p className="font-semibold text-gray-800 whitespace-normal" title={exerciseName}>
            {exerciseName}
          </p>
        </div>
        <div className="flex items-center gap-2">
            {exercise.exercicioDetalhes?.urlVideo && (
              <Button variant="ghost" size="icon" className="h-8 w-8 text-red-500 hover:bg-red-100" onClick={(e) => { e.stopPropagation(); onOpenVideo(exercise.exercicioDetalhes!.urlVideo!); }}>
                  <PlayCircle size={20} />
              </Button>
            )}
           <ChevronDown className={cn("transition-transform", isExpanded && "rotate-180")} />
        </div>
      </CardHeader>

      {isExpanded && (
        <CardContent className="p-4 pt-0">
          <div className="border-t pt-4 space-y-4">
            <div className="flex justify-around text-center">
              <div><p className="text-sm text-gray-500">Séries</p><p className="font-bold text-lg">{exercise.series || '-'}</p></div>
              <div><p className="text-sm text-gray-500">Repetições</p><p className="font-bold text-lg">{exercise.repeticoes || '-'}</p></div>
              <div>
                <p className="text-sm text-gray-500">Descanso</p>
                <div className='flex items-center justify-center gap-1'>
                  <Clock size={16} className="text-gray-500" />
                  <p className="font-bold text-lg">{exercise.descanso && exercise.descanso.trim() !== '' ? exercise.descanso : '-'}</p>
                </div>
              </div>
            </div>

            {/* SEÇÃO DE OBSERVAÇÕES - VERSÃO FINAL */}
            {exercise.observacoes && (
              <div className="space-y-2 pt-4 border-t mt-4">
                <label className="text-sm font-medium text-gray-700 flex items-center gap-2"><Info size={16} /> Observações do Personal</label>
                <p className="text-sm text-gray-600 bg-gray-50 p-3 rounded-md border">{exercise.observacoes}</p>
              </div>
            )}
            
            <div className="space-y-2 pt-4 border-t mt-4">
                <div className="flex items-center justify-between">
                    <label className="text-sm font-medium text-gray-700 flex items-center gap-2"><Weight size={16} /> Carga Utilizada (kg)</label>
                    <div className="flex items-center gap-2">
                        <p className="font-bold text-lg text-gray-800">{load || '-'}</p>
                        {!isCompleted && (
                            <Button 
                                variant="link" 
                                className="text-blue-600 hover:text-blue-800 p-0 h-auto underline" 
                                onClick={openEditModal}
                            >
                                Editar
                            </Button>
                        )}
                    </div>
                </div>
            </div>
            
            {/* Action Button - Always visible, changes based on completion status */}
            <div className="mt-4">
              {!isCompleted ? (
                <Button className="w-full bg-green-600 hover:bg-green-700" onClick={handleCompleteClick}>
                  <Check className="mr-2" size={18} /> Concluir Exercício
                </Button>
              ) : (
                <Button 
                  variant="outline" 
                  className="w-full border-green-600 text-green-700 hover:bg-green-50" 
                  onClick={() => setIsReopenConfirmOpen(true)}
                >
                  <RotateCcw className="mr-2" size={18} /> Reabrir Exercício
                </Button>
              )}
            </div>
          </div>
        </CardContent>
      )}

      <Dialog open={isEditModalOpen} onOpenChange={setIsEditModalOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Atualizar Carga Utilizada</DialogTitle>
            <DialogDescription>
              Insira a carga utilizada para este exercício.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <label htmlFor="currentLoad" className="text-right">
                Carga (kg)
              </label>
              <Input
                id="currentLoad"
                type="number"
                placeholder="Ex: 20"
                value={currentLoadInput}
                onChange={(e) => setCurrentLoadInput(e.target.value)}
                className="col-span-3"
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={closeEditModal}>Cancelar</Button>
            <Button onClick={handleSaveLoad}>Atualizar</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Reopen Confirmation Dialog */}
      <Dialog open={isReopenConfirmOpen} onOpenChange={setIsReopenConfirmOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Reabrir Exercício</DialogTitle>
            <DialogDescription>
              Tem certeza que deseja reabrir este exercício? Isso irá marcá-lo como não concluído.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsReopenConfirmOpen(false)}>
              Cancelar
            </Button>
            <Button 
              onClick={() => {
                handleUncompleteClick();
                setIsReopenConfirmOpen(false);
              }}
            >
              Reabrir
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </Card>
  );
};
===== ./client/src/components/buttons/ExerciseDeleteButton.tsx =====
// client/src/components/buttons/ExerciseDeleteButton.tsx
import { useState } from "react";
import { Trash, Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogCancel,
  AlertDialogAction,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/hooks/use-toast"; // <<< USA O HOOK
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";

interface Props {
  exercicioId: string;
  onDeleted: () => void;
}

export default function ExerciseDeleteButton({ exercicioId, onDeleted }: Props) {
  const { toast } = useToast(); // <<< USA O HOOK
  const queryClient = useQueryClient();
  const [isAlertOpen, setIsAlertOpen] = useState(false);

  const deleteMutation = useMutation< { message: string }, Error, string >({
    mutationFn: (idToDelete) => apiRequest<{ message: string }>("DELETE", `/api/exercicios/${idToDelete}`),
    onSuccess: (data) => {
      toast({ title: "Sucesso!", description: data.message || "Exercício excluído." }); // Chama toast do hook
      onDeleted();
      queryClient.invalidateQueries({ queryKey: ['/api/exercicios/meus'] });
      setIsAlertOpen(false);
    },
    onError: (error) => {
      toast({ // Chama toast do hook
        variant: "destructive",
        title: "Erro ao Excluir",
        description: error.message || "Não foi possível excluir o exercício.",
      });
    },
  });

  const handleConfirmDelete = () => {
    deleteMutation.mutate(exercicioId);
  };

  return (
     <AlertDialog open={isAlertOpen} onOpenChange={setIsAlertOpen}>
      <AlertDialogTrigger asChild>
         <Button
           variant="ghost"
           size="icon"
           className="text-destructive hover:text-destructive hover:bg-destructive/10 h-8 w-8" // Ajuste visual
           title="Excluir Exercício"
         >
           <Trash className="w-4 h-4" />
         </Button>
      </AlertDialogTrigger>
      <AlertDialogContent>
         <AlertDialogHeader>
           <AlertDialogTitle>Excluir Exercício</AlertDialogTitle>
           <AlertDialogDescription>
             Tem certeza que deseja excluir este exercício? Os treinos que o utilizam podem ser afetados. Esta ação não poderá ser desfeita.
           </AlertDialogDescription>
         </AlertDialogHeader>
         <AlertDialogFooter>
           <AlertDialogCancel disabled={deleteMutation.isPending}>Cancelar</AlertDialogCancel>
           <AlertDialogAction
              onClick={handleConfirmDelete}
              disabled={deleteMutation.isPending}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
           >
             {deleteMutation.isPending ? ( <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Excluindo...</> ) : 'Excluir'}
           </AlertDialogAction>
         </AlertDialogFooter>
      </AlertDialogContent>
     </AlertDialog>
  );
}
===== ./client/src/components/dialogs/AlunoViewModal.tsx =====
// client/src/components/dialogs/AlunoViewModal.tsx
import React, { useState, useEffect } from 'react';
import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { useLocation } from 'wouter';
import { fetchWithAuth, apiRequest } from '@/lib/apiClient';
import { useToast } from '@/hooks/use-toast';
import { ModalConfirmacao } from "@/components/ui/modal-confirmacao";
import { useConfirmDialog } from "@/hooks/useConfirmDialog";
import {
  Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter,
} from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Aluno } from "@/types/aluno";
import {
  Dumbbell, Edit, Mail, Phone, User, Weight, Ruler, Cake, Target,
  CalendarDays, BarChart, CheckCircle2, Sigma, FileText, View, PlusCircle, MoreVertical,
  Trash2, Clock, CalendarCheck, Crown, Users, Zap, Hash
} from 'lucide-react';
import {
  DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger
} from "@/components/ui/dropdown-menu";
import { Skeleton } from '../ui/skeleton';
  import ErrorMessage from '../ErrorMessage';
import RotinaViewModal from './RotinaViewModal';
import VideoPlayerModal from './VideoPlayerModal';
import RotinaFormModal from './RotinaFormModal';
import SelectModeloRotinaModal from './SelectModeloRotinaModal';
import type { RotinaListagemItem } from '@/types/treinoOuRotinaTypes';

interface AlunoRotina {
  _id: string;
  titulo: string;
  descricao?: string;
  atualizadoEm: string;
}

interface IWorkoutHistoryLog {
  _id: string;
  treinoId: string;
  treinoTitulo: string;
  dataInicio: string;
  dataFim: string;
  duracaoTotalMinutos: number;
  nivelTreino: 'muito_facil' | 'facil' | 'moderado' | 'dificil' | 'muito_dificil';
  comentarioAluno?: string;
  aumentoCarga?: boolean;
}

interface AlunoViewModalProps {
  aluno: Aluno | null;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

const RotinasTab = ({
  alunoId,
  onVisualizarRotina,
  onAssociarRotina,
  onDeleteRotina
}: {
  alunoId: string;
  onVisualizarRotina: (id: string) => void;
  onAssociarRotina: () => void;
  onDeleteRotina: (rotinaId: string, rotinaTitulo: string) => void;
}) => {
  const { data: rotinas, isLoading, isError, error } = useQuery<AlunoRotina[]>({
    queryKey: ['alunoRotinas', alunoId],
    queryFn: () => apiRequest("GET", `/api/treinos/aluno/${alunoId}`),
    enabled: !!alunoId,
  });

  if (isLoading) {
    return (
      <div className="space-y-3 mt-4">
        {[...Array(3)].map((_, i) => <Skeleton key={i} className="h-12 w-full" />)}
      </div>
    );
  }

  if (isError) {
    return <ErrorMessage title="Erro ao buscar rotinas" message={error.message} />;
  }

  return (
    <div className="mt-4 pr-2 h-[250px] overflow-y-auto space-y-2">
      <div className="flex justify-end mb-4">
        <Button variant="outline" size="sm" onClick={onAssociarRotina}>
          <PlusCircle className="mr-2 h-4 w-4" /> Associar Rotina
        </Button>
      </div>
      {(!rotinas || rotinas.length === 0) ? (
        <div className="text-center text-muted-foreground pt-10">
          <Dumbbell className="mx-auto h-12 w-12 text-slate-300 dark:text-slate-700" />
          <p className="mt-2">Nenhuma rotina associada a este aluno.</p>
        </div>
      ) : (
        rotinas.map(rotina => (
          <div key={rotina._id} className="flex items-center justify-between p-3 rounded-md border bg-slate-50 dark:bg-slate-800/50">
            <div className="flex items-center gap-3">
              <FileText className="h-5 w-5 text-primary" />
              <div>
                <p className="font-semibold text-sm">{rotina.titulo}</p>
                <p className="text-xs text-muted-foreground">
                  Atualizada em: {new Date(rotina.atualizadoEm).toLocaleDateString('pt-BR')}
                </p>
              </div>
            </div>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8">
                  <MoreVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem
                  onClick={() => onVisualizarRotina(rotina._id)}
                  className="flex items-center px-2 py-1.5 text-sm rounded-md hover:bg-accent hover:text-accent-foreground cursor-pointer"
                >
                  <View className="mr-2 h-4 w-4" /> Visualizar
                </DropdownMenuItem>
                <DropdownMenuItem
                  onClick={() => onDeleteRotina(rotina._id, rotina.titulo)}
                  className="text-red-600 focus:text-red-700 focus:bg-red-50 dark:focus:bg-red-900/40"
                >
                  <span className="flex items-center">
                    <Trash2 className="mr-2 h-4 w-4" /> Remover
                  </span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        ))
      )}
    </div>
  );
};

const HistoricoTab = ({
  alunoId,
  isActive
}: {
  alunoId: string;
  isActive: boolean;
}) => {
  const { isLoading, isError, error } = useQuery<IWorkoutHistoryLog[]>({
    queryKey: ['historicoAlunoWorkoutLogs', alunoId],
    queryFn: () => fetchWithAuth(`/api/activity-logs/aluno/${alunoId}`),
    enabled: isActive && !!alunoId,
    staleTime: 1000 * 60 * 5,
  });

  if (isLoading) {
    return (
      <div className="space-y-3 mt-4">
        {[...Array(3)].map((_, i) => <Skeleton key={i} className="h-12 w-full" />)}
      </div>
    );
  }

  if (isError) {
    return <ErrorMessage title="Erro ao buscar histórico" message={error.message} />;
  }

  return (
    <div className="mt-4 pr-2 h-[250px] overflow-y-auto space-y-2">
      {/* Conteúdo do histórico pode ser adicionado aqui */}
    </div>
  );
};

const InfoItem = ({
  icon: Icon,
  label,
  value
}: {
  icon: React.ElementType;
  label: string;
  value: React.ReactNode;
}) => (
  <div className="flex items-start text-sm py-2 border-b border-slate-100 dark:border-slate-800">
    <Icon className="h-4 w-4 mr-3 mt-0.5 text-slate-500" />
    <span className="font-medium text-slate-600 dark:text-slate-400 w-32">{label}:</span>
    <span className="text-slate-900 dark:text-slate-100">
      {value || <span className="italic text-slate-400">Não informado</span>}
    </span>
  </div>
);

const KpiCard = ({
  title,
  value,
  icon: Icon
}: {
  title: string;
  value: string | number;
  icon: React.ElementType;
}) => (
  <Card className="bg-slate-50 dark:bg-slate-800/50 border-slate-200 dark:border-slate-700">
    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
      <CardTitle className="text-xs font-medium uppercase tracking-wider text-slate-500 dark:text-slate-400">
        {title}
      </CardTitle>
      <Icon className="h-4 w-4 text-slate-500" />
    </CardHeader>
    <CardContent>
      <div className="text-2xl font-bold text-slate-900 dark:text-slate-50">{value}</div>
    </CardContent>
  </Card>
);

const AlunoViewModal: React.FC<AlunoViewModalProps> = ({ aluno, open, onOpenChange }) => {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { isOpen: isConfirmOpen, options: confirmOptions, openConfirmDialog, closeConfirmDialog } = useConfirmDialog();
  const [, navigate] = useLocation();

  const [rotinaIdParaVer, setRotinaIdParaVer] = useState<string | null>(null);
  const [isRotinaViewModalOpen, setIsRotinaViewModalOpen] = useState(false);
  const [rotinaParaEditar, setRotinaParaEditar] = useState<RotinaListagemItem | null>(null);
  const [isRotinaFormModalOpen, setIsRotinaFormModalOpen] = useState(false);
  const [videoUrl, setVideoUrl] = useState<string | null>(null);
  const [isSelectModeloRotinaModalOpen, setIsSelectModeloRotinaModalOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("detalhes");
  const [rotinaIdToDelete, setRotinaIdToDelete] = useState<string | null>(null);

  const { data: trainerPlanStatus } = useQuery({
    queryKey: ['trainerPlanStatus', aluno?.trainerId],
    queryFn: () => fetchWithAuth(`/api/personal/meu-plano`),
    enabled: !!aluno?.trainerId && open,
    staleTime: 1000 * 60 * 5,
  });

  const { data: rotinaDetalhada, isFetching: isFetchingRotina } = useQuery<RotinaListagemItem>({
    queryKey: ['rotinaDetalhes', rotinaIdParaVer],
    queryFn: () => fetchWithAuth(`/api/treinos/${rotinaIdParaVer}`),
    enabled: !!rotinaIdParaVer,
    staleTime: 0,
    gcTime: 0,
  });

  useEffect(() => {
    if (rotinaDetalhada && !isFetchingRotina && rotinaIdParaVer) {
      setIsRotinaViewModalOpen(true);
    }
  }, [rotinaDetalhada, isFetchingRotina, rotinaIdParaVer]);

  const handleVisualizarRotina = (rotinaId: string) => {
    setRotinaIdParaVer(rotinaId);
  };

  const handleEditFromView = (rotina: RotinaListagemItem) => {
    setRotinaParaEditar(rotina);
    setIsRotinaViewModalOpen(false);
    setTimeout(() => {
      setIsRotinaFormModalOpen(true);
    }, 100);
  };

  const handlePlayVideo = (url: string) => {
    setVideoUrl(url);
  };

  const handleAssociarRotina = () => {
    setIsSelectModeloRotinaModalOpen(true);
  };

  const deleteRotinaMutation = useMutation({
  mutationFn: (rotinaId: string) => apiRequest("DELETE", `/api/treinos/${rotinaId}`),
    onSuccess: () => {
      toast({ title: "Sucesso!", description: "Rotina removida com sucesso." });
      queryClient.invalidateQueries({ queryKey: ["alunoRotinas", aluno?._id] });
    },
    onError: (error: any) => {
      toast({
        variant: "destructive",
        title: "Erro ao Remover",
        description: error.message || "Não foi possível remover a rotina."
      });
    },
    onSettled: () => {
      closeConfirmDialog();
      setRotinaIdToDelete(null);
    }
  });

  const handleDeleteRotina = (rotinaId: string, rotinaTitulo: string) => {
    setRotinaIdToDelete(rotinaId);
    openConfirmDialog({
      titulo: "Confirmar Remoção",
      mensagem: `Tem certeza que deseja remover a rotina "${rotinaTitulo}" deste aluno?`,
      onConfirm: () => { },
    });
  };

  const handleConfirmDelete = () => {
    if (rotinaIdToDelete) {
      deleteRotinaMutation.mutate(rotinaIdToDelete);
    }
  };

  const associateModelMutation = useMutation({
    mutationFn: async ({ fichaModeloId, alunoId }: { fichaModeloId: string; alunoId: string }) => {
      return apiRequest("POST", "/api/treinos/associar-modelo", { fichaModeloId, alunoId });
    },
    onSuccess: (data) => {
      toast({
        title: "Sucesso!",
        description: `Ficha "${data.titulo}" criada para o aluno.`,
      });
      queryClient.invalidateQueries({ queryKey: ["alunoRotinas", aluno?._id] });
    },
    onError: (error: any) => {
      toast({ variant: "destructive", title: "Erro ao Associar", description: error.message });
    },
    onSettled: () => setIsSelectModeloRotinaModalOpen(false)
  });

  const handleSelectModelAndAssociate = (modelId: string) => {
    if (aluno?._id) {
      associateModelMutation.mutate({ fichaModeloId: modelId, alunoId: aluno._id });
    }
  };

  const convertToModelMutation = useMutation({
    mutationFn: (rotinaId: string) => apiRequest<RotinaListagemItem>("POST", `/api/treinos/${rotinaId}/tornar-modelo`),
    onSuccess: () => {
      toast({ title: "Sucesso!", description: `Rotina convertida em modelo.` });
      queryClient.invalidateQueries({ queryKey: ['alunoRotinas', aluno?._id] });
    },
    onError: (error: any) => {
      toast({ variant: "destructive", title: "Erro ao converter", description: error.message });
    },
    onSettled: () => setIsRotinaViewModalOpen(false)
  });

  const handleConvertToModelFromRotinaView = (rotina: RotinaListagemItem) => {
    if (rotina && rotina._id) {
      convertToModelMutation.mutate(rotina._id);
    }
  };

  if (!aluno) return null;

  // Helpers para formatação
  const getInitials = (name: string) => {
    return name.split(' ').filter(n => n).map(n => n[0]).slice(0, 2).join('').toUpperCase() || '?';
  };
  const formatDateBR = (dateStr?: string | Date) => {
    if (!dateStr) return 'N/A';
    try {
      const date = new Date(dateStr);
      if (isNaN(date.getTime())) return 'N/A';
      return date.toLocaleDateString('pt-BR', { timeZone: 'UTC' });
    } catch (e) {
      return 'N/A';
    }
  };

  // Métricas fictícias (substitua conforme sua lógica real)
  const frequenciaSemanal = 3;
  const progressoFicha = 66;
  const pseMedio = 7.5;

  return (
    <>
      <Dialog open={open} onOpenChange={onOpenChange}>
        <DialogContent
          className="w-full md:max-w-3xl max-h-[90vh] overflow-y-auto p-0"
          aria-describedby="aluno-modal-description"
        >
          <div className="flex">
            {/* Coluna esquerda: informações básicas e plano */}
            <div className="w-1/3 bg-slate-50 dark:bg-slate-900/50 p-6 border-r dark:border-slate-800 hidden md:flex flex-col">
              <div className="flex flex-col items-center text-center">
                <Avatar className="h-24 w-24 mb-4 border-4 border-primary/50">
                  <AvatarFallback className="text-3xl bg-slate-200 dark:bg-slate-700 text-primary">
                    {getInitials(aluno.nome)}
                  </AvatarFallback>
                </Avatar>
                <h2 className="text-xl font-bold text-slate-900 dark:text-slate-50">{aluno.nome}</h2>
                <p className="text-sm text-slate-500 dark:text-slate-400">{aluno.email}</p>
                <Badge variant={aluno.status === "active" ? "success" : "destructive"} className="mt-3">
                  {aluno.status === "active" ? "Ativo" : "Inativo"}
                </Badge>
              </div>
              <div className="mt-8 space-y-4">
                <InfoItem icon={Mail} label="Email" value={aluno.email} />
                <InfoItem icon={Phone} label="Telefone" value={aluno.phone} />

                {trainerPlanStatus && (
                  <div className="mt-6 pt-4 border-t border-slate-200 dark:border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-600 dark:text-slate-400 mb-3">Informações do Plano</h3>
                    <InfoItem
                      icon={Crown}
                      label="Plano"
                      value={trainerPlanStatus.plano?.nome || "Sem plano ativo"}
                    />
                    {trainerPlanStatus.tokensAvulsos > 0 && (
                      <InfoItem
                        icon={Zap}
                        label="Tokens Avulsos"
                        value={`${trainerPlanStatus.tokensAvulsos} disponíveis`}
                      />
                    )}
                    <InfoItem
                      icon={Users}
                      label="Vagas"
                      value={`${trainerPlanStatus.alunosAtivos}/${trainerPlanStatus.limiteAtual}`}
                    />
                  </div>
                )}

                {/* Nova seção: informações da vaga do aluno */}
                {aluno.slotType && (
                  <div className="mt-6 pt-4 border-t border-slate-200 dark:border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-600 dark:text-slate-400 mb-3">Vaga do Aluno</h3>
                    <InfoItem
                      icon={aluno.slotType === 'plan' ? Crown : Zap}
                      label="Tipo"
                      value={aluno.slotType === 'plan' ? 'Plano' : 'Token Avulso'}
                    />
                    <InfoItem
                      icon={Hash}
                      label="ID"
                      value={aluno.slotId}
                    />
                    <InfoItem
                      icon={CalendarCheck}
                      label="Início"
                      value={formatDateBR(aluno.slotStartDate)}
                    />
                    <InfoItem
                      icon={Clock}
                      label="Vencimento"
                      value={formatDateBR(aluno.slotEndDate)}
                    />
                  </div>
                )}
              </div>
            </div>

            {/* Coluna direita: informações detalhadas e tabs */}
            <div className="w-full md:w-2/3 p-6 flex flex-col">
              <DialogHeader className="md:hidden mb-4 text-center">
                <DialogTitle>{aluno.nome}</DialogTitle>
                <DialogDescription id="aluno-modal-description">
                  Informações detalhadas do aluno, incluindo dados pessoais, rotinas de treino e histórico de atividades
                </DialogDescription>
              </DialogHeader>
              <div id="aluno-modal-description" className="hidden md:block sr-only">
                Informações detalhadas do aluno {aluno.nome}, incluindo dados pessoais, rotinas de treino e histórico de atividades
              </div>
              <div className="grid grid-cols-3 gap-4 mb-6">
                <KpiCard title="Frequência" value={`${frequenciaSemanal}/sem`} icon={BarChart} />
                <KpiCard title="PSE Médio" value={pseMedio.toFixed(1)} icon={Sigma} />
                <KpiCard title="Progresso" value={`${progressoFicha}%`} icon={CheckCircle2} />
              </div>
              {progressoFicha > 0 && <Progress value={progressoFicha} className="w-full h-2 mb-6" />}

              <Tabs defaultValue="detalhes" className="w-full flex-grow" onValueChange={setActiveTab}>
                <TabsList className="grid w-full grid-cols-3">
                  <TabsTrigger value="detalhes">Detalhes</TabsTrigger>
                  <TabsTrigger value="rotinas">Rotinas</TabsTrigger>
                  <TabsTrigger value="historico">Histórico</TabsTrigger>
                </TabsList>

                <TabsContent value="detalhes" className="mt-4 pr-2 h-[250px] overflow-y-auto">
                  <div className="space-y-1">
                    <InfoItem icon={Target} label="Objetivo" value={aluno.goal} />
                    <InfoItem icon={Cake} label="Nascimento" value={formatDateBR(aluno.birthDate)} />
                    <InfoItem icon={Weight} label="Peso" value={`${aluno.weight} kg`} />
                    <InfoItem icon={Ruler} label="Altura" value={`${aluno.height} cm`} />
                    <InfoItem icon={User} label="Gênero" value={aluno.gender} />
                    <InfoItem icon={CalendarDays} label="Início" value={formatDateBR(aluno.startDate)} />
                  </div>
                </TabsContent>

                <TabsContent value="rotinas">
                  <RotinasTab
                    alunoId={aluno._id}
                    onVisualizarRotina={handleVisualizarRotina}
                    onAssociarRotina={handleAssociarRotina}
                    onDeleteRotina={handleDeleteRotina}
                  />
                </TabsContent>

                <TabsContent value="historico">
                  <HistoricoTab alunoId={aluno._id} isActive={activeTab === "historico"} />
                </TabsContent>
              </Tabs>

              <DialogFooter className="mt-auto pt-6">
                <Button
                  variant="outline"
                  onClick={() => navigate(`/alunos/editar/${aluno._id}`)}
                >
                  <Edit className="mr-2 h-4 w-4" /> Editar Aluno
                </Button>
              </DialogFooter>
            </div>
          </div>
        </DialogContent>
      </Dialog>

      {rotinaDetalhada && (
        <RotinaViewModal
          isOpen={isRotinaViewModalOpen}
          onClose={() => {
            setIsRotinaViewModalOpen(false);
            setTimeout(() => {
              setRotinaIdParaVer(null);
            }, 150);
          }}
          rotina={rotinaDetalhada}
          onEdit={handleEditFromView}
          onAssign={() => { }}
          onPlayVideo={handlePlayVideo}
          onConvertToModel={handleConvertToModelFromRotinaView}
        />
      )}

      {videoUrl && <VideoPlayerModal videoUrl={videoUrl} onClose={() => setVideoUrl(null)} />}

      <RotinaFormModal
        open={isRotinaFormModalOpen}
        onClose={() => {
          setIsRotinaFormModalOpen(false);
          setRotinaParaEditar(null);
        }}
        rotinaParaEditar={rotinaParaEditar}
        onSuccess={(rotinaAtualizada) => {
          queryClient.invalidateQueries({ queryKey: ['rotinaDetalhes', rotinaAtualizada._id] });
          setRotinaParaEditar(null);
          setRotinaIdParaVer(null);
        }}
        alunos={[aluno]}
      />

      <SelectModeloRotinaModal
        isOpen={isSelectModeloRotinaModalOpen}
        onClose={() => setIsSelectModeloRotinaModalOpen(false)}
        onSelect={handleSelectModelAndAssociate}
      />

      <ModalConfirmacao
        isOpen={isConfirmOpen}
        onClose={closeConfirmDialog}
        onConfirm={handleConfirmDelete}
        titulo={confirmOptions.titulo}
        mensagem={confirmOptions.mensagem}
        isLoadingConfirm={deleteRotinaMutation.isPending}
      />
    </>
  );
};

export default AlunoViewModal;

===== ./client/src/components/dialogs/AssociarModeloAlunoModal.tsx =====
// client/src/components/dialogs/AssociarModeloAlunoModal.tsx
import React, { useState, useEffect } from 'react';
import {
  Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import {
  Select, SelectContent, SelectItem, SelectTrigger, SelectValue,
} from "@/components/ui/select";
import { Loader2, Users } from 'lucide-react';
import { Aluno } from '@/types/aluno';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { useQuery, useQueryClient as useTanstackQueryClient } from '@tanstack/react-query';

interface AssociarModeloAlunoModalProps {
  isOpen: boolean;
  onClose: () => void;
  fichaModeloId: string | null;
  fichaModeloTitulo: string | null;
}

interface AssociacaoResponse {
    _id: string;
    titulo: string;
    tipo: 'individual';
    alunoId: { _id: string; nome: string; };
}

const AssociarModeloAlunoModal: React.FC<AssociarModeloAlunoModalProps> = ({
  isOpen,
  onClose,
  fichaModeloId,
  fichaModeloTitulo,
}) => {
  // Inicializa selectedAlunoId como uma string vazia para manter o Select controlado
  const [selectedAlunoId, setSelectedAlunoId] = useState<string>(""); 
  const [isSubmitting, setIsSubmitting] = useState(false);
  const { toast } = useToast();
  const queryClient = useTanstackQueryClient();

  // <<< CORREÇÃO DE ROTA E QUERY KEY >>>
  const { data: alunos = [], isLoading: isLoadingAlunos } = useQuery<Aluno[], Error>({
    queryKey: ["/api/aluno/gerenciar"], // Usar a query key consistente
    queryFn: async () => {
      console.log("[AssociarModeloAlunoModal] Buscando alunos para o modal...");
      // Usar a rota correta para o personal listar seus alunos
      const data = await apiRequest<Aluno[]>("GET", "/api/aluno/gerenciar");
      console.log(`[AssociarModeloAlunoModal] ${data.length} alunos recebidos.`);
      return Array.isArray(data) ? data : [];
    },
    enabled: isOpen,
    staleTime: 1000 * 60 * 5,
  });

  useEffect(() => {
    if (isOpen) {
      // Garante que o valor seja resetado para uma string vazia ao abrir o modal
      setSelectedAlunoId(""); 
    }
  }, [isOpen, fichaModeloId]);

  const handleSubmit = async () => {
    if (!fichaModeloId || !selectedAlunoId) {
      toast({
        variant: "destructive",
        title: "Seleção Incompleta",
        description: "Por favor, selecione um aluno.",
      });
      return;
    }

    setIsSubmitting(true);
    const payload = {
        fichaModeloId,
        alunoId: selectedAlunoId
    };
    const apiPath = "/api/treinos/associar-modelo";

    try {
      const novaFichaIndividual = await apiRequest<AssociacaoResponse>("POST", apiPath, payload);
      
      toast({
        title: "Sucesso!",
        description: `Ficha "${novaFichaIndividual.titulo}" criada para ${novaFichaIndividual.alunoId.nome}.`,
      });

      queryClient.invalidateQueries({ queryKey: ["/api/treinos"] });
      queryClient.invalidateQueries({ queryKey: ["alunoRotinas", selectedAlunoId] }); // Invalida a busca de rotinas do aluno específico

      onClose();

    } catch (error: any) {
      toast({
        variant: "destructive",
        title: "Erro ao Associar",
        description: error.message || "Não foi possível criar a ficha individual a partir do modelo.",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  // REMOÇÃO: A condição de renderização não deve mais verificar fichaModeloId ou fichaModeloTitulo
  if (!isOpen) { 
    return null;
  }

  return (
    <Dialog open={isOpen} onOpenChange={(openStatus) => !openStatus && onClose()}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="flex items-center">
            <Users className="w-5 h-5 mr-2 text-primary" />
            Associar Modelo: {fichaModeloTitulo || "Selecione um Modelo"} {/* Exibir placeholder se nulo */}
          </DialogTitle>
          <DialogDescription>
            Selecione um aluno para criar uma ficha individual baseada neste modelo.
          </DialogDescription>
        </DialogHeader>

        <div className="py-4 space-y-4">
          <div>
            <label htmlFor="aluno-select-associar" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Selecionar Aluno*
            </label>
            {isLoadingAlunos ? (
              <div className="flex items-center space-x-2 text-sm text-muted-foreground">
                <Loader2 className="h-4 w-4 animate-spin" />
                <span>Carregando alunos...</span>
              </div>
            ) : alunos.length === 0 ? (
                <p className="text-sm text-muted-foreground">Nenhum aluno cadastrado para selecionar.</p>
            ) : (
              <Select
                value={selectedAlunoId} // O valor agora é sempre uma string
                onValueChange={setSelectedAlunoId}
                disabled={isSubmitting}
              >
                <SelectTrigger id="aluno-select-associar" className="w-full">
                  {/* O placeholder será exibido quando selectedAlunoId for "" */}
                  <SelectValue placeholder="Escolha um aluno..." /> 
                </SelectTrigger>
                <SelectContent>
                  {alunos.map((aluno) => (
                    <SelectItem key={aluno._id} value={aluno._id}>
                      {aluno.nome} ({aluno.email})
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            )}
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isSubmitting}>
            Cancelar
          </Button>
          <Button
            onClick={handleSubmit}
            // A condição !selectedAlunoId agora funcionará corretamente com ""
            disabled={isSubmitting || isLoadingAlunos || !selectedAlunoId || alunos.length === 0}
          >
            {isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Associar e Criar Ficha
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default AssociarModeloAlunoModal;

===== ./client/src/components/dialogs/EditFichaModal.tsx =====
import { useEffect, useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";

interface EditFichaModalProps {
  isOpen: boolean;
  onClose: () => void;
  fichaData: { // Dados necessários para edição
    _id: string;
    titulo: string;
    descricao?: string;
  } | null;
  onSave: (id: string, data: { titulo: string; descricao?: string }) => Promise<void>; // Função para salvar
  isLoading: boolean; // Estado de loading da mutation
}

export default function EditFichaModal({
  isOpen,
  onClose,
  fichaData,
  onSave,
  isLoading,
}: EditFichaModalProps) {
  const [titulo, setTitulo] = useState("");
  const [descricao, setDescricao] = useState("");

  // Atualiza o estado interno quando fichaData muda (ao abrir o modal)
  useEffect(() => {
    if (fichaData) {
      setTitulo(fichaData.titulo);
      setDescricao(fichaData.descricao || "");
    } else {
      // Reseta se não houver dados
      setTitulo("");
      setDescricao("");
    }
  }, [fichaData]);

  const handleSaveClick = async () => {
    if (!fichaData) return; // Segurança extra

    // Validação simples no frontend
    if (!titulo.trim()) {
      alert("O título não pode ficar em branco."); // Adicione um toast se necessário
      return;
    }

    try {
      await onSave(fichaData._id, { titulo: titulo.trim(), descricao });
      // Feedback e fechamento do modal tratados no sucesso da mutation
    } catch (error) {
      console.error("Erro ao salvar:", error);
      alert("Erro ao salvar as alterações. Tente novamente.");
    }
  };

  // Não renderiza nada se não estiver aberto ou sem dados
  if (!isOpen || !fichaData) {
    return null;
  }

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Editar Ficha de Treino</DialogTitle>
          <DialogDescription>Altere o título e a descrição da ficha.</DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          {/* Título */}
          <div>
            <Label htmlFor="edit-titulo-ficha">Título*</Label>
            <Input
              id="edit-titulo-ficha"
              value={titulo}
              onChange={(e) => setTitulo(e.target.value)}
              placeholder="Título da ficha"
              disabled={isLoading}
            />
          </div>

          {/* Descrição */}
          <div>
            <Label htmlFor="edit-descricao-ficha">Descrição</Label>
            <Textarea
              id="edit-descricao-ficha"
              value={descricao}
              onChange={(e) => setDescricao(e.target.value)}
              placeholder="Descrição (opcional)"
              disabled={isLoading}
            />
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose}>
            Cancelar
          </Button>
          <Button onClick={handleSaveClick} disabled={isLoading}>
            Salvar
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/dialogs/ExerciseEditModal.tsx =====
// client/src/components/dialogs/ExerciseEditModal.tsx
import { useEffect, useState } from "react"; // 'React' foi removido daqui
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Pencil, Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectTrigger,
  SelectContent,
  SelectItem,
  SelectValue,
} from "@/components/ui/select";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useFormPersistence } from '@/hooks/useFormPersistence';
import { usePersistedState } from '@/hooks/usePersistedState';

// Interfaces
interface ExercicioData {
  _id: string;
  nome: string;
  descricao?: string;
  categoria?: string;
  grupoMuscular?: string;
  tipo?: string;
  urlVideo?: string;
}
interface Props {
  exercicio: ExercicioData;
  onUpdated: () => void;
  gruposMusculares: string[];
  categoriasExercicio: string[];
}
type UpdateExercicioPayload = Omit<ExercicioData, '_id'>;

const NONE_FILTER_VALUE = "none";

export default function ExerciseEditModal({ exercicio, onUpdated, gruposMusculares, categoriasExercicio }: Props) {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [open, setOpen] = useState(false);

  // Persisted state for each form field with unique key per exercise
  const [nome, setNome, clearNome] = usePersistedState(`formEditarExercicio_${exercicio._id}_nome`, exercicio.nome);
  const [descricao, setDescricao, clearDescricao] = usePersistedState(`formEditarExercicio_${exercicio._id}_descricao`, exercicio.descricao || "");
  const [categoria, setCategoria, clearCategoria] = usePersistedState(`formEditarExercicio_${exercicio._id}_categoria`, exercicio.categoria || NONE_FILTER_VALUE);
  const [grupoMuscular, setGrupoMuscular, clearGrupoMuscular] = usePersistedState(`formEditarExercicio_${exercicio._id}_grupoMuscular`, exercicio.grupoMuscular || NONE_FILTER_VALUE);
  const [urlVideo, setUrlVideo, clearUrlVideo] = usePersistedState(`formEditarExercicio_${exercicio._id}_urlVideo`, exercicio.urlVideo || "");

  useEffect(() => {
      if (exercicio && open) {
          // Reset form with current exercise data when modal opens
          setNome(exercicio.nome);
          setDescricao(exercicio.descricao || "");
          setCategoria(exercicio.categoria || NONE_FILTER_VALUE);
          setGrupoMuscular(exercicio.grupoMuscular || NONE_FILTER_VALUE);
          setUrlVideo(exercicio.urlVideo || "");
      }
  }, [exercicio, open, setNome, setDescricao, setCategoria, setGrupoMuscular, setUrlVideo]);

  const formatVideoUrl = (url: string): string | undefined => {
    if (!url) return undefined;
    if (url.includes("youtube.com/watch?v=")) {
      const videoId = url.split("v=")[1].split("&")[0];
      return `https://www.youtube.com/embed/${videoId}`;
    }
    if (url.includes("youtu.be/")) {
        const videoId = url.split("youtu.be/")[1].split("?")[0];
        return `https://www.youtube.com/embed/${videoId}`;
    }
    return url;
  };

  const updateMutation = useMutation<ExercicioData, Error, UpdateExercicioPayload>({
    mutationFn: (payload) => apiRequest("PUT", `/api/exercicios/${exercicio._id}`, payload),
    onSuccess: (data) => {
      toast({ title: "Sucesso!", description: `Exercício "${data.nome}" atualizado.` });
      
      // Clear form persistence on successful save
      clearNome();
      clearDescricao();
      clearCategoria();
      clearGrupoMuscular();
      clearUrlVideo();
      
      onUpdated();
      queryClient.invalidateQueries({ queryKey: ['exercicios'] });
      setOpen(false);
    },
    onError: (error) => {
      toast({
        variant: "destructive",
        title: "Erro ao Atualizar",
        description: error.message || "Não foi possível salvar as alterações.",
      });
    },
  });

  const handleSubmit = () => {
     if (!nome.trim()) {
       toast({ title: "Erro de Validação", description: "O nome é obrigatório.", variant: "destructive" });
       return;
     }
    const finalVideoUrl = formatVideoUrl(urlVideo);
    const payload: UpdateExercicioPayload = {
      nome: nome.trim(),
      descricao: descricao.trim() || undefined,
      categoria: categoria === NONE_FILTER_VALUE ? undefined : categoria,
      grupoMuscular: grupoMuscular === NONE_FILTER_VALUE ? undefined : grupoMuscular,
      tipo: undefined, // Mantido para compatibilidade
      urlVideo: finalVideoUrl || undefined,
    };
    updateMutation.mutate(payload);
  };

  // Enhanced close handler that clears form persistence when cancelled
  const handleClose = () => {
    clearNome();
    clearDescricao();
    clearCategoria();
    clearGrupoMuscular();
    clearUrlVideo();
    setOpen(false);
  };

  const isLoading = updateMutation.isPending;

  return (
    <Dialog open={open} onOpenChange={(openState) => { if (!openState) handleClose(); else setOpen(true); }}>
      <DialogTrigger asChild>
        <Button variant="ghost" size="icon" className="h-8 w-8 text-gray-500 hover:text-blue-600" title="Editar Exercício">
          <Pencil className="w-4 h-4" />
        </Button>
      </DialogTrigger>
      <DialogContent className="max-w-lg overflow-y-auto max-h-[80vh]">
        <DialogHeader>
          <DialogTitle>Editar Exercício</DialogTitle>
          <DialogDescription>Atualize os dados do exercício abaixo.</DialogDescription>
        </DialogHeader>
        <div className="flex flex-col gap-4 py-4">
             <div><Label htmlFor={`edit-nome-${exercicio._id}`}>Nome*</Label><Input id={`edit-nome-${exercicio._id}`} value={nome} onChange={(e) => setNome(e.target.value)} disabled={isLoading} required /></div>
             
             <div><Label htmlFor={`edit-grupo-${exercicio._id}`}>Grupo Muscular</Label>
                <Select value={grupoMuscular} onValueChange={setGrupoMuscular} disabled={isLoading}>
                    <SelectTrigger id={`edit-grupo-${exercicio._id}`}><SelectValue placeholder="Selecione..." /></SelectTrigger>
                    <SelectContent>
                        <SelectItem value={NONE_FILTER_VALUE}>Nenhum</SelectItem>
                        {gruposMusculares.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
                    </SelectContent>
                </Select>
             </div>
             <div><Label htmlFor={`edit-categoria-${exercicio._id}`}>Categoria</Label>
                <Select value={categoria} onValueChange={setCategoria} disabled={isLoading}>
                    <SelectTrigger id={`edit-categoria-${exercicio._id}`}><SelectValue placeholder="Selecione..." /></SelectTrigger>
                    <SelectContent>
                        <SelectItem value={NONE_FILTER_VALUE}>Nenhuma</SelectItem>
                        {categoriasExercicio.map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}
                    </SelectContent>
                </Select>
             </div>
             
             <div><Label htmlFor={`edit-descricao-${exercicio._id}`}>Descrição</Label><Textarea id={`edit-descricao-${exercicio._id}`} value={descricao} onChange={(e) => setDescricao(e.target.value)} disabled={isLoading} /></div>
             <div><Label htmlFor={`edit-urlVideo-${exercicio._id}`}>URL do Vídeo</Label><Input id={`edit-urlVideo-${exercicio._id}`} value={urlVideo} onChange={(e) => setUrlVideo(e.target.value)} disabled={isLoading} /></div>
        </div>
        <DialogFooter className="mt-4 flex justify-end gap-2">
          <Button variant="outline" onClick={handleClose} disabled={isLoading}>Cancelar</Button>
          <Button onClick={handleSubmit} disabled={isLoading || !nome.trim()}>
            {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {isLoading ? "Salvando..." : "Salvar Alterações"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/dialogs/ExerciseFormModal.tsx =====
// client/src/components/dialogs/ExerciseFormModal.tsx
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Plus } from "lucide-react";
import { useState } from "react";
import { useToast } from "@/hooks/use-toast";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectTrigger,
  SelectContent,
  SelectItem,
  SelectValue,
} from "@/components/ui/select";
import { apiRequest } from "@/lib/queryClient";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useFormPersistence } from "@/hooks/useFormPersistence";

interface Props {
  onCreated: () => void;
  creationType: 'app' | 'personal';
  triggerButtonText?: string;
}

interface ExercicioPayload {
  nome: string;
  descricao?: string;
  grupoMuscular?: string;
  tipo?: string;
  categoria?: string;
  urlVideo?: string;
  isCustom?: boolean;
}

interface ExercicioCriadoResponse {
  _id: string;
}

export default function ExerciseFormModal({ onCreated, creationType, triggerButtonText = "Criar Exercício" }: Props) {
  // =================== LOG DE DIAGNÓSTICO ===================
  console.log(`%c[ExerciseFormModal] Renderizou com creationType: ${creationType}`, 'color: green;');
  // ==========================================================

  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [open, setOpen] = useState(false);

  // Form persistence hook
  const exerciseForm = useFormPersistence({
    formKey: 'exercise_form',
    initialValues: {
      nome: "",
      descricao: "",
      grupoMuscular: "",
      tipo: "",
      categoria: "",
      urlVideo: ""
    },
    enabled: open
  });

  // Enhanced close handler with proper cleanup
  const handleClose = (isOpen: boolean) => {
    if (!isOpen) {
      exerciseForm.resetForm(); // Clear form when modal is closed
    }
    setOpen(isOpen);
  };

  const formatVideoUrl = (url: string): string | undefined => {
    if (!url) return undefined;
    if (url.includes("youtube.com/watch?v=")) {
        const videoId = url.split("v=")[1].split("&")[0];
        return `https://www.youtube.com/embed/${videoId}`;
    }
    if (url.includes("youtu.be/")) {
        const videoId = url.split("youtu.be/")[1].split("?")[0];
        return `https://www.youtube.com/embed/${videoId}`;
    }
    return url;
  };

  const createExerciseMutation = useMutation<ExercicioCriadoResponse, Error, ExercicioPayload>({
    mutationFn: (newExerciseData) => apiRequest<ExercicioCriadoResponse>("POST", "/api/exercicios", newExerciseData),
    onSuccess: () => {
      handleClose(false); // Use centralized close handler
      onCreated();
      toast({ title: "Exercício criado com sucesso!" });
      queryClient.invalidateQueries({ queryKey: ['exercicios'] });
    },
    onError: (error) => {
       toast({
            title: "Erro ao criar exercício",
            description: error.message || "Não foi possível salvar o exercício.",
            variant: "destructive"
       });
    },
  });

  const handleSubmit = () => {
    if (!exerciseForm.values.nome.trim()) {
       toast({ title: "Erro de Validação", description: "O nome do exercício é obrigatório.", variant: "destructive" });
       return;
    }

    const finalVideoUrl = formatVideoUrl(exerciseForm.values.urlVideo);
    
    const payload: ExercicioPayload = {
      nome: exerciseForm.values.nome.trim(),
      isCustom: creationType === 'personal',
      ...(exerciseForm.values.descricao.trim() && { descricao: exerciseForm.values.descricao.trim() }),
      ...(exerciseForm.values.grupoMuscular && { grupoMuscular: exerciseForm.values.grupoMuscular }),
      ...(exerciseForm.values.tipo && { tipo: exerciseForm.values.tipo }),
      ...(exerciseForm.values.categoria && { categoria: exerciseForm.values.categoria }),
      ...(finalVideoUrl && { urlVideo: finalVideoUrl }),
    };

    // =================== LOG DE DIAGNÓSTICO ===================
    console.log('%c[ExerciseFormModal] Enviando payload para API:', 'color: orange; font-weight: bold;', payload);
    // ==========================================================
    createExerciseMutation.mutate(payload);
  };

  const isLoading = createExerciseMutation.isPending;

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogTrigger asChild>
        <Button>
          <Plus className="w-4 h-4 mr-2" />
          {triggerButtonText}
        </Button>
      </DialogTrigger>

      <DialogContent className="max-w-lg overflow-y-auto max-h-[80vh]">
        <DialogHeader>
          <DialogTitle>Novo Exercício</DialogTitle>
          <DialogDescription>
            Preencha os campos abaixo para adicionar um novo exercício.
          </DialogDescription>
        </DialogHeader>

        <div className="flex flex-col gap-4 py-4">
          <div>
            <Label>Nome*</Label>
            <Input 
              placeholder="Nome do exercício" 
              value={exerciseForm.values.nome} 
              onChange={(e) => exerciseForm.updateField('nome', e.target.value)} 
              disabled={isLoading} 
            />
          </div>
          <div>
            <Label>Grupo Muscular</Label>
            <Select 
              onValueChange={(value) => exerciseForm.updateField('grupoMuscular', value)} 
              value={exerciseForm.values.grupoMuscular} 
              disabled={isLoading}
            >
              <SelectTrigger><SelectValue placeholder="Selecione o grupo muscular" /></SelectTrigger>
              <SelectContent>
                {["Peitoral", "Pernas", "Costas", "Ombros", "Bíceps", "Tríceps", "Abdômen", "Lombar", "Glúteos", "Panturrilha", "Cardio", "Corpo Inteiro", "Outro"].sort().map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
              </SelectContent>
            </Select>
          </div>
          <div>
            <Label>Categoria</Label>
            <Select 
              onValueChange={(value) => exerciseForm.updateField('categoria', value)} 
              value={exerciseForm.values.categoria} 
              disabled={isLoading}
            >
              <SelectTrigger><SelectValue placeholder="Selecione a categoria" /></SelectTrigger>
              <SelectContent>
                {["Força", "Resistência", "Hipertrofia", "Potência", "Cardiovascular", "Flexibilidade", "Mobilidade", "Funcional", "Calistenia", "Outro"].sort().map(c => <SelectItem key={c} value={c}>{c}</SelectItem>)}
              </SelectContent>
            </Select>
          </div>
          <div>
            <Label>Descrição (opcional)</Label>
            <Textarea 
              placeholder="Descrição detalhada do exercício" 
              value={exerciseForm.values.descricao} 
              onChange={(e) => exerciseForm.updateField('descricao', e.target.value)} 
              disabled={isLoading}
            />
          </div>
          <div>
            <Label>URL do Vídeo (opcional)</Label>
            <Input 
              placeholder="https://youtube.com/..." 
              value={exerciseForm.values.urlVideo} 
              onChange={(e) => exerciseForm.updateField('urlVideo', e.target.value)} 
              disabled={isLoading}
            />
          </div>
        </div>

        <DialogFooter className="mt-4">
           <Button 
             variant="outline" 
             onClick={() => handleClose(false)} 
             disabled={isLoading}
           >
             Cancelar
           </Button>
          <Button onClick={handleSubmit} disabled={isLoading || !exerciseForm.values.nome.trim()}>
            {isLoading ? "Salvando..." : "Salvar Exercício"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/dialogs/GerarConviteAlunoModal.tsx =====
// client/src/components/dialogs/GerarConviteAlunoModal.tsx
import React, { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { useMutation } from '@tanstack/react-query';
import {
  Dialog, DialogContent, DialogHeader, DialogTitle,
  DialogDescription, DialogFooter,
} from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import { Loader2, Copy, Check } from 'lucide-react';

const formSchema = z.object({
  email: z.string().email("Se preenchido, deve ser um e-mail válido.").optional().or(z.literal('')),
});

type FormValues = z.infer<typeof formSchema>;

interface GerarConviteAlunoModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const GerarConviteAlunoModal: React.FC<GerarConviteAlunoModalProps> = ({ isOpen, onClose }) => {
  const { toast } = useToast();
  const [view, setView] = useState<'form' | 'success'>('form');
  const [inviteLink, setInviteLink] = useState<string | null>(null);
  const [isCopied, setIsCopied] = useState(false);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: { email: "" },
  });

  // Verifica se o personal tem vagas antes de permitir gerar convite
  useEffect(() => {
    async function checkSlots() {
      try {
        const res: any = await apiRequest("GET", "/api/personal/can-activate/1");
        if (!res?.canActivate) {
          toast({
            variant: "destructive",
            title: "Limite de alunos atingido",
            description: "Seu plano atual não permite convidar mais alunos. Faça upgrade ou compre tokens avulsos."
          });
          onClose(); // fecha a modal
        }
      } catch (error) {
        console.error("Erro ao verificar limite de convites:", error);
      }
    }
    if (isOpen) {
      checkSlots();
    }
  }, [isOpen, onClose, toast]);

  // Reseta o formulário quando a modal fecha
  useEffect(() => {
    if (!isOpen) {
      setTimeout(() => {
        form.reset();
        setView('form');
        setInviteLink(null);
        setIsCopied(false);
      }, 300);
    }
  }, [isOpen, form]);

  const mutation = useMutation({
    mutationFn: (data: FormValues) => apiRequest<{ linkConvite: string }>("POST", "/api/aluno/convite", { emailConvidado: data.email || undefined }),
    onSuccess: (data) => {
      setInviteLink(data.linkConvite);
      setView('success');
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "Erro ao gerar convite",
        description: error.message,
      });
    },
  });

  const onSubmit = (data: FormValues) => {
    mutation.mutate(data);
  };

  const handleCopyLink = () => {
    if (inviteLink) {
      navigator.clipboard.writeText(inviteLink).then(() => {
        setIsCopied(true);
        toast({ title: "Sucesso!", description: "Link copiado para a área de transferência." });
        setTimeout(() => setIsCopied(false), 2000);
      });
    }
  };

  const handleInviteAnother = () => {
    form.reset();
    setView('form');
    setInviteLink(null);
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => { if (!open) onClose(); }}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Convidar Novo Aluno</DialogTitle>
          <DialogDescription>
            {view === 'form' 
              ? "Insira o e-mail do aluno (opcional) ou gere um link de convite genérico."
              : "Link de convite gerado! Envie para o seu aluno."}
          </DialogDescription>
        </DialogHeader>
        {view === 'form' && (
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)}>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem className="my-4">
                    <FormLabel>E-mail do Aluno (Opcional)</FormLabel>
                    <FormControl>
                      <Input type="email" placeholder="nome@exemplo.com" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <DialogFooter className="mt-4 flex flex-row gap-3">
                <Button type="button" variant="outline" onClick={() => onClose()}>
                  Cancelar
                </Button>
                <Button type="submit" disabled={mutation.isPending}>
                  {mutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                  Gerar Link
                </Button>
              </DialogFooter>
            </form>
          </Form>
        )}

        {view === 'success' && inviteLink && (
          <div className="flex flex-col items-center space-y-4">
            <div className="flex items-center justify-between w-full p-2 border rounded-md">
              <span className="break-all text-sm">{inviteLink}</span>
              <Button type="button" variant="ghost" size="icon" onClick={handleCopyLink}>
                {isCopied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
              </Button>
            </div>
            <div className="flex justify-end w-full space-x-2">
              <Button variant="outline" onClick={handleInviteAnother}>Convidar Outro</Button>
              <Button onClick={() => onClose()}>Fechar</Button>
            </div>
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
};

export default GerarConviteAlunoModal;

===== ./client/src/components/dialogs/PastaFormModal.tsx =====
// client/src/components/dialogs/PastaFormModal.tsx
import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Loader2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { useMutation } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { usePersistedInput } from '@/hooks/usePersistedInput';

export interface PastaFormData { nome: string; }
export interface PastaExistente extends PastaFormData { _id: string; }
interface PastaFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSuccessCallback: () => void; // Nova prop para sinalizar sucesso
  initialData?: PastaExistente | null;
}

const PastaFormModal: React.FC<PastaFormModalProps> = ({ isOpen, onClose, onSuccessCallback, initialData }) => {
  const { toast } = useToast();
  const isEditing = !!initialData;

  // Persisted state for new folders only (not when editing)
  const [nomePasta, setNomePasta, clearNomePasta] = usePersistedInput(
    "novaPasta_nome"
  );

  useEffect(() => {
    if (isEditing && initialData) {
      // For editing, set the current folder name directly without persistence
      setNomePasta(initialData.nome || '');
    } else if (!isEditing && isOpen) {
      // For new folders, the persisted value will be loaded automatically by the hook
      // but we need to make sure it initializes properly when modal opens
    }
  }, [isOpen, isEditing, initialData, setNomePasta]);

  const mutation = useMutation<any, Error, PastaFormData>({
    mutationFn: (data) => {
      const endpoint = isEditing ? `/api/pastas/treinos/${initialData?._id}` : "/api/pastas/treinos";
      return apiRequest(isEditing ? "PUT" : "POST", endpoint, data);
    },
    // O modal não invalida mais a query, ele apenas avisa o pai que teve sucesso.
    onSuccess: () => {
      toast({ title: "Sucesso!", description: `Pasta ${isEditing ? 'atualizada' : 'criada'} com sucesso.` });
      
      // Clear form persistence on successful save (only for new folders)
      if (!isEditing) {
        clearNomePasta();
      } else {
        // For editing, just reset to empty since we don't want to persist edited values
        setNomePasta("");
      }
      
      onSuccessCallback(); // Chama a função do componente pai
    },
    onError: (error) => {
      toast({ variant: "destructive", title: "Erro", description: error.message });
      onClose(); // Fecha o modal mesmo em caso de erro.
    },
  });

  const handleSubmit = () => {
    if (!nomePasta.trim()) {
      toast({ variant: "destructive", title: "Erro de Validação", description: "O nome da pasta é obrigatório." });
      return;
    }
    mutation.mutate({ nome: nomePasta.trim() });
  };

  // Enhanced close handler that clears form persistence when cancelled
  const handleClose = () => {
    if (!isEditing) {
      clearNomePasta();
    } else {
      // For editing, just reset to empty
      setNomePasta("");
    }
    onClose();
  };

  if (!isOpen) return null;

  return (
    <Dialog open={isOpen} onOpenChange={(open) => { if (!open) handleClose(); }}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>{isEditing ? "Editar Pasta" : "Nova Pasta"}</DialogTitle>
          <DialogDescription>Organize suas rotinas modelo.</DialogDescription>
        </DialogHeader>
        <div className="py-4 space-y-2">
          <Label htmlFor="nome-pasta">Nome da Pasta*</Label>
          <Input id="nome-pasta" value={nomePasta} onChange={(e) => setNomePasta(e.target.value)}
            placeholder="Ex: Adaptação, Hipertrofia, Cutting..."
            disabled={mutation.isPending}
          />
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={handleClose} disabled={mutation.isPending}>Cancelar</Button>
          <Button onClick={handleSubmit} disabled={mutation.isPending || !nomePasta.trim()}>
            {mutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {isEditing ? "Salvar" : "Criar"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default PastaFormModal;
===== ./client/src/components/dialogs/RotinaFormModal.tsx =====
// client/src/components/dialogs/RotinaFormModal.tsx
import React, { useEffect, useState, useMemo } from 'react';
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from '@/lib/queryClient';
import { Loader2, ArrowLeft, ArrowRight, PlusCircle, Edit, Trash2, ListPlus, XCircle, AlertTriangle, Link2, CheckSquare, Square } from "lucide-react";
import { Aluno } from '@/types/aluno';
import type { RotinaListagemItem, DiaDeTreinoDetalhado, ExercicioEmDiaDeTreinoDetalhado } from '@/types/treinoOuRotinaTypes';
import SelectExerciseModal, { BibliotecaExercicio } from './SelectExerciseModal';
import { Card, CardContent } from '../ui/card';
import { useFormPersistence } from '@/hooks/useFormPersistence';

type TipoOrganizacaoRotinaBackend = 'diasDaSemana' | 'numerico' | 'livre';
const OPCOES_TIPO_DOS_TREINOS: { value: TipoOrganizacaoRotinaBackend; label: string }[] = [ { value: 'diasDaSemana', label: 'Dia da Semana' }, { value: 'numerico', label: 'Numérico (A, B, C...)' }, { value: 'livre', label: 'Livre (Nomes)' } ];
const diasDaSemanaOptions = ["Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado", "Domingo"];
export interface RotinaParaEditar { _id?: string; titulo?: string; descricao?: string | null; tipo?: "modelo" | "individual"; statusModelo?: "ativo" | "rascunho" | "arquivado" | null; tipoOrganizacaoRotina?: TipoOrganizacaoRotinaBackend; alunoId?: string | { _id: string; nome: string; } | null; pastaId?: string | { _id: string; nome: string; } | null; diasDeTreino?: DiaDeTreinoDetalhado[]; dataValidade?: string | Date | null; totalSessoesRotinaPlanejadas?: number | null; }
interface DiaDeTreinoState { tempId: string; ordemNaRotina: number; identificadorDia: string; nomeSubFicha?: string | null; exerciciosDoDia: ExercicioEmDiaDeTreinoDetalhado[]; _id?: string; }
interface Step1Data { titulo: string; descricao: string | null; tipo: 'modelo' | 'individual'; alunoId: string | null; }
interface DiaDeTreinoFormData { identificadorDia: string; nomeSubFicha: string | null; }
interface RotinaFormModalProps { open: boolean; onClose: () => void; onSuccess: (rotinaSalva: RotinaListagemItem) => void; alunos: Aluno[]; rotinaParaEditar?: RotinaParaEditar | null; }

const Stepper = ({ currentStep }: { currentStep: number }) => ( <div className="flex items-center w-full mb-8 px-2"> {[ {num: 1, label: "Detalhes"}, {num: 2, label: "Dias"}, {num: 3, label: "Exercícios"} ].map(({num, label}, index, arr) => ( <React.Fragment key={num}> <div className="flex flex-col items-center shrink-0 text-center"> <div className={`w-10 h-10 rounded-full flex items-center justify-center font-bold text-lg transition-all duration-300 ${currentStep >= num ? 'bg-primary text-primary-foreground scale-110 shadow-lg' : 'bg-slate-200 dark:bg-slate-700 text-slate-500'}`}> {num} </div> <p className={`text-xs mt-2 font-semibold transition-colors w-20 ${currentStep >= num ? 'text-primary' : 'text-slate-500'}`}>{label}</p> </div> {index < arr.length - 1 && <div className={`flex-auto border-t-2 mx-2 transition-colors ${currentStep > num ? 'border-primary' : 'border-slate-200 dark:border-slate-700'}`}></div>} </React.Fragment> ))} </div> );

// Componente para renderizar cada exercício individualmente
const ExerciseCard = ({ 
  ex, 
  index, 
  diaAtivo, 
  isCombinacoesMode, 
  exerciciosSelecionados,
  handleToggleExercicioSelecionado,
  handleExercicioDetailChange,
  handleRemoveExercicio,
  isInGroup
}: {
  ex: ExercicioEmDiaDeTreinoDetalhado;
  index: number;
  diaAtivo: string;
  isCombinacoesMode: boolean;
  exerciciosSelecionados: number[];
  handleToggleExercicioSelecionado: (index: number) => void;
  handleExercicioDetailChange: (diaTempId: string, exIndex: number, field: keyof ExercicioEmDiaDeTreinoDetalhado, value: string) => void;
  handleRemoveExercicio: (diaTempId: string, exIndex: number) => void;
  isInGroup: boolean;
}) => {
  const isSelected = exerciciosSelecionados.includes(index);
  
  return (
    <Card className={`p-3 shadow-sm border-l-4 transition-all ${
      isSelected 
        ? 'border-l-blue-500 bg-blue-50 dark:bg-blue-900/20' 
        : isInGroup 
          ? 'border-l-blue-300 bg-white dark:bg-slate-800/60'
          : 'border-l-primary/50 bg-white dark:bg-slate-800/60'
    }`}>
      <div className="flex justify-between items-start mb-2">
        <div className="flex items-center gap-2 flex-1">
          {isCombinacoesMode && !isInGroup && (
            <Button
              variant="ghost"
              size="icon"
              className="h-6 w-6 shrink-0"
              onClick={() => handleToggleExercicioSelecionado(index)}
            >
              {isSelected ? 
                <CheckSquare className="h-4 w-4 text-blue-600" /> : 
                <Square className="h-4 w-4 text-gray-400" />
              }
            </Button>
          )}
          <p className="font-medium text-sm">{(typeof ex.exercicioId === 'object' && ex.exercicioId.nome) || 'Exercício'}</p>
        </div>
        <Button 
          variant="ghost" 
          size="icon" 
          className="h-6 w-6 text-destructive/70 hover:text-destructive shrink-0" 
          onClick={() => handleRemoveExercicio(diaAtivo, index)}
        >
          <XCircle className="w-4 h-4" />
        </Button>
      </div>
      <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
        <Input 
          placeholder="Séries" 
          value={ex.series || ''} 
          onChange={e => handleExercicioDetailChange(diaAtivo, index, 'series', e.target.value)} 
        />
        <Input 
          placeholder="Reps" 
          value={ex.repeticoes || ''} 
          onChange={e => handleExercicioDetailChange(diaAtivo, index, 'repeticoes', e.target.value)} 
        />
        <Input 
          placeholder="Carga" 
          value={ex.carga || ''} 
          onChange={e => handleExercicioDetailChange(diaAtivo, index, 'carga', e.target.value)} 
        />
        <Input 
          placeholder="Descanso" 
          value={ex.descanso || ''} 
          onChange={e => handleExercicioDetailChange(diaAtivo, index, 'descanso', e.target.value)} 
        />
      </div>
      <Textarea 
        placeholder="Observações..." 
        value={ex.observacoes || ''} 
        onChange={e => handleExercicioDetailChange(diaAtivo, index, 'observacoes', e.target.value)} 
        className="mt-2 text-xs" 
        rows={1} 
      />
    </Card>
  );
};

export default function RotinaFormModal({ open, onClose, onSuccess, alunos: alunosProp, rotinaParaEditar }: RotinaFormModalProps) {
  const [step, setStep] = useState(1);
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const isEditing = !!rotinaParaEditar?._id;

  // Form persistence hooks
  const step1Form = useFormPersistence({
    formKey: 'rotina_step1',
    initialValues: { titulo: '', descricao: null, tipo: 'modelo', alunoId: null },
    enabled: open && !isEditing // Only persist for new rotinas, not edits
  });

  const step2Form = useFormPersistence({
    formKey: 'rotina_step2', 
    initialValues: { tipoOrganizacaoRotina: 'numerico' as TipoOrganizacaoRotinaBackend },
    enabled: open && !isEditing
  });

  // For editing mode, use separate state to manage form data
  const [editingFormData, setEditingFormData] = useState<Step1Data>({
    titulo: '',
    descricao: null,
    tipo: 'modelo',
    alunoId: null
  });

  const [editingStep2Data, setEditingStep2Data] = useState<{ tipoOrganizacaoRotina: TipoOrganizacaoRotinaBackend }>({
    tipoOrganizacaoRotina: 'numerico'
  });

  const [diasDeTreino, setDiasDeTreino] = useState<DiaDeTreinoState[]>([]);
  const [showDiaForm, setShowDiaForm] = useState(false);
  const [editingDiaTempId, setEditingDiaTempId] = useState<string | null>(null);

  const diaForm = useFormPersistence({
    formKey: 'rotina_dia_form',
    initialValues: { identificadorDia: '', nomeSubFicha: null },
    enabled: open && showDiaForm && !isEditing
  });

  const [isSelectExerciseModalOpen, setIsSelectExerciseModalOpen] = useState(false);
  const [diaAtivo, setDiaAtivo] = useState<string | null>(null);
  
  // Estados para funcionalidade de conjugação de exercícios
  const [isCombinacoesMode, setIsCombinacoesMode] = useState(false);
  const [exerciciosSelecionados, setExerciciosSelecionados] = useState<number[]>([]);

  // Enhanced close handler that clears form persistence
  const handleClose = () => {
    // Clear form persistence when modal is closed (cancelled)
    if (!isEditing) {
      step1Form.clearPersistence();
      step2Form.clearPersistence();
      diaForm.clearPersistence();
      localStorage.removeItem('rotina_current_step');
      localStorage.removeItem('rotina_dias_treino');
    }
    onClose();
  };

  // Get current form values
  const step1Data = isEditing ? editingFormData : step1Form.values;
  const step2Data = isEditing ? editingStep2Data : step2Form.values;

  const diaFormValues = diaForm.values;

  useEffect(() => {
    if (open) {
      if (isEditing && rotinaParaEditar) {
        // When editing, load data from props and don't use persistence
        setEditingFormData({
          titulo: rotinaParaEditar?.titulo || '', 
          descricao: rotinaParaEditar?.descricao || null, 
          tipo: rotinaParaEditar?.tipo || 'modelo', 
          alunoId: typeof rotinaParaEditar?.alunoId === 'object' && rotinaParaEditar?.alunoId !== null ? 
            rotinaParaEditar.alunoId._id : rotinaParaEditar?.alunoId as string | null 
        });

        setEditingStep2Data({
          tipoOrganizacaoRotina: rotinaParaEditar?.tipoOrganizacaoRotina || 'numerico' 
        });

        const diasEdit = (rotinaParaEditar.diasDeTreino || []).map((dia, i) => ({ 
            ...dia, 
            tempId: dia._id || `edit-dia-${i}-${Date.now()}`, 
            exerciciosDoDia: (dia.exerciciosDoDia || [])
                .filter(ex => ex.exercicioId) // Filtra exercícios cujo exercicioId é null
                .map((ex, j) => ({ ...ex, tempIdExercicio: (ex as any)._id || `edit-ex-${i}-${j}-${Date.now()}` })) 
        } as unknown as DiaDeTreinoState));

        setDiasDeTreino(diasEdit);
        if (diasEdit.length > 0) setDiaAtivo(diasEdit[0].tempId);
      } else {
        // For new rotinas, try to restore from localStorage or use defaults
        const savedDias = localStorage.getItem('rotina_dias_treino');
        if (savedDias && !isEditing) {
          try {
            const parsedDias = JSON.parse(savedDias);
            setDiasDeTreino(parsedDias);
            if (parsedDias.length > 0) setDiaAtivo(parsedDias[0].tempId);
          } catch (error) {
            localStorage.removeItem('rotina_dias_treino');
            setDiasDeTreino([]);
            setDiaAtivo(null);
          }
        } else {
          setDiasDeTreino([]);
          setDiaAtivo(null);
        }
      }
      
      // Restore step from localStorage if available (and not editing)
      if (!isEditing) {
        const savedStep = localStorage.getItem('rotina_current_step');
        if (savedStep) {
          setStep(parseInt(savedStep) || 1);
        } else {
          setStep(1);
        }
      } else {
        setStep(1);
      }
      
      setShowDiaForm(false); 
      setEditingDiaTempId(null);
      
      // Reset combination state
      setIsCombinacoesMode(false);
      setExerciciosSelecionados([]);
    }
  }, [open, isEditing, rotinaParaEditar]);

  // Save current step to localStorage
  useEffect(() => {
    if (open && !isEditing) {
      localStorage.setItem('rotina_current_step', step.toString());
    }
  }, [step, open, isEditing]);

  // Save dias de treino to localStorage
  useEffect(() => {
    if (open && !isEditing && diasDeTreino.length > 0) {
      localStorage.setItem('rotina_dias_treino', JSON.stringify(diasDeTreino));
    }
  }, [diasDeTreino, open, isEditing]);

  const { data: alunosFetched = [], isLoading: isLoadingAlunos } = useQuery<Aluno[]>({ 
    queryKey: ["/api/aluno/gerenciar"], 
    queryFn: () => apiRequest<Aluno[]>("GET", "/api/aluno/gerenciar"), 
    enabled: open && step1Data.tipo === 'individual', 
    initialData: alunosProp 
  });

  // Helper functions for updating editing form data
  const updateEditingStep1Field = (field: keyof Step1Data, value: any) => {
    if (isEditing) {
      setEditingFormData(prev => ({ ...prev, [field]: value }));
    } else {
      step1Form.updateField(field, value);
    }
  };

  const updateEditingStep1Fields = (fields: Partial<Step1Data>) => {
    if (isEditing) {
      setEditingFormData(prev => ({ ...prev, ...fields }));
    } else {
      step1Form.updateFields(fields);
    }
  };

  const updateEditingStep2Field = (field: keyof typeof editingStep2Data, value: any) => {
    if (isEditing) {
      setEditingStep2Data(prev => ({ ...prev, [field]: value }));
    } else {
      step2Form.updateField(field, value);
    }
  };


  const nextStep = () => {
    if (step === 1 && !step1Data.titulo.trim()) { toast({ variant: "destructive", title: "Campo obrigatório", description: "O título da rotina é obrigatório." }); return; }
    if (step === 1 && step1Data.tipo === 'individual' && !step1Data.alunoId) { toast({ variant: "destructive", title: "Campo obrigatório", description: "Selecione um aluno." }); return; }
    if (step === 2 && diasDeTreino.length === 0) { toast({ variant: "destructive", title: "Atenção", description: "Adicione pelo menos um dia de treino." }); return; }
    if (step === 2 && diasDeTreino.length > 0 && !diaAtivo) setDiaAtivo(diasDeTreino[0].tempId);
    setStep(s => Math.min(s + 1, 3));
  };
  const prevStep = () => setStep(s => Math.max(s - 1, 1));
  
  const mutation = useMutation<RotinaListagemItem, Error, any>({
    mutationFn: (payload) => apiRequest(isEditing ? "PUT" : "POST", isEditing ? `/api/treinos/${rotinaParaEditar?._id}` : "/api/treinos", payload),
    onSuccess: (savedRotina) => {
        toast({ title: "Sucesso!", description: `Rotina "${savedRotina.titulo}" salva.` });
        queryClient.invalidateQueries({ queryKey: ["/api/treinos"] });
        
        // Clear persisted form data on successful save
        if (!isEditing) {
          step1Form.clearPersistence();
          step2Form.clearPersistence();
          diaForm.clearPersistence();
          localStorage.removeItem('rotina_current_step');
          localStorage.removeItem('rotina_dias_treino');
        }
        
        onSuccess(savedRotina); 
        onClose();
    },
    onError: (error) => toast({ variant: "destructive", title: "Erro ao Salvar", description: error.message }),
  });

  const handleFinalSubmit = () => {
    const payload = {
        ...step1Data,
        ...step2Data,
        diasDeTreino: diasDeTreino.map(dia => ({
            _id: dia._id, identificadorDia: dia.identificadorDia, nomeSubFicha: dia.nomeSubFicha, ordemNaRotina: dia.ordemNaRotina,
            exerciciosDoDia: dia.exerciciosDoDia.map(ex => ({
                _id: (ex as any)._idSubDocExercicio,
                exercicioId: typeof ex.exercicioId === 'object' ? ex.exercicioId._id : ex.exercicioId,
                series: ex.series, repeticoes: ex.repeticoes, carga: ex.carga, descanso: ex.descanso, observacoes: ex.observacoes, ordemNoDia: ex.ordemNoDia,
                grupoCombinado: ex.grupoCombinado
            }))
        }))
    };
    console.log("Payload enviado:", payload); // Log para depuração
    mutation.mutate(payload);
  };
  
  const handleAddOrUpdateDia = () => { 
    if (!diaFormValues.identificadorDia.trim()) { 
      toast({ variant: "destructive", title: "Erro", description: "O identificador do dia é obrigatório." }); 
      return; 
    } 
    const diaJaExiste = diasDeTreino.some(dia => dia.identificadorDia.toLowerCase() === diaFormValues.identificadorDia.toLowerCase() && dia.tempId !== editingDiaTempId); 
    if (diaJaExiste) { 
      toast({ variant: "destructive", title: "Erro", description: `O identificador "${diaFormValues.identificadorDia}" já foi usado.` }); 
      return; 
    } 
    setDiasDeTreino(prev => { 
      let novosDias = [...prev]; 
      if (editingDiaTempId) { 
        novosDias = novosDias.map(d => d.tempId === editingDiaTempId ? {...d, ...diaFormValues, nomeSubFicha: diaFormValues.nomeSubFicha || null} : d); 
      } else { 
        novosDias.push({ ...diaFormValues, nomeSubFicha: diaFormValues.nomeSubFicha || null, tempId: `new-${Date.now()}`, ordemNaRotina: prev.length, exerciciosDoDia: [] }); 
      } 
      return novosDias; 
    }); 
    setShowDiaForm(false); 
    setEditingDiaTempId(null); 
    diaForm.resetForm();
  };
  
  const handleEditDia = (dia: DiaDeTreinoState) => { 
    diaForm.updateFields({ identificadorDia: dia.identificadorDia, nomeSubFicha: dia.nomeSubFicha || null }); 
    setEditingDiaTempId(dia.tempId); 
    setShowDiaForm(true); 
  };
  
  const handleRemoveDia = (tempId: string) => { 
    setDiasDeTreino(prev => prev.filter(d => d.tempId !== tempId).map((d, i) => ({...d, ordemNaRotina: i}))); 
  };
  
  const handleShowDiaForm = () => { 
    setEditingDiaTempId(null); 
    diaForm.resetForm(); 
    setShowDiaForm(true); 
  };
  const handleOpenSelectExerciseModal = (diaTempId: string) => { setDiaAtivo(diaTempId); setIsSelectExerciseModalOpen(true); };
  const handleExercisesSelected = (selecionados: BibliotecaExercicio[]) => { if (!diaAtivo) return; setDiasDeTreino(prev => prev.map(dia => { if (dia.tempId === diaAtivo) { const novosExercicios = selecionados.map((ex, i) => ({ _id: `new-ex-${Date.now()}-${i}`, exercicioId: { _id: ex._id, nome: ex.nome, grupoMuscular: ex.grupoMuscular, categoria: ex.categoria }, ordemNoDia: (dia.exerciciosDoDia?.length || 0) + i, } as unknown as ExercicioEmDiaDeTreinoDetalhado)); return { ...dia, exerciciosDoDia: [...(dia.exerciciosDoDia || []), ...novosExercicios] }; } return dia; })); setIsSelectExerciseModalOpen(false); };
  const handleExercicioDetailChange = (diaTempId: string, exIndex: number, field: keyof ExercicioEmDiaDeTreinoDetalhado, value: string) => { setDiasDeTreino(prev => prev.map(dia => { if (dia.tempId === diaTempId) { const exerciciosAtualizados = [...dia.exerciciosDoDia]; (exerciciosAtualizados[exIndex] as any)[field] = value; return { ...dia, exerciciosDoDia: exerciciosAtualizados }; } return dia; })); };
  const handleRemoveExercicio = (diaTempId: string, exIndex: number) => { setDiasDeTreino(prev => prev.map(dia => { if (dia.tempId === diaTempId) { const exerciciosAtualizados = dia.exerciciosDoDia.filter((_, index) => index !== exIndex); return { ...dia, exerciciosDoDia: exerciciosAtualizados.map((ex, i) => ({ ...ex, ordemNoDia: i })) }; } return dia; })); };
  
  // Funções para conjugação de exercícios
  const handleToggleCombinacaoMode = () => {
    setIsCombinacoesMode(!isCombinacoesMode);
    setExerciciosSelecionados([]);
  };

  const handleToggleExercicioSelecionado = (exIndex: number) => {
    setExerciciosSelecionados(prev => 
      prev.includes(exIndex) 
        ? prev.filter(idx => idx !== exIndex)
        : [...prev, exIndex]
    );
  };

  const handleConjugarExercicios = () => {
    if (!diaAtivo || exerciciosSelecionados.length < 2) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Selecione pelo menos 2 exercícios para conjugar."
      });
      return;
    }

    const grupoCombinado = `grupo-${Date.now()}`;
    
    setDiasDeTreino(prev => prev.map(dia => {
      if (dia.tempId === diaAtivo) {
        const exerciciosAtualizados = dia.exerciciosDoDia.map((ex, index) => {
          if (exerciciosSelecionados.includes(index)) {
            return { ...ex, grupoCombinado };
          }
          return ex;
        });
        return { ...dia, exerciciosDoDia: exerciciosAtualizados };
      }
      return dia;
    }));

    setExerciciosSelecionados([]);
    setIsCombinacoesMode(false);
    
    toast({
      title: "Sucesso!",
      description: `${exerciciosSelecionados.length} exercícios conjugados com sucesso.`
    });
  };

  const handleDesconjugarExercicios = (grupoCombinado: string) => {
    if (!diaAtivo) return;

    setDiasDeTreino(prev => prev.map(dia => {
      if (dia.tempId === diaAtivo) {
        const exerciciosAtualizados = dia.exerciciosDoDia.map(ex => {
          if (ex.grupoCombinado === grupoCombinado) {
            const { grupoCombinado: _, ...exercicioSemGrupo } = ex;
            return exercicioSemGrupo;
          }
          return ex;
        });
        return { ...dia, exerciciosDoDia: exerciciosAtualizados };
      }
      return dia;
    }));

    toast({
      title: "Sucesso!",
      description: "Exercícios desconjugados com sucesso."
    });
  };
  
  const diasDaSemanaUtilizados = useMemo(() => diasDeTreino.map(d => d.identificadorDia), [diasDeTreino]);

  return (
    <Dialog open={open} onOpenChange={(open) => { if (!open) handleClose(); }}>
      {/* Ajustes para responsividade: sm:max-w-4xl agora é w-[95vw] h-[90vh] para mobile, e flex-col para empilhar conteúdo */}
      <DialogContent className="sm:max-w-4xl w-[95vw] h-[90vh] flex flex-col p-0">
        <DialogHeader className="p-6 pb-4 border-b shrink-0">
          <DialogTitle>{isEditing ? "Editar Rotina" : "Nova Rotina"}</DialogTitle>
          <DialogDescription>Siga os passos para configurar a rotina de treino.</DialogDescription>
        </DialogHeader>
        <div className="flex-grow overflow-y-auto p-6">
          <Stepper currentStep={step} />
          {step === 1 && <div className="space-y-4 animate-in fade-in-50">
              <div><Label className="font-semibold">Título da Rotina*</Label><Input value={step1Data.titulo} onChange={e => updateEditingStep1Field('titulo', e.target.value)} /></div>
              <div><Label className="font-semibold">Descrição (Opcional)</Label><Textarea value={step1Data.descricao || ''} onChange={e => updateEditingStep1Field('descricao', e.target.value)} /></div>
              <div><Label className="font-semibold">Tipo de Rotina</Label><Select value={step1Data.tipo} onValueChange={(v: any) => updateEditingStep1Fields({tipo: v, alunoId: null})} disabled={isEditing}><SelectTrigger><SelectValue/></SelectTrigger><SelectContent><SelectItem value="modelo">Modelo</SelectItem><SelectItem value="individual">Individual</SelectItem></SelectContent></Select></div>
              {step1Data.tipo === 'individual' && (<div><Label className="font-semibold">Aluno*</Label><Select value={step1Data.alunoId || ''} onValueChange={(v) => updateEditingStep1Field('alunoId', v)} disabled={isEditing}><SelectTrigger>{isLoadingAlunos ? <span className="text-muted-foreground">Carregando alunos...</span> : <SelectValue placeholder="Selecione um aluno..."/>}</SelectTrigger><SelectContent>{alunosFetched.map(aluno => <SelectItem key={aluno._id} value={aluno._id}>{aluno.nome}</SelectItem>)}</SelectContent></Select></div>)}
          </div>}
          {step === 2 && <div className="space-y-6 animate-in fade-in-50">
             <div><Label className="font-semibold">Organização dos Dias*</Label><Select value={step2Data.tipoOrganizacaoRotina} onValueChange={(v:any) => updateEditingStep2Field('tipoOrganizacaoRotina', v)}><SelectTrigger><SelectValue/></SelectTrigger><SelectContent>{OPCOES_TIPO_DOS_TREINOS.map(opt => <SelectItem key={opt.value} value={opt.value}>{opt.label}</SelectItem>)}</SelectContent></Select></div>
             <div className="space-y-2">{diasDeTreino.map(dia => (<Card key={dia.tempId} className="flex items-center justify-between p-3 bg-slate-50 dark:bg-slate-800 border-l-4 border-l-primary"><div><p className="font-medium">{dia.identificadorDia}</p>{dia.nomeSubFicha && <p className="text-xs text-muted-foreground">{dia.nomeSubFicha}</p>}</div><div className="flex items-center gap-1"><Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => handleEditDia(dia)}><Edit className="h-4 w-4 text-slate-500"/></Button><Button variant="ghost" size="icon" className="h-7 w-7 text-red-500" onClick={() => handleRemoveDia(dia.tempId)}><Trash2 className="h-4 w-4"/></Button></div></Card>))}</div>
             {showDiaForm && (<Card className="p-4 border-dashed"><CardContent className="p-0 space-y-4"><h4 className="font-medium text-sm">{editingDiaTempId ? 'Editando Dia' : 'Novo Dia de Treino'}</h4><div><Label>Identificador do Dia*</Label>{step2Data.tipoOrganizacaoRotina === 'diasDaSemana' ? (<Select value={diaFormValues.identificadorDia} onValueChange={(v) => diaForm.updateField('identificadorDia', v)}><SelectTrigger><SelectValue placeholder="Selecione um dia..." /></SelectTrigger><SelectContent>{diasDaSemanaOptions.map(opt => <SelectItem key={opt} value={opt} disabled={diasDaSemanaUtilizados.includes(opt)}>{opt}</SelectItem>)}</SelectContent></Select>) : (<Input value={diaFormValues.identificadorDia} onChange={e => diaForm.updateField('identificadorDia', e.target.value)} placeholder={step2Data.tipoOrganizacaoRotina === 'numerico' ? `Ex: Treino ${diasDeTreino.length + 1}` : 'Ex: Peito & Tríceps'} />)}</div><div><Label>Nome Específico (Opcional)</Label><Input value={diaFormValues.nomeSubFicha || ''} onChange={e => diaForm.updateField('nomeSubFicha', e.target.value)} placeholder="Ex: Foco em Força" /></div><div className="flex justify-end gap-2 pt-2"><Button variant="ghost" onClick={() => {setShowDiaForm(false); setEditingDiaTempId(null); diaForm.resetForm();}}>Cancelar</Button><Button onClick={handleAddOrUpdateDia}>{editingDiaTempId ? 'Atualizar' : 'Adicionar'}</Button></div></CardContent></Card>)}
             {!showDiaForm && (<Button variant="outline" className="w-full border-dashed border-primary text-primary hover:text-primary hover:bg-primary/5" onClick={handleShowDiaForm}><PlusCircle className="mr-2 h-4 w-4"/> Adicionar Dia de Treino</Button>)}
          </div>}
          {step === 3 && (
            <div className="flex flex-col md:flex-row h-full max-h-full overflow-hidden"> {/* Alterado para flex-col em mobile e md:flex-row em desktop */}
              <div className="md:col-span-1 border-b md:border-b-0 md:border-r dark:border-slate-800 bg-slate-50 dark:bg-slate-900/50 p-4 overflow-y-auto w-full md:w-1/3 lg:w-1/4 shrink-0"> {/* Ajustes de largura e borda para mobile/desktop */}
                <h3 className="font-semibold mb-3">Dias de Treino</h3>
                <div className="space-y-2">
                  {diasDeTreino.map(dia => (
                    <Button
                      key={dia.tempId}
                      variant={diaAtivo === dia.tempId ? 'secondary' : 'ghost'}
                      className="w-full justify-start text-left h-auto py-2"
                      onClick={() => setDiaAtivo(dia.tempId)}
                    >
                      <span className="flex flex-col">
                        <span>{dia.identificadorDia}</span>
                        {dia.nomeSubFicha && <span className="text-xs font-normal opacity-70">{dia.nomeSubFicha}</span>}
                      </span>
                    </Button>
                  ))}
                </div>
              </div>
              <div className="md:col-span-2 p-4 overflow-y-auto flex-grow"> {/* flex-grow para ocupar o espaço restante */}
                {diaAtivo && diasDeTreino.find(d => d.tempId === diaAtivo) ? (
                  <div className="space-y-4">
                    <div className="flex justify-between items-center">
                      <h3 className="font-semibold">Exercícios do Dia: {diasDeTreino.find(d => d.tempId === diaAtivo)?.identificadorDia}</h3>
                      {(diasDeTreino.find(d => d.tempId === diaAtivo)?.exerciciosDoDia || []).length > 0 && (
                        <div className="flex gap-2">
                          {isCombinacoesMode && exerciciosSelecionados.length > 1 && (
                            <Button 
                              size="sm" 
                              onClick={handleConjugarExercicios}
                              className="bg-green-600 hover:bg-green-700"
                            >
                              <Link2 className="mr-2 h-4 w-4" />
                              Conjugar ({exerciciosSelecionados.length})
                            </Button>
                          )}
                          <Button 
                            variant={isCombinacoesMode ? "default" : "outline"}
                            size="sm" 
                            onClick={handleToggleCombinacaoMode}
                            disabled={(diasDeTreino.find(d => d.tempId === diaAtivo)?.exerciciosDoDia || []).length < 2 && !isCombinacoesMode}
                          >
                            <Link2 className="mr-2 h-4 w-4" />
                            {isCombinacoesMode ? "Cancelar" : "Conjugar Exercícios"}
                          </Button>
                        </div>
                      )}
                    </div>
                    
                    {/* Renderização dos exercícios com agrupamento visual */}
                    {(() => {
                      const exerciciosDoDia = diasDeTreino.find(d => d.tempId === diaAtivo)?.exerciciosDoDia || [];
                      const grupos: { [key: string]: { exercicios: typeof exerciciosDoDia, indices: number[] } } = {};
                      const exerciciosSemGrupo: { exercicio: typeof exerciciosDoDia[0], index: number }[] = [];
                      
                      exerciciosDoDia.forEach((ex, index) => {
                        if (ex.grupoCombinado) {
                          if (!grupos[ex.grupoCombinado]) {
                            grupos[ex.grupoCombinado] = { exercicios: [], indices: [] };
                          }
                          grupos[ex.grupoCombinado].exercicios.push(ex);
                          grupos[ex.grupoCombinado].indices.push(index);
                        } else {
                          exerciciosSemGrupo.push({ exercicio: ex, index });
                        }
                      });

                      return (
                        <div className="space-y-4">
                          {/* Exercícios agrupados */}
                          {Object.entries(grupos).map(([grupoId, grupo]) => (
                            <div key={grupoId} className="border-2 border-blue-200 dark:border-blue-800 rounded-lg p-3 bg-blue-50/50 dark:bg-blue-900/10">
                              <div className="flex justify-between items-center mb-3">
                                <div className="flex items-center gap-2">
                                  <Link2 className="h-4 w-4 text-blue-600" />
                                  <span className="text-sm font-medium text-blue-700 dark:text-blue-300">
                                    Exercícios Conjugados ({grupo.exercicios.length})
                                  </span>
                                </div>
                                <Button 
                                  variant="ghost" 
                                  size="sm" 
                                  onClick={() => handleDesconjugarExercicios(grupoId)}
                                  className="text-red-500 hover:text-red-700 hover:bg-red-50"
                                >
                                  <XCircle className="h-4 w-4" />
                                </Button>
                              </div>
                              <div className="space-y-3">
                                {grupo.exercicios.map((ex, grupoIndex) => {
                                  const originalIndex = grupo.indices[grupoIndex];
                                  return (
                                    <ExerciseCard 
                                      key={(ex as any)._id || (ex as any).tempIdExercicio || originalIndex}
                                      ex={ex}
                                      index={originalIndex}
                                      diaAtivo={diaAtivo}
                                      isCombinacoesMode={isCombinacoesMode}
                                      exerciciosSelecionados={exerciciosSelecionados}
                                      handleToggleExercicioSelecionado={handleToggleExercicioSelecionado}
                                      handleExercicioDetailChange={handleExercicioDetailChange}
                                      handleRemoveExercicio={handleRemoveExercicio}
                                      isInGroup={true}
                                    />
                                  );
                                })}
                              </div>
                            </div>
                          ))}
                          
                          {/* Exercícios individuais */}
                          {exerciciosSemGrupo.map(({ exercicio: ex, index }) => {
                            if (!ex.exercicioId) {
                              return (
                                <Card key={index} className="p-3 bg-red-50 dark:bg-red-900/30 border-l-4 border-red-500">
                                  <p className="text-red-600 dark:text-red-400 text-sm flex items-center">
                                    <AlertTriangle className="h-4 w-4 mr-2" />
                                    Este exercício foi removido e não pode ser editado.
                                  </p>
                                </Card>
                              );
                            }
                            return (
                              <ExerciseCard 
                                key={(ex as any)._id || (ex as any).tempIdExercicio || index}
                                ex={ex}
                                index={index}
                                diaAtivo={diaAtivo}
                                isCombinacoesMode={isCombinacoesMode}
                                exerciciosSelecionados={exerciciosSelecionados}
                                handleToggleExercicioSelecionado={handleToggleExercicioSelecionado}
                                handleExercicioDetailChange={handleExercicioDetailChange}
                                handleRemoveExercicio={handleRemoveExercicio}
                                isInGroup={false}
                              />
                            );
                          })}
                        </div>
                      );
                    })()}
                    
                    <Button variant="outline" className="w-full border-dashed" onClick={() => handleOpenSelectExerciseModal(diaAtivo)}>
                      <ListPlus className="mr-2 h-4 w-4" />Adicionar Exercício
                    </Button>
                  </div>
                ) : (
                  <div className="text-center text-muted-foreground pt-20 flex flex-col items-center">
                    <p className="font-semibold">Nenhum dia selecionado</p>
                    <p className="text-sm">Selecione um dia de treino à esquerda.</p>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
        <DialogFooter className="p-4 border-t flex justify-between shrink-0">
          <div className="flex gap-2">
            {step > 1 && <Button variant="outline" onClick={prevStep}><ArrowLeft className="mr-2 h-4 w-4"/> Voltar</Button>}
            <Button variant="ghost" onClick={handleClose}>
              Cancelar
            </Button>
          </div>
          <div>
            {step < 3 && <Button onClick={nextStep} disabled={step === 2 && diasDeTreino.length === 0}>Próximo <ArrowRight className="ml-2 h-4 w-4"/></Button>}
            {step === 3 && <Button onClick={handleFinalSubmit} disabled={mutation.isPending}>{mutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />} {isEditing ? "Salvar Alterações" : "Criar Rotina"}</Button>}
          </div>
        </DialogFooter>
      </DialogContent>
      {isSelectExerciseModalOpen && <SelectExerciseModal isOpen={isSelectExerciseModalOpen} onClose={() => setIsSelectExerciseModalOpen(false)} onExercisesSelect={handleExercisesSelected} />}
    </Dialog>
  );
}

===== ./client/src/components/dialogs/RotinaViewModal.tsx =====
// client/src/components/dialogs/RotinaViewModal.tsx
import React from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Dumbbell, Edit, CopyPlus, User, Folder, Info, Clock, PlayCircle, BookCopy } from 'lucide-react'; // Importado BookCopy
import type { RotinaListagemItem } from '@/types/treinoOuRotinaTypes';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

interface RotinaViewModalProps {
  isOpen: boolean;
  onClose: () => void;
  rotina: RotinaListagemItem | null;
  onEdit: (rotina: RotinaListagemItem) => void;
  onAssign: (rotinaId: string, rotinaTitulo: string) => void;
  onPlayVideo: (url: string) => void;
  onConvertToModel: (rotina: RotinaListagemItem) => void; // Nova prop para converter para modelo
}

const formatDate = (dateString?: string | Date) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });
    } catch {
        return 'Data inválida';
    }
};

const RotinaViewModal: React.FC<RotinaViewModalProps> = ({ isOpen, onClose, rotina, onEdit, onAssign, onPlayVideo, onConvertToModel }) => {
  if (!isOpen || !rotina) return null;

  const isModelo = rotina.tipo === 'modelo';
  const alunoNome = typeof rotina.alunoId === 'object' && rotina.alunoId?.nome ? rotina.alunoId.nome : 'N/A';

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-3xl w-[95vw] h-[90vh] flex flex-col p-0">
        <DialogHeader className="p-6 pb-4 border-b">
          <DialogTitle className="text-2xl font-bold flex items-center gap-3">
            <Dumbbell className="h-7 w-7 text-primary" />
            {rotina.titulo}
          </DialogTitle>
          <DialogDescription>{rotina.descricao || "Visualização detalhada da rotina de treino."}</DialogDescription>
        </DialogHeader>

        <div className="flex-grow p-6 overflow-y-auto">
          <Card className="mb-6 bg-slate-50 dark:bg-slate-800/50">
            <CardHeader>
              <CardTitle className="text-lg flex items-center"><Info className="h-5 w-5 mr-2"/>Informações Gerais</CardTitle>
            </CardHeader>
            <CardContent className="grid grid-cols-1 sm:grid-cols-2 gap-x-4 gap-y-2 text-sm">
              <div className="flex items-center gap-2">
                {/* <<< CORREÇÃO 2: Ajuste de cor e estilo da Badge "Individual" >>> */}
                <Badge variant={isModelo ? 'outline' : 'default'} className={
                  isModelo 
                    ? "border-purple-400 text-purple-600 dark:border-purple-600 dark:text-purple-400" 
                    : "bg-teal-100 text-teal-800 border-transparent hover:bg-teal-100/80 dark:bg-teal-900/50 dark:text-teal-300"
                }>
                  {isModelo ? <Folder className="h-3 w-3 mr-1.5"/> : <User className="h-3 w-3 mr-1.5"/>}
                  {isModelo ? 'Modelo' : 'Individual'}
                </Badge>
                {/* Nova etiqueta "Rotina Copiada" visível apenas para o personal */}
                {rotina.isCopied && (
                  <Badge variant="secondary" className="bg-blue-100 text-blue-800 border-transparent dark:bg-blue-900/50 dark:text-blue-300">
                    Rotina Copiada
                  </Badge>
                )}
              </div>
              {!isModelo && <div className="font-medium"><strong>Aluno:</strong> {alunoNome}</div>}
              <div><strong>Dias de Treino:</strong> {rotina.diasDeTreino?.length || 0}</div>
              <div className="flex items-center gap-2 text-slate-600 dark:text-slate-400">
                <Clock className="h-4 w-4"/>
                <span>Criada em: {formatDate(rotina.criadoEm)}</span>
              </div>
              {rotina.atualizadoEm && new Date(rotina.criadoEm || 0).getTime() !== new Date(rotina.atualizadoEm).getTime() && (
                <div className="flex items-center gap-2 text-slate-600 dark:text-slate-400">
                    <Clock className="h-4 w-4"/>
                    <span>Atualizada em: {formatDate(rotina.atualizadoEm)}</span>
                </div>
              )}
            </CardContent>
          </Card>

          <Accordion type="multiple" className="w-full space-y-3">
            {(rotina.diasDeTreino || []).sort((a,b) => a.ordemNaRotina - b.ordemNaRotina).map(dia => (
              <AccordionItem key={dia._id} value={dia._id || dia.identificadorDia} className="border dark:border-slate-700 rounded-lg overflow-hidden">
                <AccordionTrigger className="px-4 py-3 bg-slate-100 dark:bg-slate-800 hover:no-underline font-semibold">
                  {dia.identificadorDia} {dia.nomeSubFicha && <span className="font-normal text-muted-foreground ml-2">- {dia.nomeSubFicha}</span>}
                </AccordionTrigger>
                <AccordionContent className="p-0">
                  {dia.exerciciosDoDia && dia.exerciciosDoDia.length > 0 ? (
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead className="pl-4">Exercício</TableHead>
                          <TableHead className="text-center w-[70px]">Séries</TableHead>
                          <TableHead className="text-center w-[70px]">Reps</TableHead>
                          <TableHead>Carga</TableHead>
                          <TableHead className="pr-4">Descanso</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {/* <<< CORREÇÃO 1: Adicionado .filter() para remover exercícios nulos da visualização >>> */}
                        {(dia.exerciciosDoDia || []).filter(ex => ex.exercicioId).sort((a,b) => a.ordemNoDia - b.ordemNoDia).map(ex => {
                            const exercicioDetalhes = typeof ex.exercicioId === 'object' ? ex.exercicioId : null;
                            return (
                                <TableRow key={ex._id}>
                                    <TableCell className="font-medium pl-4 flex items-center gap-2">
                                        {exercicioDetalhes?.nome}
                                        {exercicioDetalhes?.urlVideo && (
                                            <TooltipProvider delayDuration={100}>
                                                <Tooltip>
                                                    <TooltipTrigger asChild>
                                                        <Button variant="ghost" size="icon" className="h-6 w-6" onClick={() => onPlayVideo(exercicioDetalhes.urlVideo!)}>
                                                            <PlayCircle className="h-4 w-4 text-primary opacity-60 hover:opacity-100" />
                                                        </Button>
                                                    </TooltipTrigger>
                                                    <TooltipContent><p>Ver vídeo</p></TooltipContent>
                                                </Tooltip>
                                            </TooltipProvider>
                                        )}
                                    </TableCell>
                                    <TableCell className="text-center">{ex.series || '-'}</TableCell>
                                    <TableCell className="text-center">{ex.repeticoes || '-'}</TableCell>
                                    <TableCell>{ex.carga || '-'}</TableCell>
                                    <TableCell className="pr-4">{ex.descanso || '-'}</TableCell>
                                </TableRow>
                            );
                        })}
                      </TableBody>
                    </Table>
                  ) : (
                    <div className="text-center text-sm text-muted-foreground p-4">
                      Nenhum exercício cadastrado para este dia.
                    </div>
                  )}
                </AccordionContent>
              </AccordionItem>
            ))}
          </Accordion>
        </div>

        <DialogFooter className="p-4 border-t flex-wrap justify-end gap-2">
          {isModelo && <Button onClick={() => onAssign(rotina._id, rotina.titulo)} className="bg-green-600 hover:bg-green-700"><CopyPlus className="w-4 h-4 mr-2"/>Usar este Modelo</Button>}
          {/* Novo botão "Tornar Modelo" para rotinas individuais */}
          {!isModelo && (
            <Button 
              onClick={() => onConvertToModel(rotina)} 
              className="bg-blue-600 hover:bg-blue-700 text-white" // Estilo para destacar
            >
              <BookCopy className="w-4 h-4 mr-2"/>Tornar Modelo
            </Button>
          )}
          <Button variant="outline" onClick={() => onEdit(rotina)}><Edit className="w-4 h-4 mr-2"/>Editar Rotina</Button>
          <Button variant="secondary" onClick={onClose}>Fechar</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default RotinaViewModal;

===== ./client/src/components/dialogs/SelectExerciseModal.tsx =====
// client/src/components/dialogs/SelectExerciseModal.tsx
import { useState, useEffect, useMemo } from 'react';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useQuery } from '@tanstack/react-query';
import { fetchWithAuth } from '@/lib/apiClient';
import { Loader2, CheckCircle, FilterX, Filter, ChevronUp, ChevronDown } from 'lucide-react';
import { useToast } from '@/hooks/use-toast'; // Importar useToast

export interface BibliotecaExercicio { _id: string; nome: string; grupoMuscular?: string; categoria?: string; isCustom?: boolean; }
interface SelectExerciseModalProps { isOpen: boolean; onClose: () => void; onExercisesSelect: (selecionados: BibliotecaExercicio[]) => void; }
type AbaBiblioteca = "todos" | "app" | "meus" | "favoritos";
const ALL_FILTER_VALUE = "all";

export default function SelectExerciseModal({ isOpen, onClose, onExercisesSelect }: SelectExerciseModalProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [abaSelecionada, setAbaSelecionada] = useState<AbaBiblioteca>("todos");
  const [exerciciosSelecionados, setExerciciosSelecionados] = useState<BibliotecaExercicio[]>([]);
  const [filterGrupoMuscular, setFilterGrupoMuscular] = useState(ALL_FILTER_VALUE);
  const [filterCategoria, setFilterCategoria] = useState(ALL_FILTER_VALUE);
  const [showFilters, setShowFilters] = useState(false); 

  const { toast } = useToast(); // Inicializar useToast

  const { data: exercicios = [], isLoading, error } = useQuery<BibliotecaExercicio[]>({
    queryKey: ["bibliotecaExercicios", abaSelecionada],
    queryFn: () => fetchWithAuth(`/api/exercicios/biblioteca?tipo=${abaSelecionada}`),
    enabled: isOpen,
    staleTime: 1000 * 60 * 5,
  });

  useEffect(() => {
    if (!isOpen) {
      setSearchTerm("");
      setAbaSelecionada("todos");
      setExerciciosSelecionados([]);
      setFilterGrupoMuscular(ALL_FILTER_VALUE);
      setFilterCategoria(ALL_FILTER_VALUE);
      setShowFilters(false); 
    } else {
      // Exibe a instrução do filtro apenas quando o modal abre
      toast({
        title: "Dica de Filtro",
        description: "Clique em 'Filtros' para expandir/recolher as opções.",
        duration: 4000, // A mensagem desaparecerá após 4 segundos
      });
    }
  }, [isOpen, toast]); // Adicionado 'toast' como dependência

  const exerciciosFiltradosEOrdenados = useMemo(() => {
    let filtered = exercicios;

    if (searchTerm) {
      filtered = filtered.filter(ex => ex.nome.toLowerCase().includes(searchTerm.toLowerCase()));
    }

    if (filterGrupoMuscular !== ALL_FILTER_VALUE) {
      filtered = filtered.filter(ex => ex.grupoMuscular === filterGrupoMuscular);
    }

    if (filterCategoria !== ALL_FILTER_VALUE) {
      filtered = filtered.filter(ex => ex.categoria === filterCategoria);
    }

    return filtered.sort((a, b) => a.nome.localeCompare(b.nome));
  }, [exercicios, searchTerm, filterGrupoMuscular, filterCategoria]);

  const handleToggleSelecaoExercicio = (exercicio: BibliotecaExercicio) => {
    setExerciciosSelecionados(prev => {
      if (prev.some(sel => sel._id === exercicio._id)) {
        return prev.filter(sel => sel._id !== exercicio._id);
      } else {
        return [...prev, exercicio];
      }
    });
  };

  const handleSubmitSelecao = () => {
    onExercisesSelect(exerciciosSelecionados);
  };

  const handleClearFilters = () => {
    setSearchTerm("");
    setFilterGrupoMuscular(ALL_FILTER_VALUE);
    setFilterCategoria(ALL_FILTER_VALUE);
  };

  // Extrai opções únicas para os filtros
  const gruposMusculares = useMemo(() => {
    const unique = new Set(exercicios.map(ex => ex.grupoMuscular).filter(Boolean) as string[]);
    return [ALL_FILTER_VALUE, ...Array.from(unique).sort()];
  }, [exercicios]);

  const categorias = useMemo(() => {
    const unique = new Set(exercicios.map(ex => ex.categoria).filter(Boolean) as string[]);
    return [ALL_FILTER_VALUE, ...Array.from(unique).sort()];
  }, [exercicios]);

  if (error) {
    return (
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="sm:max-w-lg">
          <DialogHeader>
            <DialogTitle>Erro</DialogTitle>
            <DialogDescription>Ocorreu um erro ao carregar os exercícios: {error.message}</DialogDescription>
          </DialogHeader>
          <DialogFooter><Button onClick={onClose}>Fechar</Button></DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-3xl flex flex-col h-[90vh] p-0">
        <DialogHeader className="p-6 pb-4 border-b shrink-0">
          <DialogTitle>Selecionar Exercício(s) da Biblioteca</DialogTitle>
          <DialogDescription>
            Use as abas e filtros para encontrar e selecionar os exercícios.
          </DialogDescription>
        </DialogHeader>

        <div className="p-6 flex flex-col flex-grow overflow-hidden">
          <Tabs value={abaSelecionada} onValueChange={(v) => setAbaSelecionada(v as AbaBiblioteca)} className="mb-4 shrink-0">
            <TabsList className="grid w-full grid-cols-4">
              <TabsTrigger value="todos">Todos</TabsTrigger>
              <TabsTrigger value="app">App</TabsTrigger>
              <TabsTrigger value="meus">Meus</TabsTrigger>
              <TabsTrigger value="favoritos">Favoritos</TabsTrigger>
            </TabsList>
          </Tabs>

          {/* Botão de filtro para mobile - sempre visível para expandir/recolher */}
          <div className="mb-4 shrink-0">
            <Button variant="outline" className="w-full" onClick={() => setShowFilters(!showFilters)}>
              <Filter className="mr-2 h-4 w-4" />
              Filtros
              {showFilters ? <ChevronUp className="ml-2 h-4 w-4" /> : <ChevronDown className="ml-2 h-4 w-4" />}
            </Button>
          </div>

          {/* Área de filtros - agora condicionalmente visível */}
          {showFilters && (
            <div className="space-y-3 mb-4 shrink-0">
              <Input
                placeholder="Buscar por nome..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
              <Select value={filterGrupoMuscular} onValueChange={setFilterGrupoMuscular}>
                <SelectTrigger><SelectValue placeholder="Todos os Grupos" /></SelectTrigger>
                <SelectContent>
                  {gruposMusculares.map(grupo => (
                    <SelectItem key={grupo} value={grupo}>{grupo === ALL_FILTER_VALUE ? "Todos os Grupos" : grupo}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <Select value={filterCategoria} onValueChange={setFilterCategoria}>
                <SelectTrigger><SelectValue placeholder="Todas as Categorias" /></SelectTrigger>
                <SelectContent>
                  {categorias.map(categoria => (
                    <SelectItem key={categoria} value={categoria}>{categoria === ALL_FILTER_VALUE ? "Todas as Categorias" : categoria}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
              {(searchTerm || filterGrupoMuscular !== ALL_FILTER_VALUE || filterCategoria !== ALL_FILTER_VALUE) && (
                <Button variant="ghost" onClick={handleClearFilters} className="w-full text-red-500 hover:text-red-600">
                  <FilterX className="mr-2 h-4 w-4" />
                  Limpar Filtros
                </Button>
              )}
            </div>
          )}

          <ScrollArea className="flex-grow pr-4 -mr-4">
            {isLoading
              ? <div className="flex justify-center items-center py-10"><Loader2 className="h-8 w-8 animate-spin text-primary" /></div>
              : exerciciosFiltradosEOrdenados.length === 0 ? <p className="text-sm text-muted-foreground text-center py-10">Nenhum exercício encontrado.</p>
              : <div className="space-y-2">
                  {exerciciosFiltradosEOrdenados.map((ex) => {
                    const isSelected = exerciciosSelecionados.some(sel => sel._id === ex._id);
                    return (
                      <div
                        key={ex._id}
                        onClick={() => handleToggleSelecaoExercicio(ex)}
                        className={`p-3 border rounded-md cursor-pointer flex justify-between items-center transition-colors ${isSelected ? "bg-primary/10 border-primary ring-2 ring-primary" : "hover:bg-muted/50"}`}
                      >
                        <div>
                          <p className={`font-medium ${isSelected ? 'text-primary' : ''}`}>{ex.nome}</p>
                          <span className="text-xs text-muted-foreground">{ex.grupoMuscular || 'N/A'}</span>
                        </div>
                        {isSelected && <CheckCircle className="w-5 h-5 text-primary shrink-0" />}
                      </div>
                    );
                  })}
                </div>
            }
          </ScrollArea>
        </div>

        <DialogFooter className="p-6 pt-4 border-t shrink-0">
            <p className="text-sm text-muted-foreground mr-auto">{exerciciosSelecionados.length} selecionado(s)</p>
            <Button variant="outline" onClick={onClose}>Cancelar</Button>
            <Button onClick={handleSubmitSelecao} disabled={exerciciosSelecionados.length === 0}>Adicionar</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

===== ./client/src/components/dialogs/SelectModeloRotinaModal.tsx =====
// client/src/components/dialogs/SelectModeloRotinaModal.tsx
import React, { useContext } from 'react'; // Importar useContext
import {
  Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Loader2, FileText } from 'lucide-react';
import { useQuery } from '@tanstack/react-query';
import { fetchWithAuth } from '@/lib/apiClient';
import { UserContext } from '@/context/UserContext'; // Importar UserContext
import type { RotinaListagemItem } from '@/types/treinoOuRotinaTypes'; // Assumindo que este tipo inclui `tipo`

// Define uma interface local para garantir que id e role sejam reconhecidos.
// Idealmente, esta interface deveria ser definida no UserContext.tsx
interface UserWithIdAndRole {
  id: string; // CORREÇÃO: Usar 'id' em vez de '_id'
  role: string;
  // Adicione outras propriedades do tipo User real se forem usadas neste componente
  // Ex: name: string; email: string;
}

interface SelectModeloRotinaModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (modelId: string, modelTitle: string) => void;
}

const SelectModeloRotinaModal: React.FC<SelectModeloRotinaModalProps> = ({
  isOpen,
  onClose,
  onSelect,
}) => {
  // Faz um type assertion para UserWithIdAndRole para satisfazer o TypeScript
  const { user } = useContext(UserContext) as { user: UserWithIdAndRole | null };

  console.log("[SelectModeloRotinaModal] Modal está aberto:", isOpen); // Log
  console.log("[SelectModeloRotinaModal] Usuário do Contexto:", user); // Log do objeto user

  // Adicionar um log para a condição 'enabled'
  // CORREÇÃO: Usar user?.id em vez de user?._id
  const isQueryEnabled = isOpen && !!user?.id;
  console.log("[SelectModeloRotinaModal] Consulta habilitada (isQueryEnabled):", isQueryEnabled, " (isOpen:", isOpen, " user?.id:", user?.id, ")");

  const { data: modelRotinas = [], isLoading, isError, error } = useQuery<RotinaListagemItem[], Error>({
    // CORREÇÃO: Usar user?.id na queryKey
    queryKey: ['modelRotinas', user?.id], // Adicionar user.id à queryKey para cachear por usuário
    queryFn: async () => { // Adicionar async aqui
      let url = '/api/treinos?tipo=modelo';
      // Se o usuário for um personal, adicionar o trainerId à consulta
      // CORREÇÃO: Usar user.id
      if (user && user.role === 'personal' && user.id) { 
        url += `&trainerId=${user.id}`; 
      }
      console.log("[SelectModeloRotinaModal] Chamando API com URL:", url); // Log da URL
      try {
        const response = await fetchWithAuth(url);
        console.log("[SelectModeloRotinaModal] Resposta da API (Sucesso):", response); // Log da resposta de sucesso
        return response;
      } catch (apiError) {
        console.error("[SelectModeloRotinaModal] Erro na chamada da API:", apiError); // Log do erro da API
        throw apiError; // Re-lançar o erro para que o useQuery possa tratá-lo
      }
    },
    enabled: isQueryEnabled, // Usar a variável de controle da condição
    staleTime: 1000 * 60 * 5, // Manter dados em cache por 5 minutos
  });

  const handleSelectModel = (modelId: string, modelTitle: string) => {
    onSelect(modelId, modelTitle);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={(openStatus) => !openStatus && onClose()}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle className="flex items-center">
            <FileText className="w-5 h-5 mr-2 text-primary" />
            Selecionar Modelo de Rotina
          </DialogTitle>
          <DialogDescription>
            Escolha um modelo de rotina para associar ao aluno.
          </DialogDescription>
        </DialogHeader>

        <div className="py-4 space-y-3 max-h-[400px] overflow-y-auto">
          {isLoading ? (
            <div className="flex items-center justify-center space-x-2 text-sm text-muted-foreground">
              <Loader2 className="h-4 w-4 animate-spin" />
              <span>Carregando modelos de rotina...</span>
            </div>
          ) : isError ? (
            <div className="text-center text-red-500 text-sm">
              Erro ao carregar modelos: {error?.message || "Erro desconhecido."}
            </div>
          ) : modelRotinas.length === 0 ? (
            <p className="text-center text-muted-foreground text-sm">Nenhum modelo de rotina disponível.</p>
          ) : (
            modelRotinas.map((rotina) => (
              <div
                key={rotina._id}
                className="flex items-center justify-between p-3 rounded-md border bg-slate-50 dark:bg-slate-800/50 cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700 transition-colors"
                onClick={() => handleSelectModel(rotina._id, rotina.titulo)}
              >
                <div>
                  <p className="font-semibold text-sm">{rotina.titulo}</p>
                  {rotina.descricao && <p className="text-xs text-muted-foreground line-clamp-1">{rotina.descricao}</p>}
                </div>
                <Button variant="ghost" size="sm">Selecionar</Button>
              </div>
            ))
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose}>
            Cancelar
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

export default SelectModeloRotinaModal;

===== ./client/src/components/dialogs/SessaoDetalheModal.tsx =====
// client/src/components/dialogs/SessaoDetalheModal.tsx
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Loader2, Star, MessageSquareText, Dumbbell, Calendar, VideoOff, PlayCircle } from 'lucide-react';
import { format, parseISO } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import VideoPlayerModal from '@/components/dialogs/VideoPlayerModal';
import { useToast } from '@/hooks/use-toast';

// --- Interfaces (sem alterações) ---
interface ExercicioDetalhePopulado { _id: string; nome: string; grupoMuscular?: string; urlVideo?: string; }
interface ExercicioEmDiaDeTreinoPopulado { _id: string; exercicioId: ExercicioDetalhePopulado | string | null; series?: string; repeticoes?: string; carga?: string; descanso?: string; observacoes?: string; ordemNoDia: number; }
interface DiaDeTreinoPopulado { _id: string; exerciciosDoDia: ExercicioEmDiaDeTreinoPopulado[]; }
interface RotinaCompletaPopulado { _id: string; diasDeTreino: DiaDeTreinoPopulado[]; }
interface SessaoHistorico {
  rotinaId?: { _id: string; titulo: string; } | null;
  diaDeTreinoId?: string | null;
  diaDeTreinoIdentificador?: string | null;
  nomeSubFichaDia?: string | null;
  concluidaEm: string;
  pseAluno?: string | null;
  comentarioAluno?: string | null;
}
interface SessaoDetalheModalProps {
  sessao: SessaoHistorico | null;
  onClose: () => void;
}

const getPseBadgeVariant = (pse: string | null | undefined): "default" | "secondary" | "destructive" | "outline" => {
    if (!pse) return "secondary";
    switch (pse) {
        case 'Muito Leve': case 'Leve': return "default";
        case 'Moderado': return "secondary";
        case 'Intenso': case 'Muito Intenso': return "outline";
        case 'Máximo Esforço': return "destructive";
        default: return "secondary";
    }
};

export default function SessaoDetalheModal({ sessao, onClose }: SessaoDetalheModalProps) {
  const isModalOpen = !!sessao;
  const { toast } = useToast();
  const [videoUrlParaExibir, setVideoUrlParaExibir] = useState<string | null>(null);

  const { data: detalhesRotina, isLoading, error, isSuccess } = useQuery<RotinaCompletaPopulado, Error>({
    queryKey: ['detalhesRotinaHistorico', sessao?.rotinaId?._id],
    // <<< INÍCIO DA CORREÇÃO >>>
    queryFn: () => apiRequest('GET', `/api/aluno/meus-treinos/${sessao!.rotinaId!._id}`, undefined, 'aluno'),
    // <<< FIM DA CORREÇÃO >>>
    enabled: isModalOpen && !!sessao?.rotinaId?._id,
  });

  const exerciciosDoDia = detalhesRotina?.diasDeTreino
    .find(dia => dia._id === sessao?.diaDeTreinoId)
    ?.exerciciosDoDia.sort((a, b) => a.ordemNoDia - b.ordemNoDia) || [];

  const dataConclusaoFormatada = sessao ? format(parseISO(sessao.concluidaEm), "dd 'de' MMMM 'de' yyyy, 'às' HH:mm", { locale: ptBR }) : '';

  const abrirVideo = (url?: string) => {
    if (!url) {
        toast({ title: "Vídeo não disponível" });
        return;
    }
    let videoUrlParaModal = url;
    if (url.includes("youtube.com/watch?v=")) {
        videoUrlParaModal = url.replace("watch?v=", "embed/");
    } else if (url.includes("youtu.be/")) {
        const id = url.split("youtu.be/")[1]?.split("?")[0];
        if(id) videoUrlParaModal = `https://www.youtube.com/embed/${id}`;
    } else if (url.includes("drive.google.com/file/d/")) {
        const id = url.split("/d/")[1]?.split("/")[0];
        if(id) videoUrlParaModal = `https://drive.google.com/file/d/${id}/preview`;
    }
    setVideoUrlParaExibir(videoUrlParaModal);
  };

  return (
    <>
      <Dialog open={isModalOpen} onOpenChange={(open) => !open && onClose()}>
        <DialogContent className="sm:max-w-[550px] max-h-[90vh] flex flex-col">
          <DialogHeader>
            <DialogTitle className="text-xl text-primary">{sessao?.rotinaId?.titulo || 'Detalhes do Treino'}</DialogTitle>
            <DialogDescription>
              {sessao?.diaDeTreinoIdentificador}{sessao?.nomeSubFichaDia && ` - ${sessao.nomeSubFichaDia}`}
            </DialogDescription>
          </DialogHeader>
          
          <div className="flex-grow overflow-y-auto pr-4 -mr-4 space-y-4">
              <div className="space-y-3 p-4 bg-muted/50 rounded-lg">
                  <div className="flex items-center gap-2"><Calendar className="w-4 h-4 text-muted-foreground"/> <span className="text-sm font-medium">{dataConclusaoFormatada}</span></div>
                  {sessao?.pseAluno && (
                      <div className="flex items-center gap-2">
                          <Star className="w-4 h-4 text-yellow-500" />
                          <span className="font-semibold text-sm">Seu PSE:</span>
                          <Badge variant={getPseBadgeVariant(sessao.pseAluno)}>{sessao.pseAluno}</Badge>
                      </div>
                  )}
                  {sessao?.comentarioAluno && (
                      <div className="flex items-start gap-2">
                          <MessageSquareText className="w-4 h-4 text-blue-500 mt-1 shrink-0" />
                          <div className="text-sm">
                              <span className="font-semibold">Seu comentário:</span>
                              <blockquote className="mt-1 text-xs italic text-muted-foreground border-l-2 pl-3">{sessao.comentarioAluno}</blockquote>
                          </div>
                      </div>
                  )}
              </div>

              <div>
                  <h3 className="text-md font-semibold mb-3 flex items-center"><Dumbbell className="w-5 h-5 mr-2" /> Exercícios Realizados</h3>
                  {isLoading && <div className="flex justify-center py-4"><Loader2 className="w-6 h-6 animate-spin text-primary" /></div>}
                  {error && <p className="text-sm text-red-500">Não foi possível carregar os exercícios.</p>}
                  {isSuccess && (
                      <div className="space-y-2">
                          {exerciciosDoDia.length > 0 ? exerciciosDoDia.map(ex => {
                              const detalhesEx = ex.exercicioId && typeof ex.exercicioId === 'object' ? ex.exercicioId : null;
                              return (
                                  <div key={ex._id} className="text-sm p-3 border rounded-md flex justify-between items-center">
                                      <div>
                                          <p className="font-medium">{detalhesEx?.nome || 'Exercício não encontrado'}</p>
                                          <p className="text-xs text-muted-foreground">
                                              {ex.series && `${ex.series}x`}
                                              {ex.repeticoes}
                                              {ex.carga && ` - ${ex.carga}`}
                                          </p>
                                      </div>
                                      {detalhesEx?.urlVideo ? (
                                          <Button variant="ghost" size="icon" className="h-8 w-8" onClick={() => abrirVideo(detalhesEx.urlVideo)}>
                                              <PlayCircle className="w-5 h-5 text-red-500"/>
                                          </Button>
                                      ) : (
                                        <span title="Vídeo não disponível">
                                          <VideoOff className="w-5 h-5 text-muted-foreground" />
                                        </span>
                                      )}
                                  </div>
                              );
                          }) : <p className="text-xs text-center text-muted-foreground py-2">Nenhum exercício detalhado encontrado para este dia.</p>}
                      </div>
                  )}
              </div>
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={onClose}>Fechar</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <VideoPlayerModal
        videoUrl={videoUrlParaExibir}
        onClose={() => setVideoUrlParaExibir(null)}
      />
    </>
  );
}
===== ./client/src/components/dialogs/SessionFormModal.tsx =====
import { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import { Select, SelectTrigger, SelectValue, SelectContent, SelectItem } from "@/components/ui/select";
import { usePersistedInput } from '@/hooks/usePersistedInput';
import { usePersistedState } from '@/hooks/usePersistedState';

interface Sessao {
  id: string;
  aluno: string;
  data: Date;
  hora: string;
  status: "confirmada" | "pendente" | "concluida" | "cancelada";
  observacoes?: string;
}

interface SessionFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (novaSessao: Sessao) => void;
}

export default function SessionFormModal({ isOpen, onClose, onSave }: SessionFormModalProps) {
  // Persisted state for each form field - using simpler hook for strings
  const [aluno, setAluno, clearAluno] = usePersistedInput("novaSessao_aluno");
  const [hora, setHora, clearHora] = usePersistedInput("novaSessao_hora");
  const [observacoes, setObservacoes, clearObservacoes] = usePersistedInput("novaSessao_observacoes");
  
  // Complex types still use usePersistedState
  const [dataString, setDataString, clearDataString] = usePersistedState("formNovaSessao_data", new Date().toISOString());
  const [status, setStatus, clearStatus] = usePersistedState<"confirmada" | "pendente" | "concluida" | "cancelada">("formNovaSessao_status", "pendente");

  // Convert dataString to Date for calendar component
  const data = dataString ? new Date(dataString) : new Date();
  
  const handleSetData = (value: Date | undefined) => {
    setDataString(value ? value.toISOString() : new Date().toISOString());
  };

  const handleSalvar = () => {
    if (!aluno || !data || !hora) return alert("Preencha todos os campos obrigatórios.");

    const novaSessao: Sessao = {
      id: Date.now().toString(),
      aluno,
      data,
      hora,
      status,
      observacoes,
    };

    onSave(novaSessao);
    
    // Clear form persistence on successful save
    clearAluno();
    clearDataString();
    clearHora();
    clearStatus();
    clearObservacoes();
    
    onClose();
  };

  // Enhanced close handler that clears form persistence when cancelled
  const handleClose = () => {
    clearAluno();
    clearDataString();
    clearHora();
    clearStatus();
    clearObservacoes();
    onClose();
  };

  const limparCampos = () => {
    clearAluno();
    clearDataString();
    clearHora();
    clearStatus();
    clearObservacoes();
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => { if (!open) handleClose(); }}>
      <DialogContent className="max-w-lg">
        <DialogHeader>
          <DialogTitle>Nova Sessão</DialogTitle>
        </DialogHeader>
        <div className="space-y-4">
          <Input placeholder="Nome do aluno" value={aluno} onChange={(e) => setAluno(e.target.value)} />
          <div className="flex gap-2 items-center">
            <Calendar selected={data} onSelect={handleSetData} mode="single" className="border rounded-md" />
            <Input type="time" value={hora} onChange={(e) => setHora(e.target.value)} className="w-1/2" />
          </div>
          <Select value={status} onValueChange={(value) => setStatus(value as any)}>
            <SelectTrigger>
              <SelectValue placeholder="Status da sessão" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="confirmada">Confirmada</SelectItem>
              <SelectItem value="pendente">Pendente</SelectItem>
              <SelectItem value="concluida">Concluída</SelectItem>
              <SelectItem value="cancelada">Cancelada</SelectItem>
            </SelectContent>
          </Select>
          <Input
            placeholder="Observações (opcional)"
            value={observacoes}
            onChange={(e) => setObservacoes(e.target.value)}
          />
          <div className="flex gap-2 pt-4">
            <Button variant="outline" onClick={handleClose}>
              Cancelar
            </Button>
            <Button onClick={handleSalvar}>
              Salvar Sessão
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

===== ./client/src/components/dialogs/TreinoFormModal.tsx =====
// client/src/components/dialogs/TreinoFormModal.tsx
import React, { useEffect, useState, useMemo, useCallback } from 'react';
import {
  Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription, DialogClose,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import {
  Select, SelectContent, SelectItem, SelectTrigger, SelectValue,
} from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from '@/lib/queryClient';
import { useMutation, useQuery, useQueryClient, QueryKey } from "@tanstack/react-query";
import { Loader2, CalendarIcon, Folder as FolderIcon, Activity, PlusCircle, Trash2, GripVertical, Edit, ListPlus, XCircle } from "lucide-react";
import { Card, CardContent } from "@/components/ui/card";
import { Aluno } from '@/types/aluno';
import { useFormPersistence } from '@/hooks/useFormPersistence';
import { usePersistedState } from '@/hooks/usePersistedState';

import type { RotinaListagemItem, DiaDeTreinoDetalhado } from '@/types/treinoOuRotinaTypes';
import SelectExerciseModal, { BibliotecaExercicio } from './SelectExerciseModal';

import { format, parseISO, isValid as isDateValid, startOfToday } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import * as z from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';
import { useForm } from 'react-hook-form';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage, FormDescription } from "@/components/ui/form";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";

const TIPOS_ORGANIZACAO_ROTINA_BACKEND = ['diasDaSemana', 'numerico', 'livre'] as const;
type TipoOrganizacaoRotinaBackend = typeof TIPOS_ORGANIZACAO_ROTINA_BACKEND[number];

const OPCOES_TIPO_DOS_TREINOS: { value: TipoOrganizacaoRotinaBackend; label: string }[] = [
    { value: 'diasDaSemana', label: 'Dia da Semana (Ex: Segunda, Terça...)' },
    { value: 'numerico', label: 'Numérico (Ex: Treino 1, Treino 2...)' },
    { value: 'livre', label: 'Livre (Nomes personalizados)' }
];

const diasDaSemanaOptions = [
    { value: "Segunda-feira", label: "Segunda-feira" }, { value: "Terça-feira", label: "Terça-feira" },
    { value: "Quarta-feira", label: "Quarta-feira" }, { value: "Quinta-feira", label: "Quinta-feira" },
    { value: "Sexta-feira", label: "Sexta-feira" }, { value: "Sábado", label: "Sábado" }, { value: "Domingo", label: "Domingo" },
];

const diaDeTreinoFormSchema = z.object({
    identificadorDia: z.string().min(1, "Identificador do dia é obrigatório.").max(50),
    nomeSubFicha: z.string().max(100).optional().nullable(),
});
type DiaDeTreinoFormValues = z.infer<typeof diaDeTreinoFormSchema>;

interface ExercicioNoDiaState {
  tempIdExercicio: string;
  exercicioId: string;
  nomeExercicio: string;
  grupoMuscular?: string;
  categoria?: string;
  series?: string;
  repeticoes?: string;
  carga?: string;
  descanso?: string;
  observacoes?: string;
  ordemNoDia: number;
  _idSubDocExercicio?: string;
}

interface DiaDeTreinoStateItem extends DiaDeTreinoFormValues {
    tempId: string;
    ordemNaRotina: number;
    exerciciosDoDia: ExercicioNoDiaState[];
    _id?: string;
}

const rotinaMetadataSchema = z.object({
  titulo: z.string().min(1, { message: "Título da rotina é obrigatório." }).max(100),
  descricao: z.string().max(500).optional().nullable(),
  tipo: z.enum(["modelo", "individual"]),
  tipoOrganizacaoRotina: z.enum(TIPOS_ORGANIZACAO_ROTINA_BACKEND, { errorMap: () => ({ message: "Selecione como os treinos são divididos." }) }).default('numerico'),
  alunoId: z.string().optional().nullable(),
  pastaId: z.string().nullable().optional(),
  statusModelo: z.enum(["ativo", "rascunho", "arquivado"]).optional().nullable(),
  dataValidade: z.date().optional().nullable(),
  totalSessoesRotinaPlanejadas: z.preprocess( (val) => (String(val ?? '').trim() === "" ? null : Number(String(val ?? '').trim())), z.number().int().min(0, "Deve ser 0 ou maior.").nullable().optional() ),
}).refine(data => !(data.tipo === 'individual' && (!data.alunoId || data.alunoId.trim() === '')), { message: "Aluno é obrigatório para rotinas individuais.", path: ["alunoId"] })
  .refine(data => !(data.tipo === 'modelo' && !data.statusModelo), { message: "Status é obrigatório para rotinas modelo.", path: ["statusModelo"] });

type RotinaMetadataFormValues = z.infer<typeof rotinaMetadataSchema>;

export interface RotinaParaEditar {
  _id?: string;
  titulo?: string;
  descricao?: string | null;
  tipo?: "modelo" | "individual";
  tipoOrganizacaoRotina?: TipoOrganizacaoRotinaBackend;
  alunoId?: string | { _id: string; nome: string; } | null;
  pastaId?: string | { _id: string; nome: string; } | null;
  statusModelo?: "ativo" | "rascunho" | "arquivado" | null;
  dataValidade?: string | Date | null;
  totalSessoesRotinaPlanejadas?: number | null;
  diasDeTreino?: Array<{
    _id?: string;
    identificadorDia: string;
    nomeSubFicha?: string | null;
    ordemNaRotina: number;
    exerciciosDoDia?: Array<{
      _id?: string;
      exercicioId: string | { _id: string; nome: string; grupoMuscular?: string; categoria?: string; tipo?: string; urlVideo?: string; descricao?: string; };
      series?: string; repeticoes?: string; carga?: string; descanso?: string; observacoes?: string; ordemNoDia: number;
    }>;
  }>;
  exercicios?: Array<{
    _id?: string;
    exercicioId: string | { _id: string; nome: string; grupoMuscular?: string; };
    series?: string; repeticoes?: string; carga?: string; descanso?: string; observacoes?: string; ordem?: number;
  }>;
}

interface Pasta {
    _id: string;
    nome: string;
}

interface RotinaFormModalProps {
  open: boolean;
  onClose: () => void;
  onSuccess: (rotinaSalva: RotinaListagemItem) => void;
  alunos: Aluno[];
  rotinaParaEditar?: RotinaParaEditar | null;
  alunoId?: string;
}

type RotinaApiPayload = RotinaMetadataFormValues & {
  diasDeTreino: Array<{
    _id?: string;
    identificadorDia: string;
    nomeSubFicha?: string | null;
    ordemNaRotina: number;
    exerciciosDoDia: Array<{
      _id?: string;
      exercicioId: string;
      series?: string;
      repeticoes?: string;
      carga?: string;
      descanso?: string;
      observacoes?: string;
      ordemNoDia: number;
    }>;
  }>;
  criadorId?: string;
};

const TREINOS_QUERY_KEY: QueryKey = ["/api/treinos"];

export default function TreinoFormModal({
  open, onClose, onSuccess, alunos: alunosProp, rotinaParaEditar, alunoId: alunoIdProp,
}: RotinaFormModalProps) {

  const { toast } = useToast();
  const queryClientHook = useQueryClient();

  const isEditing = !!(rotinaParaEditar && rotinaParaEditar._id);

  const [diasDeTreinoState, setDiasDeTreinoState] = useState<DiaDeTreinoStateItem[]>([]);
  const [showDiaForm, setShowDiaForm] = useState(false);
  const [editingDiaTempId, setEditingDiaTempId] = useState<string | null>(null);

  // Form persistence for dia form (when adding/editing workout days)
  const [diaIdentificador, setDiaIdentificador, clearDiaIdentificador] = usePersistedState(
    "formTreinoFormModal_dia_identificadorDia", 
    ""
  );
  const [diaNomeSubFicha, setDiaNomeSubFicha, clearDiaNomeSubFicha] = usePersistedState(
    "formTreinoFormModal_dia_nomeSubFicha", 
    ""
  );

  // Use persisted values or default for dia form
  const diaFormValues = isEditing ? 
    { identificadorDia: '', nomeSubFicha: '' } : 
    { identificadorDia: diaIdentificador, nomeSubFicha: diaNomeSubFicha };

  const setDiaFormValues = (newValues: Partial<DiaDeTreinoFormValues>) => {
    if (!isEditing) {
      if (newValues.identificadorDia !== undefined) {
        setDiaIdentificador(newValues.identificadorDia);
      }
      if (newValues.nomeSubFicha !== undefined) {
        setDiaNomeSubFicha(newValues.nomeSubFicha || '');
      }
    }
  };

  const clearDiaFormPersistence = () => {
    if (!isEditing) {
      clearDiaIdentificador();
      clearDiaNomeSubFicha();
    }
  };

  const [isSelectExerciseModalOpen, setIsSelectExerciseModalOpen] = useState(false);
  const [diaAtivoParaAdicionarExercicio, setDiaAtivoParaAdicionarExercicio] = useState<string | null>(null);

  const form = useForm<RotinaMetadataFormValues>({
    resolver: zodResolver(rotinaMetadataSchema),
    defaultValues: {
      titulo: "", descricao: null, tipo: "modelo", tipoOrganizacaoRotina: "numerico",
      alunoId: null, pastaId: null, statusModelo: "rascunho",
      dataValidade: null, totalSessoesRotinaPlanejadas: null,
    },
  });

  const watchedTipoOrganizacao = form.watch('tipoOrganizacaoRotina');
  const watchedTipoRotina = form.watch('tipo');

  useEffect(() => { if (showDiaForm) { 
    if (!isEditing) {
      diaFormPersistence.updateField('identificadorDia', ''); 
    }
  } }, [watchedTipoOrganizacao, showDiaForm]);

  const { data: pastas = [], isLoading: isLoadingPastas } = useQuery<Pasta[], Error>({ queryKey: ["pastasParaRotinaForm", watchedTipoRotina], queryFn: () => apiRequest<Pasta[]>("GET", "/api/pastas/treinos"), enabled: open && watchedTipoRotina === "modelo", });
  const { data: alunosFetched = [], isLoading: isLoadingAlunos } = useQuery<Aluno[], Error>({ queryKey: ["alunosParaRotinaForm", watchedTipoRotina], queryFn: async () => apiRequest<Aluno[]>("GET", "/api/alunos").then(data => Array.isArray(data) ? data : []), enabled: open && watchedTipoRotina === 'individual', initialData: watchedTipoRotina === 'individual' ? alunosProp : undefined, });
  const alunosDisponiveis = watchedTipoRotina === 'individual' ? (alunosFetched.length > 0 ? alunosFetched : alunosProp) : alunosProp;

  useEffect(() => {
    // console.log("[TreinoFormModal useEffect] Iniciando. Props:", { open, rotinaParaEditar: rotinaParaEditar ? JSON.parse(JSON.stringify(rotinaParaEditar)) : null, alunoIdProp });
    const currentIsEditing = !!(rotinaParaEditar && rotinaParaEditar._id);
    // console.log("[TreinoFormModal useEffect] currentIsEditing:", currentIsEditing);

    if (open) {
      // console.log("[TreinoFormModal useEffect] Modal está ABERTO.");
      if (currentIsEditing && rotinaParaEditar) {
        // console.log("[TreinoFormModal useEffect] MODO EDIÇÃO DETECTADO. Rotina para editar:", JSON.parse(JSON.stringify(rotinaParaEditar)));
        
        let dataValidadeDate: Date | null = null;
        if (rotinaParaEditar.dataValidade) {
            if (typeof rotinaParaEditar.dataValidade === 'string') { const parsed = parseISO(rotinaParaEditar.dataValidade); if (isDateValid(parsed)) dataValidadeDate = parsed; }
            else if (rotinaParaEditar.dataValidade instanceof Date && isDateValid(rotinaParaEditar.dataValidade)) { dataValidadeDate = rotinaParaEditar.dataValidade; }
        }
        const tipoDaRotinaParaForm = rotinaParaEditar.tipo || "modelo";
        const alunoIdParaForm = tipoDaRotinaParaForm === 'individual' ? (typeof rotinaParaEditar.alunoId === 'object' && rotinaParaEditar.alunoId ? rotinaParaEditar.alunoId._id : (rotinaParaEditar.alunoId as string | null)) : null;
        
        let finalAlunoIdParaReset = alunoIdParaForm; 
        if (tipoDaRotinaParaForm === 'individual') {
            if (alunoIdProp && !currentIsEditing) { 
                finalAlunoIdParaReset = alunoIdProp;
            } else { 
                finalAlunoIdParaReset = alunoIdParaForm;
            }
        } else {
            finalAlunoIdParaReset = null; 
        }
        
        const pastaIdParaForm = tipoDaRotinaParaForm === 'modelo' ? (typeof rotinaParaEditar.pastaId === 'object' && rotinaParaEditar.pastaId ? rotinaParaEditar.pastaId._id : (rotinaParaEditar.pastaId as string | null)) : null;

        const valoresParaReset: RotinaMetadataFormValues = { // Especificar o tipo aqui
          titulo: rotinaParaEditar.titulo || "",
          descricao: rotinaParaEditar.descricao || null,
          tipo: tipoDaRotinaParaForm,
          tipoOrganizacaoRotina: rotinaParaEditar.tipoOrganizacaoRotina || "numerico",
          alunoId: finalAlunoIdParaReset,
          pastaId: pastaIdParaForm,
          statusModelo: tipoDaRotinaParaForm === 'modelo' ? (rotinaParaEditar.statusModelo || "rascunho") : null,
          dataValidade: tipoDaRotinaParaForm === 'individual' ? dataValidadeDate : null,
          totalSessoesRotinaPlanejadas: tipoDaRotinaParaForm === 'individual' ? (rotinaParaEditar.totalSessoesRotinaPlanejadas ?? null) : null,
        };
        // console.log("[TreinoFormModal useEffect] Valores para form.reset (EDIÇÃO):", JSON.parse(JSON.stringify(valoresParaReset)));
        form.reset(valoresParaReset);

        let diasParaEstado: DiaDeTreinoStateItem[] = [];
        if (rotinaParaEditar.diasDeTreino && rotinaParaEditar.diasDeTreino.length > 0) {
            diasParaEstado = rotinaParaEditar.diasDeTreino.map((diaApi, index) => {
                const exerciciosFormatados: ExercicioNoDiaState[] = (diaApi.exerciciosDoDia || []).map((exApi, exIndex) => {
                    const exercicioData = exApi.exercicioId;
                    let idDoEx: string = '';
                    let nomeDoEx: string = 'Exercício não carregado';
                    let grupoDoEx: string | undefined;
                    let categoriaDoEx: string | undefined;

                    if (typeof exercicioData === 'string') {
                        idDoEx = exercicioData;
                        nomeDoEx = `Exercício (ID: ${idDoEx.substring(0,6)}...)`;
                    } else if (exercicioData && typeof exercicioData === 'object' && '_id' in exercicioData) {
                        idDoEx = exercicioData._id;
                        nomeDoEx = exercicioData.nome;
                        grupoDoEx = exercicioData.grupoMuscular;
                        categoriaDoEx = exercicioData.categoria || exercicioData.tipo;
                    }
                    return {
                        tempIdExercicio: exApi._id || `edit-ex-${index}-${exIndex}-${Date.now()}`,
                        exercicioId: idDoEx, nomeExercicio: nomeDoEx, grupoMuscular: grupoDoEx, categoria: categoriaDoEx,
                        series: exApi.series, repeticoes: exApi.repeticoes, carga: exApi.carga,
                        descanso: exApi.descanso, observacoes: exApi.observacoes,
                        ordemNoDia: exApi.ordemNoDia ?? exIndex, _idSubDocExercicio: exApi._id,
                    };
                });
                return {
                    _id: diaApi._id, identificadorDia: diaApi.identificadorDia, nomeSubFicha: diaApi.nomeSubFicha || null,
                    tempId: diaApi._id || `edit-dia-${index}-${Date.now()}`, ordemNaRotina: diaApi.ordemNaRotina ?? index,
                    exerciciosDoDia: exerciciosFormatados
                };
            });
        } else if (rotinaParaEditar.exercicios && rotinaParaEditar.exercicios.length > 0 && tipoDaRotinaParaForm === 'individual') {
            const exerciciosLegadosFormatados: ExercicioNoDiaState[] = rotinaParaEditar.exercicios.map((exApi: any, index) => {
                const exercicioData = exApi.exercicioId;
                let idDoEx: string = '';
                let nomeDoEx: string = 'Exercício legado não carregado';
                let grupoDoEx: string | undefined;

                if (typeof exercicioData === 'string') {
                    idDoEx = exercicioData;
                    nomeDoEx = `Exercício Legado (ID: ${idDoEx.substring(0,6)}...)`;
                } else if (exercicioData && typeof exercicioData === 'object' && '_id' in exercicioData) {
                    idDoEx = (exercicioData as any)._id;
                    nomeDoEx = (exercicioData as any).nome;
                    grupoDoEx = (exercicioData as any).grupoMuscular;
                }
                return {
                    tempIdExercicio: exApi._id || `legacy-ex-${index}-${Date.now()}`,
                    exercicioId: idDoEx, nomeExercicio: nomeDoEx, grupoMuscular: grupoDoEx,
                    series: exApi.series, repeticoes: exApi.repeticoes, carga: exApi.carga,
                    descanso: exApi.descanso, observacoes: exApi.observacoes,
                    ordemNoDia: exApi.ordem ?? index, _idSubDocExercicio: exApi._id,
                };
            });
            diasParaEstado = [{
                _id: undefined, tempId: `legacy-dia-${Date.now()}`,
                identificadorDia: form.getValues('tipoOrganizacaoRotina') === 'numerico' ? "1" : (form.getValues('tipoOrganizacaoRotina') === 'diasDaSemana' ? "Segunda-feira" : "Treino Principal"),
                nomeSubFicha: "Exercícios da ficha original", ordemNaRotina: 0,
                exerciciosDoDia: exerciciosLegadosFormatados,
            }];
        }
        setDiasDeTreinoState(diasParaEstado);
      } else { 
        // console.log("[TreinoFormModal useEffect] MODO CRIAÇÃO DETECTADO.");
        const defaultTipoForm: "modelo" | "individual" = alunoIdProp ? "individual" : "modelo";
        const defaultStatusModelo: "rascunho" | "ativo" | "arquivado" | null = defaultTipoForm === 'modelo' ? "rascunho" : null;

        const valoresParaReset: RotinaMetadataFormValues = { // Especificar o tipo aqui
            titulo: "", 
            descricao: null, 
            tipo: defaultTipoForm, 
            tipoOrganizacaoRotina: "numerico",
            alunoId: alunoIdProp || null, 
            pastaId: null, 
            statusModelo: defaultStatusModelo,
            dataValidade: null, 
            totalSessoesRotinaPlanejadas: null,
        };
        // console.log("[TreinoFormModal useEffect] Valores para form.reset (CRIAÇÃO):", JSON.parse(JSON.stringify(valoresParaReset)));
        form.reset(valoresParaReset);
        setDiasDeTreinoState([]);
      }
      setShowDiaForm(false); 
      if (!isEditing) {
        clearDiaFormPersistence();
      }
      setEditingDiaTempId(null);
      setIsSelectExerciseModalOpen(false); setDiaAtivoParaAdicionarExercicio(null);
    } else {
        // console.log("[TreinoFormModal useEffect] Modal FECHADO, não faz nada no form.reset.");
    }
  }, [open, rotinaParaEditar, form, alunoIdProp]);


  const currentWatchedTipo = form.watch("tipo");
  useEffect(() => {
    const currentIsEditingHook = !!(rotinaParaEditar && rotinaParaEditar._id);
    const currentFormValues = form.getValues();
    
    let targetTipo: "modelo" | "individual" | undefined = currentWatchedTipo;

    if (currentIsEditingHook && rotinaParaEditar?.tipo === 'individual') {
        targetTipo = "individual";
    } else if (!currentIsEditingHook && alunoIdProp) {
        targetTipo = "individual";
    }

    if (targetTipo && targetTipo !== currentFormValues.tipo) {
        form.setValue("tipo", targetTipo, { shouldValidate: true, shouldDirty: true });
        // Não precisa retornar aqui, pois o setValue acima irá disparar um novo ciclo deste useEffect
        // se o valor realmente mudar. E o useEffect principal (de [open, rotinaParaEditar...])
        // lida com o reset inicial. Este useEffect é mais para consistência pós-inicialização.
    }
    
    // Após a possível atualização do 'tipo', pegue o valor mais recente para as lógicas seguintes.
    const finalTipo = form.getValues("tipo");

    if (finalTipo === 'modelo') {
        if (currentFormValues.alunoId !== null) form.setValue('alunoId', null, { shouldDirty: true });
        if (currentFormValues.dataValidade !== null) form.setValue('dataValidade', null, { shouldDirty: true });
        if (currentFormValues.totalSessoesRotinaPlanejadas !== null) form.setValue('totalSessoesRotinaPlanejadas', null, { shouldDirty: true });
        if (form.getValues('statusModelo') === null) { // Somente seta se estiver null, para não sobrescrever um valor já existente da edição
             form.setValue('statusModelo', 'rascunho', { shouldDirty: true }); 
        }
    } else if (finalTipo === 'individual') {
        if (currentFormValues.pastaId !== null) form.setValue('pastaId', null, { shouldDirty: true });
        if (currentFormValues.statusModelo !== null) form.setValue('statusModelo', null, { shouldDirty: true });
        
        if (!currentIsEditingHook && alunoIdProp && form.getValues('alunoId') !== alunoIdProp) {
            form.setValue('alunoId', alunoIdProp, { shouldDirty: true, shouldValidate: true });
        }
    }
    if (!form.getValues('tipoOrganizacaoRotina')) { 
        form.setValue('tipoOrganizacaoRotina', 'numerico', { shouldDirty: true }); 
    }

  }, [currentWatchedTipo, rotinaParaEditar, alunoIdProp, form]);


  const handleDiaInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => { 
    const { name, value } = e.target; 
    if (!isEditing) {
      diaFormPersistence.updateField(name as keyof DiaDeTreinoFormValues, value);
    }
  };

  const handleAddOrUpdateDia = () => {
    if (!diaFormValues.identificadorDia || !diaFormValues.identificadorDia.trim()) { toast({ title: "Erro", description: "O identificador do dia é obrigatório.", variant: "destructive" }); return; }
    if (form.getValues('tipoOrganizacaoRotina') === 'diasDaSemana' && (!editingDiaTempId || diasDeTreinoState.find(d => d.tempId === editingDiaTempId)?.identificadorDia !== diaFormValues.identificadorDia) ) {
        const diaJaExiste = diasDeTreinoState.some(dia => dia.identificadorDia.toLowerCase() === diaFormValues.identificadorDia.toLowerCase());
        if (diaJaExiste) { toast({ title: "Erro", description: `O dia "${diaFormValues.identificadorDia}" já foi adicionado.`, variant: "destructive" }); return; }
    }
    setDiasDeTreinoState(prevDias => {
        const newOrUpdatedDias = [...prevDias];
        if (editingDiaTempId) {
            const index = newOrUpdatedDias.findIndex(d => d.tempId === editingDiaTempId);
            if (index > -1) { newOrUpdatedDias[index] = { ...newOrUpdatedDias[index], identificadorDia: diaFormValues.identificadorDia, nomeSubFicha: diaFormValues.nomeSubFicha || null }; }
        } else {
            newOrUpdatedDias.push({ ...diaFormValues, tempId: `new-dia-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, ordemNaRotina: newOrUpdatedDias.length, exerciciosDoDia: [] });
        }
        return newOrUpdatedDias.map((d, i) => ({ ...d, ordemNaRotina: i }));
    });
    setShowDiaForm(false); 
    if (!isEditing) {
      clearDiaFormPersistence();
    }
    setEditingDiaTempId(null);
  };

  const handleEditDia = (dia: DiaDeTreinoStateItem) => { 
    if (!isEditing) {
      diaFormPersistence.updateFields({ identificadorDia: dia.identificadorDia, nomeSubFicha: dia.nomeSubFicha || '' }); 
    }
    setEditingDiaTempId(dia.tempId); 
    setShowDiaForm(true); 
  };
  const handleRemoveDia = (tempIdToRemove: string) => { setDiasDeTreinoState(prevDias => prevDias.filter(d => d.tempId !== tempIdToRemove).map((d, index) => ({ ...d, ordemNaRotina: index }))); };
  const handleOpenSelectExerciseModal = (diaTempId: string) => { setDiaAtivoParaAdicionarExercicio(diaTempId); setIsSelectExerciseModalOpen(true); };

  const handleExercisesSelected = useCallback((exerciciosSelecionadosDaLib: BibliotecaExercicio[]) => {
    if (!diaAtivoParaAdicionarExercicio) return;
    setDiasDeTreinoState(prevDias =>
        prevDias.map(dia => {
            if (dia.tempId === diaAtivoParaAdicionarExercicio) {
                const novosExercicios: ExercicioNoDiaState[] = exerciciosSelecionadosDaLib.map((exLib, index) => ({
                    tempIdExercicio: `new-ex-${dia.tempId}-${Date.now()}-${index}`,
                    exercicioId: exLib._id, nomeExercicio: exLib.nome, grupoMuscular: exLib.grupoMuscular,
                    categoria: exLib.categoria, ordemNoDia: dia.exerciciosDoDia.length + index,
                    series: '', repeticoes: '', carga: '', descanso: '', observacoes: '',
                }));
                return { ...dia, exerciciosDoDia: [...dia.exerciciosDoDia, ...novosExercicios] };
            }
            return dia;
        })
    );
    setIsSelectExerciseModalOpen(false); setDiaAtivoParaAdicionarExercicio(null);
  }, [diaAtivoParaAdicionarExercicio]);

  const handleExercicioDetailChange = ( diaTempId: string, exercicioTempId: string, fieldName: 'series' | 'repeticoes' | 'carga' | 'descanso' | 'observacoes', value: string ) => {
    setDiasDeTreinoState(prevDias => prevDias.map(dia => dia.tempId === diaTempId ? { ...dia, exerciciosDoDia: dia.exerciciosDoDia.map(ex => ex.tempIdExercicio === exercicioTempId ? { ...ex, [fieldName]: value } : ex )} : dia ));
  };
  const handleRemoveExercicioFromDia = (diaTempId: string, exercicioTempId: string) => {
    setDiasDeTreinoState(prevDias => prevDias.map(dia => dia.tempId === diaTempId ? { ...dia, exerciciosDoDia: dia.exerciciosDoDia.filter(ex => ex.tempIdExercicio !== exercicioTempId).map((ex, index) => ({ ...ex, ordemNoDia: index }))} : dia ));
  };

  const mutation = useMutation<RotinaListagemItem, Error, RotinaMetadataFormValues>({
    mutationFn: async (formDataFromHook) => {
      const payload: Partial<RotinaApiPayload> = { ...formDataFromHook };
      payload.dataValidade = formDataFromHook.dataValidade ? formDataFromHook.dataValidade : null;
      if (formDataFromHook.tipo === 'modelo') { payload.alunoId = undefined; payload.totalSessoesRotinaPlanejadas = undefined; if (!payload.statusModelo) payload.statusModelo = "rascunho"; }
      else { payload.pastaId = undefined; payload.statusModelo = undefined; if (!payload.alunoId) { throw new Error("Aluno é obrigatório para rotinas individuais."); } }
      payload.diasDeTreino = diasDeTreinoState.map(dia => ({
          _id: dia._id, identificadorDia: dia.identificadorDia, nomeSubFicha: dia.nomeSubFicha || undefined,
          ordemNaRotina: dia.ordemNaRotina,
          exerciciosDoDia: (dia.exerciciosDoDia || []).map(exState => ({
              _id: exState._idSubDocExercicio, exercicioId: exState.exercicioId,
              series: exState.series, repeticoes: exState.repeticoes, carga: exState.carga,
              descanso: exState.descanso, observacoes: exState.observacoes, ordemNoDia: exState.ordemNoDia,
          })),
      }));
      delete (payload as any).exercicios;
      const currentIsEditingForMutation = !!(rotinaParaEditar && rotinaParaEditar._id);
      const endpoint = currentIsEditingForMutation ? `/api/treinos/${rotinaParaEditar!._id}` : "/api/treinos";
      const method = currentIsEditingForMutation ? "PUT" : "POST";
      return apiRequest<RotinaListagemItem>(method, endpoint, payload as RotinaApiPayload);
    },
    onSuccess: (savedRotina) => {
        const currentIsEditingOnSuccess = !!(rotinaParaEditar && rotinaParaEditar._id);
        toast({ title: "Sucesso!", description: `Rotina "${savedRotina.titulo}" ${currentIsEditingOnSuccess ? 'atualizada' : 'criada'} com sucesso.`});
        // Clear form persistence on successful save (for new routines)
        if (!currentIsEditingOnSuccess) {
          clearDiaFormPersistence();
        }
        queryClientHook.invalidateQueries({ queryKey: TREINOS_QUERY_KEY });
        if (currentIsEditingOnSuccess && rotinaParaEditar?._id) { queryClientHook.invalidateQueries({ queryKey: [`/api/treinos/${rotinaParaEditar._id}`] }); }
        if (form.getValues("tipo") === 'modelo') { queryClientHook.invalidateQueries({ queryKey: ["pastasParaRotinaForm"] }); queryClientHook.invalidateQueries({ queryKey: ["/api/pastas/treinos"] });}
        const alunoIdAfetado = form.getValues("alunoId") || (typeof rotinaParaEditar?.alunoId === 'object' && rotinaParaEditar.alunoId?._id) || (typeof rotinaParaEditar?.alunoId === 'string' ? rotinaParaEditar.alunoId : null);
        if (alunoIdAfetado) { queryClientHook.invalidateQueries({ queryKey: ["fichasAluno", alunoIdAfetado] }); }
        onSuccess(savedRotina);
        onClose();
    },
    onError: (error: Error) => {
        const currentIsEditingOnError = !!(rotinaParaEditar && rotinaParaEditar._id);
        console.error("Erro ao salvar rotina:", error);
        toast({ variant: "destructive", title: `Erro ao ${currentIsEditingOnError ? 'Atualizar' : 'Criar'} Rotina`, description: error.message || "Ocorreu um problema." });
    },
  });

  function onSubmit(data: RotinaMetadataFormValues) {
    mutation.mutate(data);
  }
  const diasDaSemanaUtilizados = useMemo(() => { if (watchedTipoOrganizacao === 'diasDaSemana') { return diasDeTreinoState.filter(dia => !editingDiaTempId || dia.tempId !== editingDiaTempId).map(dia => dia.identificadorDia); } return []; }, [diasDeTreinoState, editingDiaTempId, watchedTipoOrganizacao]);

  if (!open) {
    return null;
  }

  return (
    <Dialog open={open} onOpenChange={(openStatus) => { 
      if (!openStatus) {
        // Clear dia form persistence when modal is closed/cancelled (for new routines)
        if (!isEditing) {
          clearDiaFormPersistence();
        }
        onClose(); 
      } 
    }}>
      <DialogContent className="sm:max-w-3xl w-[95vw] md:w-[80vw] lg:w-[70vw] xl:w-[60vw] max-h-[95vh] flex flex-col p-0">
        <DialogHeader className="p-4 md:p-6 pb-4 border-b bg-background z-10 shrink-0">
          <DialogTitle>{isEditing ? "Editar Rotina de Treino" : "Nova Rotina de Treino"}</DialogTitle>
          <DialogDescription>{isEditing ? "Atualize os detalhes da rotina e seus dias de treino." : "Defina os detalhes da rotina e adicione os dias de treino."}</DialogDescription>
        </DialogHeader>
        <div className="flex-grow overflow-y-auto">
            <Form {...form}>
            <form id="rotinaFormHandler" onSubmit={form.handleSubmit(onSubmit)} className="px-4 md:px-6 py-4 space-y-6">
                {/* Campos de metadados da rotina */}
                <FormField control={form.control} name="titulo" render={({ field }) => ( <FormItem><FormLabel>Nome da Rotina*</FormLabel><FormControl><Input placeholder="Ex: Programa de Hipertrofia Semanal" {...field} /></FormControl><FormMessage /></FormItem> )}/>
                <FormField control={form.control} name="tipoOrganizacaoRotina" render={({ field }) => ( <FormItem><FormLabel>Organização dos Dias de Treino*</FormLabel><Select onValueChange={(value) => { field.onChange(value); if (showDiaForm && !isEditing) { diaFormPersistence.updateField('identificadorDia', ''); } }} value={field.value ?? "numerico"} > <FormControl><SelectTrigger><SelectValue placeholder="Como os treinos serão divididos?" /></SelectTrigger></FormControl> <SelectContent> {OPCOES_TIPO_DOS_TREINOS.map(opcao => ( <SelectItem key={opcao.value} value={opcao.value}>{opcao.label}</SelectItem> ))} </SelectContent> </Select> <FormDescription className="text-xs">Define como os dias (Ex: A, B, C ou Seg, Ter, Qua) são gerenciados.</FormDescription> <FormMessage /> </FormItem> )}/>
                <FormField control={form.control} name="descricao" render={({ field }) => ( <FormItem><FormLabel>Observações/Instruções Gerais</FormLabel><FormControl><Textarea placeholder="Detalhes adicionais sobre a rotina, recomendações, etc." {...field} value={field.value ?? ""} rows={2} /></FormControl><FormMessage /></FormItem> )}/>
                <FormField control={form.control} name="tipo" render={({ field }) => ( <FormItem><FormLabel>Tipo de Rotina*</FormLabel><Select onValueChange={field.onChange} value={field.value} disabled={(isEditing && rotinaParaEditar?.tipo === 'individual') || !!alunoIdProp}><FormControl><SelectTrigger><SelectValue placeholder="Selecione o tipo" /></SelectTrigger></FormControl><SelectContent><SelectItem value="modelo">Modelo (Template)</SelectItem><SelectItem value="individual">Individual (Para um aluno)</SelectItem></SelectContent></Select>{((isEditing && rotinaParaEditar?.tipo === 'individual') || !!alunoIdProp) && <FormDescription className="text-xs">O tipo da rotina não pode ser alterado neste contexto.</FormDescription>}<FormMessage /></FormItem> )}/>
                
                {watchedTipoRotina === 'modelo' && ( <> <FormField control={form.control} name="pastaId" render={({ field }) => ( <FormItem><FormLabel className="flex items-center"><FolderIcon className="w-4 h-4 mr-1.5 text-gray-500" /> Pasta de Modelos</FormLabel><Select  onValueChange={(value) => field.onChange(value === "nenhuma" ? null : value)}  value={field.value ?? "nenhuma"} disabled={isLoadingPastas} > <FormControl><SelectTrigger><SelectValue placeholder="Opcional: organizar em uma pasta" /></SelectTrigger></FormControl> <SelectContent> <SelectItem value="nenhuma">Nenhuma (Fora de pastas)</SelectItem> {isLoadingPastas && <div className="p-2 text-sm text-muted-foreground">Carregando pastas...</div>} {!isLoadingPastas && pastas.map(pasta => (<SelectItem key={pasta._id} value={pasta._id}>{pasta.nome}</SelectItem>))} </SelectContent> </Select> <FormMessage /> </FormItem> )}/> <FormField control={form.control} name="statusModelo" render={({ field }) => (  <FormItem> <FormLabel className="flex items-center"><Activity className="w-4 h-4 mr-1.5 text-gray-500" /> Status do Modelo*</FormLabel> <Select onValueChange={field.onChange} value={field.value ?? "rascunho"}> <FormControl><SelectTrigger><SelectValue placeholder="Status da rotina modelo" /></SelectTrigger></FormControl> <SelectContent> <SelectItem value="rascunho">Rascunho (Não visível para alunos)</SelectItem> <SelectItem value="ativo">Ativo (Pronto para uso)</SelectItem> <SelectItem value="arquivado">Arquivado (Antigo, não listado)</SelectItem> </SelectContent> </Select> <FormMessage /> </FormItem>  )}/> </> )}
                
                {watchedTipoRotina === 'individual' && (
                <>
                  <FormField control={form.control} name="alunoId" render={({ field }) => ( 
                      <FormItem> 
                          <FormLabel>Aluno*</FormLabel> 
                          <Select  onValueChange={field.onChange}  value={field.value ?? undefined}  
                                  disabled={(isEditing && !!rotinaParaEditar?.alunoId) || !!alunoIdProp || isLoadingAlunos} 
                          > 
                              <FormControl><SelectTrigger><SelectValue placeholder={isLoadingAlunos ? "Carregando..." : "Selecione o aluno"} /></SelectTrigger></FormControl> 
                              <SelectContent> 
                                  {isLoadingAlunos && <div className="p-2 text-sm text-muted-foreground">Carregando alunos...</div>} 
                                  {!isLoadingAlunos && alunosDisponiveis.length === 0 && <div className="p-2 text-sm text-muted-foreground">Nenhum aluno encontrado.</div>} 
                                  {!isLoadingAlunos && alunosDisponiveis.map((aluno: Aluno) => (<SelectItem key={aluno._id} value={aluno._id}>{aluno.nome}</SelectItem>))} 
                              </SelectContent> 
                          </Select> 
                          {((isEditing && !!rotinaParaEditar?.alunoId) || !!alunoIdProp) && 
                              <FormDescription className="text-xs">O aluno não pode ser alterado neste contexto.</FormDescription>
                          }
                          <FormMessage /> 
                      </FormItem> 
                  )}/>
                  <FormField control={form.control} name="dataValidade" render={({ field }) => (
                      <FormItem className="flex flex-col">
                          <FormLabel>Válido Até</FormLabel>
                          <FormControl>
                              <Popover>
                                  <PopoverTrigger asChild>
                                      <Button variant="outline" className={`w-full justify-start pl-3 text-left font-normal ${!field.value && "text-muted-foreground"}`} ref={field.ref} >
                                          <span className="flex items-center w-full">
                                              <span className="flex-grow">
                                                  {field.value ? format(field.value, "PPP", { locale: ptBR }) : <span>Data de expiração (opcional)</span>}
                                              </span>
                                              <CalendarIcon className="ml-auto h-4 w-4 opacity-50 flex-shrink-0" />
                                          </span>
                                      </Button>
                                  </PopoverTrigger>
                                  <PopoverContent className="w-auto p-0" align="start">
                                      <Calendar mode="single" selected={field.value ?? undefined} onSelect={field.onChange}  disabled={(date) => date < startOfToday()} initialFocus />
                                  </PopoverContent>
                              </Popover>
                          </FormControl>
                          <FormMessage />
                      </FormItem>
                  )}/>
                  <FormField control={form.control} name="totalSessoesRotinaPlanejadas" render={({ field }) => (
                      <FormItem>
                        <FormLabel>Nº de Sessões Planejadas</FormLabel>
                        <FormControl>
                          <Input
                            type="number"
                            placeholder="Ex: 12 (opcional)"
                            {...field} 
                            value={field.value === null || field.value === undefined ? "" : String(field.value)} 
                            onChange={e => {
                              const rawValue = e.target.value;
                              if (rawValue.trim() === '') {
                                field.onChange(null); 
                              } else {
                                const numValue = parseInt(rawValue, 10);
                                if (!isNaN(numValue)) {
                                  field.onChange(numValue); 
                                }
                              }
                            }}
                            min="0"
                          />
                        </FormControl>
                        <FormDescription className="text-xs">Opcional. Defina um limite de sessões para esta rotina.</FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </> 
                )}
                
                {/* Seção de Dias de Treino */}
                <div className="pt-6 mt-6 border-t dark:border-gray-700">
                    <div className="flex justify-between items-center mb-4"> <h3 className="text-lg font-semibold">Dias de Treino da Rotina</h3> <Button type="button" size="sm" variant="outline" onClick={() => { 
      if (!isEditing) {
        clearDiaFormPersistence();
      }
      setEditingDiaTempId(null); 
      setShowDiaForm(true); 
    }}> <PlusCircle className="w-4 h-4 mr-2"/> Adicionar Dia de Treino </Button> </div>
                    {showDiaForm && ( <Card className="p-4 mb-4 border-dashed dark:border-gray-600 bg-slate-50 dark:bg-slate-800/30"> <CardContent className="p-0 space-y-4"> <div> <Label htmlFor="identificadorDiaForm" className="text-sm font-medium"> {watchedTipoOrganizacao === 'diasDaSemana' && "Selecione o Dia da Semana*"} {watchedTipoOrganizacao === 'numerico' && "Número do Dia* (Ex: 1)"} {watchedTipoOrganizacao === 'livre' && "Identificador do Dia* (Ex: Peito/Tríceps)"} </Label> {watchedTipoOrganizacao === 'diasDaSemana' ? ( <Select value={diaFormValues.identificadorDia} onValueChange={(value) => { setDiaFormValues({ identificadorDia: value }); }} > <SelectTrigger className="mt-1"> <SelectValue placeholder="Selecione o dia" /> </SelectTrigger> <SelectContent> {diasDaSemanaOptions.map(opt => ( <SelectItem key={opt.value} value={opt.value} disabled={diasDaSemanaUtilizados.includes(opt.value) && diaFormValues.identificadorDia !== opt.value} > {opt.label} </SelectItem> ))} </SelectContent> </Select> ) : watchedTipoOrganizacao === 'numerico' ? ( <Input id="identificadorDiaForm" name="identificadorDia" type="number" value={diaFormValues.identificadorDia} onChange={handleDiaInputChange} placeholder={`Ex: ${diasDeTreinoState.filter(d => !editingDiaTempId || d.tempId !== editingDiaTempId).length + 1}`} className="mt-1" min="1" /> ) : ( <Input id="identificadorDiaForm" name="identificadorDia" value={diaFormValues.identificadorDia} onChange={handleDiaInputChange} placeholder="Ex: Peito e Tríceps, Dia de Força" className="mt-1" /> )} <p className="text-xs text-muted-foreground mt-1"> {watchedTipoOrganizacao === 'diasDaSemana' && "Selecione um dia da semana."} {watchedTipoOrganizacao === 'numerico' && `Sugestão para próximo dia: ${diasDeTreinoState.filter(d => !editingDiaTempId || d.tempId !== editingDiaTempId).length + 1}`} {watchedTipoOrganizacao === 'livre' && "Use um nome curto e descritivo."} </p> </div> <div> <Label htmlFor="nomeSubFichaForm" className="text-sm font-medium">Nome Específico do Treino (Opcional)</Label> <Input id="nomeSubFichaForm" name="nomeSubFicha" value={diaFormValues.nomeSubFicha ?? ""} onChange={handleDiaInputChange} placeholder="Ex: Foco em Peito e Tríceps" className="mt-1" /> </div> <div className="flex justify-end gap-2 pt-2"> <Button type="button" variant="ghost" onClick={() => {
  setShowDiaForm(false); 
  setEditingDiaTempId(null); 
  if (!isEditing) {
    clearDiaFormPersistence();
  }
}}>Cancelar</Button> <Button type="button" onClick={handleAddOrUpdateDia}>{editingDiaTempId ? "Atualizar Dia" : "Confirmar Dia"}</Button> </div> </CardContent> </Card> )}
                    {diasDeTreinoState.length === 0 && !showDiaForm && ( <div className="text-center py-6"> <Activity className="mx-auto h-12 w-12 text-gray-400" /> <h3 className="mt-2 text-sm font-medium text-gray-900 dark:text-gray-100">Nenhum dia de treino adicionado</h3> <p className="mt-1 text-sm text-gray-500 dark:text-gray-400">Comece adicionando o primeiro dia de treino da rotina.</p> </div> )}
                    
                    {diasDeTreinoState.length > 0 && (
                        <Accordion type="multiple" className="w-full space-y-2" defaultValue={diasDeTreinoState.map(d => d.tempId)}>
                            {diasDeTreinoState.map((dia) => (
                                <AccordionItem key={dia.tempId} value={dia.tempId} className="border rounded-md bg-white dark:bg-slate-800/70 shadow-sm">
                                    <div className="flex items-center justify-between px-3 py-2 group hover:bg-muted/20 dark:hover:bg-slate-700/30 rounded-t-md">
                                        <AccordionTrigger className="flex-1 p-0 hover:no-underline focus-visible:ring-1 focus-visible:ring-ring ">
                                            <div className="flex items-center gap-2 text-sm">
                                                <GripVertical className="w-4 h-4 text-muted-foreground cursor-grab group-data-[state=open]:text-primary transition-colors" />
                                                <span className="font-medium text-gray-700 dark:text-gray-200">{dia.identificadorDia}</span>
                                                {dia.nomeSubFicha && <span className="text-xs text-gray-500 dark:text-gray-400">- {dia.nomeSubFicha}</span>}
                                            </div>
                                        </AccordionTrigger>
                                        <div className="flex items-center gap-1 opacity-100 md:opacity-0 md:group-hover:opacity-100 md:focus-within:opacity-100 transition-opacity shrink-0">
                                            <Button type="button" variant="ghost" size="icon" className="h-7 w-7" onClick={(e) => {e.stopPropagation(); handleEditDia(dia);}} title="Editar dia"> <Edit className="w-3.5 h-3.5"/> </Button>
                                            <Button type="button" variant="ghost" size="icon" className="h-7 w-7 text-destructive hover:text-destructive" onClick={(e) => {e.stopPropagation(); handleRemoveDia(dia.tempId);}} title="Remover dia"> <Trash2 className="w-3.5 h-3.5"/> </Button>
                                        </div>
                                    </div>
                                    <AccordionContent className="px-4 pb-3 pt-0 border-t border-gray-200 dark:border-slate-700/50">
                                        <div className="pt-3 space-y-3">
                                            {dia.exerciciosDoDia && dia.exerciciosDoDia.length > 0 ? (
                                                dia.exerciciosDoDia.map(ex => (
                                                    <Card key={ex.tempIdExercicio} className="p-3 bg-slate-50 dark:bg-slate-700/50">
                                                        <div className="flex justify-between items-start mb-2">
                                                            <div>
                                                                <p className="text-sm font-medium">{ex.nomeExercicio}</p>
                                                                <p className="text-xs text-muted-foreground"> {ex.grupoMuscular}{ex.categoria && ` - ${ex.categoria}`} </p>
                                                            </div>
                                                            <Button type="button" variant="ghost" size="icon" className="h-6 w-6 text-destructive hover:text-destructive shrink-0" onClick={() => handleRemoveExercicioFromDia(dia.tempId, ex.tempIdExercicio)} title="Remover exercício do dia" > <XCircle className="w-4 h-4" /> </Button>
                                                        </div>
                                                        <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-x-2 gap-y-3 items-end">
                                                            <FormItem className="flex-grow"> <FormLabel htmlFor={`${ex.tempIdExercicio}-series`} className="text-xs mb-1 block">Séries</FormLabel> <Input id={`${ex.tempIdExercicio}-series`} value={ex.series || ''} onChange={(e) => handleExercicioDetailChange(dia.tempId, ex.tempIdExercicio, 'series', e.target.value)} placeholder="Ex: 3" className="text-xs h-8" /> </FormItem>
                                                            <FormItem className="flex-grow"> <FormLabel htmlFor={`${ex.tempIdExercicio}-repeticoes`} className="text-xs mb-1 block">Repetições</FormLabel> <Input id={`${ex.tempIdExercicio}-repeticoes`} value={ex.repeticoes || ''} onChange={(e) => handleExercicioDetailChange(dia.tempId, ex.tempIdExercicio, 'repeticoes', e.target.value)} placeholder="Ex: 10-12" className="text-xs h-8" /> </FormItem>
                                                            <FormItem className="flex-grow"> <FormLabel htmlFor={`${ex.tempIdExercicio}-carga`} className="text-xs mb-1 block">Carga</FormLabel> <Input id={`${ex.tempIdExercicio}-carga`} value={ex.carga || ''} onChange={(e) => handleExercicioDetailChange(dia.tempId, ex.tempIdExercicio, 'carga', e.target.value)} placeholder="Ex: 20kg" className="text-xs h-8" /> </FormItem>
                                                            <FormItem className="flex-grow"> <FormLabel htmlFor={`${ex.tempIdExercicio}-descanso`} className="text-xs mb-1 block">Descanso</FormLabel> <Input id={`${ex.tempIdExercicio}-descanso`} value={ex.descanso || ''} onChange={(e) => handleExercicioDetailChange(dia.tempId, ex.tempIdExercicio, 'descanso', e.target.value)} placeholder="Ex: 60s" className="text-xs h-8" /> </FormItem>
                                                            <FormItem className="col-span-2 sm:col-span-3 md:col-span-5"> <FormLabel htmlFor={`${ex.tempIdExercicio}-observacoes`} className="text-xs mb-1 block">Obs.</FormLabel> <Textarea id={`${ex.tempIdExercicio}-observacoes`} value={ex.observacoes || ''} onChange={(e) => handleExercicioDetailChange(dia.tempId, ex.tempIdExercicio, 'observacoes', e.target.value)} placeholder="Ex: Cadência 2020, até a falha..." className="text-xs min-h-[32px] py-1" rows={1} /> </FormItem>
                                                        </div>
                                                    </Card>
                                                ))
                                            ) : ( <p className="text-xs text-muted-foreground italic text-center py-2"> Nenhum exercício adicionado a este dia. </p> )}
                                            <Button type="button" variant="outline" size="sm" className="w-full mt-2 border-dashed hover:border-solid" onClick={() => handleOpenSelectExerciseModal(dia.tempId)} > <ListPlus className="w-4 h-4 mr-2" /> Adicionar Exercício ao Dia: {dia.identificadorDia} </Button>
                                        </div>
                                    </AccordionContent>
                                </AccordionItem>
                            ))}
                        </Accordion>
                    )}
                </div>
            </form>
            </Form>
        </div>
        <DialogFooter className="p-4 md:p-6 pt-4 border-t bg-background z-10 shrink-0">
          <DialogClose asChild><Button variant="outline" type="button" disabled={mutation.isPending}>Cancelar</Button></DialogClose>
          <Button type="submit" form="rotinaFormHandler" disabled={mutation.isPending || (form.getValues("tipo") === "individual" && !form.getValues("alunoId") && !isEditing )}>
            {mutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {isEditing ? "Salvar Alterações" : "Criar Rotina"}
          </Button>
        </DialogFooter>
      </DialogContent>
      {isSelectExerciseModalOpen && diaAtivoParaAdicionarExercicio && ( <SelectExerciseModal isOpen={isSelectExerciseModalOpen} onClose={() => { setIsSelectExerciseModalOpen(false); setDiaAtivoParaAdicionarExercicio(null); }} onExercisesSelect={handleExercisesSelected} /> )}
    </Dialog>
  );
}
===== ./client/src/components/dialogs/VideoPlayerModal.tsx =====
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";

interface VideoPlayerModalProps {
  videoUrl: string | null;
  onClose: () => void;
}

export default function VideoPlayerModal({ videoUrl, onClose }: VideoPlayerModalProps) {
  return (
    <Dialog open={!!videoUrl} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl w-full p-0 border-0">
        {/* Adiciona um título e descrição para acessibilidade (sr-only os esconde visualmente) */}
        <DialogHeader className="sr-only">
          <DialogTitle>Vídeo do Exercício</DialogTitle>
          <DialogDescription>
            Um vídeo demonstrando a execução correta do exercício. Pressione a tecla Esc para fechar.
          </DialogDescription>
        </DialogHeader>

        {videoUrl && (
          <iframe
            src={videoUrl.includes("watch?v=") ? videoUrl.replace("watch?v=", "embed/") : videoUrl}
            className="w-full h-full rounded-md aspect-video"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowFullScreen
            title="Visualizador de Vídeo do Exercício"
          ></iframe>
        )}
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/dialogs/admin/PlanoModal.tsx =====
// client/src/components/dialogs/admin/EnhancedPlanoModal.tsx
import React, { useState, useEffect } from 'react';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '../../ui/dialog';
import { Button } from '../../ui/button';
import { Input } from '../../ui/input';
import { Label } from '../../ui/label';
import { Textarea } from '../../ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../ui/select';
import { PersonalTrainerWithStatus, Plano, AssignPlanForm, AddTokensForm } from '../../../../../shared/types/planos';
import { Badge } from '../../ui/badge';
import { Alert, AlertDescription } from '../../ui/alert';
import { CalendarDays, Users, Clock, DollarSign, AlertCircle, CheckCircle, XCircle, Info, Loader2, Calendar, X } from 'lucide-react';

interface PlanoModalProps {
  isOpen: boolean;
  onClose: () => void;
  personal: PersonalTrainerWithStatus | null;
  planos: Plano[];
  onAssignPlan: (personalId: string, data: AssignPlanForm) => Promise<void>;
  onAddTokens: (personalId: string, data: AddTokensForm) => Promise<void>;
  getPlanNameById: (planId: string | null) => string;
  getPlanById: (planId: string | null) => Plano | null;
}

interface DetailedPersonalStatus {
  personalInfo: any;
  currentPlan: any;
  activeTokens: any[];
  expiredTokens: any[];
  totalActiveTokens: number;
  activeStudents: number;
  totalLimit: number;
  planHistory: any[];
}

type ModalMode = 'view' | 'assign-plan' | 'add-tokens';

export function PlanoModal({ 
  isOpen, 
  onClose, 
  personal, 
  planos, 
  onAssignPlan, 
  onAddTokens,
  getPlanNameById,
  getPlanById
}: PlanoModalProps) {
  const [mode, setMode] = useState<ModalMode>('view');
  const [loading, setLoading] = useState(false);
  const [detailedStatus, setDetailedStatus] = useState<DetailedPersonalStatus | null>(null);
  const [loadingStatus, setLoadingStatus] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Plan assignment form
  const [assignForm, setAssignForm] = useState<AssignPlanForm>({
    planoId: '',
    customDuration: undefined,
    motivo: ''
  });
  
  // Token addition form
  const [tokenForm, setTokenForm] = useState<AddTokensForm>({
    quantidade: 1,
    customDays: 30,
    motivo: ''
  });

  // Reset form and load detailed status when modal opens
  useEffect(() => {
    if (isOpen && personal) {
      setMode('view');
      setError(null);
      setAssignForm({ planoId: '', customDuration: undefined, motivo: '' });
      setTokenForm({ quantidade: 1, customDays: 30, motivo: '' });
      loadDetailedStatus();
    }
  }, [isOpen, personal]);

  const loadDetailedStatus = async () => {
    if (!personal) return;
    
    setLoadingStatus(true);
    setError(null);
    
    try {
      console.log('🔄 Loading detailed status for personal...', personal._id);
      
      const response = await fetch(`/api/admin/personal/${personal._id}/status`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`
        }
      });

      if (response.ok) {
        const status = await response.json();
        console.log('✅ Detailed status loaded:', status);
        setDetailedStatus(status);
      } else {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.message || 'Erro ao carregar detalhes');
      }
    } catch (error) {
      console.error('❌ Error loading detailed status:', error);
      setError(error instanceof Error ? error.message : 'Erro ao carregar detalhes do personal');
    } finally {
      setLoadingStatus(false);
    }
  };

  const handleAssignPlan = async () => {
    if (!personal || !assignForm.planoId) return;
    
    setLoading(true);
    setError(null);
    
    try {
      await onAssignPlan(personal._id, assignForm);
      // Success handling is done in the parent hook
    } catch (error) {
      console.error('Error assigning plan:', error);
      setError(error instanceof Error ? error.message : 'Erro ao atribuir plano');
    } finally {
      setLoading(false);
    }
  };

  const handleAddTokens = async () => {
    if (!personal || tokenForm.quantidade < 1) return;
    
    setLoading(true);
    setError(null);
    
    try {
      await onAddTokens(personal._id, tokenForm);
      // Success handling is done in the parent hook
    } catch (error) {
      console.error('Error adding tokens:', error);
      setError(error instanceof Error ? error.message : 'Erro ao adicionar tokens');
    } finally {
      setLoading(false);
    }
  };

  const getStatusColor = (percentual: number) => {
    if (percentual >= 90) return 'bg-red-500';
    if (percentual >= 70) return 'bg-yellow-500';
    return 'bg-green-500';
  };

  const getStatusText = (percentual: number) => {
    if (percentual >= 90) return 'Crítico';
    if (percentual >= 70) return 'Atenção';
    return 'Normal';
  };

  const getStatusIcon = (percentual: number) => {
    if (percentual >= 90) return <XCircle className="w-4 h-4 text-red-500" />;
    if (percentual >= 70) return <AlertCircle className="w-4 h-4 text-yellow-500" />;
    return <CheckCircle className="w-4 h-4 text-green-500" />;
  };

  const selectedPlan = assignForm.planoId ? getPlanById(assignForm.planoId) : null;

  if (!personal) return null;

  // Get current plan name using the robust lookup function
  const currentPlanName = getPlanNameById(personal.planoId);
  const currentPlan = getPlanById(personal.planoId);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            {mode === 'view' && `Gerenciar Plano - ${personal.nome}`}
            {mode === 'assign-plan' && 'Atribuir Plano'}
            {mode === 'add-tokens' && 'Adicionar Tokens'}
          </DialogTitle>
          <DialogDescription>
            {mode === 'view' && 'Visualize e gerencie o plano do personal trainer'}
            {mode === 'assign-plan' && 'Atribua um novo plano ao personal trainer'}
            {mode === 'add-tokens' && 'Adicione tokens avulsos ao personal trainer'}
          </DialogDescription>
        </DialogHeader>

        {/* Error Alert */}
        {error && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              {error}
            </AlertDescription>
          </Alert>
        )}

        {mode === 'view' && (
          <div className="space-y-6">
            {/* Personal Info */}
            <div className="bg-gradient-to-r from-blue-50 to-purple-50 p-6 rounded-lg border">
              <h3 className="font-semibold text-lg mb-4 flex items-center gap-2">
                <Users className="w-5 h-5 text-blue-600" />
                Informações do Personal
              </h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <p className="text-sm text-gray-600">Nome</p>
                  <p className="font-medium text-lg">{personal.nome}</p>
                </div>
                <div className="space-y-2">
                  <p className="text-sm text-gray-600">Email</p>
                  <p className="font-medium">{personal.email}</p>
                </div>
              </div>
            </div>

            {/* Expired Plan Alert */}
            {personal.isExpired && (
              <div className="bg-red-50 border-2 border-red-200 p-6 rounded-lg">
                <div className="flex items-center gap-3 mb-4">
                  <X className="w-6 h-6 text-red-600" />
                  <h3 className="font-semibold text-lg text-red-800">Plano Expirado</h3>
                </div>
                <div className="space-y-2">
                  <p className="text-red-700">
                    Este plano expirou e o personal trainer não pode mais ativar novos alunos.
                  </p>
                  {personal.dataVencimento && (
                    <p className="text-sm text-red-600">
                      <strong>Data de expiração:</strong> {new Date(personal.dataVencimento).toLocaleDateString('pt-BR')}
                    </p>
                  )}
                  <p className="text-sm text-red-600 font-medium">
                    Para reativar o acesso, atribua um novo plano ao personal trainer.
                  </p>
                </div>
              </div>
            )}

            {/* Current Plan Status - Enhanced Display */}
            <div className={`border-2 p-6 rounded-lg ${personal.isExpired ? 'bg-red-50 border-red-200' : 'bg-white border-gray-200'}`}>
              <h3 className="font-semibold text-lg mb-4 flex items-center gap-2">
                <CalendarDays className={`w-5 h-5 ${personal.isExpired ? 'text-red-600' : 'text-purple-600'}`} />
                {personal.isExpired ? 'Status do Plano Expirado' : 'Status do Plano Atual'}
              </h3>
              
              {loadingStatus ? (
                <div className="flex items-center justify-center py-8">
                  <Loader2 className="w-6 h-6 animate-spin text-blue-600 mr-2" />
                  <span className="text-gray-600">Carregando status detalhado...</span>
                </div>
              ) : (
                <div className="space-y-6">
                  {/* Primary Status Cards */}
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                    <div className={`p-4 rounded-lg border ${personal.isExpired ? 'bg-red-100 border-red-300' : 'bg-blue-50 border-blue-200'}`}>
                      <div className="flex items-center justify-between mb-2">
                        <CalendarDays className={`w-5 h-5 ${personal.isExpired ? 'text-red-600' : 'text-blue-600'}`} />
                        <Info className={`w-4 h-4 ${personal.isExpired ? 'text-red-400' : 'text-blue-400'}`} />
                      </div>
                      <p className={`text-sm font-medium ${personal.isExpired ? 'text-red-600' : 'text-blue-600'}`}>
                        {personal.isExpired ? 'Plano Expirado' : 'Plano Atual'}
                      </p>
                      <p className={`font-bold text-lg ${personal.isExpired ? 'text-red-800' : 'text-blue-800'}`}>
                        {currentPlanName}
                      </p>
                      {personal.planoId && (
                        <p className={`text-xs mt-1 ${personal.isExpired ? 'text-red-500' : 'text-blue-500'}`}>
                          ID: {personal.planoId.substring(0, 8)}...
                        </p>
                      )}
                    </div>
                    
                    <div className="bg-green-50 p-4 rounded-lg border border-green-200">
                      <div className="flex items-center justify-between mb-2">
                        <Users className="w-5 h-5 text-green-600" />
                        <span className="text-xs text-green-500">ativos</span>
                      </div>
                      <p className="text-sm text-green-600 font-medium">Alunos</p>
                      <p className="font-bold text-lg text-green-800">
                        {personal.alunosAtivos}/{personal.limiteAlunos}
                      </p>
                    </div>
                    
                    <div className={`p-4 rounded-lg border ${
                      personal.isExpired 
                        ? 'bg-red-100 border-red-300' 
                        : personal.percentualUso >= 90 
                          ? 'bg-red-50 border-red-200' 
                          : personal.percentualUso >= 70 
                            ? 'bg-yellow-50 border-yellow-200' 
                            : 'bg-green-50 border-green-200'
                    }`}>
                      <div className="flex items-center justify-between mb-2">
                        {personal.isExpired ? (
                          <X className="w-4 h-4 text-red-500" />
                        ) : (
                          getStatusIcon(personal.percentualUso)
                        )}
                        <Badge variant={
                          personal.isExpired ? 'destructive' :
                          personal.percentualUso >= 90 ? 'destructive' : 
                          personal.percentualUso >= 70 ? 'default' : 'secondary'
                        }>
                          {personal.isExpired ? 'Expirado' : getStatusText(personal.percentualUso)}
                        </Badge>
                      </div>
                      <p className={`text-sm font-medium ${
                        personal.isExpired ? 'text-red-600' : 
                        personal.percentualUso >= 90 ? 'text-red-600' : 
                        personal.percentualUso >= 70 ? 'text-yellow-600' : 'text-green-600'
                      }`}>Status</p>
                      <p className={`font-bold text-lg ${
                        personal.isExpired ? 'text-red-800' : 
                        personal.percentualUso >= 90 ? 'text-red-800' : 
                        personal.percentualUso >= 70 ? 'text-yellow-800' : 'text-green-800'
                      }`}>
                        {personal.isExpired ? 'Bloqueado' : `${personal.percentualUso}% usado`}
                      </p>
                    </div>
                    
                    <div className="bg-orange-50 p-4 rounded-lg border border-orange-200">
                      <div className="flex items-center justify-between mb-2">
                        <div className={`w-3 h-3 rounded-full ${
                          personal.isExpired ? 'bg-red-500' : getStatusColor(personal.percentualUso)
                        }`} />
                        <Clock className="w-4 h-4 text-orange-400" />
                      </div>
                      <p className="text-sm text-orange-600 font-medium">Utilização</p>
                      <div className="mt-2">
                        <div className="w-full bg-orange-200 rounded-full h-3">
                          <div 
                            className={`h-3 rounded-full transition-all duration-300 ${
                              personal.isExpired ? 'bg-red-500' : getStatusColor(personal.percentualUso)
                            }`}
                            style={{ 
                              width: personal.isExpired ? '100%' : `${Math.min(personal.percentualUso, 100)}%` 
                            }}
                          />
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Plan Details */}
                  {currentPlan && (
                    <div className="bg-gray-50 p-4 rounded-lg">
                      <h4 className="font-semibold mb-3 flex items-center gap-2">
                        <DollarSign className="w-4 h-4 text-green-600" />
                        Detalhes do Plano
                      </h4>
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                        <div>
                          <span className="text-gray-600">Limite de Alunos:</span>
                          <p className="font-medium">{currentPlan.limiteAlunos}</p>
                        </div>
                        <div>
                          <span className="text-gray-600">Preço:</span>
                          <p className="font-medium">R$ {currentPlan.preco.toFixed(2)}</p>
                        </div>
                        <div>
                          <span className="text-gray-600">Duração:</span>
                          <p className="font-medium">{currentPlan.duracao} dias</p>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Plan History/Dates - Always show if available */}
                  {(personal.dataInicio || personal.dataVencimento || detailedStatus?.currentPlan?.personalPlano) && (
                    <div className={`p-4 rounded-lg ${personal.isExpired ? 'bg-red-50 border border-red-200' : 'bg-gray-50'}`}>
                      <h4 className="font-semibold mb-3 flex items-center gap-2">
                        <Calendar className={`w-4 h-4 ${personal.isExpired ? 'text-red-600' : 'text-blue-600'}`} />
                        {personal.isExpired ? 'Histórico do Plano Expirado' : 'Datas do Plano'}
                      </h4>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                        {(personal.dataInicio || personal.dataVencimento || detailedStatus?.currentPlan?.personalPlano) && (
                          <div>
                            <span className={`${personal.isExpired ? 'text-red-600' : 'text-gray-600'}`}>
                              {personal.isExpired ? 'Data de Início (Expirado):' : 'Início da Assinatura:'}
                            </span>
                            <p className="font-medium">
                              {personal.dataInicio 
                                ? new Date(personal.dataInicio).toLocaleDateString('pt-BR')
                                : new Date(detailedStatus.currentPlan.personalPlano.dataInicio).toLocaleDateString('pt-BR')
                              }
                            </p>
                          </div>
                        )}
                        {(personal.dataVencimento || detailedStatus?.currentPlan?.personalPlano?.dataVencimento) && (
                          <div>
                            <span className={`${personal.isExpired ? 'text-red-600' : 'text-gray-600'}`}>
                              {personal.isExpired ? 'Data de Expiração:' : 'Fim da Assinatura:'}
                            </span>
                            <p className={`font-medium ${personal.isExpired ? 'text-red-700' : ''}`}>
                              {personal.dataVencimento 
                                ? new Date(personal.dataVencimento).toLocaleDateString('pt-BR')
                                : new Date(detailedStatus.currentPlan.personalPlano.dataVencimento).toLocaleDateString('pt-BR')
                              }
                            </p>
                          </div>
                        )}
                      </div>
                      
                      {/* Duration calculation for expired plans */}
                      {personal.isExpired && personal.dataInicio && personal.dataVencimento && (
                        <div className="mt-3 pt-3 border-t border-red-200">
                          <div className="text-sm text-red-600">
                            <strong>Duração do plano:</strong> {' '}
                            {Math.ceil((new Date(personal.dataVencimento).getTime() - new Date(personal.dataInicio).getTime()) / (1000 * 60 * 60 * 24))} dias
                          </div>
                        </div>
                      )}
                    </div>
                  )}

                  {/* Comprehensive Token Display Section */}
                  {(detailedStatus?.activeTokens?.length > 0 || detailedStatus?.expiredTokens?.length > 0) && (
                    <div className="bg-gradient-to-r from-green-50 to-blue-50 p-6 rounded-lg border">
                      <h4 className="font-semibold text-lg mb-4 flex items-center gap-2">
                        <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
                        Detalhes dos Tokens
                      </h4>

                      {/* Active Tokens Summary */}
                      {detailedStatus?.activeTokens?.length > 0 && (
                        <div className="mb-6">
                          <div className="flex items-center justify-between mb-3">
                            <h5 className="font-medium text-green-800 flex items-center gap-2">
                              <CheckCircle className="w-4 h-4 text-green-600" />
                              Tokens Ativos ({detailedStatus.activeTokens.length})
                            </h5>
                            <Badge variant="secondary" className="bg-green-100 text-green-800">
                              {detailedStatus.totalActiveTokens || detailedStatus.activeTokens.reduce((sum, token) => sum + token.quantidade, 0)} tokens disponíveis
                            </Badge>
                          </div>
                          
                          <div className="grid gap-3">
                            {detailedStatus.activeTokens.map((token, index) => {
                              const createdDate = new Date(token.createdAt);
                              const expirationDate = new Date(token.dataVencimento);
                              const now = new Date();
                              const daysUntilExpiration = Math.ceil((expirationDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                              const isExpiringSoon = daysUntilExpiration <= 7 && daysUntilExpiration > 0;
                              
                              return (
                                <div key={token._id || index} className={`p-4 rounded-lg border-2 ${
                                  isExpiringSoon 
                                    ? 'bg-yellow-50 border-yellow-200' 
                                    : 'bg-white border-green-200'
                                }`}>
                                  <div className="flex items-start justify-between mb-3">
                                    <div className="flex items-center gap-2">
                                      <div className={`w-3 h-3 rounded-full ${
                                        isExpiringSoon ? 'bg-yellow-500' : 'bg-green-500'
                                      }`} />
                                      <span className="font-medium">
                                        Token #{index + 1}
                                      </span>
                                      {isExpiringSoon && (
                                        <Badge variant="outline" className="text-yellow-700 border-yellow-300">
                                          Expira em {daysUntilExpiration} dia{daysUntilExpiration !== 1 ? 's' : ''}
                                        </Badge>
                                      )}
                                    </div>
                                    <Badge className={`${
                                      isExpiringSoon 
                                        ? 'bg-yellow-600 hover:bg-yellow-700' 
                                        : 'bg-green-600 hover:bg-green-700'
                                    } text-white`}>
                                      {token.quantidade} token{token.quantidade !== 1 ? 's' : ''}
                                    </Badge>
                                  </div>
                                  
                                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
                                    <div>
                                      <span className="text-gray-600 font-medium">Início:</span>
                                      <p className="text-gray-800">
                                        {createdDate.toLocaleDateString('pt-BR')} às {createdDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
                                      </p>
                                    </div>
                                    <div>
                                      <span className={`font-medium ${isExpiringSoon ? 'text-yellow-600' : 'text-gray-600'}`}>
                                        Expira em:
                                      </span>
                                      <p className={`${isExpiringSoon ? 'text-yellow-800 font-medium' : 'text-gray-800'}`}>
                                        {expirationDate.toLocaleDateString('pt-BR')} às {expirationDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}
                                      </p>
                                    </div>
                                  </div>
                                  
                                  {(token.motivoAdicao || token.adicionadoPorAdmin) && (
                                    <div className="mt-3 pt-3 border-t border-gray-200">
                                      {token.adicionadoPorAdmin && (
                                        <div className="mb-2">
                                          <span className="text-gray-600 text-sm">Adicionado por:</span>
                                          <p className="text-sm font-medium text-blue-700">
                                            {typeof token.adicionadoPorAdmin === 'object' 
                                              ? token.adicionadoPorAdmin.nome 
                                              : 'Admin'
                                            }
                                          </p>
                                        </div>
                                      )}
                                      {token.motivoAdicao && (
                                        <div>
                                          <span className="text-gray-600 text-sm">Motivo:</span>
                                          <p className="text-sm text-gray-700 italic">"{token.motivoAdicao}"</p>
                                        </div>
                                      )}
                                    </div>
                                  )}
                                </div>
                              );
                            })}
                          </div>
                        </div>
                      )}

                      {/* Expired Tokens (Recent) */}
                      {detailedStatus?.expiredTokens?.length > 0 && (
                        <div>
                          <div className="flex items-center justify-between mb-3">
                            <h5 className="font-medium text-red-800 flex items-center gap-2">
                              <XCircle className="w-4 h-4 text-red-600" />
                              Tokens Expirados Recentes ({detailedStatus.expiredTokens.length})
                            </h5>
                            <Badge variant="destructive" className="bg-red-100 text-red-800">
                              Últimos 30 dias
                            </Badge>
                          </div>
                          
                          <div className="grid gap-3">
                            {detailedStatus.expiredTokens.slice(0, 3).map((token, index) => {
                              const createdDate = new Date(token.createdAt);
                              const expirationDate = new Date(token.dataVencimento);
                              
                              return (
                                <div key={token._id || index} className="p-4 rounded-lg border-2 bg-red-50 border-red-200 opacity-75">
                                  <div className="flex items-start justify-between mb-3">
                                    <div className="flex items-center gap-2">
                                      <div className="w-3 h-3 rounded-full bg-red-500" />
                                      <span className="font-medium text-red-800">
                                        Token #{index + 1} (Expirado)
                                      </span>
                                    </div>
                                    <Badge variant="destructive">
                                      {token.quantidade} token{token.quantidade !== 1 ? 's' : ''}
                                    </Badge>
                                  </div>
                                  
                                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
                                    <div>
                                      <span className="text-red-600 font-medium">Início:</span>
                                      <p className="text-red-700">
                                        {createdDate.toLocaleDateString('pt-BR')}
                                      </p>
                                    </div>
                                    <div>
                                      <span className="text-red-600 font-medium">Expirou em:</span>
                                      <p className="text-red-700 font-medium">
                                        {expirationDate.toLocaleDateString('pt-BR')}
                                      </p>
                                    </div>
                                  </div>
                                  
                                  {(token.motivoAdicao || token.adicionadoPorAdmin) && (
                                    <div className="mt-3 pt-3 border-t border-red-200">
                                      {token.adicionadoPorAdmin && (
                                        <div className="mb-2">
                                          <span className="text-red-600 text-sm">Adicionado por:</span>
                                          <p className="text-sm font-medium text-red-700">
                                            {typeof token.adicionadoPorAdmin === 'object' 
                                              ? token.adicionadoPorAdmin.nome 
                                              : 'Admin'
                                            }
                                          </p>
                                        </div>
                                      )}
                                      {token.motivoAdicao && (
                                        <div>
                                          <span className="text-red-600 text-sm">Motivo:</span>
                                          <p className="text-sm text-red-700 italic">"{token.motivoAdicao}"</p>
                                        </div>
                                      )}
                                    </div>
                                  )}
                                </div>
                              );
                            })}
                            
                            {detailedStatus.expiredTokens.length > 3 && (
                              <div className="text-center py-2">
                                <p className="text-sm text-gray-500">
                                  ... e mais {detailedStatus.expiredTokens.length - 3} token{detailedStatus.expiredTokens.length - 3 !== 1 ? 's' : ''} expirado{detailedStatus.expiredTokens.length - 3 !== 1 ? 's' : ''}
                                </p>
                              </div>
                            )}
                          </div>
                        </div>
                      )}

                      {/* No Tokens Message */}
                      {(!detailedStatus?.activeTokens?.length && !detailedStatus?.expiredTokens?.length) && (
                        <div className="text-center py-8">
                          <div className="w-16 h-16 mx-auto mb-4 bg-gray-100 rounded-full flex items-center justify-center">
                            <Info className="w-8 h-8 text-gray-400" />
                          </div>
                          <p className="text-gray-600 font-medium">Nenhum token encontrado</p>
                          <p className="text-sm text-gray-500 mt-1">
                            Este personal trainer não possui tokens ativos ou expirados recentes.
                          </p>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        )}

        {mode === 'assign-plan' && (
          <div className="space-y-6">
            <div>
              <Label htmlFor="plano" className="text-base font-medium">Selecione o Plano</Label>
              <Select value={assignForm.planoId} onValueChange={(value) => setAssignForm({ ...assignForm, planoId: value })}>
                <SelectTrigger className="mt-2">
                  <SelectValue placeholder={planos.length === 0 ? "Nenhum plano disponível" : "Escolha um plano"} />
                </SelectTrigger>
                <SelectContent>
                  {planos.length === 0 ? (
                    <SelectItem value="empty" disabled>
                      <span className="text-gray-500">Nenhum plano disponível</span>
                    </SelectItem>
                  ) : (
                    planos.map((plano) => (
                      <SelectItem key={plano._id} value={plano._id}>
                        <div className="flex items-center justify-between w-full">
                          <div className="flex flex-col">
                            <span className="font-medium">{plano.nome}</span>
                            <span className="text-xs text-gray-500">
                              {plano.limiteAlunos} alunos • R$ {plano.preco.toFixed(2)} • {plano.duracao} dias
                            </span>
                          </div>
                        </div>
                      </SelectItem>
                    ))
                  )}
                </SelectContent>
              </Select>
              {planos.length === 0 && (
                <Alert className="mt-2">
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>
                    Nenhum plano disponível. Entre em contato com o administrador.
                  </AlertDescription>
                </Alert>
              )}
              
              {/* Plan Preview */}
              {selectedPlan && (
                <div className="mt-4 p-4 bg-blue-50 rounded-lg border border-blue-200">
                  <h4 className="font-medium text-blue-800 mb-2">Preview do Plano Selecionado</h4>
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                      <span className="text-blue-600">Nome:</span>
                      <p className="font-medium">{selectedPlan.nome}</p>
                    </div>
                    <div>
                      <span className="text-blue-600">Limite:</span>
                      <p className="font-medium">{selectedPlan.limiteAlunos} alunos</p>
                    </div>
                    <div>
                      <span className="text-blue-600">Preço:</span>
                      <p className="font-medium">R$ {selectedPlan.preco.toFixed(2)}</p>
                    </div>
                    <div>
                      <span className="text-blue-600">Duração:</span>
                      <p className="font-medium">{selectedPlan.duracao} dias</p>
                    </div>
                  </div>
                  {selectedPlan.descricao && (
                    <div className="mt-2">
                      <span className="text-blue-600">Descrição:</span>
                      <p className="text-sm text-gray-700">{selectedPlan.descricao}</p>
                    </div>
                  )}
                </div>
              )}
            </div>

            <div>
              <Label htmlFor="customDuration" className="text-base font-medium">Duração Customizada (dias)</Label>
              <Input
                id="customDuration"
                type="number"
                min="1"
                placeholder={selectedPlan ? `Padrão: ${selectedPlan.duracao} dias` : "Deixe vazio para usar duração padrão"}
                value={assignForm.customDuration || ''}
                onChange={(e) => setAssignForm({ 
                  ...assignForm, 
                  customDuration: e.target.value ? parseInt(e.target.value) : undefined 
                })}
                className="mt-2"
              />
              <p className="text-sm text-gray-500 mt-1">
                Opcional. Se não informado, será usado a duração padrão do plano.
              </p>
            </div>

            <div>
              <Label htmlFor="motivo" className="text-base font-medium">Motivo da Atribuição</Label>
              <Textarea
                id="motivo"
                placeholder="Descreva o motivo desta atribuição..."
                value={assignForm.motivo}
                onChange={(e) => setAssignForm({ ...assignForm, motivo: e.target.value })}
                className="mt-2"
                rows={3}
              />
            </div>
          </div>
        )}

        {mode === 'add-tokens' && (
          <div className="space-y-6">
            <div>
              <Label htmlFor="quantidade" className="text-base font-medium">Quantidade de Tokens</Label>
              <Input
                id="quantidade"
                type="number"
                min="1"
                value={tokenForm.quantidade}
                onChange={(e) => setTokenForm({ ...tokenForm, quantidade: parseInt(e.target.value) || 1 })}
                className="mt-2"
              />
              <p className="text-sm text-gray-500 mt-1">
                Número de tokens avulsos para adicionar ao personal.
              </p>
            </div>

            <div>
              <Label htmlFor="customDays" className="text-base font-medium">Validade (dias)</Label>
              <Input
                id="customDays"
                type="number"
                min="1"
                value={tokenForm.customDays}
                onChange={(e) => setTokenForm({ ...tokenForm, customDays: parseInt(e.target.value) || 30 })}
                className="mt-2"
              />
              <p className="text-sm text-gray-500 mt-1">
                Período de validade dos tokens em dias.
              </p>
            </div>

            <div>
              <Label htmlFor="motivoToken" className="text-base font-medium">Motivo da Adição</Label>
              <Textarea
                id="motivoToken"
                placeholder="Descreva o motivo desta adição de tokens..."
                value={tokenForm.motivo}
                onChange={(e) => setTokenForm({ ...tokenForm, motivo: e.target.value })}
                className="mt-2"
                rows={3}
              />
            </div>

            {/* Token Preview */}
            <div className="p-4 bg-green-50 rounded-lg border border-green-200">
              <h4 className="font-medium text-green-800 mb-2">Preview dos Tokens</h4>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="text-green-600">Quantidade:</span>
                  <p className="font-medium">{tokenForm.quantidade} tokens</p>
                </div>
                <div>
                  <span className="text-green-600">Validade:</span>
                  <p className="font-medium">{tokenForm.customDays} dias</p>
                </div>
              </div>
              <div className="mt-2">
                <span className="text-green-600">Vencimento:</span>
                <p className="text-sm text-gray-700">
                  {new Date(Date.now() + tokenForm.customDays * 24 * 60 * 60 * 1000).toLocaleDateString('pt-BR')}
                </p>
              </div>
            </div>
          </div>
        )}

        <DialogFooter>
          {mode === 'view' && (
            <>
              <Button 
                variant="outline" 
                onClick={() => setMode('add-tokens')}
                disabled={loadingStatus}
              >
                Adicionar Tokens
              </Button>
              <Button 
                onClick={() => setMode('assign-plan')}
                disabled={loadingStatus}
              >
                Atribuir Plano
              </Button>
            </>
          )}
          
          {mode === 'assign-plan' && (
            <>
              <Button variant="outline" onClick={() => setMode('view')}>
                Voltar
              </Button>
              <Button 
                onClick={handleAssignPlan} 
                disabled={!assignForm.planoId || planos.length === 0 || loading}
              >
                {loading ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Atribuindo...
                  </>
                ) : (
                  'Atribuir Plano'
                )}
              </Button>
            </>
          )}
          
          {mode === 'add-tokens' && (
            <>
              <Button variant="outline" onClick={() => setMode('view')}>
                Voltar
              </Button>
              <Button 
                onClick={handleAddTokens} 
                disabled={tokenForm.quantidade < 1 || loading}
              >
                {loading ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Adicionando...
                  </>
                ) : (
                  'Adicionar Tokens'
                )}
              </Button>
            </>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/dialogs/admin/VisualizarPersonalModal.tsx =====
// client/src/components/dialogs/admin/VisualizarPersonalModal.tsx
import React from 'react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from '@/components/ui/badge';
import { Loader2, UserCircle, Mail, ShieldCheck, CalendarDays, Link2, Users, BarChartHorizontalBig, Info, Crown, Zap, Clock, XCircle } from 'lucide-react';
// <<< INÍCIO DA ALTERAÇÃO: Importa os tipos do local compartilhado >>>
import { PersonalDetalhes, AlunoParaModal } from '@shared/types/personal';
// <<< FIM DA ALTERAÇÃO >>>


interface VisualizarPersonalModalProps {
  isOpen: boolean;
  onClose: () => void;
  personal: PersonalDetalhes | null;
  isLoading?: boolean;
  // <<< INÍCIO DA ALTERAÇÃO: A prop agora usa o tipo importado >>>
  alunosDoPersonal: AlunoParaModal[];
  // <<< FIM DA ALTERAÇÃO >>>
}

const formatDate = (dateString?: Date | string): string => {
  if (!dateString) return 'N/A';
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) {
        return 'Data inválida';
    }
    return date.toLocaleDateString('pt-BR', {
      day: '2-digit', month: '2-digit', year: 'numeric',
    });
  } catch (e) {
    return String(dateString);
  }
};

const InfoItem: React.FC<{ label: string; value?: string | number | React.ReactNode; isMonospace?: boolean; icon?: React.ReactNode }> = ({ label, value, isMonospace, icon }) => (
  <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between py-2.5 border-b border-gray-200 dark:border-gray-700 last:border-b-0">
    <dt className="text-sm font-medium text-gray-500 dark:text-gray-400 flex items-center min-w-[160px] sm:min-w-fit mb-1 sm:mb-0">
      {icon && <span className="mr-2 shrink-0">{icon}</span>}
      {label}:
    </dt>
    <dd className={`text-sm text-gray-900 dark:text-gray-100 sm:text-right ${isMonospace ? 'font-mono text-xs break-all' : 'break-words'}`}>
      {value ?? <span className="text-gray-400 dark:text-gray-500 italic">Não informado</span>}
    </dd>
  </div>
);

const AlunoAssociationCard: React.FC<{ aluno: AlunoParaModal }> = ({ aluno }) => {
    const getSlotIcon = () => {
        if (aluno.status === 'inactive') return <XCircle className="h-4 w-4 text-gray-500" />;
        if (aluno.slotType === 'plan') return <Crown className="h-4 w-4 text-purple-500" />;
        if (aluno.slotType === 'token') return <Zap className="h-4 w-4 text-yellow-500" />;
        return <Info className="h-4 w-4 text-gray-500" />;
    };
    const getSlotLabel = () => {
        if (aluno.status === 'inactive') return 'Inativo';
        if (aluno.slotType === 'plan') return 'Vaga do Plano';
        if (aluno.slotType === 'token') return 'Token Avulso';
        return 'Não associado';
    };
    const getSlotColorClass = () => {
        if (aluno.status === 'inactive') return 'bg-gray-100 dark:bg-gray-800 border-gray-300 dark:border-gray-600';
        if (aluno.slotType === 'plan') return 'bg-purple-50 dark:bg-purple-900/30 border-purple-300 dark:border-purple-700';
        if (aluno.slotType === 'token') return 'bg-yellow-50 dark:bg-yellow-900/30 border-yellow-300 dark:border-yellow-700';
        return 'bg-gray-100 dark:bg-gray-800 border-gray-300 dark:border-gray-600';
    };

    return (
        <div className={`p-3 rounded-lg border ${getSlotColorClass()}`}>
            <div className="flex justify-between items-start">
                <div>
                    <p className="font-semibold text-sm">{aluno.nome}</p>
                    <p className="text-xs text-muted-foreground">{aluno.email}</p>
                </div>
                <div className="flex items-center gap-1.5 text-xs font-medium">
                    {getSlotIcon()}
                    {getSlotLabel()}
                </div>
            </div>
            {aluno.status === 'active' && aluno.slotEndDate && (
                 <div className="mt-2 pt-2 border-t text-xs text-muted-foreground flex items-center gap-1.5">
                    <Clock className="h-3 w-3" />
                    <span>Expira em: {formatDate(aluno.slotEndDate)}</span>
                 </div>
            )}
        </div>
    );
};

export default function VisualizarPersonalModal({ isOpen, onClose, personal, isLoading, alunosDoPersonal }: VisualizarPersonalModalProps) {
  if (!isOpen) return null;
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-lg md:max-w-2xl">
        <DialogHeader>
          <DialogTitle className="flex items-center text-2xl">
            <UserCircle className="mr-3 h-7 w-7 text-primary" />
            Detalhes do Personal Trainer
          </DialogTitle>
          {personal && !isLoading && (
            <DialogDescription>
              Informações detalhadas sobre {personal.nome}.
            </DialogDescription>
          )}
        </DialogHeader>
        
        {isLoading && (
          <div className="py-12 flex flex-col justify-center items-center">
            <Loader2 className="h-10 w-10 animate-spin text-primary" />
            <span className="mt-3 text-gray-600 dark:text-gray-400">Carregando detalhes...</span>
          </div>
        )}

        {!isLoading && personal && (
          <div className="py-4 space-y-4 max-h-[65vh] overflow-y-auto pr-3 -mr-3 custom-scrollbar">
            {/* --- SEÇÃO DE DADOS GERAIS --- */}
            <InfoItem label="Nome Completo" value={personal.nome} icon={<UserCircle className="h-4 w-4 text-gray-500"/>} />
            <InfoItem label="Email" value={personal.email} icon={<Mail className="h-4 w-4 text-gray-500"/>} />
            <InfoItem 
              label="Função (Role)" 
              icon={<ShieldCheck className="h-4 w-4 text-gray-500"/>}
              value={
                <Badge variant={personal.role === 'Admin' ? 'destructive' : 'default'}
                       className={`font-medium ${personal.role === 'Admin' ? 
                                  'bg-red-100 text-red-700 dark:bg-red-900/60 dark:text-red-300 border-red-300 dark:border-red-700' : 
                                  'bg-blue-100 text-blue-700 dark:bg-sky-900/60 dark:text-sky-300 border-blue-300 dark:border-sky-700'}`}>
                  {personal.role === 'Admin' && <ShieldCheck className="mr-1.5 h-3.5 w-3.5" />}
                  {personal.role}
                </Badge>
              }
            />
            <InfoItem label="Data de Cadastro" value={formatDate(personal.createdAt)} icon={<CalendarDays className="h-4 w-4 text-gray-500"/>} />
            
            {/* --- SEÇÃO DE ASSINATURA --- */}
            <h3 className="text-md font-semibold pt-4 text-gray-700 dark:text-gray-300 border-t mt-4">Assinatura</h3>
            <InfoItem label="Status" icon={<Info className="h-4 w-4 text-gray-500"/>} value={<Badge variant={personal.statusAssinatura === 'ativa' ? 'success' : 'secondary'}>{personal.statusAssinatura || 'Não definida'}</Badge>} />
            <InfoItem label="Plano" value={personal.plano?.nome || 'Não definido'} icon={<BarChartHorizontalBig className="h-4 w-4 text-gray-500"/>} />
            <InfoItem label="Limite de Alunos" value={personal.limiteAlunos} icon={<Users className="h-4 w-4 text-gray-500"/>} />
            <InfoItem label="Fim da Assinatura" value={formatDate(personal.dataFimAssinatura)} icon={<CalendarDays className="h-4 w-4 text-gray-500"/>} />
            
            {/* <<< INÍCIO DA ALTERAÇÃO: Nova seção para listar alunos e seus slots >>> */}
            <h3 className="text-md font-semibold pt-4 text-gray-700 dark:text-gray-300 border-t mt-4">Alunos Associados ({alunosDoPersonal.length})</h3>
            <div className="space-y-2">
                {alunosDoPersonal.length > 0 ? (
                    alunosDoPersonal.map(aluno => (
                        <AlunoAssociationCard key={aluno._id} aluno={aluno} />
                    ))
                ) : (
                    <p className="text-sm text-center text-muted-foreground py-4">Nenhum aluno associado.</p>
                )}
            </div>
            {/* <<< FIM DA ALTERAÇÃO >>> */}

            {personal.tokenCadastroAluno && (
              <>
                <h3 className="text-md font-semibold pt-4 text-gray-700 dark:text-gray-300 border-t mt-4">Link de Cadastro</h3>
                <InfoItem label="Token" value={personal.tokenCadastroAluno} isMonospace icon={<Link2 className="h-4 w-4 text-gray-500"/>} />
              </>
            )}
          </div>
        )}

        {!isLoading && !personal && isOpen && (
             <div className="py-8 text-center text-gray-500 dark:text-gray-400">Não foi possível carregar os dados do personal.</div>
        )}

        <DialogFooter className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <Button variant="outline" onClick={onClose}>Fechar</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/layout/AlunoSidebar.tsx =====
// Caminho: ./client/src/components/layout/AlunoSidebar.tsx
// <<< ALTERAÇÃO: 'React' foi removido da importação pois não é mais necessário >>>
import { Link, useLocation } from "wouter";
import { Home, ListChecks, History, LogOut } from "lucide-react"; 
import { useAluno, AlunoLogado } from "@/context/AlunoContext";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

const AlunoSidebarLinks = [
  { href: "/aluno/dashboard", label: "Meu Painel", icon: Home },
  { href: "/aluno/meus-treinos", label: "Minhas Fichas", icon: ListChecks },
  { href: "/aluno/historico", label: "Meu Histórico", icon: History },
];

interface AlunoSidebarProps {
  onNavigate?: () => void;
}

const getAlunoDisplayName = (currentAluno: AlunoLogado | null): string => {
  if (!currentAluno) return "Aluno";
  return currentAluno.nome || currentAluno.email || "Aluno";
};

const getAlunoInitials = (currentAluno: AlunoLogado | null): string => {
  if (!currentAluno || !currentAluno.nome) return '?';
  const names = currentAluno.nome.split(' ');
  const firstInitial = names[0]?.[0] || '';
  const lastInitial = names.length > 1 ? names[names.length - 1]?.[0] || '' : '';
  const initials = `${firstInitial}${lastInitial}`.toUpperCase();
  return initials.length > 0 ? initials : (currentAluno.email?.[0]?.toUpperCase() || '?');
};


export default function AlunoSidebar({ onNavigate }: AlunoSidebarProps) {
  const [location] = useLocation();
  const { aluno, logoutAluno } = useAluno();

  const handleLinkClick = () => {
    if (onNavigate) {
      onNavigate();
    }
  };

  const handleLogoutClick = () => {
    logoutAluno();
    if (onNavigate) {
      onNavigate();
    }
  };
  
  const isActive = (path: string): boolean => {
    if (path === "/aluno/dashboard") {
      return location === path;
    }
    return location.startsWith(path);
  };

  const getLinkClasses = (path: string): string => {
    return `flex items-center px-3 py-2.5 rounded-lg transition-colors duration-150 text-sm w-full text-left ${
      isActive(path)
        ? "bg-primary text-primary-foreground hover:bg-primary/90 dark:bg-primary dark:text-primary-foreground dark:hover:bg-primary/90"
        : "text-foreground/70 hover:text-foreground hover:bg-muted/50 dark:text-foreground/60 dark:hover:text-foreground dark:hover:bg-muted/30"
    }`;
  };

  if (!aluno) {
    return null; 
  }

  return (
    <aside className="flex flex-col h-full bg-card text-card-foreground border-r dark:border-border/50">
      <div className="flex flex-col items-center justify-center h-auto px-6 py-4 border-b dark:border-border/50 shrink-0">
        <img
          src="/logodyfit.png"
          alt="Logo DyFit"
          className="h-12 w-auto object-contain mb-3"
        />
        <Avatar className="h-16 w-16 mb-2 border-2 border-primary">
          <AvatarFallback className="bg-primary/10 text-primary text-xl font-semibold">
            {getAlunoInitials(aluno)}
          </AvatarFallback>
        </Avatar>
        <p className="font-medium text-md truncate">
          {getAlunoDisplayName(aluno)}
        </p>
        <p className="text-xs text-muted-foreground">
          Aluno DyFit
        </p>
      </div>

      <div className="overflow-y-auto flex-1 py-4 px-3">
        <nav className="space-y-1.5">
          {AlunoSidebarLinks.map((link) => (
            <Link key={link.label} href={link.href} onClick={handleLinkClick} className={getLinkClasses(link.href)}>
              <link.icon className="w-5 h-5 mr-3 shrink-0" />
              <span className="truncate">{link.label}</span>
            </Link>
          ))}
        </nav>
      </div>

      <div className="mt-auto p-3 border-t dark:border-border/50">
        <Button
          variant="ghost"
          onClick={handleLogoutClick}
          className="w-full justify-start text-foreground/70 hover:text-foreground hover:bg-muted/50 dark:text-foreground/60 dark:hover:text-foreground dark:hover:bg-muted/30"
        >
          <LogOut className="w-5 h-5 mr-3" />
          Sair
        </Button>
      </div>
    </aside>
  );
}
===== ./client/src/components/layout/header.tsx =====
// Caminho: ./client/src/components/layout/header.tsx
import { useState, useContext } from "react";
import { Menu, X, LogOut, User as UserIcon, ChevronDown } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import Sidebar from "./sidebar";
import AlunoSidebar from "./AlunoSidebar";
import WorkoutMiniPlayerHeader from "@/components/WorkoutMiniPlayerHeader";
import { UserContext } from "@/context/UserContext";
import { useAluno } from "@/context/AlunoContext";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Link as WouterLink } from "wouter";
import { cn } from "@/lib/utils";

interface HeaderProps {
  isScrolled: boolean;
  isAluno: boolean;
}

export default function Header({ isScrolled, isAluno }: HeaderProps) {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const { user, logout: logoutUser } = useContext(UserContext);
  const { aluno, logoutAluno } = useAluno();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const closeMobileMenu = () => setIsMobileMenuOpen(false);

  const getInitials = (
    currentUser: { firstName?: string; lastName?: string; nome?: string } | null
  ): string => {
    if (!currentUser) return "?";
    const first =
      currentUser.firstName?.[0] || currentUser.nome?.split(" ")[0][0] || "";
    const last =
      currentUser.lastName?.[0] ||
      (currentUser.nome?.includes(" ")
        ? currentUser.nome.split(" ").pop()?.[0]
        : "") ||
      "";
    const initials = `${first}${last}`.toUpperCase();
    return initials.length > 0
      ? initials
      : currentUser.nome?.[0]?.toUpperCase() || "?";
  };

  const getFullName = (
    currentUser:
      | { firstName?: string; lastName?: string; nome?: string; email?: string }
      | null
  ): string => {
    if (!currentUser) return "Usuário";
    return (
      `${currentUser.firstName || ""} ${currentUser.lastName || ""}`.trim() ||
      currentUser.nome ||
      currentUser.email ||
      "Usuário"
    );
  };

  const activeMobileLogoutFunction = () => {
    if (aluno) logoutAluno();
    else if (user) logoutUser();
    closeMobileMenu();
  };

  const headerClasses = cn(
    "sticky top-0 z-20 transition-all duration-300 ease-in-out transform",
    {
      "opacity-0 -translate-y-full pointer-events-none": !isScrolled,
      "opacity-100 translate-y-0": isScrolled,
      "bg-transparent border-transparent text-white": isAluno && !isScrolled,
      "glass bg-white/10 border-white/20 text-white": isAluno && isScrolled,
      "glass bg-card/95 border-border/50 text-card-foreground shadow-glass": !isAluno,
      "shadow-elevated": !isAluno && isScrolled,
      "shadow-none border-transparent": !isAluno && !isScrolled,
    }
  );

  const MobileHeader = () => (
    <header
      className={cn("md:hidden flex items-center justify-between h-16 px-4", headerClasses)}
    >
      <div className="flex items-center">
        <Sheet open={isMobileMenuOpen} onOpenChange={setIsMobileMenuOpen}>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon">
              <Menu size={24} />
            </Button>
          </SheetTrigger>
          <SheetContent
            side="left"
            className="p-0 w-72 bg-card border-r dark:border-border/50"
          >
            {aluno ? (
              <AlunoSidebar onNavigate={closeMobileMenu} />
            ) : user ? (
              <Sidebar onNavigate={closeMobileMenu} />
            ) : null}
          </SheetContent>
        </Sheet>
        <img
          src={
            isAluno && !isScrolled ? "/images/logo-branco.png" : "/logodyfit.png"
          }
          alt="Logo DyFit"
          className="ml-4 h-8 w-auto"
        />
      </div>
      
      <div className="flex items-center space-x-2 sm:space-x-4">
        {/* Workout Mini Player in Header */}
        <WorkoutMiniPlayerHeader isScrolled={isScrolled} isAluno={isAluno} />
        
        {(aluno || user) && (
          <Button
            variant="ghost"
            size="icon"
            onClick={activeMobileLogoutFunction}
            className="hover:text-destructive/80"
            title="Sair"
          >
            <LogOut size={20} />
          </Button>
        )}
      </div>
      {isSearchOpen && (
        <div className="absolute inset-0 bg-background z-30 p-4 flex items-center">
          <div className="relative flex-1">
            <UserIcon className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              type="search"
              placeholder="Pesquisar..."
              className="pl-8 w-full"
              autoFocus
            />
          </div>
          <button type="button" className="ml-2" onClick={() => setIsSearchOpen(false)}>
            <X size={24} />
          </button>
        </div>
      )}
    </header>
  );

  const displayUserForDesktopHeader = aluno && !user ? aluno : user;
  const logoutForDesktopHeader = () => {
    if (aluno && !user) logoutAluno();
    else if (user) logoutUser();
  };

  return (
    <>
      <div className="hidden md:block">
        <header className={cn("flex items-center justify-end h-16 px-6", headerClasses)}>
          <div className="flex items-center space-x-4">
            {/* Workout Mini Player in Desktop Header */}
            <WorkoutMiniPlayerHeader isScrolled={isScrolled} isAluno={!!aluno} />
            
            {displayUserForDesktopHeader && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    className={cn("flex items-center gap-2 px-2 py-1 h-auto rounded-full", {
                      "text-white hover:text-white/90": isAluno && !isScrolled,
                      "text-card-foreground": !isAluno || isScrolled,
                    })}
                  >
                    <Avatar className="h-8 w-8">
                      <AvatarFallback className="bg-primary/10 text-primary text-xs">
                        {getInitials(displayUserForDesktopHeader)}
                      </AvatarFallback>
                    </Avatar>
                    <span className="text-sm font-medium hidden lg:inline">
                      {getFullName(displayUserForDesktopHeader).split(" ")[0]}
                    </span>
                    <ChevronDown className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent className="w-56" align="end" forceMount>
                  <DropdownMenuLabel className="font-normal">
                    <div className="flex flex-col space-y-1">
                      <p className="text-sm font-medium leading-none">
                        {getFullName(displayUserForDesktopHeader)}
                      </p>
                      <p className="text-xs leading-none text-muted-foreground">
                        {displayUserForDesktopHeader.email}
                      </p>
                    </div>
                  </DropdownMenuLabel>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem asChild>
                    <WouterLink href="/perfil/editar">
                      <UserIcon className="mr-2 h-4 w-4" />
                      <span>Editar Perfil</span>
                    </WouterLink>
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={logoutForDesktopHeader}
                    className="text-destructive focus:text-destructive-foreground focus:bg-destructive/80 cursor-pointer"
                  >
                    <LogOut className="mr-2 h-4 w-4" />
                    <span>Sair</span>
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            )}
          </div>
        </header>
      </div>
      <div className="md:hidden">
        <MobileHeader />
      </div>
    </>
  );
}

===== ./client/src/components/layout/main-layout.tsx =====
// Caminho: ./client/src/components/layout/main-layout.tsx
import { ReactNode, useContext, useState, useRef, useEffect } from "react";
import Sidebar from "./sidebar";
import AlunoSidebar from "./AlunoSidebar";
import Header from "./header";
import MobileNav from "./mobile-nav";
import { UserContext } from "@/context/UserContext";
import { useAluno } from "@/context/AlunoContext";
import { cn } from "@/lib/utils";

export default function MainLayout({ children }: { children: ReactNode }) {
  const { user } = useContext(UserContext);
  const { aluno } = useAluno();
  
  const [isScrolled, setIsScrolled] = useState(false);
  const mainScrollRef = useRef<HTMLDivElement>(null);

  const DesktopSpecificSidebar = aluno && !user ? AlunoSidebar : (user ? Sidebar : null);
  
  // Modern gradient backgrounds for different user types
  const backgroundClass = aluno 
    ? "bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500" 
    : user?.role?.toLowerCase() === 'admin'
    ? "bg-gradient-to-br from-slate-900 via-purple-900 to-indigo-900"
    : "bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 dark:from-slate-900 dark:via-blue-900 dark:to-indigo-900";
  
  // Content container styling
  const contentContainerClass = aluno 
    ? "bg-transparent" 
    : "bg-background/95 backdrop-blur-sm";

  useEffect(() => {
    const mainEl = mainScrollRef.current;
    if (!mainEl) return;
    const handleScroll = () => { setIsScrolled(mainEl.scrollTop > 0); };
    mainEl.addEventListener('scroll', handleScroll);
    return () => { mainEl.removeEventListener('scroll', handleScroll); };
  }, []);

  return (
    <div className={cn("flex h-screen transition-all duration-500", backgroundClass)}>
      {DesktopSpecificSidebar && (
        <div className="hidden md:flex md:flex-shrink-0">
          <div className="flex flex-col w-64 lg:w-72 bg-card/95 backdrop-blur-md text-card-foreground border-r border-border shadow-xl">
            <DesktopSpecificSidebar />
          </div>
        </div>
      )}

      <div className={cn("flex flex-col flex-1 w-0 text-foreground overflow-hidden", contentContainerClass)}>
        <Header isScrolled={isScrolled} isAluno={!!aluno} />

        <main ref={mainScrollRef} className="flex-1 relative overflow-y-auto focus:outline-none scrollbar-hide">
          <div className="p-4 md:p-6 pb-16 md:pb-6 animate-fade-in">
            {children}
          </div>
        </main>
      </div>

      {(user || aluno) && <MobileNav />}
    </div>
  );
}

===== ./client/src/components/layout/mobile-nav.tsx =====
// Caminho: ./client/src/components/layout/mobile-nav.tsx
import { useState } from 'react';
import { Link as WouterLink, useLocation } from "wouter"; 
import { Home, Users, Dumbbell, Menu as MenuIcon, ListChecks, UserCog, List } from "lucide-react";
import { useUser } from "@/context/UserContext";
import { useAluno } from "@/context/AlunoContext";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import Sidebar from "./sidebar";
import AlunoSidebar from "./AlunoSidebar";


export default function MobileNav() {
  const [location] = useLocation();
  const { user } = useUser();
  const { aluno } = useAluno();

  const [isSheetOpen, setIsSheetOpen] = useState(false);
  const closeSheet = () => setIsSheetOpen(false);

  const isActive = (path: string): boolean => {
    if (path === "/aluno/dashboard" || path === "/" || path === "/admin") {
        return location === path;
    }
    return location.startsWith(path);
  };
  
  const getNavLinkClasses = (path: string): string => {
    return `flex flex-col items-center justify-center flex-1 py-2 text-xs
      ${isActive(path) ? "text-primary dark:text-primary" : "text-muted-foreground hover:text-foreground"
    }`;
  };
  
  const getButtonSheetClasses = (): string => {
      return `flex flex-col items-center justify-center flex-1 py-2 text-xs text-muted-foreground hover:text-foreground`;
  };


  if (aluno) {
    return (
      <nav className="md:hidden mobile-nav-fixed bg-card border-t border-border flex justify-around items-stretch h-16 z-20">
        <WouterLink href="/aluno/dashboard" className={getNavLinkClasses("/aluno/dashboard")}>
          <Home size={22} strokeWidth={isActive("/aluno/dashboard") ? 2.5 : 2} />
          <span className="mt-1">Início</span>
        </WouterLink>
        
        <WouterLink href="/aluno/meus-treinos" className={getNavLinkClasses("/aluno/meus-treinos")}>
          <ListChecks size={22} strokeWidth={isActive("/aluno/meus-treinos") ? 2.5 : 2} />
          <span className="mt-1">Fichas</span>
        </WouterLink>
        
        <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
          <SheetTrigger asChild>
            <button className={getButtonSheetClasses()}>
              <MenuIcon size={22} strokeWidth={2} />
              <span className="mt-1">Mais</span>
            </button>
          </SheetTrigger>
          <SheetContent side="left" className="p-0 w-72 bg-card border-r dark:border-border/50">
            <AlunoSidebar onNavigate={closeSheet} />
          </SheetContent>
        </Sheet>
      </nav>
    );
  } else if (user && user.role?.toLowerCase() === 'admin') {
    return (
      <nav className="md:hidden fixed bottom-0 left-0 right-0 bg-card border-t border-border flex justify-around items-stretch h-16 z-20">
        <WouterLink href="/admin" className={getNavLinkClasses("/admin")}>
          <Home size={22} strokeWidth={isActive("/admin") ? 2.5 : 2} />
          <span className="mt-1">Início</span>
        </WouterLink>
        {/* <<< INÍCIO DA ALTERAÇÃO >>> */}
        <WouterLink href="/admin/personais" className={getNavLinkClasses("/admin/personais")}>
          <UserCog size={22} strokeWidth={isActive("/admin/personais") ? 2.5 : 2} />
          <span className="mt-1">Personais</span>
        </WouterLink>
        <WouterLink href="/exercises" className={getNavLinkClasses("/exercises")}>
          <List size={22} strokeWidth={isActive("/exercises") ? 2.5 : 2} />
          <span className="mt-1">Exercícios</span>
        </WouterLink>
        {/* <<< FIM DA ALTERAÇÃO >>> */}
        <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
          <SheetTrigger asChild>
            <button className={getButtonSheetClasses()}>
              <MenuIcon size={22} strokeWidth={2} />
              <span className="mt-1">Menu</span>
            </button>
          </SheetTrigger>
          <SheetContent side="left" className="p-0 w-72 bg-card border-r dark:border-border/50">
            <Sidebar onNavigate={closeSheet} /> 
          </SheetContent>
        </Sheet>
      </nav>
    );
  } else if (user) {
    return (
      <nav className="md:hidden mobile-nav-fixed bg-card border-t border-border flex justify-around items-stretch h-16 z-20">
        <WouterLink href="/" className={getNavLinkClasses("/")}>
          <Home size={22} strokeWidth={isActive("/") ? 2.5 : 2} />
          <span className="mt-1">Início</span>
        </WouterLink>
        <WouterLink href="/alunos" className={getNavLinkClasses("/alunos")}>
          <Users size={22} strokeWidth={isActive("/alunos") ? 2.5 : 2} />
          <span className="mt-1">Alunos</span>
        </WouterLink>
        <WouterLink href="/treinos" className={getNavLinkClasses("/treinos")}>
          <Dumbbell size={22} strokeWidth={isActive("/treinos") ? 2.5 : 2} />
          <span className="mt-1">Treinos</span>
        </WouterLink>
        <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
          <SheetTrigger asChild>
            <button className={getButtonSheetClasses()}>
              <MenuIcon size={22} strokeWidth={2} />
              <span className="mt-1">Menu</span>
            </button>
          </SheetTrigger>
          <SheetContent side="left" className="p-0 w-72 bg-card border-r dark:border-border/50">
            <Sidebar onNavigate={closeSheet} /> 
          </SheetContent>
        </Sheet>
      </nav>
    );
  }

  return null;
}
===== ./client/src/components/layout/sidebar.tsx =====
// client/src/components/layout/sidebar.tsx
import { Link, useLocation } from "wouter";
import { Home, Users, Dumbbell, List, LogOut, UserCog, Mail, CreditCard, Briefcase, RefreshCw, FileText } from "lucide-react";
import { useUser, User } from "@/context/UserContext";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

// <<< CORREÇÃO: Link para Gerenciar Exercícios RESTAURADO para o Admin >>>
const adminSidebarLinks = [
  { href: "/admin", label: "Início", icon: Home },
  { href: "/admin/personais", label: "Gerenciar Personais", icon: UserCog },
  { href: "/admin/planos", label: "Gerenciar Planos", icon: CreditCard },
  { href: "/admin/convites", label: "Gerenciar Convites", icon: Mail },
  { href: "/admin/solicitacoes-renovacao", label: "Solicitações de Renovação", icon: FileText },
  { href: "/exercises", label: "Gerenciar Exercícios", icon: List },
];

const personalSidebarLinks = [
  { href: "/meu-plano", label: "Meu Plano", icon: Briefcase },
  { href: "/solicitar-renovacao", label: "Solicitar Renovação", icon: RefreshCw },
  { href: "/alunos", label: "Alunos", icon: Users },
  { href: "/treinos", label: "Treinos", icon: Dumbbell },
  { href: "/exercises", label: "Exercícios", icon: List },
];


interface SidebarProps {
  onNavigate?: () => void;
}

export default function Sidebar({ onNavigate }: SidebarProps) {
  const [location] = useLocation();
  const { user, logout: logoutUser } = useUser();

  const handleLinkClick = () => { if (onNavigate) onNavigate(); };
  const handleLogoutClick = () => { logoutUser(); if (onNavigate) onNavigate(); };

  const isActive = (path: string): boolean => {
    // A rota exata deve ser ativa
    if (path === location) return true;
    // Para rotas com sub-rotas, mas não para as raízes
    if (path !== '/' && path !== '/admin' && location.startsWith(path)) {
        return true;
    }
    return false;
  };

  const getLinkClasses = (path: string): string => {
    return `flex items-center px-3 py-2.5 rounded-lg transition-colors duration-150 text-sm w-full text-left ${
      isActive(path)
        ? "bg-primary text-white font-medium dark:bg-sky-600 dark:text-white"
        : "text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700"
    }`;
  };
  
  const getDisplayName = (currentUser: User | null): string => {
    if (!currentUser) return "Usuário";
    return `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim();
  };

  const getInitials = (currentUser: User | null): string => {
    if (!currentUser) return '?';
    const first = currentUser.firstName?.[0] || '';
    const last = currentUser.lastName?.[0] || '';
    const initials = `${first}${last}`.toUpperCase();
    return initials.length > 0 ? initials : (currentUser.username?.[0]?.toUpperCase()) || '?';
  };

  if (!user) return null;

  const isAdmin = user.role?.toLowerCase() === 'admin';
  const linksToShow = isAdmin ? adminSidebarLinks : personalSidebarLinks;
  const homeLink = isAdmin ? "/admin" : "/";

  return (
    <aside className="flex flex-col h-full md:w-64 lg:w-72 border-r bg-white dark:bg-gray-800 dark:border-gray-700 z-30 overflow-y-auto">
      <div className="flex items-center justify-center h-auto px-6 py-4 border-b shrink-0">
        <Link href={homeLink} onClick={handleLinkClick}>
            <img src="/logodyfit.png" alt="Logo DyFit" className="h-14 w-auto object-contain cursor-pointer" />
        </Link>
      </div>
      <div className="flex-1 py-4 px-3">
        <div className="mb-6">
          <div className="flex items-center space-x-3 px-3 py-2">
            <Avatar className="h-10 w-10 border-2 border-primary dark:border-sky-500 shrink-0">
              <AvatarFallback className="font-semibold bg-muted">{getInitials(user)}</AvatarFallback>
            </Avatar>
            <div className="truncate">
              <p className="font-semibold text-sm text-gray-900 dark:text-gray-100 truncate">{getDisplayName(user)}</p>
              <p className="text-xs text-gray-500 dark:text-gray-400 capitalize truncate">{user.role}</p>
            </div>
          </div>
        </div>
        
        <nav className="space-y-1">
          {linksToShow.map((link) => (
            <Link key={link.href} href={link.href} onClick={handleLinkClick} className={getLinkClasses(link.href)}>
              <link.icon className="w-5 h-5 mr-3" />
              {link.label}
            </Link>
          ))}
        </nav>
      </div>
      <div className="mt-auto p-3 border-t">
        <Button variant="ghost" onClick={handleLogoutClick} className="w-full justify-start text-gray-600 hover:bg-gray-100 dark:text-gray-300 dark:hover:bg-gray-700">
          <LogOut className="w-5 h-5 mr-3" />
          Sair
        </Button>
      </div>
    </aside>
  );
}
===== ./client/src/components/modalConfirmacao.tsx =====
import { motion, AnimatePresence } from "framer-motion";

interface ModalConfirmacaoProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  titulo?: string;
  mensagem?: string;
  textoConfirmar?: string;
  textoCancelar?: string;
}

export function ModalConfirmacao({
  isOpen,
  onClose,
  onConfirm,
  titulo = "Confirmação",
  mensagem = "Tem certeza que deseja continuar?",
  textoConfirmar = "Confirmar",
  textoCancelar = "Cancelar",
}: ModalConfirmacaoProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className="bg-white p-6 rounded-lg shadow-lg w-full max-w-sm"
            initial={{ scale: 0.9, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.9, opacity: 0 }}
            transition={{ duration: 0.2 }}
          >
            <h2 className="text-lg font-semibold mb-4">{titulo}</h2>
            <p className="mb-6">{mensagem}</p>
            <div className="flex justify-end gap-4">
              <button
                className="px-4 py-2 bg-gray-300 text-gray-800 rounded hover:bg-gray-400 transition"
                onClick={onClose}
              >
                {textoCancelar}
              </button>
              <button
                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition"
                onClick={onConfirm}
              >
                {textoConfirmar}
              </button>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

===== ./client/src/components/rotinas/MoverParaPastaMenu.tsx =====
// client/src/components/rotinas/MoverParaPastaMenu.tsx
import React from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
// =======================================================
// --- CORREÇÃO: Importando do arquivo correto ---
import { apiRequest } from '@/lib/queryClient';
// =======================================================
import { DropdownMenuItem, DropdownMenuPortal, DropdownMenuSub, DropdownMenuSubContent, DropdownMenuSubTrigger } from '@/components/ui/dropdown-menu';
import { Folder, FolderPlus, Trash2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import type { Pasta } from '@/pages/treinos/index';

interface MoverParaPastaMenuProps {
  rotinaId: string;
  pastas: Pasta[];
  onActionComplete?: () => void; // Tornando opcional
}

export const MoverParaPastaMenu: React.FC<MoverParaPastaMenuProps> = ({ rotinaId, pastas, onActionComplete }) => {
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const mutation = useMutation<any, Error, { pastaId: string | null }>({
    mutationFn: ({ pastaId }) => apiRequest("PUT", `/api/treinos/${rotinaId}/pasta`, { pastaId }),
    onSuccess: () => {
      toast({ title: "Sucesso!", description: "Rotina movida." });
      queryClient.invalidateQueries({ queryKey: ["/api/treinos"] });
      if (onActionComplete) onActionComplete();
    },
    onError: (error) => toast({ variant: "destructive", title: "Erro", description: error.message }),
  });

  const handleMove = (pastaId: string | null) => {
    mutation.mutate({ pastaId });
  };

  return (
    <DropdownMenuSub>
      <DropdownMenuSubTrigger>
        <FolderPlus className="mr-2 h-4 w-4" />
        <span>Mover para Pasta</span>
      </DropdownMenuSubTrigger>
      <DropdownMenuPortal>
        <DropdownMenuSubContent>
          <DropdownMenuItem onClick={() => handleMove(null)}>
            <Trash2 className="mr-2 h-4 w-4 text-red-500" />
            <span>Remover da Pasta</span>
          </DropdownMenuItem>
          <div className="my-1 border-t"></div>
          {pastas.map(pasta => (
            <DropdownMenuItem key={pasta._id} onClick={() => handleMove(pasta._id)}>
              <Folder className="mr-2 h-4 w-4" />
              <span>{pasta.nome}</span>
            </DropdownMenuItem>
          ))}
          {pastas.length === 0 && <DropdownMenuItem disabled>Nenhuma pasta criada</DropdownMenuItem>}
        </DropdownMenuSubContent>
      </DropdownMenuPortal>
    </DropdownMenuSub>
  );
};
===== ./client/src/components/rotinas/RotinaCard.tsx =====
// client/src/components/rotinas/RotinaCard.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Edit, Trash2, Eye, CopyPlus, User, Folder as FolderIcon, BookCopy } from 'lucide-react'; // Importado BookCopy
import type { RotinaListagemItem } from '@/types/treinoOuRotinaTypes';
import type { Pasta } from '@/pages/treinos/index';

interface RotinaCardProps {
  rotina: RotinaListagemItem;
  pastas: Pasta[];
  alunoNome?: string;
  onView: (rotina: RotinaListagemItem) => void;
  onEdit: (rotina: RotinaListagemItem) => void;
  onDelete: (rotina: RotinaListagemItem) => void;
  onAssign: (rotinaId: string, rotinaTitulo: string) => void;
  onMoveToFolder: (rotinaId: string, pastaId: string) => void;
  onRemoveFromFolder: (rotinaId: string) => void;
  onConvertToModel: (rotina: RotinaListagemItem) => void; // Nova prop para converter para modelo
}

export const RotinaCard: React.FC<RotinaCardProps> = ({ 
  rotina, 
  pastas,
  alunoNome, 
  onView, 
  onEdit, 
  onDelete, 
  onAssign,
  onMoveToFolder,
  onRemoveFromFolder,
  onConvertToModel // Nova prop
}) => {
  const isModelo = rotina.tipo === 'modelo';
  const diasDeTreinoCount = Array.isArray(rotina.diasDeTreino) ? rotina.diasDeTreino.length : 0;
  const pastaAtualId = typeof rotina.pastaId === 'object' ? rotina.pastaId?._id : rotina.pastaId;

  const outrasPastas = pastas.filter(p => p._id !== pastaAtualId);

  const ActionButton = ({ title, onClick, children, className }: { title: string, onClick: () => void, children: React.ReactNode, className?: string }) => (
    <TooltipProvider delayDuration={200}>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button 
            variant="ghost" 
            size="sm" 
            className={`h-8 w-8 p-0 transition-all duration-200 ${className}`} 
            onClick={onClick}
          >
            {children}
          </Button>
        </TooltipTrigger>
        <TooltipContent side="top" className="text-xs">
          <p>{title}</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );

  return (
    <Card className="group card-hover-lift flex flex-col h-full shadow-md border border-border/60 bg-amber-50 backdrop-blur-sm overflow-hidden">
      <CardHeader className="pb-3">
        <div className="flex justify-between items-start">
          <CardTitle className="text-base font-bold text-zinc-800 flex items-center gap-2 group-hover:text-primary transition-colors duration-200 flex-1 min-w-0" title={rotina.titulo}>
            {/* Icon based on type */}
            <div className={`w-2 h-2 rounded-full flex-shrink-0 ${isModelo ? 'bg-primary' : 'bg-accent'} animate-pulse`} />
            <span className="truncate">{rotina.titulo}</span>
          </CardTitle>
        </div>
        {rotina.descricao && (
          <CardDescription 
            className="text-xs text-zinc-500 leading-relaxed overflow-hidden"
            style={{
              display: '-webkit-box',
              WebkitLineClamp: 2,
              WebkitBoxOrient: 'vertical',
              textOverflow: 'ellipsis'
            }}
            title={rotina.descricao}
          >
            {rotina.descricao}
          </CardDescription>
        )}
      </CardHeader>
      
      <CardContent className="flex-grow pt-2 pb-4 space-y-3">
        <div className="flex flex-wrap gap-2">
          <span className="bg-indigo-100 text-indigo-700 px-2 py-1 rounded text-xs">
            {`${diasDeTreinoCount} Dia${diasDeTreinoCount !== 1 ? 's' : ''}`}
          </span>
          <span className={
            isModelo 
              ? "bg-emerald-100 text-emerald-700 px-2 py-1 rounded text-xs" 
              : "bg-orange-100 text-orange-700 px-2 py-1 rounded text-xs"
          }>
            {isModelo ? 'Modelo' : 'Individual'}
          </span>
        </div>
        
        {!isModelo && alunoNome && (
            <div className="flex items-center text-sm text-zinc-600 pt-1 bg-zinc-100 rounded-lg p-2 border border-zinc-200">
                <User className="h-4 w-4 mr-2 shrink-0 text-accent" />
                <span className="truncate font-medium" title={alunoNome}>{alunoNome}</span>
            </div>
        )}
      </CardContent>

      <CardFooter className="p-3 border-t border-zinc-200 bg-zinc-50 flex justify-between items-center gap-2 mt-auto rounded-b-lg">
        <div className="flex-1">
          {isModelo && (
            <Popover>
              <TooltipProvider delayDuration={200}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <PopoverTrigger asChild>
                      <Button 
                        variant="ghost" 
                        size="sm" 
                        className="h-8 w-8 p-0 hover:bg-primary/10 hover:text-primary transition-all duration-200"
                      >
                        <FolderIcon className="h-4 w-4" />
                      </Button>
                    </PopoverTrigger>
                  </TooltipTrigger>
                  <TooltipContent><p>Mover para Pasta</p></TooltipContent>
                </Tooltip>
              </TooltipProvider>
              <PopoverContent className="w-56 p-2 border border-border/60 bg-card/95 backdrop-blur-sm">
                <div className="grid gap-1">
                  <p className="font-semibold text-sm px-2 py-1.5 text-muted-foreground">Mover para...</p>
                  
                  {outrasPastas.length > 0 ? (
                    outrasPastas.map(p => (
                      <Button 
                        key={p._id} 
                        variant="ghost" 
                        className="w-full justify-start text-sm hover:bg-primary/10 hover:text-primary transition-colors" 
                        onClick={() => onMoveToFolder(rotina._id, p._id)}
                      >
                        {p.nome}
                      </Button>
                    ))
                  ) : (
                    <p className="text-xs text-muted-foreground px-2 py-1.5">Nenhuma outra pasta disponível.</p>
                  )}
                  {pastaAtualId && (
                    <>
                      <hr className="my-1 border-border/40"/>
                      <Button 
                        variant="ghost" 
                        className="w-full justify-start text-sm text-destructive hover:text-destructive hover:bg-destructive/10 transition-colors" 
                        onClick={() => onRemoveFromFolder(rotina._id)}
                      >
                        Remover da Pasta Atual
                      </Button>
                    </>
                  )}
                </div>
              </PopoverContent>
            </Popover>
          )}
        </div>

        <div className="flex items-center gap-1 flex-shrink-0">
          <ActionButton 
            title="Visualizar" 
            onClick={() => onView(rotina)}
            className="hover:bg-primary/10 hover:text-primary"
          >
            <Eye className="h-4 w-4" />
          </ActionButton>
          
          {isModelo && (
            <ActionButton 
              title="Atribuir a Aluno" 
              onClick={() => onAssign(rotina._id, rotina.titulo)}
              className="hover:bg-secondary/10 hover:text-secondary"
            >
              <CopyPlus className="h-4 w-4" />
            </ActionButton>
          )}
          
          {!isModelo && (
            <ActionButton 
              title="Tornar Modelo" 
              onClick={() => onConvertToModel(rotina)}
              className="hover:bg-accent/10 hover:text-accent"
            >
              <BookCopy className="h-4 w-4" />
            </ActionButton>
          )}
          
          <ActionButton 
            title="Editar" 
            onClick={() => onEdit(rotina)}
            className="hover:bg-primary/10 hover:text-primary"
          >
            <Edit className="h-4 w-4" />
          </ActionButton>
          
          <ActionButton 
            title="Excluir" 
            onClick={() => onDelete(rotina)} 
            className="hover:bg-destructive/10 hover:text-destructive"
          >
            <Trash2 className="h-4 w-4" />
          </ActionButton>
        </div>
      </CardFooter>
    </Card>
  );
};

===== ./client/src/components/ui/ActionsAluno.tsx =====
// client/src/components/ui/ActionsAluno.tsx
import React from 'react';
import { Button } from "@/components/ui/button";
import { 
    DropdownMenu, 
    DropdownMenuContent, 
    DropdownMenuItem, 
    DropdownMenuTrigger 
} from "@/components/ui/dropdown-menu";
import { Pencil, Trash2, MoreVertical } from 'lucide-react'; 

// --- INTERFACE CORRIGIDA ---
interface ActionsAlunoProps {
  onEdit: () => void;    // Função chamada ao clicar em Editar
  onDelete: () => void;  // Função chamada ao clicar em Excluir
}
// --- FIM DA CORREÇÃO ---

const ActionsAluno: React.FC<ActionsAlunoProps> = ({ onEdit, onDelete }) => {
  
  const handleEdit = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Edit button clicked'); // Debug log
    onEdit();
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Delete button clicked'); // Debug log
    onDelete();
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button 
          variant="ghost" 
          size="icon" 
          title="Mais ações"
          className="h-8 w-8" // Tamanho consistente com o botão de visualizar
        > 
          <MoreVertical className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end"> 
        {/* Editar */}
        <DropdownMenuItem onClick={handleEdit}>
          <Pencil className="mr-2 h-4 w-4" /> 
          <span>Editar</span>
        </DropdownMenuItem>
        {/* Excluir */}
        <DropdownMenuItem 
          onClick={handleDelete}
          className="text-red-600 focus:text-red-700 focus:bg-red-50" 
        >
          <Trash2 className="mr-2 h-4 w-4" /> 
          <span>Excluir</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export default ActionsAluno;
===== ./client/src/components/ui/ActionsExercicio.tsx =====
// client/src/components/ui/ActionsExercicio.tsx
// (Assumindo estrutura similar aos outros componentes com botões)
import React from 'react'; // Import React
import { Button } from "@/components/ui/button";
import { Pencil, Trash, Star } from "lucide-react";
import { useToast } from "@/hooks/use-toast"; // <<< USA O HOOK

interface ActionsExercicioProps {
  exercicioId: string;
  isFavorito?: boolean;
  isCustom?: boolean; // Para saber se pode editar/excluir
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
  onToggleFavorite: (id: string, currentState: boolean) => void;
}

export default function ActionsExercicio({
  exercicioId,
  isFavorito = false,
  isCustom = false,
  onEdit,
  onDelete,
  onToggleFavorite,
}: ActionsExercicioProps) {
  const { toast } = useToast(); // <<< USA O HOOK

  const handleEdit = () => {
    if (isCustom) {
      onEdit(exercicioId);
    } else {
      toast({ variant: "destructive", title: "Ação não permitida", description: "Exercícios do App não podem ser editados." });
    }
  };

  const handleDelete = () => {
    if (isCustom) {
      onDelete(exercicioId); // A confirmação deve estar no componente pai ou no botão de delete
    } else {
      toast({ variant: "destructive", title: "Ação não permitida", description: "Exercícios do App não podem ser excluídos." });
    }
  };

  const handleFavorite = () => {
    onToggleFavorite(exercicioId, isFavorito);
  };

  return (
    <div className="flex justify-end items-center space-x-1">
       {/* Mostrar Editar/Excluir apenas se for custom */}
       {isCustom && (
          <>
             <Button variant="ghost" size="icon" className="h-8 w-8 text-gray-500 hover:text-blue-600" title="Editar" onClick={handleEdit}>
                 <Pencil className="w-4 h-4" />
             </Button>
             {/* O botão de Delete pode ser o ExerciseDeleteButton que já usa AlertDialog */}
             {/* <ExerciseDeleteButton exercicioId={exercicioId} onDeleted={() => onDelete(exercicioId)} /> */}
             {/* Ou um botão simples que chama onDelete (pai lida com confirmação) */}
             <Button variant="ghost" size="icon" className="h-8 w-8 text-red-500 hover:text-red-700" title="Excluir" onClick={handleDelete}>
                 <Trash className="w-4 h-4" />
             </Button>
          </>
       )}
        <Button variant="ghost" size="icon" className={`h-8 w-8 ${isFavorito ? 'text-yellow-500 hover:text-yellow-600' : 'text-gray-400 hover:text-yellow-500'}`} title={isFavorito ? "Desfavoritar" : "Favoritar"} onClick={handleFavorite}>
            <Star className={`w-4 h-4 ${isFavorito ? 'fill-current' : ''}`} />
        </Button>
    </div>
  );
}
===== ./client/src/components/ui/ModalEditarAluno.tsx =====
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Loader2 } from "lucide-react"; // Import Loader2
import { formatDateForInput } from "@/utils/dateUtils";

// Interface Original para dados do Aluno (como vem da API ou é esperado no submit final)
interface AlunoEditData {
    _id?: string;
    nome?: string;
    email?: string;
    birthDate?: string;
    gender?: string;
    goal?: string;
    weight?: number | null;
    height?: number | null;
    startDate?: string;
    phone?: string;
    status?: 'active' | 'inactive';
    notes?: string;
    trainerId?: string; // Fixed: should be string, not number
}

// NOVA Interface para o ESTADO do formulário (permite string para campos numéricos durante digitação)
interface AlunoFormDataState {
    _id?: string;
    nome?: string;
    email?: string;
    birthDate?: string;
    gender?: string;
    goal?: string;
    weight?: string | number | null; // Permite string
    height?: string | number | null; // Permite string
    startDate?: string;
    phone?: string;
    status?: 'active' | 'inactive';
    notes?: string;
    trainerId?: string | null; // Fixed: should be string, not number
}


interface ModalEditarAlunoProps {
  isOpen: boolean;
  onClose: () => void;
  aluno: AlunoEditData | null; // Recebe o tipo original
  atualizarAlunos: () => void;
}

export function ModalEditarAluno({ isOpen, onClose, aluno, atualizarAlunos }: ModalEditarAlunoProps) {
  const { toast } = useToast();
  // Usa a NOVA interface para o estado do formulário
  const [formData, setFormData] = useState<AlunoFormDataState>({});
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (aluno && isOpen) {
        // Ao popular o estado, converte números para string para os inputs text
      setFormData({
        ...aluno,
        birthDate: formatDateForInput(aluno.birthDate),
        startDate: formatDateForInput(aluno.startDate),
        // Converte para string ao carregar no estado, ou usa '' se for null/undefined
        weight: aluno.weight !== null && aluno.weight !== undefined ? String(aluno.weight) : '',
        height: aluno.height !== null && aluno.height !== undefined ? String(aluno.height) : '',
        trainerId: aluno.trainerId || '', // trainerId is already a string
      });
    }
    // Não limpar o form ao fechar para não causar piscar de dados se reabrir rápido
    // else if (!isOpen) {
    //    setFormData({});
    // }
  }, [aluno, isOpen]);

  // handleChange agora está consistente com o tipo AlunoFormDataState (que permite string)
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

   // handleSelectChange também está consistente
   const handleSelectChange = (name: keyof AlunoFormDataState) => (value: string) => {
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async () => {
    if (!aluno?._id) {
        toast({ title: "ID do aluno não encontrado", variant: "destructive" });
        return;
    }

    // Basic validation for required fields
    if (!formData.nome?.trim()) {
        toast({ title: "Nome é obrigatório", variant: "destructive" });
        return;
    }
    if (!formData.email?.trim()) {
        toast({ title: "Email é obrigatório", variant: "destructive" });
        return;
    }
    if (!formData.birthDate) {
        toast({ title: "Data de nascimento é obrigatória", variant: "destructive" });
        return;
    }
    if (!formData.gender) {
        toast({ title: "Gênero é obrigatório", variant: "destructive" });
        return;
    }
    if (!formData.goal) {
        toast({ title: "Objetivo é obrigatório", variant: "destructive" });
        return;
    }
    if (!formData.startDate) {
        toast({ title: "Data de início é obrigatória", variant: "destructive" });
        return;
    }
    if (!formData.status) {
        toast({ title: "Status é obrigatório", variant: "destructive" });
        return;
    }

    setIsLoading(true);

    // Prepara os dados para enviar, convertendo de volta para número onde necessário
    const dataToSend: AlunoEditData = { // Envia o tipo esperado pela API
        _id: formData._id, // Mantém o ID se necessário na API
        nome: formData.nome,
        email: formData.email,
        birthDate: formData.birthDate,
        gender: formData.gender,
        goal: formData.goal,
        phone: formData.phone,
        status: formData.status,
        notes: formData.notes,

        weight: formData.weight !== null && formData.weight !== undefined && String(formData.weight).trim() !== ''
                 ? parseFloat(String(formData.weight).replace(',', '.'))
                 : null,
        height: formData.height !== null && formData.height !== undefined && String(formData.height).trim() !== ''
                ? parseInt(String(formData.height), 10)
                : null,
        startDate: formData.startDate, // Garanta que esteja no formato correto se necessário

        trainerId: formData.trainerId && String(formData.trainerId).trim() !== ''
                 ? String(formData.trainerId).trim()
                 : undefined, // trainerId is string, not number
    };

    // Validação simples antes de enviar
    // Verifica se, após a conversão, o resultado é NaN (Not a Number)
    if ((dataToSend.weight !== null && isNaN(dataToSend.weight)) || 
        (dataToSend.height !== null && isNaN(dataToSend.height))) {
       toast({ title: "Peso ou Altura contém valor inválido.", variant: "destructive" });
       setIsLoading(false);
       return;
     }

    // Remover campos não editáveis ou que a API não espera no PUT
    // delete dataToSend._id; // Exemplo: remover _id do corpo

    try {
      // Use the correct API endpoint
      const response = await fetch(`/api/alunos/gerenciar/${aluno._id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(dataToSend),
      });

      if (response.ok) {
        toast({ title: "Aluno atualizado com sucesso!" });
        atualizarAlunos();
        onClose();
      } else {
         const errorData = await response.json().catch(() => null);
        toast({
            title: "Erro ao atualizar aluno",
            description: errorData?.message || errorData?.erro || `Status: ${response.status}`,
            variant: "destructive"
        });
      }
    } catch (error) {
      console.error("Erro ao editar aluno:", error);
      toast({ title: "Erro de conexão ao salvar", variant: "destructive" });
    } finally {
        setIsLoading(false);
    }
  };

   if (!isOpen || !aluno) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      {/* Conteúdo do Dialog (mantido igual ao anterior, pois a lógica de UI não mudou) */}
      <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Editar Aluno</DialogTitle>
           <DialogDescription>Atualize as informações de {aluno?.nome || 'aluno'}.</DialogDescription>
        </DialogHeader>

        <div className="grid gap-4 py-4">
          {/* Linha 1: Nome */}
          <div className="grid grid-cols-4 items-center gap-4">
             <Label htmlFor="nome" className="text-right">Nome*</Label>
            <Input id="nome" name="nome" value={formData.nome || ""} onChange={handleChange} className="col-span-3" placeholder="Nome completo" />
          </div>
           {/* Linha 2: Email */}
           <div className="grid grid-cols-4 items-center gap-4">
             <Label htmlFor="email" className="text-right">Email*</Label>
            <Input id="email" name="email" type="email" value={formData.email || ""} onChange={handleChange} className="col-span-3" placeholder="email@exemplo.com" />
          </div>
           {/* Linha 3: Telefone */}
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="phone" className="text-right">Telefone</Label>
            <Input id="phone" name="phone" value={formData.phone || ""} onChange={handleChange} className="col-span-3" placeholder="(00) 00000-0000" />
          </div>
          {/* Linha 4: Data Nasc e Gênero */}
          <div className="grid grid-cols-2 gap-4">
             <div>
                <Label htmlFor="birthDate">Data de Nascimento*</Label>
                <Input id="birthDate" name="birthDate" type="date" value={formData.birthDate || ""} onChange={handleChange} />
             </div>
              <div>
                 <Label htmlFor="gender">Gênero*</Label>
                 <Select name="gender" value={formData.gender || ""} onValueChange={handleSelectChange('gender')}>
                     <SelectTrigger id="gender"><SelectValue placeholder="Selecione" /></SelectTrigger>
                     <SelectContent>
                         <SelectItem value="Masculino">Masculino</SelectItem>
                         <SelectItem value="Feminino">Feminino</SelectItem>
                         <SelectItem value="Outro">Outro</SelectItem>
                     </SelectContent>
                 </Select>
             </div>
          </div>
          {/* Linha 5: Peso e Altura */}
           <div className="grid grid-cols-2 gap-4">
             <div>
                 <Label htmlFor="weight">Peso (kg)</Label>
                 <Input
                    id="weight"
                    name="weight"
                    type="text"
                    inputMode="decimal"
                    // Usa o valor do estado (que pode ser string, number ou null)
                    // ?? '' garante que se for null/undefined, o input fique vazio
                    value={formData.weight ?? ''}
                    onChange={handleChange}
                    placeholder="Ex: 75,5"
                 />
             </div>
             <div>
                <Label htmlFor="height">Altura (cm)</Label>
                 <Input
                    id="height"
                    name="height"
                    type="text"
                    inputMode="numeric"
                    value={formData.height ?? ''}
                    onChange={handleChange}
                    placeholder="Ex: 178"
                 />
             </div>
           </div>
          {/* Linha 6: Objetivo */}
          <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="goal" className="text-right">Objetivo*</Label>
              <Select name="goal" value={formData.goal || ""} onValueChange={handleSelectChange('goal')} >
                 <SelectTrigger className="col-span-3"><SelectValue placeholder="Selecione o objetivo" /></SelectTrigger>
                 <SelectContent>
                    <SelectItem value="Hipertrofia">Hipertrofia</SelectItem>
                    <SelectItem value="Emagrecimento">Emagrecimento</SelectItem>
                    <SelectItem value="Reabilitação">Reabilitação</SelectItem>
                    <SelectItem value="Condicionamento físico">Condicionamento físico</SelectItem>
                    <SelectItem value="Definição muscular">Definição muscular</SelectItem>
                    <SelectItem value="Manutenção">Manutenção</SelectItem>
                    <SelectItem value="Preparação para competição">Preparação para competição</SelectItem>
                    <SelectItem value="Outros">Outros</SelectItem>
                 </SelectContent>
              </Select>
          </div>
          {/* Linha 7: Data Início e Status */}
           <div className="grid grid-cols-2 gap-4">
              <div>
                <Label htmlFor="startDate">Data de Início*</Label>
                <Input id="startDate" name="startDate" type="date" value={formData.startDate || ""} onChange={handleChange} />
              </div>
              <div>
                 <Label htmlFor="status">Status*</Label>
                 <Select name="status" value={formData.status || ""} onValueChange={handleSelectChange('status')}>
                     <SelectTrigger id="status"><SelectValue placeholder="Selecione" /></SelectTrigger>
                     <SelectContent>
                         <SelectItem value="active">Ativo</SelectItem>
                         <SelectItem value="inactive">Inativo</SelectItem>
                     </SelectContent>
                 </Select>
              </div>
           </div>
           {/* Linha 8: Notas */}
           <div className="grid grid-cols-4 items-start gap-4">
             <Label htmlFor="notes" className="text-right pt-2">Notas</Label>
             <Textarea id="notes" name="notes" value={formData.notes || ""} onChange={handleChange} placeholder="Observações adicionais..." className="col-span-3" rows={3} />
           </div>
          {/* Linha 9: Trainer ID (Comentado - descomente e ajuste se precisar editar) */}
          {/* <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="trainerId" className="text-right">ID Personal</Label>
            <Input id="trainerId" name="trainerId" type="text" inputMode="numeric" value={formData.trainerId ?? ''} onChange={handleChange} className="col-span-3" />
          </div> */}
        </div>

        {/* Botões */}
        <div className="flex justify-end gap-2 pt-4">
          <Button variant="outline" onClick={onClose} disabled={isLoading}>
            Cancelar
          </Button>
          <Button onClick={handleSubmit} disabled={isLoading}>
             {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {isLoading ? 'Salvando...' : 'Salvar Alterações'}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/ui/TesteBotao.tsx =====
import { Pencil, Trash2 } from "lucide-react";

export default function TesteBotao() {
  function handleEdit() {
    console.log("✅ Botão editar funcionando!");
    alert("Botão de Editar Funcionando!");
  }

  function handleDelete() {
    console.log("✅ Botão excluir funcionando!");
    alert("Botão de Excluir Funcionando!");
  }

  return (
    <div className="flex gap-4 p-8">
      <button
        onClick={handleEdit}
        className="flex items-center justify-center h-10 w-10 rounded-md bg-gray-100 hover:bg-gray-300 transition"
      >
        <Pencil className="h-5 w-5 text-black pointer-events-auto" />
      </button>

      <button
        onClick={handleDelete}
        className="flex items-center justify-center h-10 w-10 rounded-md bg-gray-100 hover:bg-gray-300 transition"
      >
        <Trash2 className="h-5 w-5 text-black pointer-events-auto" />
      </button>
    </div>
  );
}

===== ./client/src/components/ui/accordion.tsx =====
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

===== ./client/src/components/ui/alert-dialog.tsx =====
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

===== ./client/src/components/ui/alert.tsx =====
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

===== ./client/src/components/ui/aspect-ratio.tsx =====
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

===== ./client/src/components/ui/avatar.tsx =====
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

===== ./client/src/components/ui/badge.tsx =====
// client/src/components/ui/badge.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-3 py-1 text-xs font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-gradient-to-r from-primary to-primary/90 text-primary-foreground hover:shadow-lg hover:shadow-primary/25",
        secondary:
          "border-transparent bg-gradient-to-r from-secondary to-secondary/90 text-secondary-foreground hover:shadow-lg hover:shadow-secondary/25",
        destructive:
          "border-transparent bg-gradient-to-r from-destructive to-destructive/90 text-destructive-foreground hover:shadow-lg hover:shadow-destructive/25",
        success:
          "border-transparent bg-gradient-to-r from-success to-success/90 text-success-foreground hover:shadow-lg hover:shadow-success/25",
        warning:
          "border-transparent bg-gradient-to-r from-warning to-warning/90 text-warning-foreground hover:shadow-lg hover:shadow-warning/25",
        outline:
          "text-foreground border-border hover:bg-accent hover:text-accent-foreground",
        glass:
          "glass bg-white/10 text-white border-white/20 hover:bg-white/20",
      },
      size: {
        default: "px-3 py-1 text-xs",
        sm: "px-2 py-0.5 text-2xs",
        lg: "px-4 py-1.5 text-sm",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, size, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant, size }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
===== ./client/src/components/ui/breadcrumb.tsx =====
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

===== ./client/src/components/ui/button.tsx =====
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { Loader2 } from "lucide-react"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-xl text-sm font-medium ring-offset-background transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 interactive touch-target",
  {
    variants: {
      variant: {
        default: "bg-gradient-to-r from-primary to-primary/90 text-primary-foreground hover:from-primary/90 hover:to-primary shadow-md hover:shadow-lg hover:shadow-primary/25",
        destructive: "bg-gradient-to-r from-destructive to-destructive/90 text-destructive-foreground hover:from-destructive/90 hover:to-destructive shadow-md hover:shadow-lg hover:shadow-destructive/25",
        outline: "border-2 border-input bg-transparent hover:bg-accent hover:text-accent-foreground hover:border-accent",
        secondary: "bg-gradient-to-r from-secondary to-secondary/90 text-secondary-foreground hover:from-secondary/90 hover:to-secondary shadow-md hover:shadow-lg hover:shadow-secondary/25",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        success: "bg-gradient-to-r from-success to-success/90 text-success-foreground hover:from-success/90 hover:to-success shadow-md hover:shadow-lg hover:shadow-success/25",
        warning: "bg-gradient-to-r from-warning to-warning/90 text-warning-foreground hover:from-warning/90 hover:to-warning shadow-md hover:shadow-lg hover:shadow-warning/25",
        glass: "glass bg-white/10 text-white border border-white/20 hover:bg-white/20 shadow-glass",
      },
      size: {
        default: "h-11 px-6 py-2",
        sm: "h-9 rounded-lg px-4",
        lg: "h-12 rounded-xl px-8 text-base",
        xl: "h-14 rounded-xl px-10 text-lg",
        icon: "h-11 w-11",
        "icon-sm": "h-9 w-9 rounded-lg",
        "icon-lg": "h-12 w-12",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
  loading?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, loading, children, disabled, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        disabled={disabled || loading}
        {...props}
      >
        {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
        {children}
      </Comp>
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

===== ./client/src/components/ui/calendar.tsx =====
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

===== ./client/src/components/ui/card.tsx =====
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow-elevated hover:shadow-xl transition-all duration-300 interactive",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-2 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground leading-relaxed", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

===== ./client/src/components/ui/carousel.tsx =====
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}

===== ./client/src/components/ui/chart.tsx =====
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}

===== ./client/src/components/ui/checkbox.tsx =====
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

===== ./client/src/components/ui/collapsible.tsx =====
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

===== ./client/src/components/ui/command.tsx =====
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

===== ./client/src/components/ui/context-menu.tsx =====
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

===== ./client/src/components/ui/dashboard/AlunosAtivosList.tsx =====
// client/src/components/ui/dashboard/AlunosAtivosList.tsx
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Link } from "wouter";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Skeleton } from "@/components/ui/skeleton";
import { Eye, Pencil, Search, MoreVertical, UserPlus } from "lucide-react";
import { fetchWithAuth } from "@/lib/apiClient";
import ErrorMessage from "@/components/ErrorMessage";
import { Aluno } from "@/types/aluno";
import AlunoViewModal from "@/components/dialogs/AlunoViewModal";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

// Componente de Card para um único aluno - Design moderno e responsivo
const AlunoAtivoCard = ({ student, onView }: { student: Aluno, onView: (s: Aluno) => void }) => {
    const getInitials = (nome: string) => {
        const partes = nome.split(' ').filter(Boolean);
        if (partes.length > 1) return `${partes[0][0]}${partes[partes.length - 1][0]}`.toUpperCase();
        return partes[0] ? partes[0].substring(0, 2).toUpperCase() : '?';
    };

    return (
        <div className="group relative flex items-center justify-between p-4 md:p-5 border-b last:border-b-0 
                        hover:bg-gradient-to-r hover:from-blue-50/80 hover:via-indigo-50/40 hover:to-purple-50/80 
                        dark:hover:from-blue-900/20 dark:hover:via-indigo-900/10 dark:hover:to-purple-900/20 
                        transition-all duration-300 ease-out cursor-pointer
                        hover:shadow-md hover:-translate-y-0.5 hover:scale-[1.01]
                        active:scale-[0.99] active:transition-transform active:duration-75">
            
            {/* Subtle gradient overlay on hover */}
            <div className="absolute inset-0 bg-gradient-to-r from-blue-500/5 via-indigo-500/5 to-purple-500/5 
                            opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg" />
            
            <div className="relative flex items-center gap-3 md:gap-4 flex-1 min-w-0">
                <Avatar className="ring-2 ring-blue-100 dark:ring-blue-900/30 
                                 group-hover:ring-blue-200 dark:group-hover:ring-blue-800/50
                                 group-hover:scale-110 transition-all duration-300 
                                 shadow-lg group-hover:shadow-xl">
                    <AvatarFallback className="bg-gradient-to-br from-blue-500 via-indigo-500 to-purple-600 
                                             text-white font-semibold text-xs md:text-sm
                                             group-hover:from-blue-600 group-hover:via-indigo-600 group-hover:to-purple-700
                                             transition-all duration-300">
                        {getInitials(student.nome)}
                    </AvatarFallback>
                </Avatar>
                <div className="flex-1 min-w-0 space-y-1">
                    <h4 className="font-semibold text-sm md:text-base text-gray-800 dark:text-gray-100 
                                   group-hover:text-blue-700 dark:group-hover:text-blue-300 
                                   transition-colors duration-300 truncate">
                        {student.nome}
                    </h4>
                    <p className="text-xs md:text-sm text-gray-500 dark:text-gray-400 
                                  group-hover:text-gray-600 dark:group-hover:text-gray-300 
                                  transition-colors duration-300 truncate">
                        {student.email || "Email não disponível"}
                    </p>
                </div>
            </div>
            
            <DropdownMenu>
                <DropdownMenuTrigger asChild>
                    <Button variant="ghost" 
                            size="icon" 
                            className="relative h-9 w-9 md:h-10 md:w-10 min-h-[44px] min-w-[44px] 
                                     hover:bg-white/80 dark:hover:bg-slate-700/80 
                                     hover:shadow-lg hover:scale-110 
                                     active:scale-95 transition-all duration-200 
                                     group-hover:bg-white/50 dark:group-hover:bg-slate-600/50
                                     backdrop-blur-sm border border-transparent
                                     hover:border-blue-200 dark:hover:border-blue-700">
                        <MoreVertical className="h-4 w-4 text-gray-600 dark:text-gray-300 
                                               hover:text-blue-600 dark:hover:text-blue-400 
                                               transition-colors duration-200" />
                    </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" 
                                   className="bg-white/95 dark:bg-slate-800/95 backdrop-blur-md 
                                            border border-white/20 dark:border-slate-700/50 
                                            shadow-xl rounded-lg animate-in fade-in-0 zoom-in-95 
                                            slide-in-from-top-2 duration-200">
                    <DropdownMenuItem 
                        onClick={() => onView(student)} 
                        className="hover:bg-blue-50 dark:hover:bg-blue-900/30 
                                 focus:bg-blue-50 dark:focus:bg-blue-900/30 
                                 transition-colors duration-200 cursor-pointer">
                        <Eye className="mr-2 h-4 w-4 text-blue-600 dark:text-blue-400" /> 
                        <span className="font-medium">Visualizar</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem asChild>
                        <Link href={`/alunos/editar/${student._id}`} 
                              className="flex items-center hover:bg-indigo-50 dark:hover:bg-indigo-900/30 
                                       focus:bg-indigo-50 dark:focus:bg-indigo-900/30 
                                       transition-colors duration-200 cursor-pointer
                                       px-2 py-1.5 text-sm rounded-sm">
                            <Pencil className="mr-2 h-4 w-4 text-indigo-600 dark:text-indigo-400" /> 
                            <span className="font-medium">Editar Aluno</span>
                        </Link>
                    </DropdownMenuItem>
                </DropdownMenuContent>
            </DropdownMenu>
        </div>
    );
};

// Componente principal da lista
export function AlunosAtivosList({ trainerId }: { trainerId: string }) {
    const [searchQuery, setSearchQuery] = useState("");
    const [selectedStudent, setSelectedStudent] = useState<Aluno | null>(null);
    const [isViewModalOpen, setIsViewModalOpen] = useState(false);

    const { data: students = [], isLoading, isError, error } = useQuery<Aluno[], Error>({
        queryKey: ['alunosAtivos', trainerId],
        queryFn: () => fetchWithAuth<Aluno[]>(`/api/aluno/gerenciar?status=active&trainerId=${trainerId}`),
        retry: 1,
        enabled: !!trainerId,
    });

    const filteredStudents = students.filter(student => 
        student.nome.toLowerCase().includes(searchQuery.toLowerCase())
    );

    const handleViewClick = (student: Aluno) => {
        setSelectedStudent(student);
        setIsViewModalOpen(true);
    };
    
    return (
        <>
            <Card className="relative overflow-hidden bg-white/90 dark:bg-slate-800/90 backdrop-blur-md 
                           border border-white/30 dark:border-slate-700/50 shadow-2xl 
                           hover:shadow-3xl transition-all duration-500 hover:-translate-y-1">
                
                {/* Subtle gradient background overlay */}
                <div className="absolute inset-0 bg-gradient-to-br from-blue-50/50 via-indigo-50/30 to-purple-50/50 
                               dark:from-blue-900/10 dark:via-indigo-900/5 dark:to-purple-900/10" />
                
                <CardHeader className="relative pb-4">
                    <div className="flex flex-col gap-4 sm:gap-6">
                        <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-3 sm:gap-4">
                            <div className="space-y-2">
                                <CardTitle className="text-xl md:text-2xl font-bold bg-gradient-to-r from-blue-700 via-indigo-600 to-purple-600 
                                                   dark:from-blue-400 dark:via-indigo-400 dark:to-purple-400 
                                                   bg-clip-text text-transparent">
                                    Alunos Ativos
                                </CardTitle>
                                <CardDescription className="text-sm md:text-base text-gray-600 dark:text-gray-400 
                                                          leading-relaxed max-w-md">
                                    Gerencie seus alunos com planos de treino em andamento.
                                </CardDescription>
                            </div>
                            <Link href="/alunos/novo" className="shrink-0">
                                <Button size="sm" 
                                        className="min-h-[44px] px-4 md:px-6 py-2 md:py-3 text-sm md:text-base font-semibold
                                                 bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-600 
                                                 hover:from-blue-600 hover:via-indigo-600 hover:to-purple-700 
                                                 text-white shadow-lg hover:shadow-xl 
                                                 transition-all duration-300 ease-out
                                                 hover:scale-105 hover:-translate-y-0.5
                                                 active:scale-95 active:transition-transform active:duration-75
                                                 border-0 rounded-lg">
                                    <UserPlus className="h-4 w-4 mr-2 transition-transform duration-300 group-hover:scale-110" /> 
                                    <span className="hidden sm:inline">Adicionar</span> Aluno
                                </Button>
                            </Link>
                        </div>
                        
                        <div className="relative">
                            <div className="relative group">
                                <Search className="absolute left-3 md:left-4 top-1/2 -translate-y-1/2 
                                                text-gray-400 dark:text-gray-500 h-4 w-4 md:h-5 md:w-5
                                                group-focus-within:text-blue-500 dark:group-focus-within:text-blue-400
                                                transition-colors duration-300" />
                                <Input 
                                    type="search" 
                                    placeholder="Buscar aluno ativo..." 
                                    className="pl-10 md:pl-12 pr-4 py-3 md:py-4 w-full text-sm md:text-base
                                             bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm
                                             border border-gray-200/60 dark:border-slate-700/60 
                                             rounded-lg shadow-sm hover:shadow-md
                                             focus:ring-2 focus:ring-blue-500/30 dark:focus:ring-blue-400/30
                                             focus:border-blue-400 dark:focus:border-blue-500
                                             transition-all duration-300 ease-out
                                             hover:bg-white dark:hover:bg-slate-800
                                             placeholder:text-gray-400 dark:placeholder:text-gray-500" 
                                    value={searchQuery} 
                                    onChange={(e) => setSearchQuery(e.target.value)} 
                                />
                                
                                {/* Search field glow effect on focus */}
                                <div className="absolute inset-0 rounded-lg bg-gradient-to-r from-blue-500/20 via-indigo-500/20 to-purple-500/20 
                                               opacity-0 group-focus-within:opacity-100 transition-opacity duration-300 -z-10 blur-sm" />
                            </div>
                        </div>
                    </div>
                </CardHeader>
                <CardContent className="relative p-0">
                    {isLoading && (
                        <div className="p-4 md:p-6 space-y-4">
                            {[...Array(3)].map((_, i) => (
                                <div key={i} className="flex items-center gap-3 md:gap-4 p-3 md:p-4 
                                                       bg-gray-50/50 dark:bg-slate-700/30 rounded-lg 
                                                       animate-pulse">
                                    <Skeleton className="h-10 w-10 md:h-12 md:w-12 rounded-full 
                                                       bg-gradient-to-br from-gray-200 to-gray-300 
                                                       dark:from-slate-600 dark:to-slate-700" />
                                    <div className="flex-grow space-y-2">
                                        <Skeleton className="h-4 md:h-5 w-3/5 bg-gradient-to-r from-gray-200 to-gray-300 
                                                         dark:from-slate-600 dark:to-slate-700 rounded-full" />
                                        <Skeleton className="h-3 md:h-4 w-2/5 bg-gradient-to-r from-gray-200 to-gray-300 
                                                         dark:from-slate-600 dark:to-slate-700 rounded-full" />
                                    </div>
                                    <Skeleton className="h-8 w-8 md:h-10 md:w-10 rounded-lg 
                                                       bg-gradient-to-br from-gray-200 to-gray-300 
                                                       dark:from-slate-600 dark:to-slate-700" />
                                </div>
                            ))}
                        </div>
                    )}
                    
                    {isError && (
                        <div className="p-4 md:p-6">
                            <ErrorMessage title="Erro ao carregar alunos" message={error.message} />
                        </div>
                    )}
                    
                    {!isLoading && !isError && filteredStudents.length > 0 && (
                        <div className="divide-y divide-gray-100 dark:divide-slate-700/50">
                            {filteredStudents.map((student, index) => (
                                <div key={student._id} 
                                     className="animate-in fade-in-0 slide-in-from-bottom-4 duration-300"
                                     style={{ animationDelay: `${index * 100}ms` }}>
                                    <AlunoAtivoCard student={student} onView={handleViewClick} />
                                </div>
                            ))}
                        </div>
                    )}

                    {!isLoading && !isError && filteredStudents.length === 0 && (
                        <div className="flex flex-col items-center justify-center py-12 md:py-16 px-4">
                            <div className="text-center space-y-3 max-w-sm">
                                <div className="mx-auto w-16 h-16 md:w-20 md:h-20 bg-gradient-to-br from-gray-100 to-gray-200 
                                               dark:from-slate-700 dark:to-slate-800 rounded-full flex items-center justify-center">
                                    <Search className="h-6 w-6 md:h-8 md:w-8 text-gray-400 dark:text-slate-500" />
                                </div>
                                <h3 className="text-base md:text-lg font-semibold text-gray-700 dark:text-gray-300">
                                    {students.length > 0 ? "Nenhum resultado encontrado" : "Nenhum aluno ativo"}
                                </h3>
                                <p className="text-sm text-gray-500 dark:text-gray-400 leading-relaxed">
                                    {students.length > 0 
                                        ? "Tente ajustar sua busca para encontrar o aluno desejado."
                                        : "Adicione seus primeiros alunos para começar a gerenciar seus treinos."
                                    }
                                </p>
                                {students.length === 0 && (
                                    <Link href="/alunos/novo" className="inline-block mt-2">
                                        <Button variant="outline" 
                                                className="min-h-[44px] bg-white dark:bg-slate-800 
                                                         hover:bg-gradient-to-r hover:from-blue-50 hover:to-indigo-50
                                                         dark:hover:from-blue-900/20 dark:hover:to-indigo-900/20
                                                         border-blue-200 dark:border-blue-800
                                                         text-blue-700 dark:text-blue-400
                                                         hover:border-blue-300 dark:hover:border-blue-700
                                                         transition-all duration-300">
                                            <UserPlus className="h-4 w-4 mr-2" />
                                            Adicionar Primeiro Aluno
                                        </Button>
                                    </Link>
                                )}
                            </div>
                        </div>
                    )}
                </CardContent>
            </Card>

            <AlunoViewModal aluno={selectedStudent} open={isViewModalOpen} onOpenChange={setIsViewModalOpen} />
        </>
    );
}
===== ./client/src/components/ui/dashboard/FrequenciaSemanal.tsx =====

===== ./client/src/components/ui/dashboard/activity-card.tsx =====
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Check, MessageSquare, UserPlus, Dumbbell } from "lucide-react";
import { useQuery } from "@tanstack/react-query";
import { formatDistanceToNow } from "date-fns";
import { ptBR } from "date-fns/locale";
import { apiRequest } from "@/lib/queryClient"; // Importar apiRequest

// Interface para os dados de atividade esperados da API
interface ActivityLog {
  id: string; // ou number, dependendo da sua API
  activityType: string;
  details: any; // Seja mais específico se possível, ex: { name: string; workoutPlanName?: string; studentName?: string; progress?: number }
  timestamp: string; // ou Date
}

interface ActivityProps {
  trainerId: string; // Alterado para string para corresponder ao user.id
}

export function ActivityCard({ trainerId }: ActivityProps) {
  const { data: activities, isLoading } = useQuery<ActivityLog[], Error>({
    queryKey: ["/api/activity-logs", { trainerId, limit: 4 }], // Chave da query mais específica
    queryFn: async () => {
      if (!trainerId) throw new Error("Trainer ID não fornecido para buscar atividades.");
      // Usando apiRequest para chamadas autenticadas
      return apiRequest<ActivityLog[]>("GET", `/api/activity-logs?trainerId=${trainerId}&limit=4`);
    },
    enabled: !!trainerId, // Só executa se trainerId existir
  });

  const getActivityIcon = (activityType: string) => {
    switch (activityType) {
      case "student-added":
        return (
          <div className="w-10 h-10 rounded-full bg-primary/10 flex items-center justify-center text-primary">
            <UserPlus className="h-5 w-5" />
          </div>
        );
      case "workout-created":
      case "workout-updated":
      case "workout-assigned":
        return (
          <div className="w-10 h-10 rounded-full bg-secondary/10 flex items-center justify-center text-secondary">
            <Dumbbell className="h-5 w-5" />
          </div>
        );
      case "session-completed":
        return (
          <div className="w-10 h-10 rounded-full bg-green-500/10 flex items-center justify-center text-green-600"> {/* Corrigido para verde */}
            <Check className="h-5 w-5" />
          </div>
        );
      default:
        return (
          <div className="w-10 h-10 rounded-full bg-accent/10 flex items-center justify-center text-accent">
            <MessageSquare className="h-5 w-5" />
          </div>
        );
    }
  };

  const getActivityTitle = (activity: ActivityLog) => {
    switch (activity.activityType) {
      case "student-added":
        return `Novo aluno cadastrado`;
      case "workout-created":
        return `Plano de treino criado`;
      case "workout-updated":
        return `Plano de treino atualizado`;
      case "workout-assigned":
        return `Plano de treino atribuído`;
      case "workout-progress-updated":
        return `Progresso do treino atualizado`;
      case "session-scheduled":
        return `Nova sessão agendada`;
      case "session-confirmed":
        return `Sessão confirmada`;
      case "session-completed":
        return `Sessão concluída`;
      case "session-cancelled":
        return `Sessão cancelada`;
      default:
        return `Atividade registrada`;
    }
  };

  const getActivityDescription = (activity: ActivityLog) => {
    // Adicionar verificações para activity.details para evitar erros se não existir
    const details = activity.details || {};
    switch (activity.activityType) {
      case "student-added":
        return `${details.name || 'Aluno'} foi adicionado à sua lista de alunos`;
      case "workout-created":
        return `Você criou o plano de treino "${details.name || 'desconhecido'}"`;
      case "workout-updated":
        return `Você atualizou o plano de treino "${details.name || 'desconhecido'}"`;
      case "workout-assigned":
        return `Você atribuiu "${details.workoutPlanName || 'plano desconhecido'}" para ${details.studentName || 'aluno desconhecido'}`;
      case "workout-progress-updated":
        return `Progresso de ${details.studentName || 'aluno desconhecido'} no plano "${details.workoutPlanName || 'desconhecido'}" atualizado para ${details.progress || 0}%`;
      case "session-scheduled":
        return `Nova sessão agendada com ${details.studentName || 'aluno desconhecido'}`;
      case "session-confirmed":
        return `Sessão com ${details.studentName || 'aluno desconhecido'} confirmada`;
      case "session-completed":
        return `${details.studentName || 'Aluno desconhecido'} concluiu a sessão`;
      case "session-cancelled":
        return `Sessão com ${details.studentName || 'aluno desconhecido'} foi cancelada`;
      default:
        return `Detalhes da atividade não disponíveis`;
    }
  };

  const renderActivitySkeleton = () => (
    <>
      {[1, 2, 3, 4].map((i) => (
        <div key={i} className="p-4 flex items-start border-b border-gray-100 dark:border-gray-700 last:border-0">
          <div className="flex-shrink-0 mr-4">
            <div className="w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 animate-pulse"></div>
          </div>
          <div className="w-full">
            <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4 animate-pulse"></div>
            <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-full mt-2 animate-pulse"></div>
            <div className="h-3 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mt-2 animate-pulse"></div>
          </div>
        </div>
      ))}
    </>
  );

  return (
    <Card className="border border-gray-100 dark:border-gray-800 overflow-hidden shadow-sm">
      <CardHeader className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex flex-row items-center justify-between">
        <CardTitle className="font-semibold text-gray-900 dark:text-gray-100">Atividade Recente</CardTitle>
        {/* <button className="text-sm text-primary hover:text-primary-dark">Ver tudo</button> */}
      </CardHeader>
      <CardContent className="p-0 divide-y divide-gray-100 dark:divide-gray-700">
        {isLoading ? (
          renderActivitySkeleton()
        ) : (
          <>
            {activities && activities.length > 0 ? activities.map((activity: ActivityLog) => (
              <div key={activity.id} className="p-4 flex items-start hover:bg-muted/30 dark:hover:bg-muted/10">
                <div className="flex-shrink-0 mr-4">
                  {getActivityIcon(activity.activityType)}
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-800 dark:text-gray-200">{getActivityTitle(activity)}</p>
                  <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">{getActivityDescription(activity)}</p>
                  <p className="text-xs text-gray-400 dark:text-gray-500 mt-1">
                    {formatDistanceToNow(new Date(activity.timestamp), {
                      addSuffix: true,
                      locale: ptBR
                    })}
                  </p>
                </div>
              </div>
            )) : (
              <div className="p-6 text-center text-sm text-gray-500 dark:text-gray-400">Nenhuma atividade recente.</div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
}

===== ./client/src/components/ui/dashboard/plano-status-card.tsx =====
// client/src/components/ui/dashboard/plano-status-card.tsx
import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '../card';
import { Badge } from '../badge';
import { Button } from '../button';
import { Progress } from '../progress';
import { 
    CalendarDays, 
    Users, 
    Crown, 
    AlertTriangle, 
    CheckCircle, 
    Clock,
    TrendingUp,
    Zap
} from 'lucide-react';
import { PersonalPlanStatus } from '../../../../../shared/types/planos';

interface PlanoStatusCardProps {
    planStatus: PersonalPlanStatus;
    onUpgradeClick?: () => void;
    showUpgradeButton?: boolean;
}

export function PlanoStatusCard({ 
    planStatus, 
    onUpgradeClick, 
    showUpgradeButton = false 
}: PlanoStatusCardProps) {
    const {
        plano,
        personalPlano,
        limiteAtual,
        alunosAtivos,
        tokensAvulsos,
        percentualUso = 0,
        podeAtivarMais = false,
        vagasDisponiveis = 0
    } = planStatus;

    // Ensure percentualUso displays properly - show 0% when null/undefined
    const displayPercentualUso = percentualUso ?? 0;

    const getStatusInfo = () => {
        if (displayPercentualUso >= 90) {
            return {
                variant: 'destructive' as const,
                icon: AlertTriangle,
                text: 'Crítico',
                color: 'text-red-600',
                bgColor: 'bg-red-50',
                borderColor: 'border-red-200'
            };
        }
        if (displayPercentualUso >= 70) {
            return {
                variant: 'default' as const,
                icon: Clock,
                text: 'Atenção',
                color: 'text-yellow-600',
                bgColor: 'bg-yellow-50',
                borderColor: 'border-yellow-200'
            };
        }
        return {
            variant: 'secondary' as const,
            icon: CheckCircle,
            text: 'Normal',
            color: 'text-green-600',
            bgColor: 'bg-green-50',
            borderColor: 'border-green-200'
        };
    };

    const statusInfo = getStatusInfo();
    const StatusIcon = statusInfo.icon;

    const formatDate = (date: Date | string) => {
        return new Date(date).toLocaleDateString('pt-BR');
    };

    const getDaysUntilExpiration = () => {
        if (!personalPlano?.dataVencimento) return null;
        const today = new Date();
        const expiration = new Date(personalPlano.dataVencimento);
        const diffTime = expiration.getTime() - today.getTime();
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays;
    };

    const daysUntilExpiration = getDaysUntilExpiration();

    return (
        <Card className={`${statusInfo.bgColor} ${statusInfo.borderColor} border-2`}>
            <CardHeader>
                <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                        <Crown className="w-5 h-5 text-blue-600" />
                        <CardTitle className="text-lg">Status do Plano</CardTitle>
                    </div>
                    <Badge variant={statusInfo.variant} className="flex items-center gap-1">
                        <StatusIcon className="w-3 h-3" />
                        {statusInfo.text}
                    </Badge>
                </div>
                <CardDescription>
                    {plano ? `Plano ${plano.nome} ativo` : 'Nenhum plano ativo'}
                </CardDescription>
            </CardHeader>

            <CardContent className="space-y-6">
                {/* Usage Statistics */}
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div className="text-center">
                        <div className="flex items-center justify-center w-10 h-10 bg-blue-100 rounded-full mx-auto mb-2">
                            <Users className="w-5 h-5 text-blue-600" />
                        </div>
                        <p className="text-sm text-gray-600 mb-1">Alunos Ativos</p>
                        <p className="text-xl font-bold">{alunosAtivos}</p>
                    </div>

                    <div className="text-center">
                        <div className="flex items-center justify-center w-10 h-10 bg-purple-100 rounded-full mx-auto mb-2">
                            <TrendingUp className="w-5 h-5 text-purple-600" />
                        </div>
                        <p className="text-sm text-gray-600 mb-1">Limite</p>
                        <p className="text-xl font-bold">{limiteAtual}</p>
                    </div>

                    <div className="text-center">
                        <div className="flex items-center justify-center w-10 h-10 bg-green-100 rounded-full mx-auto mb-2">
                            <CheckCircle className="w-5 h-5 text-green-600" />
                        </div>
                        <p className="text-sm text-gray-600 mb-1">Disponível</p>
                        <p className="text-xl font-bold">{vagasDisponiveis}</p>
                    </div>

                    {tokensAvulsos > 0 && (
                        <div className="text-center">
                            <div className="flex items-center justify-center w-10 h-10 bg-orange-100 rounded-full mx-auto mb-2">
                                <Zap className="w-5 h-5 text-orange-600" />
                            </div>
                            <p className="text-sm text-gray-600 mb-1">Tokens</p>
                            <p className="text-xl font-bold">{tokensAvulsos}</p>
                        </div>
                    )}
                </div>

                {/* Usage Progress */}
                <div>
                    <div className="flex justify-between items-center mb-2">
                        <span className="text-sm font-medium">Utilização do Plano</span>
                        <span className="text-sm text-gray-600">{displayPercentualUso}%</span>
                    </div>
                    <Progress 
                        value={displayPercentualUso} 
                        className="h-3"
                    />
                    <div className="flex justify-between text-xs text-gray-500 mt-1">
                        <span>{alunosAtivos} usados</span>
                        <span>{limiteAtual} total</span>
                    </div>
                </div>

                {/* Plan Details */}
                {plano && personalPlano && (
                    <div className="bg-white/50 p-4 rounded-lg">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                            <div>
                                <span className="text-gray-600">Plano:</span>
                                <p className="font-medium">{plano.nome}</p>
                            </div>
                            <div>
                                <span className="text-gray-600">Valor:</span>
                                <p className="font-medium">
                                    {plano.preco === 0 ? 'Gratuito' : `R$ ${plano.preco.toFixed(2)}`}
                                </p>
                            </div>
                            <div>
                                <span className="text-gray-600">Início:</span>
                                <p className="font-medium">{formatDate(personalPlano.dataInicio)}</p>
                            </div>
                            <div>
                                <span className="text-gray-600">Vencimento:</span>
                                <p className="font-medium">
                                    {formatDate(personalPlano.dataVencimento)}
                                    {daysUntilExpiration !== null && (
                                        <span className={`ml-1 text-xs ${
                                            daysUntilExpiration <= 7 ? 'text-red-600' : 
                                            daysUntilExpiration <= 30 ? 'text-yellow-600' : 'text-gray-500'
                                        }`}>
                                            ({daysUntilExpiration > 0 ? `${daysUntilExpiration} dias` : 'Vencido'})
                                        </span>
                                    )}
                                </p>
                            </div>
                        </div>
                    </div>
                )}

                {/* Action Buttons */}
                {showUpgradeButton && (
                    <div className="flex gap-2">
                        {!podeAtivarMais && (
                            <Button 
                                onClick={onUpgradeClick}
                                className="flex-1"
                                variant={displayPercentualUso >= 90 ? "destructive" : "default"}
                            >
                                {displayPercentualUso >= 90 ? 'Upgrade Urgente' : 'Fazer Upgrade'}
                            </Button>
                        )}
                        
                        {!plano && (
                            <Button onClick={onUpgradeClick} className="flex-1">
                                Ativar Plano
                            </Button>
                        )}
                    </div>
                )}

                {/* Warnings */}
                {daysUntilExpiration !== null && daysUntilExpiration <= 7 && daysUntilExpiration > 0 && (
                    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
                        <div className="flex items-center gap-2 text-yellow-800">
                            <AlertTriangle className="w-4 h-4" />
                            <span className="text-sm font-medium">
                                Seu plano vence em {daysUntilExpiration} dia{daysUntilExpiration !== 1 ? 's' : ''}
                            </span>
                        </div>
                    </div>
                )}

                {!podeAtivarMais && limiteAtual > 0 && (
                    <div className="bg-red-50 border border-red-200 rounded-lg p-3">
                        <div className="flex items-center gap-2 text-red-800">
                            <AlertTriangle className="w-4 h-4" />
                            <span className="text-sm font-medium">
                                Limite de alunos atingido. Faça upgrade para adicionar mais alunos.
                            </span>
                        </div>
                    </div>
                )}
            </CardContent>
        </Card>
    );
}
===== ./client/src/components/ui/dashboard/sessions-card.tsx =====
// client/src/components/ui/dashboard/sessions-card.tsx
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { format } from "date-fns";
import { ptBR } from "date-fns/locale";
// <<< CORREÇÃO: Removidos ícones não utilizados (UserCircle, Edit3) >>>
import { MoreVertical, Plus, CalendarClock, Info, Loader2, Activity, ClipboardCheck, Dumbbell } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle, } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, } from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter, DialogDescription, } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { Aluno } from "@/types/aluno";
import LoadingSpinner from "@/components/LoadingSpinner";

export const TIPOS_COMPROMISSO_FRONTEND = ['avaliacao', 'checkin', 'treino_acompanhado', 'outro'] as const;
export type TipoCompromissoFrontend = typeof TIPOS_COMPROMISSO_FRONTEND[number];

interface CompromissoData {
  _id: string;
  sessionDate: string; 
  tipoCompromisso: TipoCompromissoFrontend;
  notes?: string;
  status: "pending" | "confirmed" | "completed" | "cancelled";
  studentId: { _id: string; nome: string; } | string; 
  trainerId: string;
}

interface NewCompromissoState {
    sessionDate: string;
    tipoCompromisso: TipoCompromissoFrontend;
    notes: string;
    status: CompromissoData['status'];
    studentId: string;
    trainerId: string;
}

interface SessionsCardProps {
  trainerId: string; 
}

export function SessionsCard({ trainerId }: SessionsCardProps) {
  const { toast } = useToast();
  const queryClientHook = useQueryClient();
  const today = new Date();
  const [isModalOpen, setIsModalOpen] = useState(false);

  const initialNewCompromissoState: NewCompromissoState = {
    sessionDate: format(new Date(), "yyyy-MM-dd'T'HH:mm"),
    tipoCompromisso: 'treino_acompanhado', 
    notes: "",
    status: "pending" as CompromissoData['status'],
    studentId: "",
    trainerId: trainerId,
  };
  const [newCompromisso, setNewCompromisso] = useState<NewCompromissoState>(initialNewCompromissoState);

  const { data: compromissos = [], isLoading: isLoadingCompromissos, error: errorCompromissos } = useQuery<CompromissoData[], Error>({
    queryKey: ["/api/sessions/today", { trainerId, date: format(today, "yyyy-MM-dd") }],
    queryFn: async () => {
      if (!trainerId) throw new Error("Trainer ID não fornecido para buscar compromissos.");
      return apiRequest<CompromissoData[]>("GET", `/api/sessions?trainerId=${trainerId}&date=${format(today, "yyyy-MM-dd")}&populateStudent=true`);
    },
    enabled: !!trainerId,
  });

  const { data: students = [], isLoading: isLoadingStudents } = useQuery<Aluno[], Error>({
    queryKey: ["/api/alunos", { forComponent: "SessionsCardModal" }],
    queryFn: async () => {
      return apiRequest<Aluno[]>("GET", `/api/alunos`);
    },
    enabled: isModalOpen, 
  });

  const updateCompromissoStatusMutation = useMutation<CompromissoData, Error, { compromissoId: string; status: string }>({
    mutationFn: ({ compromissoId, status }) => apiRequest<CompromissoData>("PUT", `/api/sessions/${compromissoId}`, { status }),
    onSuccess: (updatedCompromisso) => { 
      toast({ title: "Compromisso atualizado", description: `Status do compromisso com ${getStudentName(updatedCompromisso.studentId)} alterado para ${updatedCompromisso.status}.` });
      queryClientHook.invalidateQueries({ queryKey: ["/api/sessions/today", { trainerId, date: format(today, "yyyy-MM-dd") }] });
      queryClientHook.invalidateQueries({ queryKey: ["/api/dashboard/geral", trainerId] }); 
    },
    onError: (error) => {
      toast({ title: "Erro", description: error.message || "Falha ao atualizar o status do compromisso.", variant: "destructive" });
    },
  });

  const createCompromissoMutation = useMutation<CompromissoData, Error, NewCompromissoState>({
    mutationFn: (compromissoData) => apiRequest<CompromissoData>("POST", "/api/sessions", compromissoData),
    onSuccess: (createdCompromisso) => {
      toast({ title: "Compromisso criado!", description: `Novo compromisso (${getTipoCompromissoLabel(createdCompromisso.tipoCompromisso)}) com ${getStudentName(createdCompromisso.studentId)} agendado.` });
      queryClientHook.invalidateQueries({ queryKey: ["/api/sessions/today", { trainerId, date: format(today, "yyyy-MM-dd") }] });
      queryClientHook.invalidateQueries({ queryKey: ["/api/dashboard/geral", trainerId] }); 
      setIsModalOpen(false);
      setNewCompromisso(initialNewCompromissoState);
    },
    onError: (error) => {
      toast({ title: "Erro ao criar compromisso", description: error.message || "Não foi possível agendar o compromisso.", variant: "destructive" });
    },
  });

  const handleUpdateStatus = (compromissoId: string, status: string) => {
    updateCompromissoStatusMutation.mutate({ compromissoId, status });
  };

  const handleCreateCompromisso = () => {
    if (!newCompromisso.studentId) {
        toast({ title: "Erro de Validação", description: "Por favor, selecione um aluno.", variant: "destructive" });
        return;
    }
    if (!newCompromisso.sessionDate) {
        toast({ title: "Erro de Validação", description: "Por favor, defina a data e hora.", variant: "destructive" });
        return;
    }
    if (!newCompromisso.tipoCompromisso) {
        toast({ title: "Erro de Validação", description: "Por favor, selecione o tipo de compromisso.", variant: "destructive" });
        return;
    }
    createCompromissoMutation.mutate(newCompromisso);
  };

  const getStatusBadge = (status: string) => {
    switch (status) {
      case "confirmed": return <Badge variant="success" className="text-xs">Confirmada</Badge>;
      case "pending": return <Badge variant="secondary" className="bg-yellow-100 text-yellow-800 dark:bg-yellow-700/30 dark:text-yellow-300 text-xs">Pendente</Badge>;
      case "completed": return <Badge variant="default" className="bg-blue-100 text-blue-800 dark:bg-blue-700/30 dark:text-blue-300 text-xs">Concluído</Badge>;
      case "cancelled": return <Badge variant="destructive" className="text-xs">Cancelado</Badge>;
      default: return <Badge variant="outline" className="text-xs">{status}</Badge>;
    }
  };
  
  const getStudentName = (studentIdField: CompromissoData['studentId']): string => {
    if (typeof studentIdField === 'object' && studentIdField !== null && studentIdField.nome) {
        return studentIdField.nome;
    }
    const studentDetails = students.find(s => s._id === studentIdField);
    return studentDetails?.nome || "Aluno";
  };

  const getTipoCompromissoLabel = (tipo: TipoCompromissoFrontend): string => {
    switch (tipo) {
      case 'avaliacao': return 'Avaliação';
      case 'checkin': return 'Check-in';
      case 'treino_acompanhado': return 'Treino Acompanhado';
      case 'outro': return 'Outro';
      // <<< CORREÇÃO: Removida a função 'exhaustiveCheck' não utilizada >>>
    }
  };
  
  const getTipoCompromissoIcon = (tipo: TipoCompromissoFrontend) => {
    switch (tipo) {
        case 'avaliacao': return <ClipboardCheck className="w-4 h-4 mr-1.5 text-blue-500" />;
        case 'checkin': return <Activity className="w-4 h-4 mr-1.5 text-green-500" />;
        case 'treino_acompanhado': return <Dumbbell className="w-4 h-4 mr-1.5 text-purple-500" />;
        case 'outro': return <Info className="w-4 h-4 mr-1.5 text-gray-500" />;
        // <<< CORREÇÃO: Removida a função 'exhaustiveCheck' não utilizada >>>
    }
  };

  return (
    <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
      <Card className="border border-gray-100 dark:border-gray-800 overflow-hidden shadow-sm flex flex-col h-full">
        <CardHeader className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex flex-row items-center justify-between shrink-0">
          <CardTitle className="font-semibold text-gray-900 dark:text-gray-100 flex items-center">
            <CalendarClock className="w-5 h-5 mr-2 text-primary" />
            Agenda do Dia
          </CardTitle>
          <DialogTrigger asChild>
            <Button variant="outline" size="sm">
              <Plus className="w-4 h-4 mr-1.5" /> Adicionar
            </Button>
          </DialogTrigger>
        </CardHeader>

        <CardContent className="p-0 flex-grow overflow-y-auto">
          {isLoadingCompromissos ? (
            <div className="p-6 flex justify-center items-center h-full">
                <LoadingSpinner text="Carregando compromissos..." />
            </div>
          ) : errorCompromissos ? (
            <div className="p-6 text-center text-red-600 dark:text-red-400 text-sm">
                Erro ao carregar compromissos: {errorCompromissos.message}
            </div>
          ) : compromissos.length > 0 ? (
            <ul className="divide-y divide-gray-100 dark:divide-gray-700">
                {compromissos.map((compromisso) => (
                <li key={compromisso._id} className="p-4 hover:bg-muted/30 dark:hover:bg-muted/10">
                    <div className="flex justify-between items-start">
                      <div className="flex-grow">
                          <div className="flex items-center">
                              {getTipoCompromissoIcon(compromisso.tipoCompromisso)}
                              <p className="text-sm font-medium text-gray-800 dark:text-gray-200">
                                  {format(new Date(compromisso.sessionDate), "HH:mm", { locale: ptBR })} - {getStudentName(compromisso.studentId)}
                                  <span className="text-xs text-muted-foreground ml-1">({getTipoCompromissoLabel(compromisso.tipoCompromisso)})</span>
                              </p>
                          </div>
                          {compromisso.notes && <p className="text-xs text-gray-500 dark:text-gray-400 mt-0.5 ml-5 truncate max-w-xs">{compromisso.notes}</p>}
                      </div>
                      <div className="flex items-center gap-2 flex-shrink-0">
                          {getStatusBadge(compromisso.status)}
                          <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                              <Button variant="ghost" size="icon" className="text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-300 h-8 w-8">
                              <MoreVertical className="h-4 w-4" />
                              </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                              <DropdownMenuItem onClick={() => handleUpdateStatus(compromisso._id, "confirmed")}>Confirmar</DropdownMenuItem>
                              <DropdownMenuItem onClick={() => handleUpdateStatus(compromisso._id, "completed")}>Concluir</DropdownMenuItem>
                              <DropdownMenuItem onClick={() => handleUpdateStatus(compromisso._id, "cancelled")} className="text-red-600 focus:text-red-500">Cancelar</DropdownMenuItem>
                          </DropdownMenuContent>
                          </DropdownMenu>
                      </div>
                    </div>
                </li>
                ))}
            </ul>
          ) : (
            <div className="p-6 text-center text-sm text-gray-500 dark:text-gray-400 flex flex-col items-center justify-center h-full">
                <Info className="w-10 h-10 text-gray-400 dark:text-gray-500 mb-3"/>
                <p>Nenhum compromisso agendado para hoje.</p>
                <Button variant="link" size="sm" className="mt-2" onClick={() => setIsModalOpen(true)}>Agendar primeiro compromisso</Button>
            </div>
          )}
        </CardContent>
      </Card>

      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle>Novo Compromisso</DialogTitle>
          <DialogDescription>
            Preencha os detalhes para agendar um novo compromisso.
          </DialogDescription>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="sessionDate" className="text-right">Data e Hora</Label>
            <Input
              id="sessionDate"
              type="datetime-local"
              value={newCompromisso.sessionDate}
              onChange={(e) => setNewCompromisso((prev) => ({ ...prev, sessionDate: e.target.value }))}
              className="col-span-3"
              disabled={createCompromissoMutation.isPending}
            />
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="studentId" className="text-right">Aluno</Label>
            <Select
              onValueChange={(value) => setNewCompromisso((prev) => ({ ...prev, studentId: value }))}
              value={newCompromisso.studentId}
              disabled={createCompromissoMutation.isPending || isLoadingStudents}
            >
              <SelectTrigger id="studentId" className="col-span-3">
                <SelectValue placeholder={isLoadingStudents ? "Carregando..." : "Selecione o aluno"} />
              </SelectTrigger>
              <SelectContent>
                {isLoadingStudents ? (
                    <div className="p-2 text-sm text-muted-foreground">Carregando alunos...</div>
                ) : students.length === 0 ? (
                    <div className="p-2 text-sm text-muted-foreground">Nenhum aluno cadastrado.</div>
                ) : (
                    students.map((student) => (
                        <SelectItem key={student._id} value={student._id}>
                        {student.nome}
                        </SelectItem>
                    ))
                )}
              </SelectContent>
            </Select>
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="tipoCompromisso" className="text-right">Tipo</Label>
            <Select
              onValueChange={(value) => setNewCompromisso((prev) => ({ ...prev, tipoCompromisso: value as TipoCompromissoFrontend }))}
              value={newCompromisso.tipoCompromisso}
              disabled={createCompromissoMutation.isPending}
            >
              <SelectTrigger id="tipoCompromisso" className="col-span-3">
                <SelectValue placeholder="Selecione o tipo" />
              </SelectTrigger>
              <SelectContent>
                {TIPOS_COMPROMISSO_FRONTEND.map(tipo => (
                    <SelectItem key={tipo} value={tipo}>
                        {getTipoCompromissoLabel(tipo)}
                    </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="grid grid-cols-4 items-center gap-4">
            <Label htmlFor="status" className="text-right">Status</Label>
            <Select
              onValueChange={(value) => setNewCompromisso((prev) => ({ ...prev, status: value as CompromissoData['status'] }))}
              value={newCompromisso.status}
              disabled={createCompromissoMutation.isPending}
            >
              <SelectTrigger id="status" className="col-span-3">
                <SelectValue placeholder="Status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="pending">Pendente</SelectItem>
                <SelectItem value="confirmed">Confirmado</SelectItem>
                <SelectItem value="completed">Concluído</SelectItem>
                <SelectItem value="cancelled">Cancelado</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <div className="grid grid-cols-4 items-start gap-4"> 
            <Label htmlFor="notes" className="text-right pt-2">Observações</Label>
            <Textarea
              id="notes"
              placeholder="Alguma observação para este compromisso?"
              value={newCompromisso.notes}
              onChange={(e) => setNewCompromisso((prev) => ({ ...prev, notes: e.target.value }))}
              className="col-span-3 min-h-[80px]"
              disabled={createCompromissoMutation.isPending}
            />
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={() => { setIsModalOpen(false); setNewCompromisso(initialNewCompromissoState);}} disabled={createCompromissoMutation.isPending}>
            Cancelar
          </Button>
          <Button onClick={handleCreateCompromisso} disabled={createCompromissoMutation.isPending || !newCompromisso.studentId || !newCompromisso.sessionDate || !newCompromisso.tipoCompromisso}>
            {createCompromissoMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Agendar Compromisso
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/ui/dashboard/stats-card.tsx =====
// client/src/components/ui/dashboard/stats-card.tsx

import { Card } from "@/components/ui/card";
import {
  ArrowDown,
  ArrowUp,
  CalendarCheck,
  CheckCircle,
  Dumbbell,
  UsersRound,
  Activity, // <<< ADIÇÃO: Importa o novo ícone 'Activity'
} from "lucide-react";

interface StatsCardProps {
  title: string;
  value: string | number;
  change?: {
    value: string;
    trend: "up" | "down" | "neutral";
  };
  // <<< ALTERAÇÃO: Adiciona 'activity' à lista de ícones permitidos >>>
  icon: "students" | "workouts" | "sessions" | "completion" | "activity";
  isLoading?: boolean;
}

export function StatsCard({
  title,
  value,
  change,
  icon,
  isLoading = false,
}: StatsCardProps) {
  const getIcon = () => {
    switch (icon) {
      case "students":
        return <UsersRound className="w-6 h-6" />;
      case "workouts":
        return <Dumbbell className="w-6 h-6" />;
      case "sessions":
        return <CalendarCheck className="w-6 h-6" />;
      case "completion":
        return <CheckCircle className="w-6 h-6" />;
      // <<< ADIÇÃO: Novo caso para o ícone 'activity' >>>
      case "activity":
        return <Activity className="w-6 h-6" />;
      default:
        return <UsersRound className="w-6 h-6" />;
    }
  };

  const getIconBgColor = () => {
    switch (icon) {
      case "students":
        return "bg-gradient-to-br from-blue-500 to-indigo-600 text-white shadow-blue-500/25";
      case "workouts":
        return "bg-gradient-to-br from-indigo-500 to-purple-600 text-white shadow-indigo-500/25";
      case "sessions":
        return "bg-gradient-to-br from-purple-500 to-pink-600 text-white shadow-purple-500/25";
      case "completion":
        return "bg-gradient-to-br from-emerald-500 to-green-600 text-white shadow-emerald-500/25";
      case "activity":
        return "bg-gradient-to-br from-orange-500 to-red-500 text-white shadow-orange-500/25";
      default:
        return "bg-gradient-to-br from-blue-500 to-indigo-600 text-white shadow-blue-500/25";
    }
  };

  const getTrendColor = () => {
    if (!change) return "";
    if (change.trend === "up") return "text-success";
    if (change.trend === "down") return "text-error";
    return "text-gray-500";
  };

  const getTrendIcon = () => {
    if (!change) return null;
    if (change.trend === "up") return <ArrowUp className="w-3 h-3 mr-1" />;
    if (change.trend === "down") return <ArrowDown className="w-3 h-3 mr-1" />;
    return null;
  };

  return (
    <Card className="group relative p-6 border-0 shadow-lg hover:shadow-2xl 
                   bg-white/90 dark:bg-slate-800/90 backdrop-blur-sm 
                   transition-all duration-500 ease-out
                   hover:scale-105 hover:-translate-y-2
                   rounded-xl overflow-hidden">
      
      {/* Gradient background overlay */}
      <div className="absolute inset-0 bg-gradient-to-br from-blue-50/50 via-indigo-50/30 to-purple-50/50 
                     dark:from-blue-900/10 dark:via-indigo-900/5 dark:to-purple-900/10
                     opacity-0 group-hover:opacity-100 transition-opacity duration-500" />
      
      <div className="relative flex justify-between items-start">
        <div className="flex-1 space-y-3">
          <p className="text-gray-600 dark:text-gray-400 text-sm md:text-base font-medium leading-relaxed">
            {title}
          </p>
          {isLoading ? (
            <div className="h-8 md:h-10 w-16 md:w-20 bg-gradient-to-r from-gray-200 to-gray-300 
                           dark:from-slate-600 dark:to-slate-700 animate-pulse rounded-lg"></div>
          ) : (
            <h3 className="text-2xl md:text-3xl lg:text-4xl font-bold bg-gradient-to-r from-gray-800 to-gray-900 
                         dark:from-gray-100 dark:to-gray-200 bg-clip-text text-transparent
                         group-hover:from-blue-600 group-hover:via-indigo-600 group-hover:to-purple-600
                         dark:group-hover:from-blue-400 dark:group-hover:via-indigo-400 dark:group-hover:to-purple-400
                         transition-all duration-500">
              {value}
            </h3>
          )}
          {change && (
            <p className={`text-sm font-medium flex items-center gap-1 ${getTrendColor()} 
                          opacity-80 group-hover:opacity-100 transition-opacity duration-300`}>
              {getTrendIcon()}
              {change.value}
            </p>
          )}
        </div>
        
        <div className={`relative h-14 w-14 md:h-16 md:w-16 rounded-2xl flex items-center justify-center 
                        shadow-lg group-hover:shadow-xl transition-all duration-500
                        group-hover:scale-110 group-hover:rotate-3
                        ${getIconBgColor()}`}>
          
          {/* Icon glow effect */}
          <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-white/20 to-transparent 
                         opacity-0 group-hover:opacity-100 transition-opacity duration-500" />
          
          <div className="relative transform transition-transform duration-500 group-hover:scale-110">
            {getIcon()}
          </div>
        </div>
      </div>
    </Card>
  );
}
===== ./client/src/components/ui/dashboard/students-table.tsx =====
// client/src/components/ui/dashboard/students-table.tsx
import { useState } from "react";
import { ModalEditarAluno } from "@/components/ui/ModalEditarAluno"; // Verifique se este modal usa apiRequest
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Eye, Loader2, Plus, Search, UserX } from "lucide-react"; 
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"; // Adicionado useMutation e useQueryClient
import { Link, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import ActionsAluno from "@/components/ui/ActionsAluno"; 
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient"; // Importar apiRequest
import { Aluno } from "@/types/aluno"; // Importar tipo Aluno
import { ModalConfirmacao } from "@/components/ui/modal-confirmacao"; // Para confirmação de exclusão
import { useConfirmDialog } from "@/hooks/useConfirmDialog"; // Para confirmação de exclusão
import ErrorMessage from "@/components/ErrorMessage"; // Para exibir erros
import { Input } from "@/components/ui/input"; // Para o campo de busca

interface StudentsTableProps {
  trainerId: string; // Alterado para string
}

export function StudentsTable({ trainerId }: StudentsTableProps) {
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const queryClientHook = useQueryClient(); // Hook para invalidar queries

  const [modalEditarOpen, setModalEditarOpen] = useState(false);
  const [alunoSelecionado, setAlunoSelecionado] = useState<Aluno | null>(null);
  const [alunoParaExcluir, setAlunoParaExcluir] = useState<Aluno | null>(null);
  const [searchQuery, setSearchQuery] = useState("");

  const { 
    isOpen: isConfirmDeleteOpen, 
    options: confirmDeleteOptions, 
    openConfirmDialog: openDeleteStudentDialog, 
    closeConfirmDialog: closeDeleteStudentDialog,
    confirm: confirmDeleteStudentAction
  } = useConfirmDialog();

  const { data: students = [], isLoading, error, refetch: refetchStudents } = useQuery<Aluno[], Error>({ 
    queryKey: ["/api/alunos/gerenciar", { trainerId, forComponent: "StudentsTableDashboard" }], // Chave mais específica
    queryFn: async (): Promise<Aluno[]> => { 
      if (!trainerId) throw new Error("Trainer ID não fornecido para buscar alunos.");
      // Usando apiRequest para chamadas autenticadas
      // A rota /api/alunos/gerenciar já deve filtrar pelo trainerId do usuário autenticado no backend
      return apiRequest<Aluno[]>("GET", `/api/alunos/gerenciar`); 
    },
    enabled: !!trainerId,
    staleTime: 1000 * 60 * 2, // Cache de 2 minutos para a tabela no dashboard
  });

  // Mutação para excluir aluno
  const deleteStudentMutation = useMutation<any, Error, string>({
    mutationFn: (alunoId: string) => {
        return apiRequest("DELETE", `/api/alunos/gerenciar/${alunoId}`);
    },
    onSuccess: (data, alunoId) => {
        toast({ title: "Aluno Removido", description: `${alunoParaExcluir?.nome || 'O aluno'} foi removido.` });
        queryClientHook.invalidateQueries({ queryKey: ["/api/alunos/gerenciar"] }); // Invalida a lista principal de alunos
        queryClientHook.invalidateQueries({ queryKey: ["/api/alunos/gerenciar", { trainerId, forComponent: "StudentsTableDashboard" }] }); // Invalida esta query específica
        // Invalidar também a query de estatísticas do dashboard se ela contar alunos
        queryClientHook.invalidateQueries({ queryKey: ["/api/dashboard/geral", trainerId] });
        setAlunoParaExcluir(null);
        closeDeleteStudentDialog();
    },
    onError: (error) => {
        toast({ variant: "destructive", title: "Erro ao Remover", description: error.message || "Não foi possível remover o aluno." });
        setAlunoParaExcluir(null);
        closeDeleteStudentDialog();
    },
  });


  const handleEditClick = (aluno: Aluno) => {
    setAlunoSelecionado(aluno);
    setModalEditarOpen(true); // ModalEditarAluno deve usar apiRequest internamente
  };
  
  const handleViewClick = (alunoId: string) => {
     navigate(`/alunos/${alunoId}`); 
  }

  const handleDeleteClick = (aluno: Aluno) => {
    if (!aluno._id || !aluno.nome) {
        toast({ variant: "destructive", title: "Erro", description: "ID ou nome do aluno inválido." });
        return;
    }
    setAlunoParaExcluir(aluno);
    openDeleteStudentDialog({
        titulo: "Remover Aluno",
        mensagem: `Tem certeza que deseja remover ${aluno.nome}? Esta ação não pode ser desfeita e removerá também suas fichas de treino.`,
        textoConfirmar: "Remover Aluno",
        textoCancelar: "Cancelar",
        onConfirm: () => {
            if (aluno._id) {
                deleteStudentMutation.mutate(aluno._id);
            }
        },
    });
  };

  const filteredStudents = students.filter((student) => {
    const fullName = (student.nome || "").toLowerCase();
    const email = (student.email || "").toLowerCase();
    const query = searchQuery.toLowerCase();
    return fullName.includes(query) || email.includes(query);
  }).slice(0, 5); // Limitar a 5 alunos no dashboard

  const renderStudentSkeleton = (count = 3) => (
    [...Array(count)].map((_, i) => (
        <TableRow key={`skeleton-student-${i}`}>
            <TableCell className="pl-6 py-3"><div className="flex items-center"><div className="h-9 w-9 rounded-full bg-gray-200 dark:bg-gray-700 animate-pulse mr-3"></div><div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-32 animate-pulse"></div></div></TableCell>
            <TableCell className="px-6 py-3"><div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-40 animate-pulse"></div></TableCell>
            <TableCell className="px-6 py-3"><div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-24 animate-pulse"></div></TableCell>
            <TableCell className="px-6 py-3"><div className="h-6 w-16 bg-gray-200 dark:bg-gray-700 rounded-full animate-pulse"></div></TableCell>
            <TableCell className="text-right pr-6 py-3"><div className="flex justify-end items-center gap-1"><div className="h-8 w-8 bg-gray-200 dark:bg-gray-700 rounded animate-pulse"></div><div className="h-8 w-8 bg-gray-200 dark:bg-gray-700 rounded animate-pulse"></div></div></TableCell>
        </TableRow>
    ))
  );


  return (
    <>
      <Card className="border border-gray-100 dark:border-gray-800 overflow-hidden shadow-sm">
        <CardHeader className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2">
          <CardTitle className="font-semibold text-gray-900 dark:text-gray-100">Alunos Recentes</CardTitle>
          <div className="flex items-center space-x-2">
            <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500 h-4 w-4 pointer-events-none" />
                <Input 
                    type="search" 
                    placeholder="Buscar alunos..." 
                    className="pl-9 w-full sm:w-48 h-9 text-sm bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 rounded-md" 
                    value={searchQuery} 
                    onChange={(e) => setSearchQuery(e.target.value)} 
                    aria-label="Pesquisar alunos"
                />
            </div>
            <Button size="sm" variant="outline" onClick={() => navigate("/alunos/novo")}> 
              <Plus className="mr-1.5 w-4 h-4" /> Adicionar
            </Button>
          </div>
        </CardHeader>
        <CardContent className="p-0">
          <div className="overflow-x-auto">
            <Table>
              <TableHeader className="bg-gray-50 dark:bg-gray-800/50">
                <TableRow>
                  <TableHead className="pl-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Aluno</TableHead> 
                  <TableHead className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Email</TableHead>
                  <TableHead className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Objetivo</TableHead> 
                  <TableHead className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Status</TableHead>
                  <TableHead className="text-right pr-6 py-3 text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Ações</TableHead> 
                </TableRow>
              </TableHeader>
              <TableBody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                {isLoading && renderStudentSkeleton(3)}
                {error && !isLoading && (
                    <TableRow><TableCell colSpan={5} className="text-center py-10"><ErrorMessage title="Erro ao Carregar Alunos" message={error.message} /></TableCell></TableRow>
                )}
                {!isLoading && !error && filteredStudents.length === 0 && ( 
                  <TableRow>
                    <TableCell colSpan={5} className="text-center py-10 text-gray-500 dark:text-gray-400"> 
                      {searchQuery ? `Nenhum aluno encontrado para "${searchQuery}".` : "Nenhum aluno cadastrado."}
                    </TableCell>
                  </TableRow>
                )}
                {!isLoading && !error && filteredStudents.map((student) => (
                    <TableRow key={student._id} className="hover:bg-slate-50 dark:hover:bg-gray-800/70"> 
                      <TableCell className="pl-6 py-3 whitespace-nowrap"> 
                        <div className="flex items-center">
                          <div className="h-9 w-9 rounded-full bg-primary/10 text-primary flex items-center justify-center mr-3 font-medium text-sm">
                            {student.nome?.split(' ').map(n => n[0]).slice(0, 2).join('').toUpperCase() || '?'}
                          </div>
                          <div className="text-sm font-medium text-gray-900 dark:text-gray-100">{student.nome || 'N/A'}</div>
                        </div>
                      </TableCell>
                      <TableCell className="px-6 py-3 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                         {student.email || '-'}
                      </TableCell>
                      <TableCell className="px-6 py-3 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400 truncate max-w-xs">
                         {student.goal || '-'}
                      </TableCell>
                      <TableCell className="px-6 py-3 whitespace-nowrap">
                           <Badge variant={student.status === 'active' ? 'success' : 'destructive'} 
                                  className={`text-xs ${student.status === 'active' ? 'bg-green-100 text-green-800 dark:bg-green-700/30 dark:text-green-300' : 'bg-red-100 text-red-800 dark:bg-red-700/30 dark:text-red-300'}`}>
                             {student.status === 'active' ? 'Ativo' : 'Inativo'}
                           </Badge>
                      </TableCell>
                      <TableCell className="px-6 py-3 whitespace-nowrap text-right">
                        <div className="flex justify-end items-center gap-0.5"> 
                          <Button variant="ghost" size="icon" onClick={() => handleViewClick(student._id)} title="Visualizar Detalhes" className="h-8 w-8 text-blue-600 hover:text-blue-700">
                            <Eye className="h-4 w-4" />
                          </Button>
                          <ActionsAluno
                            onEdit={() => handleEditClick(student)} 
                            onDelete={() => handleDeleteClick(student)}
                          />
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
              </TableBody>
            </Table>
          </div>
           {students.length > 5 && !isLoading && (
                <div className="p-4 text-center border-t border-gray-100 dark:border-gray-800">
                    <Link href="/alunos">
                        <Button variant="link" size="sm">Ver todos os alunos</Button>
                    </Link>
                </div>
            )}
        </CardContent>
      </Card>

      {modalEditarOpen && alunoSelecionado && (
        <ModalEditarAluno
          isOpen={modalEditarOpen}
          onClose={() => { setModalEditarOpen(false); setAlunoSelecionado(null); }}
          aluno={alunoSelecionado} 
          atualizarAlunos={refetchStudents} 
        />
      )}
      <ModalConfirmacao
        isOpen={isConfirmDeleteOpen}
        onClose={closeDeleteStudentDialog}
        onConfirm={confirmDeleteStudentAction}
        titulo={confirmDeleteOptions.titulo}
        mensagem={confirmDeleteOptions.mensagem}
        textoConfirmar={confirmDeleteOptions.textoConfirmar}
        textoCancelar={confirmDeleteOptions.textoCancelar}
        isLoadingConfirm={deleteStudentMutation.isPending}
      />
    </>
  );
}

===== ./client/src/components/ui/dashboard/workout-plans-grid.tsx =====
// client/src/components/ui/dashboard/workout-plans-grid.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Dumbbell, Users, Plus } from "lucide-react";
import { useQuery } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Link, useLocation } from "wouter";
import { apiRequest } from "@/lib/queryClient"; // Importar apiRequest

// Interface para os dados de plano de treino esperados da API
// Esta interface deve corresponder à estrutura de uma Ficha de Treino do tipo 'modelo'
interface WorkoutPlanModelo {
  id: string; // ou _id, dependendo da sua API/modelo Treino
  _id: string;
  name: string; // Deve ser 'titulo' do modelo Treino
  titulo: string;
  status?: "active" | "draft" | "archived" | string; // 'status' do modelo Treino
  description?: string; // 'descricao' do modelo Treino
  duration?: number; // semanas - Este campo pode não existir no modelo Treino
  // Adicionar campos que você realmente tem no modelo Treino e quer exibir
  exerciseCount?: number; // Pode ser calculado a partir de ficha.exercicios.length
  assignedStudentCount?: number; // Esta informação pode não estar diretamente na ficha modelo
  studentAvatars?: string[];
  tipo?: "modelo" | "individual";
}

interface WorkoutPlansGridProps {
  trainerId: string; // Já ajustado para string
}

export function WorkoutPlansGrid({ trainerId }: WorkoutPlansGridProps) {
  const [, navigate] = useLocation();

  // Ajustado para chamar /api/treinos com filtros
  const { data: workoutPlans, isLoading } = useQuery<WorkoutPlanModelo[], Error>({
    queryKey: ["/api/treinos", { criadorId: trainerId, tipo: 'modelo', limit: 4, forComponent: "WorkoutPlansGridDashboard" }],
    queryFn: async () => {
      if (!trainerId) throw new Error("Trainer ID não fornecido para buscar planos de treino modelo.");
      // Chama /api/treinos, o backend deve filtrar por criadorId (do token) e tipo=modelo
      return apiRequest<WorkoutPlanModelo[]>("GET", `/api/treinos?tipo=modelo&limit=4`);
    },
    enabled: !!trainerId,
  });

  const getStatusBadge = (status?: string) => {
    switch (status) {
      case "ativo": // Ajustado para corresponder ao status do modelo Treino
        return <Badge className="bg-green-100 text-green-800 hover:bg-green-200 dark:bg-green-700/30 dark:text-green-300">Ativo</Badge>;
      case "rascunho":
        return <Badge className="bg-yellow-100 text-yellow-800 hover:bg-yellow-200 dark:bg-yellow-700/30 dark:text-yellow-300">Rascunho</Badge>;
      case "arquivado":
        return <Badge className="bg-gray-100 text-gray-800 hover:bg-gray-200 dark:bg-gray-700/30 dark:text-gray-400">Arquivado</Badge>;
      default:
        return <Badge variant="outline" className="dark:text-gray-400">{status || "Indefinido"}</Badge>;
    }
  };

  const renderWorkoutSkeleton = (count = 2) => (
    <>
      {[...Array(count)].map((_, i) => (
        <div key={i} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4 shadow-sm animate-pulse">
          <div className="flex items-center justify-between mb-3">
            <div className="h-5 bg-gray-300 dark:bg-gray-600 rounded w-32"></div>
            <div className="h-6 bg-gray-300 dark:bg-gray-600 rounded w-16"></div>
          </div>
          <div className="h-4 bg-gray-300 dark:bg-gray-600 rounded w-full mb-3"></div>
          <div className="flex items-center text-xs text-gray-500 dark:text-gray-400 mb-4">
            <div className="h-3 bg-gray-300 dark:bg-gray-600 rounded w-20 mr-4"></div>
            <div className="h-3 bg-gray-300 dark:bg-gray-600 rounded w-20"></div>
          </div>
          <div className="flex justify-between items-center">
            <div className="flex -space-x-2">
              {[1,2,3].map(s => <div key={s} className="w-6 h-6 rounded-full bg-gray-400 dark:bg-gray-500 border-2 border-white dark:border-gray-800"></div>)}
            </div>
            <div className="h-8 bg-gray-300 dark:bg-gray-600 rounded w-20"></div>
          </div>
        </div>
      ))}
    </>
  );

  return (
    <Card className="border border-gray-100 dark:border-gray-800 overflow-hidden shadow-sm">
      <CardHeader className="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex flex-row items-center justify-between">
        <CardTitle className="font-semibold text-gray-900 dark:text-gray-100">Planos de Treino Modelo</CardTitle>
        <div className="flex items-center space-x-2">
          <Link href="/treinos" className="text-sm text-primary hover:text-primary/90 dark:hover:text-primary/70">
            Ver todos
          </Link>
          <Button size="sm" variant="outline" onClick={() => navigate("/treinos")}> {/* Navega para /treinos onde pode criar novo */}
            <Plus className="w-4 h-4 mr-1.5" />
            Novo Plano
          </Button>
        </div>
      </CardHeader>
      <CardContent className="p-4 md:p-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6">
          {isLoading ? (
            renderWorkoutSkeleton()
          ) : (
            <>
              {workoutPlans && workoutPlans.length > 0 ? workoutPlans.map((plan) => (
                <div key={plan._id} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4 hover:shadow-md transition-shadow duration-150 flex flex-col justify-between">
                  <div>
                    <div className="flex items-start justify-between mb-2">
                      <h4 className="font-medium text-gray-800 dark:text-gray-200 truncate" title={plan.titulo}>{plan.titulo}</h4>
                      {getStatusBadge(plan.status)}
                    </div>
                    <p className="text-sm text-gray-500 dark:text-gray-400 mb-3 line-clamp-2" title={plan.description}>
                      {plan.description || (plan.duration ? `Programa de ${plan.duration} semanas` : "Sem descrição")}
                    </p>
                    <div className="flex items-center text-xs text-gray-500 dark:text-gray-400 mb-4 space-x-3">
                      {plan.exerciseCount !== undefined && (
                        <span className="flex items-center">
                          <Dumbbell className="w-3 h-3 mr-1" /> {plan.exerciseCount} exercícios
                        </span>
                      )}
                      {/* assignedStudentCount e studentAvatars podem não vir diretamente do modelo Treino tipo 'modelo' */}
                      {/* Você pode precisar de outra lógica se quiser exibir isso */}
                    </div>
                  </div>
                  <div className="flex justify-between items-center mt-auto pt-3 border-t border-gray-100 dark:border-gray-700">
                    <div className="flex -space-x-2 overflow-hidden">
                      {/* Lógica para avatares de alunos, se aplicável a planos modelo */}
                    </div>
                    <Button 
                      variant="link" 
                      size="sm" 
                      className="text-primary hover:text-primary/90 dark:hover:text-primary/70 font-medium p-0 h-auto"
                      onClick={() => navigate(`/treinos`)} // Idealmente, navegar para o detalhe do plano/ficha: /treinos/${plan._id}
                    >
                      Ver Detalhes
                    </Button>
                  </div>
                </div>
              )) : (
                <div className="md:col-span-2 text-center py-8 text-sm text-gray-500 dark:text-gray-400">
                  Nenhum plano de treino modelo encontrado. <Link href="/treinos" className="text-primary hover:underline">Crie seu primeiro plano!</Link>
                </div>
              )}
            </>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

===== ./client/src/components/ui/dialog.tsx =====
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

===== ./client/src/components/ui/drawer.tsx =====
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

===== ./client/src/components/ui/dropdown-menu.tsx =====
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

===== ./client/src/components/ui/form.tsx =====
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

===== ./client/src/components/ui/hover-card.tsx =====
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }

===== ./client/src/components/ui/input-otp.tsx =====
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

===== ./client/src/components/ui/input.tsx =====
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-11 w-full rounded-xl border-2 border-input bg-background px-4 py-2 text-base ring-offset-background transition-all duration-200 file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:border-primary hover:border-primary/50 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm touch-target",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

===== ./client/src/components/ui/label.tsx =====
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

===== ./client/src/components/ui/menubar.tsx =====
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}

===== ./client/src/components/ui/modal-confirmacao.tsx =====
// client/src/components/ui/modal-confirmacao.tsx
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogDescription, // Importar DialogDescription se quiser usá-la
} from "@/components/ui/dialog";
// ---> ADICIONADO: Importar Loader2 <---
import { Loader2 } from "lucide-react";

interface ModalConfirmacaoProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  titulo?: string;
  mensagem?: string | React.ReactNode; // Permitir ReactNode para mais flexibilidade
  textoConfirmar?: string;
  textoCancelar?: string;
  isLoadingConfirm?: boolean; // ---> ADICIONADO: Nova prop para estado de loading <---
}

export function ModalConfirmacao({
  isOpen,
  onClose,
  onConfirm,
  titulo = "Confirmação",
  mensagem = "Tem certeza que deseja continuar?",
  textoConfirmar = "Confirmar",
  textoCancelar = "Cancelar",
  isLoadingConfirm = false, // ---> ADICIONADO: Valor padrão false <---
}: ModalConfirmacaoProps) {
  return (
    // Controla a abertura/fechamento do Dialog pelo estado externo 'isOpen'
    // onOpenChange chama onClose quando o usuário tenta fechar (clique fora, Esc)
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="max-w-md w-full p-6 rounded-lg bg-background shadow-lg space-y-4">
        <DialogHeader className="text-center sm:text-left"> {/* Ajuste de alinhamento */}
          <DialogTitle className="text-lg font-semibold"> {/* Ajuste de tamanho/peso */}
            {titulo}
          </DialogTitle>
          {/* Opcional: Usar DialogDescription para a mensagem principal */}
           {typeof mensagem === 'string' ? (
             <DialogDescription className="text-sm text-muted-foreground pt-2">
               {mensagem}
             </DialogDescription>
           ) : (
             // Renderiza diretamente se for um ReactNode
             <div className="text-sm text-muted-foreground pt-2">{mensagem}</div>
           )}
        </DialogHeader>

        {/* Removido div extra, mensagem agora está no Header com DialogDescription */}
        {/* <div className="text-center text-gray-600 dark:text-gray-300">
          {mensagem}
        </div> */}

        <DialogFooter className="flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2 pt-2"> {/* Ajustes de layout do footer */}
          {/* Botão Cancelar */}
          <Button
            variant="outline"
            onClick={onClose}
            disabled={isLoadingConfirm} // Desabilita durante o loading
          >
            {textoCancelar}
          </Button>
          {/* Botão Confirmar (Destrutivo) */}
          <Button
            variant="destructive" // Mantém variante destrutiva
            onClick={onConfirm}
            disabled={isLoadingConfirm} // Desabilita durante o loading
          >
            {/* Mostra spinner se estiver carregando */}
            {isLoadingConfirm && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            {textoConfirmar}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
===== ./client/src/components/ui/navigation-menu.tsx =====
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

===== ./client/src/components/ui/pagination.tsx =====
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}

===== ./client/src/components/ui/popover.tsx =====
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

===== ./client/src/components/ui/progress.tsx =====
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const progressVariants = cva(
  "relative w-full overflow-hidden rounded-full bg-secondary",
  {
    variants: {
      size: {
        default: "h-3",
        sm: "h-2",
        lg: "h-4",
        xl: "h-6",
      },
      variant: {
        default: "bg-secondary",
        glass: "glass bg-white/10 border border-white/20",
      },
    },
    defaultVariants: {
      size: "default",
      variant: "default",
    },
  }
)

const indicatorVariants = cva(
  "h-full w-full flex-1 transition-all duration-500 ease-out",
  {
    variants: {
      variant: {
        default: "bg-gradient-to-r from-primary to-primary/90",
        success: "bg-gradient-to-r from-success to-success/90",
        warning: "bg-gradient-to-r from-warning to-warning/90",
        destructive: "bg-gradient-to-r from-destructive to-destructive/90",
        glass: "bg-gradient-to-r from-white/80 to-white/60",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface ProgressProps
  extends React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>,
    VariantProps<typeof progressVariants> {
  indicatorVariant?: VariantProps<typeof indicatorVariants>["variant"]
}

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  ProgressProps
>(({ className, value, size, variant, indicatorVariant, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(progressVariants({ size, variant }), className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className={cn(indicatorVariants({ variant: indicatorVariant || variant }))}
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

===== ./client/src/components/ui/radio-group.tsx =====
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

===== ./client/src/components/ui/resizable.tsx =====
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

===== ./client/src/components/ui/scroll-area.tsx =====
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

===== ./client/src/components/ui/select.tsx =====
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

===== ./client/src/components/ui/separator.tsx =====
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

===== ./client/src/components/ui/sheet.tsx =====
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

===== ./client/src/components/ui/sidebar.tsx =====
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

===== ./client/src/components/ui/skeleton.tsx =====
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-xl bg-gradient-to-r from-muted to-muted/50", className)}
      {...props}
    />
  )
}

// Modern Card Skeleton
function CardSkeleton({ className }: { className?: string }) {
  return (
    <div className={cn("rounded-xl border bg-card shadow-elevated p-6 animate-fade-in", className)}>
      <div className="space-y-4">
        <Skeleton className="h-4 w-3/4" />
        <Skeleton className="h-3 w-1/2" />
        <div className="space-y-2">
          <Skeleton className="h-3 w-full" />
          <Skeleton className="h-3 w-5/6" />
        </div>
      </div>
    </div>
  )
}

// Table Skeleton
function TableSkeleton({ rows = 5 }: { rows?: number }) {
  return (
    <div className="rounded-xl border bg-card shadow-elevated p-6">
      <div className="space-y-4">
        <Skeleton className="h-6 w-1/4" />
        <div className="space-y-3">
          {Array.from({ length: rows }).map((_, i) => (
            <div key={i} className="flex space-x-4">
              <Skeleton className="h-4 w-1/6" />
              <Skeleton className="h-4 w-1/4" />
              <Skeleton className="h-4 w-1/5" />
              <Skeleton className="h-4 w-1/6" />
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

// Profile Skeleton
function ProfileSkeleton() {
  return (
    <div className="flex items-center space-x-4 p-4">
      <Skeleton className="h-12 w-12 rounded-full" />
      <div className="space-y-2">
        <Skeleton className="h-4 w-32" />
        <Skeleton className="h-3 w-24" />
      </div>
    </div>
  )
}

export { Skeleton, CardSkeleton, TableSkeleton, ProfileSkeleton }

===== ./client/src/components/ui/slider.tsx =====
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

===== ./client/src/components/ui/switch.tsx =====
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

===== ./client/src/components/ui/table.tsx =====
// src/components/ui/table.tsx
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-x-auto rounded-xl border border-border bg-card shadow-elevated">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead 
    ref={ref} 
    className={cn("bg-muted/50 [&_tr]:border-b [&_tr]:border-border", className)} 
    {...props} 
  />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/30 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b border-border transition-all duration-200 hover:bg-muted/30 data-[state=selected]:bg-muted/50 even:bg-muted/10",
      className
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-6 text-left align-middle font-semibold text-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("px-6 py-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};

===== ./client/src/components/ui/tabs.tsx =====
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

===== ./client/src/components/ui/textarea.tsx =====
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

===== ./client/src/components/ui/toast.tsx =====
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-6 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <Cross2Icon className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

===== ./client/src/components/ui/toaster.tsx =====
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

===== ./client/src/components/ui/toggle-group.tsx =====
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

===== ./client/src/components/ui/toggle.tsx =====
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

===== ./client/src/components/ui/tooltip.tsx =====
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

===== ./client/src/context/AlunoContext.tsx =====
// client/src/context/AlunoContext.tsx
import React, { createContext, useState, useEffect, useContext, ReactNode, useCallback } from 'react';
import { jwtDecode } from 'jwt-decode';
import { useLocation } from 'wouter';
import { apiRequest } from '@/lib/queryClient';

export interface AlunoLogado {
  id: string;
  nome: string;
  role: 'aluno';
  email: string;
  personalId?: string;
  exp?: number;
  iat?: number;
}

interface AlunoRefreshResponse {
  message: string;
  token: string;
  aluno: AlunoLogado;
}

interface AlunoContextType {
  aluno: AlunoLogado | null;
  tokenAluno: string | null;
  isLoadingAluno: boolean;
  loginAluno: (token: string, refreshToken: string) => void;
  logoutAluno: (options?: { redirect?: boolean }) => void;
  checkAlunoSession: () => void;
}

export const AlunoContext = createContext<AlunoContextType | undefined>(undefined);

export const AlunoProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [aluno, setAluno] = useState<AlunoLogado | null>(null);
  const [tokenAluno, setTokenAluno] = useState<string | null>(null);
  const [isLoadingAluno, setIsLoadingAluno] = useState<boolean>(true);
  const [, setLocationWouter] = useLocation();

  const ALUNO_TOKEN_KEY = 'alunoAuthToken';
  const ALUNO_REFRESH_TOKEN_KEY = 'alunoRefreshToken';

  const isPublicInviteRoute = useCallback((pathname?: string) => {
    const currentPath = pathname || window.location.pathname;
    return currentPath.includes('/convite/aluno/') || 
           currentPath.includes('/cadastrar-aluno/convite/') ||
           currentPath.includes('/cadastrar-personal/convite/');
  }, []);

  const setAlunoFromToken = useCallback((token: string): AlunoLogado | null => {
    try {
      const decodedToken = jwtDecode<AlunoLogado>(token);
      if (decodedToken.exp && decodedToken.exp * 1000 <= Date.now()) {
        return null;
      }
      if (decodedToken.id && decodedToken.role === 'aluno' && decodedToken.nome && decodedToken.email) {
        setAluno(decodedToken);
        setTokenAluno(token);
        localStorage.setItem(ALUNO_TOKEN_KEY, token);
        return decodedToken;
      }
      return null;
    } catch (error) {
      return null;
    }
  }, []);

  const logoutAluno = useCallback((options?: { redirect?: boolean }) => {
    const shouldRedirect = options?.redirect ?? true;
    console.log("[AlunoContext] Iniciando logout do aluno...");

    setAluno(null);
    setTokenAluno(null);
    localStorage.removeItem(ALUNO_TOKEN_KEY);
    localStorage.removeItem(ALUNO_REFRESH_TOKEN_KEY);
    localStorage.removeItem('alunoData');
    
    // <<< CORREÇÃO PRINCIPAL AQUI >>>
    // Só redireciona se um Personal/Admin NÃO estiver logado.
    // Isso impede que o logout do Aluno (em background) expulse um Personal logado.
    const personalToken = localStorage.getItem('authToken');
    if (shouldRedirect && !personalToken) {
        console.log("[AlunoContext] Nenhum Personal logado. Redirecionando para /login.");
        setLocationWouter("/login");
    } else if (personalToken) {
        console.log("[AlunoContext] Personal está logado. Logout do aluno efetuado sem redirecionamento.");
    }
  }, [setLocationWouter]);

  const refreshAlunoToken = useCallback(async (): Promise<boolean> => {
    const refreshToken = localStorage.getItem(ALUNO_REFRESH_TOKEN_KEY);
    if (!refreshToken) {
      return false;
    }

    try {
      const response = await apiRequest('POST', '/api/auth/aluno/refresh', { refreshToken }, 'aluno') as AlunoRefreshResponse;
      if (response.token && response.aluno) {
        setAlunoFromToken(response.token);
        return true;
      }
      logoutAluno({ redirect: false }); // Não redireciona se falhar
      return false;
    } catch (error) {
      logoutAluno({ redirect: false }); // Não redireciona se falhar
      return false;
    }
  }, [setAlunoFromToken, logoutAluno]);

  const loginAluno = useCallback((token: string, refreshToken: string) => {
    setAlunoFromToken(token);
    localStorage.setItem(ALUNO_REFRESH_TOKEN_KEY, refreshToken);
  }, [setAlunoFromToken]);

  const checkAlunoSession = useCallback(async () => {
    setIsLoadingAluno(true);
    // <<< CORREÇÃO: Não fazer nada se estiver em rotas públicas de convite >>>
    if (isPublicInviteRoute()) {
        setIsLoadingAluno(false);
        return;
    }

    const storedToken = localStorage.getItem(ALUNO_TOKEN_KEY);

    if (storedToken) {
        try {
            const decodedToken = jwtDecode<AlunoLogado>(storedToken);
            if (decodedToken.exp && decodedToken.exp * 1000 > Date.now()) {
                setAlunoFromToken(storedToken);
            } else {
                const refreshed = await refreshAlunoToken();
                if (!refreshed) logoutAluno({ redirect: false }); // Não redireciona
            }
        } catch {
            logoutAluno({ redirect: false }); // Não redireciona
        }
    } else {
        const refreshed = await refreshAlunoToken();
        if (!refreshed) {
             // Só limpa o estado se não houver token, sem forçar logout/redirect
             setAluno(null);
             setTokenAluno(null);
        }
    }
    setIsLoadingAluno(false);
  }, [setAlunoFromToken, refreshAlunoToken, logoutAluno, isPublicInviteRoute]);

  useEffect(() => {
    checkAlunoSession();
  }, [checkAlunoSession]);
  
  return (
    <AlunoContext.Provider value={{ aluno, tokenAluno, isLoadingAluno, loginAluno, logoutAluno, checkAlunoSession }}>
      {children}
    </AlunoContext.Provider>
  );
};

export const useAluno = (): AlunoContextType => {
  const context = useContext(AlunoContext);
  if (context === undefined) {
    throw new Error('useAluno deve ser usado dentro de um AlunoProvider');
  }
  return context;
};
===== ./client/src/context/PWAInstallContext.tsx =====
// client/src/context/PWAInstallContext.tsx
import React, { createContext, useState, useEffect, useContext, ReactNode, useCallback } from 'react';
// <<< INÍCIO DA ALTERAÇÃO >>>
import { Share, PlusSquare, X } from 'lucide-react'; 
// <<< FIM DA ALTERAÇÃO >>>

// Interface para o evento especial que o navegador dispara para PWAs
interface BeforeInstallPromptEvent extends Event {
  readonly platforms: string[];
  readonly userChoice: Promise<{
    outcome: 'accepted' | 'dismissed';
    platform: string;
  }>;
  prompt(): Promise<void>;
}

interface PWAInstallContextType {
  canInstall: boolean;
  triggerInstallPrompt: () => void;
  // <<< INÍCIO DA ALTERAÇÃO >>>
  showIOSInstallBanner: boolean;
  // <<< FIM DA ALTERAÇÃO >>>
}

const PWAInstallContext = createContext<PWAInstallContextType | undefined>(undefined);


// <<< INÍCIO DA CRIAÇÃO DO NOVO COMPONENTE >>>
const IOSInstallBanner: React.FC = () => {
    const [isVisible, setIsVisible] = useState(true);

    if (!isVisible) {
        return null;
    }

    return (
        <div className="fixed bottom-4 left-1/2 -translate-x-1/2 w-[95%] max-w-lg bg-indigo-700 text-white p-3 rounded-lg shadow-2xl z-50 animate-slide-up-fade-in">
            <button
                onClick={() => setIsVisible(false)}
                className="absolute top-1 right-1 p-1 text-indigo-200 hover:text-white"
                aria-label="Dispensar"
            >
                <X size={16} />
            </button>
            <div className="flex items-center gap-3">
                <img src="/pwa-192x192.png" alt="DyFit Logo" className="w-12 h-12 rounded-lg" />
                <div>
                    <p className="font-bold text-sm">Instale o DyFit no seu iPhone!</p>
                    <p className="text-xs text-indigo-200 mt-1">
                        Toque em <Share size={12} className="inline-block mx-1" />
                        e depois em 'Adicionar à Tela de Início' <PlusSquare size={12} className="inline-block mx-1" />
                    </p>
                </div>
            </div>
        </div>
    );
};
// <<< FIM DA CRIAÇÃO DO NOVO COMPONENTE >>>
// CONTINUAÇÃO...

export const PWAInstallProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [installPromptEvent, setInstallPromptEvent] = useState<BeforeInstallPromptEvent | null>(null);
  // <<< INÍCIO DA ALTERAÇÃO >>>
  const [showIOSInstallBanner, setShowIOSInstallBanner] = useState(false);
  // <<< FIM DA ALTERAÇÃO >>>

  useEffect(() => {
    console.log('[PWA Context] Contexto inicializado e ouvindo pelo evento de instalação.');

    // --- Lógica para Android/Desktop (baseada em evento) ---
    const handleBeforeInstallPrompt = (event: Event) => {
      event.preventDefault();
      setInstallPromptEvent(event as BeforeInstallPromptEvent);
      console.log('[PWA Context] SUCESSO: Evento de instalação capturado e pronto para ser usado.');
    };
    window.addEventListener('beforeinstallprompt', handleBeforeInstallPrompt);

    // --- Lógica para iOS (baseada em detecção do navegador) ---
    const isIOS = () => /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;
    const isPWAInstalled = window.matchMedia('(display-mode: standalone)').matches;

    // Se for iOS e o app ainda NÃO estiver instalado, mostramos o banner de instrução.
    if (isIOS() && !isPWAInstalled) {
      // Pequeno delay para garantir que a UI principal renderize primeiro
      setTimeout(() => {
        setShowIOSInstallBanner(true);
      }, 1500);
    }
    
    return () => {
      window.removeEventListener('beforeinstallprompt', handleBeforeInstallPrompt);
    };
  }, []);

  const triggerInstallPrompt = useCallback(() => {
    if (!installPromptEvent) {
      console.error("[PWA Context] FALHA: O botão 'Instalar' foi clicado, mas o navegador ainda não forneceu o evento 'beforeinstallprompt'.");
      alert("A instalação não está disponível no momento. Verifique se você está usando um navegador compatível (como Chrome ou Edge) e se o site é seguro (HTTPS).");
      return;
    }
    
    installPromptEvent.prompt();

    installPromptEvent.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === 'accepted') {
        console.log('[PWA Context] Usuário aceitou a instalação do PWA.');
      } else {
        console.log('[PWA Context] Usuário recusou a instalação do PWA.');
      }
      setInstallPromptEvent(null);
    });
  }, [installPromptEvent]);

  const value = {
    canInstall: installPromptEvent !== null,
    triggerInstallPrompt,
    // <<< INÍCIO DA ALTERAÇÃO >>>
    showIOSInstallBanner,
    // <<< FIM DA ALTERAÇÃO >>>
  };

  return (
    <PWAInstallContext.Provider value={value}>
      {children}
      {/* <<< INÍCIO DA ALTERAÇÃO >>> */}
      {/* O banner de instrução para iOS é renderizado aqui se a condição for verdadeira */}
      {showIOSInstallBanner && <IOSInstallBanner />}
      {/* <<< FIM DA ALTERAÇÃO >>> */}
    </PWAInstallContext.Provider>
  );
};

export const usePWAInstall = (): PWAInstallContextType => {
  const context = useContext(PWAInstallContext);
  if (context === undefined) {
    throw new Error('usePWAInstall deve ser usado dentro de um PWAInstallProvider');
  }
  return context;
};
===== ./client/src/context/UserContext.tsx =====
// client/src/context/UserContext.tsx
import { createContext, useContext, useState, ReactNode, useEffect, useCallback } from "react";
import { useLocation } from "wouter";

export interface User {
  id: string;
  username: string;
  firstName: string;
  lastName: string;
  email: string;
  role: string;
}

interface UserContextType {
  user: User | null;
  setUser: (user: User | null) => void;
  logout: (options?: { redirect?: boolean }) => void;
  isLoading: boolean;
}

export const UserContext = createContext<UserContextType>({
  user: null,
  setUser: () => { console.warn("setUser called outside UserProvider"); },
  logout: () => { console.warn("logout called outside UserProvider"); },
  isLoading: true,
});

export function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUserState] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [, setLocationWouter] = useLocation();

  useEffect(() => {
    try {
      const storedUserData = localStorage.getItem('userData');
      if (storedUserData) {
        const parsedUser: User = JSON.parse(storedUserData);
         if (parsedUser && parsedUser.id) {
            setUserState(parsedUser);
         } else {
            console.warn("Dados do usuário no localStorage inválidos.");
            localStorage.removeItem('userData');
         }
      }
    } catch (error) {
      console.error("Erro ao carregar usuário do localStorage:", error);
      localStorage.removeItem('userData');
    } finally {
      setIsLoading(false);
    }
  }, []);

  const handleSetUser = (newUser: User | null) => {
    setUserState(newUser);
    if (newUser) {
      localStorage.setItem('userData', JSON.stringify(newUser));
    } else {
      localStorage.removeItem('userData');
      localStorage.removeItem('authToken');
      localStorage.removeItem('refreshToken');
    }
  };

  const logout = useCallback((options?: { redirect?: boolean }) => {
    const shouldRedirect = options?.redirect ?? true;
    console.log(`[UserContext] logout chamado. Limpando dados do Personal/Admin. Redirecionar: ${shouldRedirect}`);
    handleSetUser(null);

    // <<< CORREÇÃO PRINCIPAL AQUI >>>
    // Só redireciona se um Aluno NÃO estiver logado.
    // Isso impede que o logout do Personal (em background) expulse um Aluno logado.
    const alunoToken = localStorage.getItem('alunoAuthToken');
    if (shouldRedirect && !alunoToken) {
      console.log("[UserContext] Nenhum Aluno logado. Redirecionando para /login.");
      setLocationWouter("/login");
    } else if (alunoToken) {
      console.log("[UserContext] Aluno está logado. Logout do Personal efetuado sem redirecionamento.");
    }
  }, [setLocationWouter]);

  useEffect(() => {
    const handleAuthFailed = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail && customEvent.detail.status === 401) {
        if (customEvent.detail.forPersonalAdmin && user) {
          console.warn("[UserContext] Falha de autenticação (401) para Personal/Admin detectada. Fazendo logout...");
          logout();
        }
      }
    };

    window.addEventListener('auth-failed', handleAuthFailed as EventListener);
    return () => {
      window.removeEventListener('auth-failed', handleAuthFailed as EventListener);
    };
  }, [user, logout]);

  const value: UserContextType = {
      user,
      setUser: handleSetUser,
      logout,
      isLoading
    };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
}

export function useUser() {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error("useUser must be used within a UserProvider");
  }
  return context;
}
===== ./client/src/context/WorkoutPlayerContext.tsx =====
// client/src/context/WorkoutPlayerContext.tsx
import React, { createContext, useState, useEffect, useContext, ReactNode, useCallback, useRef } from 'react';

// --- Tipos de Dados ---
interface WorkoutExercise {
  _id: string; 
  exercicioDetalhes: { nome: string; } | null;
  carga?: string;
  descanso?: string;
}

interface WorkoutSession {
  startTime: number;
  exercises: WorkoutExercise[];
  completedExercises: string[];
  exerciseLoads: Record<string, string>;
  diaDeTreinoId?: string;
  rotinaId?: string;
}

interface WorkoutPlayerContextType {
  isWorkoutActive: boolean;
  startWorkout: (exercises: WorkoutExercise[], diaDeTreinoId: string, rotinaId: string) => void;
  stopWorkout: () => void;
  resetWorkout: () => void;
  completeExercise: (exerciseId: string) => void;
  uncompleteExercise: (exerciseId: string) => void;
  completeMultipleExercises: (exerciseIds: string[]) => void;
  uncompleteMultipleExercises: (exerciseIds: string[]) => void;
  activeExerciseId: string | null;
  completedExercises: Set<string>;
  elapsedTime: number;
  updateExerciseLoad: (exerciseId: string, load: string) => void;
  getExerciseLoad: (exerciseId: string) => string;
  restTimeRemaining: number | null;
  isResting: boolean;
  workoutStartTime: Date | null;
  currentWorkoutSession: WorkoutSession | null;
}

const WorkoutPlayerContext = createContext<WorkoutPlayerContextType | undefined>(undefined);

const WORKOUT_SESSION_KEY = 'dyfit-active-workout-session';

export const WorkoutPlayerProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [isWorkoutActive, setIsWorkoutActive] = useState(false);
  const [session, setSession] = useState<WorkoutSession | null>(null);
  const [elapsedTime, setElapsedTime] = useState(0);
  const [restTimeRemaining, setRestTimeRemaining] = useState<number | null>(null);
  const [isResting, setIsResting] = useState<boolean>(false);

  const timerRef = useRef<NodeJS.Timeout | null>(null);
  
  useEffect(() => {
    console.log('[WorkoutPlayerContext] CONTEXT_INIT: Contexto está sendo montado.');
    try {
      const savedSessionRaw = localStorage.getItem(WORKOUT_SESSION_KEY);
      if (savedSessionRaw) {
        console.log('[WorkoutPlayerContext] CONTEXT_INIT: Sessão encontrada no localStorage:', savedSessionRaw);
        const savedSession: WorkoutSession = JSON.parse(savedSessionRaw);
        setSession(savedSession);
        setIsWorkoutActive(true);
        // Recalcular elapsedTime na hidratação para refletir o tempo real
        const now = Date.now();
        const start = savedSession.startTime;
        setElapsedTime(Math.floor((now - start) / 1000));
        console.log('[WorkoutPlayerContext] CONTEXT_INIT: Estado do contexto HIDRATADO com sucesso. Tempo decorrido inicial:', Math.floor((now - start) / 1000), 'segundos.');
      } else {
        console.log('[WorkoutPlayerContext] CONTEXT_INIT: Nenhuma sessão ativa encontrada no localStorage.');
      }
    } catch (error) {
      console.error("[WorkoutPlayerContext] CONTEXT_INIT: Erro ao carregar sessão do localStorage:", error);
      localStorage.removeItem(WORKOUT_SESSION_KEY);
    }

    return () => {
      console.log('[WorkoutPlayerContext] CONTEXT_CLEANUP: Limpando timer ao desmontar o contexto.');
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, []);

  useEffect(() => {
    console.log(`[WorkoutPlayerContext] TIMER_EFFECT: isWorkoutActive mudou para ${isWorkoutActive}, session mudou para ${session ? 'Existente' : 'Nulo'}, isResting mudou para ${isResting}.`);
    if (timerRef.current) {
      console.log('[WorkoutPlayerContext] TIMER_EFFECT: Limpando timer existente.');
      clearInterval(timerRef.current);
    }

    if (isWorkoutActive && session) {
      console.log(`[WorkoutPlayerContext] TIMER_EFFECT: Timer ativado. Início da sessão: ${new Date(session.startTime).toLocaleTimeString()}`);
      timerRef.current = setInterval(() => {
        if (isResting) {
          setRestTimeRemaining(prev => {
            if (prev !== null && prev > 1) {
              console.log(`[WorkoutPlayerContext] TIMER_TICK: Descanso restante: ${prev - 1}s`);
              return prev - 1;
            } else {
              console.log('[WorkoutPlayerContext] TIMER_TICK: Descanso terminou. Retornando ao treino.');
              setIsResting(false);
              return null;
            }
          });
        } else {
          const now = Date.now();
          const start = session.startTime;
          const newElapsedTime = Math.floor((now - start) / 1000);
          console.log(`[WorkoutPlayerContext] TIMER_TICK: Tempo decorrido: ${newElapsedTime}s`);
          setElapsedTime(newElapsedTime);
        }
      }, 1000);
    } else {
        console.log(`[WorkoutPlayerContext] TIMER_EFFECT: Timer parado. isWorkoutActive: ${isWorkoutActive}, session: ${session ? 'Existe' : 'Nulo'}`);
    }
    return () => { 
      console.log('[WorkoutPlayerContext] TIMER_EFFECT_CLEANUP: Limpando timer ao sair do efeito.');
      if (timerRef.current) clearInterval(timerRef.current); 
    };
  }, [isWorkoutActive, session, isResting]);

  const findNextActiveExercise = useCallback((currentList: WorkoutExercise[], completedSet: Set<string>) => {
    const next = currentList.find(e => !completedSet.has(e._id))?._id || null;
    console.log('[WorkoutPlayerContext] findNextActiveExercise: Próximo exercício ativo:', next);
    return next;
  }, []);
  
  const updateSession = (newSessionData: Partial<WorkoutSession> | null) => {
    if (newSessionData === null) {
      console.log('[WorkoutPlayerContext] UPDATE_SESSION: Removendo sessão do estado e localStorage.');
      setSession(null);
      localStorage.removeItem(WORKOUT_SESSION_KEY);
      return;
    }
    setSession(prevSession => {
      const updated = { ...prevSession, ...newSessionData } as WorkoutSession;
      console.log('[WorkoutPlayerContext] UPDATE_SESSION: Atualizando sessão no localStorage:', updated);
      localStorage.setItem(WORKOUT_SESSION_KEY, JSON.stringify(updated));
      return updated;
    });
  };

  const startWorkout = useCallback((initialExercises: WorkoutExercise[], diaDeTreinoId: string, rotinaId: string) => {
    console.log(`[WorkoutPlayerContext] START_WORKOUT: Função chamada para o diaDeTreinoId: ${diaDeTreinoId}, rotinaId: ${rotinaId}`);
    
    const createNewWorkoutSession = () => {
      console.log('[WorkoutPlayerContext] START_WORKOUT: Executando createNewWorkoutSession...');
      const startTime = Date.now();
      
      // Initialize exercise loads from template
      const initialLoads: Record<string, string> = {};
      initialExercises.forEach(exercise => {
        if (exercise.carga && exercise.carga.trim()) {
          initialLoads[exercise._id] = exercise.carga.trim();
          console.log(`[WorkoutPlayerContext] START_WORKOUT: Inicializando carga para exercício ${exercise._id}: ${exercise.carga}`);
        }
      });
      
      const newSession: WorkoutSession = {
        startTime,
        exercises: initialExercises,
        completedExercises: [],
        exerciseLoads: initialLoads,
        diaDeTreinoId,
        rotinaId,
      };
      setSession(newSession);
      setIsWorkoutActive(true);
      setElapsedTime(0); // Resetar tempo ao iniciar nova sessão
      localStorage.setItem(WORKOUT_SESSION_KEY, JSON.stringify(newSession));
      console.log('[WorkoutPlayerContext] START_WORKOUT: Nova sessão criada e salva no localStorage:', newSession);
    };

    const savedSessionRaw = localStorage.getItem(WORKOUT_SESSION_KEY);

    if (savedSessionRaw) {
      console.log('[WorkoutPlayerContext] START_WORKOUT: Verificando sessão existente no localStorage...');
      try {
        const savedSession: WorkoutSession = JSON.parse(savedSessionRaw);
        if (savedSession.diaDeTreinoId !== diaDeTreinoId) {
          console.warn(`[WorkoutPlayerContext] START_WORKOUT: Sessão ativa para um treino diferente encontrada (${savedSession.diaDeTreinoId}). Resetando e iniciando a nova (${diaDeTreinoId}).`);
          createNewWorkoutSession();
        } else {
          console.log('[WorkoutPlayerContext] START_WORKOUT: Treino já está ativo para este dia. Hidratando sessão existente.');
          setSession(savedSession); // Garantir que o estado da sessão seja o salvo
          setIsWorkoutActive(true);
          // Recalcular elapsedTime para a sessão existente
          const now = Date.now();
          const start = savedSession.startTime;
          setElapsedTime(Math.floor((now - start) / 1000));
          console.log('[WorkoutPlayerContext] START_WORKOUT: Sessão existente reativada. Tempo decorrido:', Math.floor((now - start) / 1000), 'segundos.');
        }
      } catch (e) {
        console.error('[WorkoutPlayerContext] START_WORKOUT: Erro ao parsear sessão existente do localStorage, criando uma nova.', e);
        localStorage.removeItem(WORKOUT_SESSION_KEY); // Limpar dados corrompidos
        createNewWorkoutSession();
      }
    } else {
      console.log('[WorkoutPlayerContext] START_WORKOUT: Nenhuma sessão salva encontrada, criando uma nova.');
      createNewWorkoutSession();
    }
  }, []); // Removido isWorkoutActive das dependências para evitar loop e garantir que a lógica de start seja sempre a mesma

  const stopWorkout = useCallback(() => {
    console.log('[WorkoutPlayerContext] STOP_WORKOUT: Pausando o treino (isWorkoutActive = false).');
    setIsWorkoutActive(false);
  }, []);
  
  const resetWorkout = useCallback(() => {
    console.log('[WorkoutPlayerContext] RESET_WORKOUT: Resetando completamente o estado do treino e limpando localStorage.');
    setIsWorkoutActive(false);
    setSession(null);
    setElapsedTime(0);
    setIsResting(false);
    setRestTimeRemaining(null);
    localStorage.removeItem(WORKOUT_SESSION_KEY);
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = null;
    }
  }, []);
  
  const completeExercise = useCallback((exerciseId: string) => {
    console.log(`[WorkoutPlayerContext] COMPLETE_EXERCISE: Exercício ${exerciseId} marcado como concluído.`);
    if (!session) {
      console.warn('[WorkoutPlayerContext] COMPLETE_EXERCISE: Nenhuma sessão ativa para completar exercício.');
      return;
    }
    
    const newCompletedArray = [...session.completedExercises, exerciseId];
    const newCompletedSet = new Set(newCompletedArray);

    updateSession({ completedExercises: newCompletedArray });

    const currentExercise = session.exercises.find(e => e._id === exerciseId);
    const restSeconds = currentExercise?.descanso ? parseInt(currentExercise.descanso, 10) : 0;
    console.log(`[WorkoutPlayerContext] COMPLETE_EXERCISE: Descanso para o exercício ${exerciseId}: ${restSeconds}s`);
    
    const nextActiveId = findNextActiveExercise(session.exercises, newCompletedSet);
    if (!nextActiveId || restSeconds <= 0) {
      console.log('[WorkoutPlayerContext] COMPLETE_EXERCISE: Sem próximo exercício ou sem descanso. Não iniciando descanso.');
      setIsResting(false);
    } else {
      console.log('[WorkoutPlayerContext] COMPLETE_EXERCISE: Iniciando descanso.');
      setIsResting(true);
      setRestTimeRemaining(restSeconds);
    }
  }, [session, findNextActiveExercise, updateSession]);

  const uncompleteExercise = useCallback((exerciseId: string) => {
    console.log(`[WorkoutPlayerContext] UNCOMPLETE_EXERCISE: Exercício ${exerciseId} marcado como não concluído.`);
    if (!session) {
      console.warn('[WorkoutPlayerContext] UNCOMPLETE_EXERCISE: Nenhuma sessão ativa para desmarcar exercício.');
      return;
    }
    const newCompletedArray = session.completedExercises.filter(id => id !== exerciseId);
    updateSession({ completedExercises: newCompletedArray });
  }, [session, updateSession]);

  const completeMultipleExercises = useCallback((exerciseIds: string[]) => {
    console.log(`[WorkoutPlayerContext] COMPLETE_MULTIPLE_EXERCISES: Marcando ${exerciseIds.length} exercícios como concluídos:`, exerciseIds);
    if (!session) {
      console.warn('[WorkoutPlayerContext] COMPLETE_MULTIPLE_EXERCISES: Nenhuma sessão ativa para completar exercícios.');
      return;
    }

    // Create a new array with all existing completed exercises plus the new ones (avoiding duplicates)
    const existingCompleted = new Set(session.completedExercises);
    exerciseIds.forEach(id => existingCompleted.add(id));
    const newCompletedArray = Array.from(existingCompleted);
    const newCompletedSet = new Set(newCompletedArray);

    updateSession({ completedExercises: newCompletedArray });

    // Handle rest time for the first exercise in the group (if applicable)
    const firstExercise = session.exercises.find(e => exerciseIds.includes(e._id));
    const restSeconds = firstExercise?.descanso ? parseInt(firstExercise.descanso, 10) : 0;
    console.log(`[WorkoutPlayerContext] COMPLETE_MULTIPLE_EXERCISES: Descanso para o grupo: ${restSeconds}s`);
    
    const nextActiveId = findNextActiveExercise(session.exercises, newCompletedSet);
    if (!nextActiveId || restSeconds <= 0) {
      console.log('[WorkoutPlayerContext] COMPLETE_MULTIPLE_EXERCISES: Sem próximo exercício ou sem descanso. Não iniciando descanso.');
      setIsResting(false);
    } else {
      console.log('[WorkoutPlayerContext] COMPLETE_MULTIPLE_EXERCISES: Iniciando descanso.');
      setIsResting(true);
      setRestTimeRemaining(restSeconds);
    }
  }, [session, findNextActiveExercise, updateSession]);

  const uncompleteMultipleExercises = useCallback((exerciseIds: string[]) => {
    console.log(`[WorkoutPlayerContext] UNCOMPLETE_MULTIPLE_EXERCISES: Desmarcando ${exerciseIds.length} exercícios:`, exerciseIds);
    if (!session) {
      console.warn('[WorkoutPlayerContext] UNCOMPLETE_MULTIPLE_EXERCISES: Nenhuma sessão ativa para desmarcar exercícios.');
      return;
    }
    
    // Remove all the specified exercise IDs from completed exercises
    const newCompletedArray = session.completedExercises.filter(id => !exerciseIds.includes(id));
    updateSession({ completedExercises: newCompletedArray });
  }, [session, updateSession]);

  const updateExerciseLoad = (exerciseId: string, load: string) => {
    console.log(`[WorkoutPlayerContext] UPDATE_EXERCISE_LOAD: Atualizando carga para ${exerciseId} para ${load}.`);
    if (!session) {
      console.warn('[WorkoutPlayerContext] UPDATE_EXERCISE_LOAD: Nenhuma sessão ativa para atualizar carga.');
      return;
    }
    const newLoads = { ...session.exerciseLoads, [exerciseId]: load };
    updateSession({ exerciseLoads: newLoads });
  };

  const getExerciseLoad = (exerciseId: string) => {
    const load = session?.exerciseLoads[exerciseId] || '';
    console.log(`[WorkoutPlayerContext] GET_EXERCISE_LOAD: Obtendo carga para ${exerciseId}: ${load}.`);
    return load;
  };
  
  const value = {
    isWorkoutActive,
    startWorkout,
    stopWorkout,
    resetWorkout,
    completeExercise,
    uncompleteExercise,
    completeMultipleExercises,
    uncompleteMultipleExercises,
    activeExerciseId: session ? findNextActiveExercise(session.exercises, new Set(session.completedExercises)) : null,
    completedExercises: new Set(session?.completedExercises || []),
    elapsedTime,
    updateExerciseLoad,
    getExerciseLoad,
    restTimeRemaining,
    isResting,
    workoutStartTime: session ? new Date(session.startTime) : null,
    currentWorkoutSession: session,
  };

  return (
    <WorkoutPlayerContext.Provider value={value}>
      {children}
    </WorkoutPlayerContext.Provider>
  );
};

export const useWorkoutPlayer = (): WorkoutPlayerContextType => {
  const context = useContext(WorkoutPlayerContext);
  if (context === undefined) {
    throw new Error('useWorkoutPlayer deve ser usado dentro de um WorkoutPlayerProvider');
  }
  return context;
};

===== ./client/src/forms/ExerciseForm.tsx =====
// client/src/forms/ExerciseForm.tsx
import React, { useEffect } from 'react'; 
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { exerciseFormSchema, ExerciseFormData, gruposMuscularesOptions, categoriasOptions } from '@/lib/validators/exerciseSchema';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea"; 
import { Checkbox } from "@/components/ui/checkbox"; // Necessário
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"; 
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Loader2 } from 'lucide-react';

// Interface Props
interface ExerciseFormProps {
  onSubmit: (data: ExerciseFormData) => void; 
  isLoading?: boolean;                      
  initialData?: Partial<ExerciseFormData>;  
  isEditing?: boolean;                      
}

export const ExerciseForm: React.FC<ExerciseFormProps> = ({ 
  onSubmit, 
  isLoading = false, 
  initialData = {}, 
  isEditing = false 
}) => {

  const form = useForm<ExerciseFormData>({
    resolver: zodResolver(exerciseFormSchema),
    defaultValues: { 
      nome: initialData?.nome ?? '',
      grupoMuscular: initialData?.grupoMuscular ?? '', 
      descricao: initialData?.descricao ?? '',
      categoria: initialData?.categoria ?? '', 
      imageUrl: initialData?.imageUrl ?? '',
      videoUrl: initialData?.videoUrl ?? '',
      isCustom: initialData?.isCustom ?? false,
    },
  });

  // Comentado pois estava causando problemas, reavaliar se necessário para edição
  /*
  useEffect(() => {
    form.reset({
      nome: initialData?.nome ?? '',
      grupoMuscular: initialData?.grupoMuscular ?? '', 
      descricao: initialData?.descricao ?? '',
      categoria: initialData?.categoria ?? '',
      imageUrl: initialData?.imageUrl ?? '',
      videoUrl: initialData?.videoUrl ?? '',
      isCustom: initialData?.isCustom ?? false,
    });
  }, [initialData, form.reset]); 
  */

  const handleFormSubmit = (data: ExerciseFormData) => {
    console.log("Dados do formulário validados (handleFormSubmit):", data); 
    onSubmit(data); 
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleFormSubmit)} className="space-y-6"> 
        
        {/* Nome */}
        <FormField
          control={form.control}
          name="nome"
          render={({ field }) => ( 
            <FormItem>
              <FormLabel>Nome do Exercício *</FormLabel>
              <FormControl><Input placeholder="Ex: Supino Reto com Barra" {...field} /></FormControl>
              <FormMessage /> 
            </FormItem>
           )}
        />

        {/* Grupo Muscular */}
        <FormField
          control={form.control}
          name="grupoMuscular"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Grupo Muscular *</FormLabel>
              <Select onValueChange={field.onChange} value={field.value ?? ""}> 
                <FormControl>
                  <SelectTrigger ref={field.ref}> 
                    <SelectValue placeholder="Selecione o grupo principal" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {gruposMuscularesOptions.map((grupo) => (
                    <SelectItem key={grupo} value={grupo}>{grupo}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
        
        {/* Categoria (Select) - DESCOMENTADO */}
         <FormField
          control={form.control}
          name="categoria"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Categoria</FormLabel>
              <Select onValueChange={field.onChange} value={field.value ?? ""}>
                <FormControl>
                   {/* Adicionar ref aqui também por consistência */}
                  <SelectTrigger ref={field.ref}> 
                    <SelectValue placeholder="Selecione uma categoria (opcional)" />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {categoriasOptions.map((cat) => (
                    <SelectItem key={cat} value={cat}>{cat}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Descrição */}
        <FormField
          control={form.control}
          name="descricao"
          render={({ field }) => ( 
             <FormItem>
               <FormLabel>Descrição</FormLabel>
               <FormControl><Textarea placeholder="Instruções..." className="resize-y min-h-[80px]" {...field} /></FormControl>
               <FormMessage />
             </FormItem>
           )}
        />

        {/* URL Imagem - DESCOMENTADO */}
        <FormField
          control={form.control}
          name="imageUrl"
          render={({ field }) => (
            <FormItem>
              <FormLabel>URL da Imagem</FormLabel>
              <FormControl><Input type="url" placeholder="https://exemplo.com/imagem.jpg (opcional)" {...field} /></FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* URL Vídeo - DESCOMENTADO */}
         <FormField
          control={form.control}
          name="videoUrl"
          render={({ field }) => (
            <FormItem>
              <FormLabel>URL do Vídeo</FormLabel>
              <FormControl><Input type="url" placeholder="https://youtube.com/watch?v=... (opcional)" {...field} /></FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

         {/* Checkbox Personalizado - DESCOMENTADO */}
         <FormField
          control={form.control}
          name="isCustom"
          render={({ field }) => (
            // Usando um layout ligeiramente diferente para Checkbox com FormField
            <FormItem className="flex flex-row items-center space-x-3 space-y-0">
              <FormControl>
                 {/* Passando props específicas do Checkbox */}
                <Checkbox
                  checked={field.value}
                  onCheckedChange={field.onChange} // RHF lida com o valor boolean
                  ref={field.ref} // Passa a ref também
                />
              </FormControl>
              <div className="space-y-1 leading-none">
                 {/* Associando o label ao checkbox corretamente */}
                 <FormLabel htmlFor={field.name} className="cursor-pointer"> 
                   Exercício Personalizado
                 </FormLabel>
                <FormDescription>Marque se este exercício foi criado por você.</FormDescription>
              </div>
               <FormMessage /> {/* Mensagem de erro se houver */}
            </FormItem>
          )}
        />

        {/* Botão Submit */}
        <Button type="submit" disabled={isLoading} className="w-full md:w-auto"> 
          {isLoading ? (<><Loader2 className="mr-2 h-4 w-4 animate-spin" />Salvando...</>) 
                     : (isEditing ? 'Salvar Alterações' : 'Criar Exercício')}
        </Button>
        
      </form>
    </Form>
  );
};
===== ./client/src/forms/student-form.tsx =====
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { Button } from '@/components/ui/button';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Loader2 } from 'lucide-react';
import { Separator } from '@/components/ui/separator';
import { Aluno } from '@/types/aluno';
import { useFormPersistence } from '@/hooks/useFormPersistence';
import { useEffect } from 'react';
import { formatDateForInput } from '@/utils/dateUtils';

// --- Funções de Validação (sem alterações) ---
const requiredNumericString = (fieldName: string) => z.string().min(1, `${fieldName} é obrigatório.`).refine((val) => !isNaN(parseFloat(val.replace(',', '.'))), { message: "Deve ser um número." });
const requiredIntegerString = (fieldName: string) => z.string().min(1, `${fieldName} é obrigatório.`).refine((val) => /^\d+$/.test(val), { message: "Deve ser um número inteiro." });

// <<< CORREÇÃO FINAL: Schema de validação com lógica aprimorada no superRefine >>>
const createStudentFormSchema = (isEditing: boolean) => z.object({
    nome: z.string().min(3, "Nome completo é obrigatório."),
    email: z.string().email("E-mail inválido."),
    phone: z.string().optional(),
    birthDate: z.string().min(1, "Data de nascimento é obrigatória."),
    gender: z.enum(['masculino', 'feminino', 'outro']),
    goal: z.string().min(1, "Objetivo é obrigatório."),
    weight: requiredNumericString("Peso"),
    height: requiredIntegerString("Altura"),
    startDate: z.string().min(1, "Data de início é obrigatória."),
    status: z.enum(['active', 'inactive']),
    notes: z.string().optional(),
    password: z.string().optional(),
    confirmPassword: z.string().optional(),
}).superRefine((data, ctx) => {
    const password = data.password || "";
    const confirmPassword = data.confirmPassword || "";

    if (!isEditing) {
        // --- MODO DE CRIAÇÃO ---
        if (password.length < 6) {
            ctx.addIssue({ code: z.ZodIssueCode.custom, message: "A senha deve ter no mínimo 6 caracteres.", path: ["password"] });
        }
        if (password !== confirmPassword) {
            ctx.addIssue({ code: z.ZodIssueCode.custom, message: "As senhas não coincidem.", path: ["confirmPassword"] });
        }
    } else {
        // --- MODO DE EDIÇÃO ---
        // A validação só acontece se uma nova senha for fornecida
        if (password.length > 0) {
            if (password.length < 6) {
                ctx.addIssue({ code: z.ZodIssueCode.custom, message: "A nova senha deve ter no mínimo 6 caracteres.", path: ["password"] });
            }
            if (password !== confirmPassword) {
                ctx.addIssue({ code: z.ZodIssueCode.custom, message: "As senhas não coincidem.", path: ["confirmPassword"] });
            }
        }
        // Se a senha estiver vazia, mas a confirmação não, isso é um erro
        else if (confirmPassword.length > 0) {
            ctx.addIssue({ code: z.ZodIssueCode.custom, message: "Digite a nova senha primeiro.", path: ["password"] });
        }
    }
});


type StudentFormValues = z.infer<ReturnType<typeof createStudentFormSchema>>;

export interface StudentFormDataProcessed {
    nome: string; email: string; phone?: string; birthDate: string;
    gender: 'masculino' | 'feminino' | 'outro'; goal: string; weight: number;
    height: number; startDate: string; status: 'active' | 'inactive'; notes?: string;
    password?: string;
}

interface StudentFormProps { onSubmit: (data: StudentFormDataProcessed) => void; isLoading?: boolean; initialData?: Aluno; isEditing?: boolean; onCancel?: () => void; }

export function StudentForm({ onSubmit: onSubmitProp, isLoading = false, initialData, isEditing = false, onCancel }: StudentFormProps) {
    // Form persistence for new students only
    const persistedForm = useFormPersistence({
        formKey: 'novo_aluno',
        initialValues: {
            nome: "", email: "", phone: "", birthDate: "", gender: undefined, goal: "",
            weight: "", height: "", startDate: "", status: 'active', notes: "",
            password: "", confirmPassword: ""
        },
        enabled: !isEditing // Only persist for new students, not edits
    });

    // Determine initial values: editing uses initialData, new student uses persisted values
    const getInitialValues = () => {
        if (isEditing) {
            return {
                nome: initialData?.nome || "", email: initialData?.email || "", phone: initialData?.phone || "",
                birthDate: formatDateForInput(initialData?.birthDate),
                gender: initialData?.gender as any || undefined, goal: initialData?.goal || "",
                weight: initialData?.weight ? String(initialData.weight) : '', height: initialData?.height ? String(initialData.height) : '',
                startDate: formatDateForInput(initialData?.startDate),
                status: initialData?.status || 'active', notes: initialData?.notes || "",
                password: "", confirmPassword: ""
            };
        } else {
            // For new students, use persisted values if available
            return {
                nome: persistedForm.values.nome || "", 
                email: persistedForm.values.email || "", 
                phone: persistedForm.values.phone || "",
                birthDate: persistedForm.values.birthDate || "",
                gender: persistedForm.values.gender || undefined, 
                goal: persistedForm.values.goal || "",
                weight: persistedForm.values.weight || '', 
                height: persistedForm.values.height || '',
                startDate: persistedForm.values.startDate || "",
                status: persistedForm.values.status || 'active', 
                notes: persistedForm.values.notes || "",
                password: persistedForm.values.password || "", 
                confirmPassword: persistedForm.values.confirmPassword || ""
            };
        }
    };

    const form = useForm<StudentFormValues>({
        resolver: zodResolver(createStudentFormSchema(isEditing)),
        defaultValues: getInitialValues(),
    });

    // Watch form changes and sync with persistence for new students
    const watchedValues = form.watch();
    useEffect(() => {
        if (!isEditing) {
            // Only update persistence if form is dirty and has values
            const hasAnyValue = Object.values(watchedValues).some(value => 
                value !== undefined && value !== null && value !== ""
            );
            if (hasAnyValue) {
                persistedForm.updateFields(watchedValues);
            }
        }
    }, [watchedValues, isEditing, persistedForm]);

    function handleFormSubmit(data: StudentFormValues) {
        const { confirmPassword, ...restOfData } = data;
        const processedData: StudentFormDataProcessed = {
            ...restOfData,
            weight: parseFloat(data.weight.replace(',', '.')),
            height: parseInt(data.height, 10),
            password: data.password && data.password.trim() !== '' ? data.password : undefined,
        };
        
        // Clear persistence before submitting for new students
        if (!isEditing) {
            persistedForm.clearPersistence();
        }
        
        onSubmitProp(processedData);
    }

    const handleCancel = () => {
        // Clear persistence when cancelled for new students
        if (!isEditing) {
            persistedForm.clearPersistence();
        }
        
        if (onCancel) {
            onCancel();
        } else {
            window.history.back();
        }
    };

    const passwordValue = form.watch('password');

    return (
        <Form {...form}>
            <form onSubmit={form.handleSubmit(handleFormSubmit)} className="space-y-8">
                {/* Dados Pessoais */}
                <div className="space-y-4">
                    <h3 className="text-lg font-semibold border-b pb-2">Dados Pessoais</h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                        <FormField control={form.control} name="nome" render={({ field }) => ( <FormItem><FormLabel>Nome completo*</FormLabel><FormControl><Input placeholder="Digite o nome completo" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="email" render={({ field }) => ( <FormItem><FormLabel>Email*</FormLabel><FormControl><Input type="email" placeholder="exemplo@email.com" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="phone" render={({ field }) => ( <FormItem><FormLabel>Telefone</FormLabel><FormControl><Input placeholder="(00) 00000-0000" {...field} value={field.value ?? ''} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="birthDate" render={({ field }) => ( <FormItem><FormLabel>Data de nascimento*</FormLabel><FormControl><Input type="date" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="gender" render={({ field }) => ( <FormItem><FormLabel>Gênero*</FormLabel><Select onValueChange={field.onChange} value={field.value}><FormControl><SelectTrigger><SelectValue placeholder="Selecione o gênero" /></SelectTrigger></FormControl><SelectContent><SelectItem value="masculino">Masculino</SelectItem><SelectItem value="feminino">Feminino</SelectItem><SelectItem value="outro">Outro</SelectItem></SelectContent></Select><FormMessage /></FormItem> )} />
                    </div>
                </div>

                {/* Medidas Corporais */}
                <div className="space-y-4">
                     <h3 className="text-lg font-semibold border-b pb-2">Medidas Corporais</h3>
                     <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                        <FormField control={form.control} name="weight" render={({ field }) => ( <FormItem><FormLabel>Peso (kg)*</FormLabel><FormControl><Input type="text" inputMode="decimal" placeholder="Ex: 75,5" {...field} value={field.value ?? ''} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="height" render={({ field }) => ( <FormItem><FormLabel>Altura (cm)*</FormLabel><FormControl><Input type="text" inputMode="numeric" placeholder="Ex: 178" {...field} value={field.value ?? ''} /></FormControl><FormMessage /></FormItem> )} />
                    </div>
                </div>

                {/* Seção de Senha */}
                <div className="space-y-4">
                     <h3 className="text-lg font-semibold border-b pb-2">Credenciais de Acesso</h3>
                     <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                        <FormField control={form.control} name="password" render={({ field }) => ( <FormItem><FormLabel>{isEditing ? 'Nova Senha (Opcional)' : 'Senha*'}</FormLabel><FormControl><Input type="password" placeholder={isEditing ? 'Deixe em branco para não alterar' : 'Mínimo 6 caracteres'} {...field} /></FormControl><FormMessage /></FormItem> )} />
                        {/* <<< CORREÇÃO: Renderização condicional mais estrita >>> */}
                        {(passwordValue && passwordValue.trim() !== '') || !isEditing ? (
                             <FormField control={form.control} name="confirmPassword" render={({ field }) => ( <FormItem><FormLabel>Confirmar Senha*</FormLabel><FormControl><Input type="password" placeholder="Repita a senha" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        ) : null}
                    </div>
                </div>

                 {/* Metas e Status */}
                <div className="space-y-4">
                     <h3 className="text-lg font-semibold border-b pb-2">Metas e Status</h3>
                    <div className="space-y-4">
                        <FormField control={form.control} name="goal" render={({ field }) => ( <FormItem><FormLabel>Objetivo*</FormLabel><Select onValueChange={field.onChange} value={field.value}><FormControl><SelectTrigger><SelectValue placeholder="Selecione o objetivo" /></SelectTrigger></FormControl><SelectContent><SelectItem value="Hipertrofia">Hipertrofia</SelectItem><SelectItem value="Emagrecimento">Emagrecimento</SelectItem><SelectItem value="Outros">Outros</SelectItem></SelectContent></Select><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="startDate" render={({ field }) => ( <FormItem><FormLabel>Data de início*</FormLabel><FormControl><Input type="date" {...field} /></FormControl><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="status" render={({ field }) => ( <FormItem><FormLabel>Status*</FormLabel><Select onValueChange={field.onChange} value={field.value}><FormControl><SelectTrigger><SelectValue placeholder="Selecione o status" /></SelectTrigger></FormControl><SelectContent><SelectItem value="active">Ativo</SelectItem><SelectItem value="inactive">Inativo</SelectItem></SelectContent></Select><FormMessage /></FormItem> )} />
                        <FormField control={form.control} name="notes" render={({ field }) => ( <FormItem><FormLabel>Observações</FormLabel><FormControl><Textarea placeholder="Observações adicionais..." {...field} value={field.value ?? ''} rows={4} /></FormControl><FormMessage /></FormItem> )} />
                    </div>
                </div>
                
                <Separator className="my-8" />
                <div className="flex justify-end space-x-3">
                    <Button variant="outline" type="button" onClick={handleCancel} disabled={isLoading}>Cancelar</Button>
                    <Button type="submit" disabled={isLoading}>{isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}{isEditing ? "Salvar Alterações" : "Adicionar Aluno"}</Button>
                </div>
            </form>
        </Form>
    );
}
===== ./client/src/forms/workout-form.tsx =====
import { useState } from "react";
import { useLocation } from "wouter";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

import { Button } from "@/components/ui/button";
import {
  Form, FormControl, FormDescription, FormField,
  FormItem, FormLabel, FormMessage
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select, SelectContent, SelectItem,
  SelectTrigger, SelectValue
} from "@/components/ui/select";

import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";

// ✅ Schema corrigido (não depende mais do shared/schema)
const formSchema = z.object({
  name: z.string().min(1, { message: "O nome do treino é obrigatório" }),
  description: z.string().optional(),
  duration: z.coerce.number().min(1, { message: "A duração deve ser no mínimo 1 semana" }),
  status: z.string(),
  trainerId: z.number(),
});

type FormValues = z.infer<typeof formSchema>;

export function WorkoutForm() {
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);

  const defaultValues: Partial<FormValues> = {
    name: "",
    description: "",
    duration: 4,
    status: "active",
    trainerId: 1,
  };

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues,
  });

  async function onSubmit(data: FormValues) {
    setIsSubmitting(true);
    try {
      const result = await apiRequest("POST", "/api/workout-plans", data);
      const workoutPlan = await result.json();

      await queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });

      toast({
        title: "Plano de treino criado com sucesso!",
        description: "Você será redirecionado para editá-lo.",
      });

      navigate(`/workouts/${workoutPlan.id}`);
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Não foi possível criar o plano de treino. Tente novamente.",
      });
      setIsSubmitting(false);
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Nome do Treino*</FormLabel>
              <FormControl>
                <Input placeholder="Ex: Treinamento de Força" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid gap-4 sm:grid-cols-2">
          <FormField
            control={form.control}
            name="duration"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Duração (semanas)*</FormLabel>
                <FormControl>
                  <Input type="number" min={1} {...field} />
                </FormControl>
                <FormDescription>
                  Quantas semanas o plano de treino deve durar
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="status"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Status</FormLabel>
                <Select onValueChange={field.onChange} defaultValue={field.value}>
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Selecione o status" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="active">Ativo</SelectItem>
                    <SelectItem value="draft">Rascunho</SelectItem>
                    <SelectItem value="archived">Arquivado</SelectItem>
                  </SelectContent>
                </Select>
                <FormDescription>
                  Rascunhos não serão visíveis para os alunos até que sejam ativados
                </FormDescription>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Descrição</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Descreva os objetivos e o foco desse plano de treino"
                  className="resize-none"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="flex justify-end space-x-2">
          <Button
            variant="outline"
            type="button"
            onClick={() => navigate("/workouts")}
          >
            Cancelar
          </Button>
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? "Criando..." : "Criar Treino"}
          </Button>
        </div>
      </form>
    </Form>
  );
}

===== ./client/src/hooks/use-mobile.tsx =====
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

===== ./client/src/hooks/use-students.ts =====
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";

export function useStudents(trainerId: number) {
  // Get all students for a trainer
  const getStudents = () => {
    return useQuery<any[]>({
      queryKey: ["/api/alunos/gerenciar", { trainerId }],
      queryFn: async () => {
        return apiRequest("GET", "/api/alunos/gerenciar");
      }
    });
  };

  // Get a single student by ID
  const getStudent = (id: string) => {
    return useQuery<any>({
      queryKey: [`/api/alunos/gerenciar/${id}`],
      queryFn: async () => {
        return apiRequest("GET", `/api/alunos/gerenciar/${id}`);
      }
    });
  };

  // Add a new student
  const addStudent = () => {
    return useMutation({
      mutationFn: async (student: any) => {
        return apiRequest("POST", "/api/alunos/gerenciar", student);
      },
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ["/api/alunos/gerenciar"] });
      }
    });
  };

  // Update a student
  const updateStudent = () => {
    return useMutation({
      mutationFn: async ({ id, data }: { id: string; data: Partial<any> }) => {
        return apiRequest("PUT", `/api/alunos/gerenciar/${id}`, data);
      },
      onSuccess: (_, variables) => {
        queryClient.invalidateQueries({ queryKey: ["/api/alunos/gerenciar"] });
        queryClient.invalidateQueries({ queryKey: [`/api/alunos/gerenciar/${variables.id}`] });
      }
    });
  };

  // Delete a student
  const deleteStudent = () => {
    return useMutation({
      mutationFn: async (id: string) => {
        await apiRequest("DELETE", `/api/alunos/gerenciar/${id}`, undefined);
        return id;
      },
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ["/api/alunos/gerenciar"] });
      }
    });
  };

  return {
    getStudents,
    getStudent,
    addStudent,
    updateStudent,
    deleteStudent
  };
}

===== ./client/src/hooks/use-toast.ts =====
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

===== ./client/src/hooks/use-workouts.ts =====
import { useQuery, useMutation } from "@tanstack/react-query";
import { apiRequest, queryClient } from "@/lib/queryClient";
import type { WorkoutPlan, InsertWorkoutPlan, WorkoutExercise, InsertWorkoutExercise } from "@shared/schema";

export function useWorkouts(trainerId: number) {
  // Get all workout plans for a trainer
  const getWorkoutPlans = () => {
    return useQuery<WorkoutPlan[]>({
      queryKey: ["/api/workout-plans", { trainerId }],
      queryFn: async () => {
        const res = await fetch(`/api/workout-plans?trainerId=${trainerId}`);
        if (!res.ok) throw new Error("Failed to fetch workout plans");
        return res.json();
      }
    });
  };

  // Get a single workout plan by ID
  const getWorkoutPlan = (id: number) => {
    return useQuery<WorkoutPlan>({
      queryKey: [`/api/workout-plans/${id}`],
      queryFn: async () => {
        const res = await fetch(`/api/workout-plans/${id}`);
        if (!res.ok) throw new Error("Failed to fetch workout plan");
        return res.json();
      }
    });
  };

  // Add a new workout plan
  const addWorkoutPlan = () => {
    return useMutation({
      mutationFn: async (workoutPlan: InsertWorkoutPlan) => {
        const res = await apiRequest("POST", "/api/workout-plans", workoutPlan);
        return res.json();
      },
      onSuccess: () => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });
      }
    });
  };

  // Update a workout plan
  const updateWorkoutPlan = () => {
    return useMutation({
      mutationFn: async ({ id, data }: { id: number; data: Partial<InsertWorkoutPlan> }) => {
        const res = await apiRequest("PUT", `/api/workout-plans/${id}`, data);
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });
        queryClient.invalidateQueries({ queryKey: [`/api/workout-plans/${variables.id}`] });
      }
    });
  };

  // Delete a workout plan
  const deleteWorkoutPlan = () => {
    return useMutation({
      mutationFn: async (id: number) => {
        await apiRequest("DELETE", `/api/workout-plans/${id}`, undefined);
        return id;
      },
      onSuccess: () => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });
      }
    });
  };

  // Get exercises for a workout plan
  const getWorkoutExercises = (workoutPlanId: number) => {
    return useQuery<WorkoutExercise[]>({
      queryKey: [`/api/workout-plans/${workoutPlanId}/exercises`],
      queryFn: async () => {
        const res = await fetch(`/api/workout-plans/${workoutPlanId}/exercises`);
        if (!res.ok) throw new Error("Failed to fetch workout exercises");
        return res.json();
      }
    });
  };

  // Add an exercise to a workout plan
  const addWorkoutExercise = () => {
    return useMutation({
      mutationFn: async (workoutExercise: InsertWorkoutExercise) => {
        const res = await apiRequest("POST", "/api/workout-exercises", workoutExercise);
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/workout-plans/${variables.workoutPlanId}/exercises`] 
        });
      }
    });
  };

  // Update a workout exercise
  const updateWorkoutExercise = () => {
    return useMutation({
      mutationFn: async ({ id, data, workoutPlanId }: { 
        id: number; 
        data: Partial<InsertWorkoutExercise>;
        workoutPlanId: number;
      }) => {
        const res = await apiRequest("PUT", `/api/workout-exercises/${id}`, data);
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/workout-plans/${variables.workoutPlanId}/exercises`] 
        });
      }
    });
  };

  // Remove an exercise from a workout plan
  const removeWorkoutExercise = () => {
    return useMutation({
      mutationFn: async ({ id, workoutPlanId }: { id: number; workoutPlanId: number }) => {
        await apiRequest("DELETE", `/api/workout-exercises/${id}`, undefined);
        return id;
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/workout-plans/${variables.workoutPlanId}/exercises`] 
        });
      }
    });
  };

  // Assign a workout plan to a student
  const assignWorkoutToStudent = () => {
    return useMutation({
      mutationFn: async (data: { studentId: number; workoutPlanId: number }) => {
        const res = await apiRequest("POST", "/api/student-workouts", {
          studentId: data.studentId,
          workoutPlanId: data.workoutPlanId,
          assignedDate: new Date().toISOString(),
          status: "assigned",
          progress: 0
        });
        return res.json();
      },
      onSuccess: (_, variables) => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries({ 
          queryKey: [`/api/students/${variables.studentId}/workouts`] 
        });
      }
    });
  };

  return {
    getWorkoutPlans,
    getWorkoutPlan,
    addWorkoutPlan,
    updateWorkoutPlan,
    deleteWorkoutPlan,
    getWorkoutExercises,
    addWorkoutExercise,
    updateWorkoutExercise,
    removeWorkoutExercise,
    assignWorkoutToStudent
  };
}

===== ./client/src/hooks/useAppUpdates.ts =====
import { useState, useEffect, useRef } from 'react';
import { useRegisterSW } from 'virtual:pwa-register/react';

interface UpdateState {
  hasUpdate: boolean;
  isUpdating: boolean;
  offlineReady: boolean;
  updateAvailable: boolean;
}

export function useAppUpdates() {
  const [state, setState] = useState<UpdateState>({
    hasUpdate: false,
    isUpdating: false,
    offlineReady: false,
    updateAvailable: false,
  });

  // Track if notifications have been shown to prevent duplicates
  const notificationsShown = useRef({
    update: false,
    offline: false,
  });

  const {
    offlineReady: [offlineReady, setOfflineReady],
    needRefresh: [needRefresh, setNeedRefresh],
    updateServiceWorker,
  } = useRegisterSW({
    onRegistered(r) {
      console.log('PWA Service Worker registered:', r);
      if (r) {
        // Check for updates every hour
        setInterval(() => {
          console.log('PWA: Checking for updates...');
          r.update();
        }, 60 * 60 * 1000);
      }
    },
    onRegisterError(error) {
      console.error('PWA Service Worker registration error:', error);
    },
  });

  // Update state when PWA status changes
  useEffect(() => {
    setState(prev => ({
      ...prev,
      hasUpdate: needRefresh,
      updateAvailable: needRefresh,
      offlineReady: offlineReady,
    }));
  }, [needRefresh, offlineReady]);

  const handleUpdate = async () => {
    setState(prev => ({ ...prev, isUpdating: true }));
    
    try {
      await updateServiceWorker(true);
      // The page will reload, so we don't need to update state
    } catch (error) {
      console.error('Error updating service worker:', error);
      setState(prev => ({ ...prev, isUpdating: false }));
      
      // Reset the notification state to allow retry
      notificationsShown.current.update = false;
    }
    
    // Failsafe: if the update doesn't complete within 10 seconds, reset the state
    setTimeout(() => {
      setState(prev => ({ 
        ...prev, 
        isUpdating: false 
      }));
    }, 10000);
  };

  const handleOfflineReady = () => {
    setOfflineReady(false);
    setState(prev => ({ ...prev, offlineReady: false }));
  };

  const dismissUpdate = () => {
    setNeedRefresh(false);
    notificationsShown.current.update = false;
    setState(prev => ({ ...prev, hasUpdate: false, updateAvailable: false }));
  };

  // Reset notification flags when states change
  useEffect(() => {
    if (!needRefresh) {
      notificationsShown.current.update = false;
    }
  }, [needRefresh]);

  useEffect(() => {
    if (!offlineReady) {
      notificationsShown.current.offline = false;
    }
  }, [offlineReady]);

  return {
    ...state,
    needRefresh,
    offlineReady,
    notificationShown: notificationsShown.current,
    handleUpdate,
    handleOfflineReady,
    dismissUpdate,
    markUpdateNotificationShown: () => { notificationsShown.current.update = true; },
    markOfflineNotificationShown: () => { notificationsShown.current.offline = true; },
  };
}
===== ./client/src/hooks/useConfirmDialog.ts =====
// client/src/hooks/useConfirmDialog.ts
import React, { useState } from "react"; // Import React para React.ReactNode

interface ConfirmDialogOptions {
  titulo?: string;
  mensagem?: string | React.ReactNode; // <<< ALTERADO AQUI para aceitar ReactNode
  textoConfirmar?: string;
  textoCancelar?: string;
  onConfirm?: () => void;
}

export function useConfirmDialog() {
  const [isOpen, setIsOpen] = useState(false);
  const [options, setOptions] = useState<ConfirmDialogOptions>({});

  const openConfirmDialog = (options: ConfirmDialogOptions) => {
    setOptions(options);
    setIsOpen(true);
  };

  const closeConfirmDialog = () => {
    setIsOpen(false);
    // É uma boa prática resetar as options ao fechar para evitar que dados antigos persistam
    // se o modal for reaberto rapidamente com outras opções antes do setOptions ser chamado.
    // setOptions({}); // Descomente se achar necessário.
  };

  const confirm = () => {
    if (options.onConfirm) {
      options.onConfirm();
    }
    closeConfirmDialog();
  };

  return {
    isOpen,
    options,
    openConfirmDialog,
    closeConfirmDialog,
    confirm,
  };
}

===== ./client/src/hooks/useDebounce.ts =====
// client/src/hooks/useDebounce.ts
import { useCallback, useRef } from 'react';

/**
 * Custom hook for debouncing function calls
 * Prevents multiple rapid calls to the same function
 */
export function useDebounce<T extends (...args: any[]) => void>(
  callback: T,
  delay: number
): T {
  const timeoutRef = useRef<NodeJS.Timeout>();

  const debouncedCallback = useCallback(
    (...args: Parameters<T>) => {
      // Clear existing timeout
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      // Set new timeout
      timeoutRef.current = setTimeout(() => {
        callback(...args);
      }, delay);
    },
    [callback, delay]
  );

  return debouncedCallback as T;
}

/**
 * Custom hook for throttling function calls  
 * Ensures function is called at most once per specified interval
 */
export function useThrottle<T extends (...args: any[]) => void>(
  callback: T,
  delay: number
): T {
  const lastCallRef = useRef<number>(0);

  const throttledCallback = useCallback(
    (...args: Parameters<T>) => {
      const now = Date.now();
      
      if (now - lastCallRef.current >= delay) {
        lastCallRef.current = now;
        callback(...args);
      }
    },
    [callback, delay]
  );

  return throttledCallback as T;
}
===== ./client/src/hooks/useFinalizeRenewalCycle.ts =====
// client/src/hooks/useFinalizeRenewalCycle.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { fetchWithAuth } from "@/lib/apiClient";
import { useToast } from "@/hooks/use-toast";

// O único tipo de payload que a página 'renovar-plano' envia
type FinalizePayload = {
  keepStudentIds: string[];
  removeStudentIds: string[];
  note?: string;
  // O ID da solicitação é opcional, pois a rota do backend pode resolvê-lo automaticamente
  renewalId?: string; 
};

// Chaves de query que serão invalidadas após o sucesso, para sincronizar o estado da UI
export const QK_RENEWALS_APPROVED = ["personal-renewals", "approved"];
export const QK_RENEWALS_LIST = ["personal-renewals", "list"];
export const QK_RENEWALS_STATUS = ["personal-renewals", "status"];

export function useFinalizeRenewalCycle() {
  const queryClient = useQueryClient();
  const [, navigate] = useLocation();
  const { toast } = useToast();

  const mutation = useMutation({
    mutationFn: async (payload: FinalizePayload) => {
      // A rota do backend é inteligente o suficiente para encontrar a solicitação
      // "approved" ou "cycle_assignment_pending" se o ID não for fornecido.
      const endpoint = payload.renewalId
        ? `/api/personal/renewal-requests/${payload.renewalId}/finalize-cycle`
        : `/api/personal/renewal-requests/finalize-cycle`;

      // Esta rota foi corrigida no passo anterior para ser um POST
      return fetchWithAuth(
        endpoint,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        },
        "personalAdmin"
      );
    },
    onSuccess: async () => {
      // Invalida as queries de solicitações para limpar os banners e listas na página anterior
      await queryClient.invalidateQueries({ queryKey: QK_RENEWALS_APPROVED });
      await queryClient.invalidateQueries({ queryKey: QK_RENEWALS_LIST });
      await queryClient.invalidateQueries({ queryKey: QK_RENEWALS_STATUS });
      
      toast({
        title: "Ciclo de Renovação Finalizado!",
        description: "Seu plano foi atualizado e as vagas dos alunos foram redefinidas com sucesso.",
      });

      // Redireciona de volta para a página de solicitação, que agora estará "limpa"
      navigate("/solicitar-renovacao", { replace: true });
    },
    onError: (error: any) => {
      toast({
        variant: "destructive",
        title: "Erro ao Finalizar Ciclo",
        description:
          error?.message || "Não foi possível concluir a operação. Tente novamente.",
      });
    },
  });

  return {
    finalizarCiclo: mutation.mutate,
    isFinalizando: mutation.isPending,
  };
}
===== ./client/src/hooks/useFormPersistence.ts =====
// client/src/hooks/useFormPersistence.ts
import { useEffect, useState, useCallback } from 'react';

interface UseFormPersistenceOptions<T> {
  formKey: string;
  initialValues: T;
  enabled?: boolean;
}

export function useFormPersistence<T extends Record<string, any>>({ 
  formKey, 
  initialValues, 
  enabled = true 
}: UseFormPersistenceOptions<T>) {
  const [values, setValues] = useState<T>(() => {
    // Initialize from localStorage on first render if enabled
    if (!enabled) return initialValues;
    
    const savedValues = localStorage.getItem(`form_${formKey}`);
    if (savedValues) {
      try {
        const parsedValues = JSON.parse(savedValues);
        return { ...initialValues, ...parsedValues };
      } catch (error) {
        console.warn(`Failed to restore form values for ${formKey}:`, error);
        localStorage.removeItem(`form_${formKey}`);
      }
    }
    return initialValues;
  });

  // Save form values to localStorage when they change (with debouncing)
  useEffect(() => {
    if (!enabled) return;

    const timeoutId = setTimeout(() => {
      localStorage.setItem(`form_${formKey}`, JSON.stringify(values));
    }, 500); // Debounce to avoid excessive localStorage writes

    return () => clearTimeout(timeoutId);
  }, [values, formKey, enabled]);

  const updateField = useCallback(<K extends keyof T>(field: K, value: T[K]) => {
    setValues(prev => ({ ...prev, [field]: value }));
  }, []);

  const updateFields = useCallback((newValues: Partial<T>) => {
    setValues(prev => ({ ...prev, ...newValues }));
  }, []);

  const resetForm = useCallback(() => {
    setValues(initialValues);
    if (enabled) {
      localStorage.removeItem(`form_${formKey}`);
    }
  }, [initialValues, formKey, enabled]);

  const clearPersistence = useCallback(() => {
    if (enabled) {
      localStorage.removeItem(`form_${formKey}`);
    }
  }, [formKey, enabled]);

  return {
    values,
    setValues,
    updateField,
    updateFields,
    resetForm,
    clearPersistence
  };
}
===== ./client/src/hooks/useModalPersistence.ts =====
// client/src/hooks/useModalPersistence.ts
import { useEffect, useState } from 'react';

interface UseModalPersistenceOptions {
  modalKey: string;
  onRestore?: () => void;
  expectedRoute?: string; // Route where modal should be restored
}

export function useModalPersistence({ modalKey, onRestore, expectedRoute }: UseModalPersistenceOptions) {
  const [isOpen, setIsOpen] = useState(false);

  // Restore modal state on mount with route validation
  useEffect(() => {
    const savedState = localStorage.getItem(`modal_${modalKey}`);
    if (savedState === 'true') {
      // Verify user is still on the correct page before restoring modal
      if (expectedRoute && !window.location.pathname.includes(expectedRoute)) {
        // User is not on the expected route, clear the modal state
        localStorage.removeItem(`modal_${modalKey}`);
        return;
      }
      
      setIsOpen(true);
      onRestore?.();
    }
  }, [modalKey, onRestore, expectedRoute]);

  // Save modal state to localStorage when it changes
  useEffect(() => {
    if (isOpen) {
      localStorage.setItem(`modal_${modalKey}`, 'true');
    } else {
      localStorage.removeItem(`modal_${modalKey}`);
    }
  }, [isOpen, modalKey]);

  const openModal = () => setIsOpen(true);
  
  const closeModal = () => {
    setIsOpen(false);
    // Immediately clear persistence to prevent unwanted restoration
    localStorage.removeItem(`modal_${modalKey}`);
  };

  return {
    isOpen,
    openModal,
    closeModal,
    setIsOpen
  };
}
===== ./client/src/hooks/usePersistedInput.ts =====
import { useState, useEffect } from "react"

/**
 * Hook para manter o valor de um campo salvo no localStorage.
 * Ideal para formulários que precisam preservar o preenchimento entre páginas.
 */
export function usePersistedInput(key: string, defaultValue = "") {
  const [value, setValue] = useState(() => {
    if (typeof window === "undefined") return defaultValue
    try {
      return localStorage.getItem(key) || defaultValue
    } catch {
      return defaultValue
    }
  })

  useEffect(() => {
    try {
      localStorage.setItem(key, value)
    } catch {}
  }, [key, value])

  const clear = () => {
    localStorage.removeItem(key)
    setValue(defaultValue)
  }

  return [value, setValue, clear] as const
}
===== ./client/src/hooks/usePersistedState.ts =====
import { useState, useEffect } from "react"

/**
 * Hook para persistir valores de estado local no localStorage.
 * Ideal para campos de formulários que não devem perder dados ao trocar de rota ou aba.
 * 
 * @param key Nome da chave no localStorage
 * @param defaultValue Valor inicial padrão
 */
export function usePersistedState<T>(key: string, defaultValue: T) {
  const [state, setState] = useState<T>(() => {
    if (typeof window === "undefined") return defaultValue
    try {
      const storedValue = localStorage.getItem(key)
      return storedValue ? (JSON.parse(storedValue) as T) : defaultValue
    } catch {
      return defaultValue
    }
  })

  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(state))
    } catch {
      // silencioso
    }
  }, [key, state])

  const clear = () => {
    localStorage.removeItem(key)
    setState(defaultValue)
  }

  return [state, setState, clear] as const
}
===== ./client/src/hooks/usePersonalTrainers.ts =====
// client/src/hooks/usePlanManagement.ts
import { useState, useCallback, useMemo } from 'react';
import { PersonalTrainerWithStatus, Plano, AssignPlanForm, AddTokensForm } from '../../../shared/types/planos';
import { fetchWithAuth } from '../lib/apiClient';
import { handleApiError } from '../lib/handleApiError';
import { showToast } from '../lib/toastUtils';

interface PlanLookupMap {
  [planId: string]: Plano;
}

interface UsePlanManagementState {
  personalTrainers: PersonalTrainerWithStatus[];
  planos: Plano[];
  planLookupMap: PlanLookupMap;
  loading: boolean;
  error: string | null;
  lastUpdated: Date | null;
}

interface UsePlanManagementActions {
  fetchData: () => Promise<void>;
  assignPlan: (personalId: string, data: AssignPlanForm) => Promise<void>;
  addTokens: (personalId: string, data: AddTokensForm) => Promise<void>;
  refreshPersonalData: (personalId: string) => Promise<void>;
  clearError: () => void;
  getPlanNameById: (planId: string | null) => string;
  getPlanById: (planId: string | null) => Plano | null;
}

interface UsePlanManagementReturn extends UsePlanManagementState, UsePlanManagementActions {}

/**
 * Enhanced custom hook for managing Personal Trainers and Plans.
 * Features:
 * - Robust plan name resolution with lookup maps
 * - Centralized error handling
 * - Optimized API calls
 * - Better loading states
 * - Plan name fallbacks
 */
export function usePersonalTrainers(): UsePlanManagementReturn {
  const [state, setState] = useState<UsePlanManagementState>({
    personalTrainers: [],
    planos: [],
    planLookupMap: {},
    loading: false,
    error: null,
    lastUpdated: null,
  });

  const clearError = useCallback(() => {
    setState(prev => ({ ...prev, error: null }));
  }, []);

  /**
   * Creates a lookup map for fast plan resolution
   */
  const createPlanLookupMap = useCallback((planos: Plano[]): PlanLookupMap => {
    const lookupMap: PlanLookupMap = {};
    planos.forEach(plano => {
      if (plano._id) {
        lookupMap[plano._id] = plano;
      }
    });
    console.log('📊 [usePlanManagement] Created plan lookup map:', lookupMap);
    return lookupMap;
  }, []);

  /**
   * Get plan name by ID with robust fallback
   */
  const getPlanNameById = useCallback((planId: string | null): string => {
    if (!planId) return 'Sem plano';
    
    const plan = state.planLookupMap[planId];
    if (plan && plan.nome) {
      return plan.nome;
    }
    
    // Fallback: try to find in the planos array directly
    const directPlan = state.planos.find(p => p._id === planId);
    if (directPlan && directPlan.nome) {
      console.log('⚠️  [usePlanManagement] Using fallback plan resolution for:', planId);
      return directPlan.nome;
    }
    
    console.warn('❌ [usePlanManagement] Plan name not found for ID:', planId);
    return `Plano ID: ${planId.substring(0, 8)}...`;
  }, [state.planLookupMap, state.planos]);

  /**
   * Get complete plan object by ID
   */
  const getPlanById = useCallback((planId: string | null): Plano | null => {
    if (!planId) return null;
    
    const plan = state.planLookupMap[planId];
    if (plan) {
      return plan;
    }
    
    // Fallback: try to find in the planos array directly
    const directPlan = state.planos.find(p => p._id === planId);
    if (directPlan) {
      console.log('⚠️  [usePlanManagement] Using fallback plan object resolution for:', planId);
      return directPlan;
    }
    
    return null;
  }, [state.planLookupMap, state.planos]);

  /**
   * Enhanced data processing that ensures plan names are correctly resolved
   */
  const processPersonalTrainerData = useCallback((
    rawPersonalTrainers: any[], 
    planLookupMap: PlanLookupMap
  ): PersonalTrainerWithStatus[] => {
    return rawPersonalTrainers.map(personal => {
      // Extract plan ID - try multiple sources for robustness
      const planId = personal.planDetails?.id || personal.planoId || null;
      
      // Resolve plan name using lookup map
      let planoAtual = 'Sem plano';
      let planDetails = null;
      
      if (planId && planLookupMap[planId]) {
        const plan = planLookupMap[planId];
        planoAtual = plan.nome;
        planDetails = {
          id: plan._id,
          nome: plan.nome,
          limiteAlunos: plan.limiteAlunos,
          preco: plan.preco,
        };
      } else if (personal.planoAtual && personal.planoAtual !== 'Sem plano') {
        // Use whatever was provided by the server as fallback
        planoAtual = personal.planoAtual;
        planDetails = personal.planDetails;
      }

      const processedPersonal: PersonalTrainerWithStatus = {
        _id: personal._id,
        nome: personal.nome,
        email: personal.email,
        createdAt: personal.createdAt,
        planoAtual,
        planoId: planId,
        planoDisplay: planoAtual,
        alunosAtivos: personal.alunosAtivos || 0,
        limiteAlunos: personal.limiteAlunos || 0,
        percentualUso: personal.percentualUso || 0,
        hasActivePlan: planId !== null && planoAtual !== 'Sem plano' && !personal.isExpired,
        isExpired: personal.isExpired || false, // Handle expired plan status
        dataInicio: personal.dataInicio || null, // Preserve plan start date
        dataVencimento: personal.dataVencimento || null, // Preserve plan expiration date
        planDetails,
      };

      console.log(`✅ [usePlanManagement] Processed ${personal.nome}: ${planoAtual}`);
      return processedPersonal;
    });
  }, []);

  /**
   * Main data fetching function - fetches both personal trainers and plans
   * then processes them together for consistent plan name resolution
   */
  const fetchData = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      console.log('🔄 [usePlanManagement] Starting data fetch...');
      
      // Fetch both datasets in parallel for better performance
      const [personalTrainersResponse, planosResponse] = await Promise.all([
        fetchWithAuth('/api/admin/personal-trainers') as Promise<any[]>,
        fetchWithAuth('/api/admin/planos') as Promise<Plano[]>
      ]);

      console.log('📊 [usePlanManagement] Raw personal trainers data:', personalTrainersResponse);
      console.log('📊 [usePlanManagement] Plans data:', planosResponse);

      // Create plan lookup map for efficient resolution
      const planLookupMap = createPlanLookupMap(planosResponse);
      
      // Process personal trainers with enhanced plan name resolution
      const processedPersonalTrainers = processPersonalTrainerData(personalTrainersResponse, planLookupMap);

      setState(prev => ({
        ...prev,
        personalTrainers: processedPersonalTrainers,
        planos: planosResponse,
        planLookupMap,
        loading: false,
        lastUpdated: new Date(),
      }));

      console.log('✅ [usePlanManagement] Data fetched and processed successfully');
      console.log('📊 [usePlanManagement] Final processed data:', processedPersonalTrainers);
      
    } catch (error) {
      console.error('❌ [usePlanManagement] Error fetching data:', error);
      handleApiError(error, 'Erro ao carregar dados dos personal trainers');
      setState(prev => ({ 
        ...prev, 
        loading: false, 
        error: 'Erro ao carregar dados. Tente novamente.' 
      }));
    }
  }, [createPlanLookupMap, processPersonalTrainerData]);

  /**
   * Refresh data for a specific personal trainer
   */
  const refreshPersonalData = useCallback(async (personalId: string) => {
    try {
      console.log('🔄 [usePlanManagement] Refreshing data for personal:', personalId);
      
      // For now, refresh all data to ensure consistency
      // In the future, we could implement a more targeted refresh
      await fetchData();
      
    } catch (error) {
      console.error('❌ [usePlanManagement] Error refreshing personal data:', error);
      throw error;
    }
  }, [fetchData]);

  /**
   * Assign a plan to a personal trainer with enhanced error handling
   */
  const assignPlan = useCallback(async (personalId: string, data: AssignPlanForm) => {
    try {
      console.log('🔄 [usePlanManagement] Assigning plan...', { personalId, data });

      // Validate plan exists
      const planExists = state.planos.find(p => p._id === data.planoId);
      if (!planExists) {
        throw new Error('Plano selecionado não encontrado');
      }

      await fetchWithAuth(`/api/admin/personal/${personalId}/assign-plan`, {
        method: 'POST',
        body: JSON.stringify(data),
      });

      console.log('✅ [usePlanManagement] Plan assigned successfully');

      // Show success feedback
      showToast({
        title: 'Plano Atribuído',
        description: `Plano "${planExists.nome}" atribuído com sucesso.`,
        variant: 'default',
      });

      // Refresh data to get updated state
      await fetchData();

    } catch (error) {
      console.error('❌ [usePlanManagement] Error assigning plan:', error);
      handleApiError(error, 'Erro ao atribuir plano');
      throw error;
    }
  }, [state.planos, fetchData]);

  /**
   * Add tokens to a personal trainer with enhanced error handling
   */
  const addTokens = useCallback(async (personalId: string, data: AddTokensForm) => {
    try {
      console.log('🔄 [usePlanManagement] Adding tokens...', { personalId, data });

      if (!data.quantidade || data.quantidade < 1) {
        throw new Error('Quantidade de tokens deve ser pelo menos 1');
      }

      await fetchWithAuth(`/api/admin/personal/${personalId}/add-tokens`, {
        method: 'POST',
        body: JSON.stringify(data),
      });

      console.log('✅ [usePlanManagement] Tokens added successfully');

      // Show success feedback
      showToast({
        title: 'Tokens Adicionados',
        description: `${data.quantidade} tokens adicionados com sucesso.`,
        variant: 'default',
      });

      // Refresh data to get updated state
      await fetchData();

    } catch (error) {
      console.error('❌ [usePlanManagement] Error adding tokens:', error);
      handleApiError(error, 'Erro ao adicionar tokens');
      throw error;
    }
  }, [fetchData]);

  // Memoized computed values
  const memoizedValues = useMemo(() => ({
    planLookupMap: state.planLookupMap,
    getPlanNameById,
    getPlanById
  }), [state.planLookupMap, getPlanNameById, getPlanById]);

  return {
    // State
    personalTrainers: state.personalTrainers,
    planos: state.planos,
    planLookupMap: memoizedValues.planLookupMap,
    loading: state.loading,
    error: state.error,
    lastUpdated: state.lastUpdated,
    
    // Actions
    fetchData,
    assignPlan,
    addTokens,
    refreshPersonalData,
    clearError,
    getPlanNameById: memoizedValues.getPlanNameById,
    getPlanById: memoizedValues.getPlanById,
  };
}
===== ./client/src/index.css =====
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Modern Design System Variables */
:root {
  /* Base Colors */
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --muted: 210 40% 98%;
  --muted-foreground: 215.4 16.3% 46.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 222.2 84% 4.9%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;
  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  
  /* Primary Brand Colors with Gradients */
  --primary: 225 83% 60%;
  --primary-foreground: 210 40% 98%;
  --primary-gradient: linear-gradient(135deg, hsl(225 83% 60%) 0%, hsl(235 83% 65%) 100%);
  
  /* Secondary Colors */
  --secondary: 258 87% 33%;
  --secondary-foreground: 210 40% 98%;
  --secondary-gradient: linear-gradient(135deg, hsl(258 87% 33%) 0%, hsl(268 87% 38%) 100%);
  
  /* Accent Colors */
  --accent: 331 91% 56%;
  --accent-foreground: 210 40% 98%;
  --accent-gradient: linear-gradient(135deg, hsl(331 91% 56%) 0%, hsl(341 91% 61%) 100%);
  
  /* Status Colors */
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;
  --success: 142.1 76.2% 36.3%;
  --success-foreground: 355.7 100% 97.3%;
  --warning: 32.2 95% 44.1%;
  --warning-foreground: 355.7 100% 97.3%;
  
  /* Ring and Focus */
  --ring: 225 83% 60%;
  
  /* Border Radius System */
  --radius: 0.75rem;
  --radius-sm: 0.5rem;
  --radius-md: 0.75rem;
  --radius-lg: 1rem;
  --radius-xl: 1.5rem;
  
  /* Shadow System */
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  
  /* Glassmorphism */
  --glass-background: rgba(255, 255, 255, 0.15);
  --glass-border: rgba(255, 255, 255, 0.2);
  --glass-backdrop: blur(10px);
  
  /* Gradient Backgrounds */
  --bg-gradient-primary: linear-gradient(135deg, hsl(225 83% 60%) 0%, hsl(258 87% 33%) 100%);
  --bg-gradient-secondary: linear-gradient(135deg, hsl(258 87% 33%) 0%, hsl(331 91% 56%) 100%);
  --bg-gradient-subtle: linear-gradient(135deg, hsl(210 40% 98%) 0%, hsl(220 40% 96%) 100%);
  
  /* Sidebar specific colors */
  --sidebar-background: 222.2 84% 4.9%;
  --sidebar-foreground: 210 40% 98%;
  --sidebar-primary: 225 83% 60%;
  --sidebar-primary-foreground: 210 40% 98%;
  --sidebar-accent: 215 27.9% 16.9%;
  --sidebar-accent-foreground: 210 40% 98%;
  --sidebar-border: 215 27.9% 16.9%;
  --sidebar-ring: 225 83% 60%;
}

/* Dark Mode Variables */
.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
  --muted: 217.2 32.6% 17.5%;
  --muted-foreground: 215 20.2% 65.1%;
  --popover: 222.2 84% 4.9%;
  --popover-foreground: 210 40% 98%;
  --card: 222.2 84% 4.9%;
  --card-foreground: 210 40% 98%;
  --border: 217.2 32.6% 17.5%;
  --input: 217.2 32.6% 17.5%;
  
  /* Primary Brand Colors for Dark Mode */
  --primary: 225 83% 65%;
  --primary-foreground: 222.2 84% 4.9%;
  --primary-gradient: linear-gradient(135deg, hsl(225 83% 65%) 0%, hsl(235 83% 70%) 100%);
  
  /* Secondary Colors for Dark Mode */
  --secondary: 258 87% 38%;
  --secondary-foreground: 210 40% 98%;
  --secondary-gradient: linear-gradient(135deg, hsl(258 87% 38%) 0%, hsl(268 87% 43%) 100%);
  
  /* Accent Colors for Dark Mode */
  --accent: 331 91% 61%;
  --accent-foreground: 222.2 84% 4.9%;
  --accent-gradient: linear-gradient(135deg, hsl(331 91% 61%) 0%, hsl(341 91% 66%) 100%);
  
  /* Ring for Dark Mode */
  --ring: 225 83% 65%;
  
  /* Glassmorphism for Dark Mode */
  --glass-background: rgba(255, 255, 255, 0.05);
  --glass-border: rgba(255, 255, 255, 0.1);
  
  /* Gradient Backgrounds for Dark Mode */
  --bg-gradient-primary: linear-gradient(135deg, hsl(225 83% 30%) 0%, hsl(258 87% 20%) 100%);
  --bg-gradient-secondary: linear-gradient(135deg, hsl(258 87% 20%) 0%, hsl(331 91% 35%) 100%);
  --bg-gradient-subtle: linear-gradient(135deg, hsl(217.2 32.6% 17.5%) 0%, hsl(215 27.9% 16.9%) 100%);
}

@layer base {
  * {
    @apply border-border;
  }
  
  body {
    @apply bg-background text-foreground font-sans antialiased;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
  
  /* Typography Hierarchy */
  h1 {
    @apply text-4xl font-bold tracking-tight lg:text-5xl;
  }
  
  h2 {
    @apply text-3xl font-semibold tracking-tight;
  }
  
  h3 {
    @apply text-2xl font-semibold tracking-tight;
  }
  
  h4 {
    @apply text-xl font-semibold tracking-tight;
  }
  
  h5 {
    @apply text-lg font-medium;
  }
  
  h6 {
    @apply text-base font-medium;
  }
  
  /* Focus visible improvements */
  *:focus-visible {
    @apply outline-none ring-2 ring-ring ring-offset-2 ring-offset-background;
  }
  
  /* Smooth scrolling and Scrollbar fix */
  html {
    scroll-behavior: smooth;
    /* <<< INÍCIO DA CORREÇÃO >>> */
    /* Força a barra de rolagem a estar sempre visível para evitar "saltos" no layout */
    overflow-y: scroll;
    /* <<< FIM DA CORREÇÃO >>> */
  }
}

@layer components {
  .container {
    @apply mx-auto px-4;
  }
  
  /* Modern Gradient Utilities */
  .bg-gradient-primary {
    background: var(--bg-gradient-primary);
  }
  
  .bg-gradient-secondary {
    background: var(--bg-gradient-secondary);
  }
  
  .bg-gradient-subtle {
    background: var(--bg-gradient-subtle);
  }
  
  /* Glassmorphism Effect */
  .glass {
    background: var(--glass-background);
    border: 1px solid var(--glass-border);
    backdrop-filter: var(--glass-backdrop);
    -webkit-backdrop-filter: var(--glass-backdrop);
  }
  
  /* Modern Shadow System */
  .shadow-glass {
    box-shadow: 
      0 8px 32px 0 rgba(31, 38, 135, 0.15),
      inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
  }
  
  .shadow-neumorphism {
    box-shadow: 
      6px 6px 12px rgba(0, 0, 0, 0.1),
      -6px -6px 12px rgba(255, 255, 255, 0.7);
  }
  
  .shadow-elevated {
    box-shadow: 
      0 4px 14px 0 rgba(0, 0, 0, 0.1),
      0 2px 4px 0 rgba(0, 0, 0, 0.05);
  }
  
  /* Animation Utilities */
  .animate-fade-in {
    animation: fadeIn 0.3s ease-out;
  }
  
  .animate-slide-up {
    animation: slideUp 0.3s ease-out;
  }
  
  .animate-scale-in {
    animation: scaleIn 0.2s ease-out;
  }
  
  /* Interactive States */
  .interactive {
    @apply transition-all duration-200 ease-out;
  }
  
  .interactive:hover {
    transform: translateY(-1px);
  }
  
  .interactive:active {
    transform: translateY(0);
  }
}

@layer utilities {
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }
  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  
  /* Touch Target Utilities */
  .touch-target {
    @apply min-h-[44px] min-w-[44px];
  }
  
  /* Mobile-first responsive text */
  .text-responsive {
    @apply text-sm sm:text-base;
  }
  
  /* Gradient Text */
  .text-gradient {
    background: var(--primary-gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  /* Mobile Navigation Fixed Positioning Utilities */
  .mobile-nav-fixed {
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    transform: none !important;
    -webkit-transform: none !important;
    will-change: auto !important;
  }

  /* Enhanced Card Hover Effects */
  .card-hover-lift {
    transition: transform 0.2s ease-out, box-shadow 0.3s ease-out;
  }
  
  .card-hover-lift:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  }

  /* Responsive Grid Improvements */
  @media (max-width: 640px) {
    .grid-responsive {
      grid-template-columns: 1fr;
      gap: 1rem;
    }
  }

  @media (min-width: 641px) and (max-width: 768px) {
    .grid-responsive {
      grid-template-columns: repeat(2, 1fr);
      gap: 1.25rem;
    }
  }

  @media (min-width: 769px) and (max-width: 1024px) {
    .grid-responsive {
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
    }
  }

  @media (min-width: 1025px) {
    .grid-responsive {
      grid-template-columns: repeat(4, 1fr);
      gap: 1.5rem;
    }
  }

  /* Enhanced Button Styles */
  .btn-gradient {
    background: linear-gradient(135deg, hsl(var(--primary)) 0%, hsl(var(--secondary)) 100%);
    border: none;
    color: hsl(var(--primary-foreground));
    transition: all 0.2s ease-out;
  }

  .btn-gradient:hover {
    background: linear-gradient(135deg, hsl(var(--primary)) 10%, hsl(var(--secondary)) 90%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .btn-gradient:active {
    transform: translateY(0);
  }

  /* 🔧 ENHANCED: Toast Animations - SMOOTH & STABLE */
  [data-radix-toast-viewport] {
    position: fixed !important;
    top: 1.5rem !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: calc(100vw - 2rem) !important;
    max-width: 420px !important;
    z-index: 2147483647 !important;
    pointer-events: none !important;
    /* Prevent layout shifts */
    will-change: auto !important;
  }

  [data-radix-toast-viewport] > * {
    pointer-events: auto !important;
  }

  /* Toast individual - STABLE animations to prevent loops */
  [data-state="open"][data-radix-toast] {
    animation: toast-slide-in-top 300ms cubic-bezier(0.16, 1, 0.3, 1) !important;
    animation-fill-mode: forwards !important;
  }

  [data-state="closed"][data-radix-toast] {
    animation: toast-slide-out-top 200ms cubic-bezier(0.4, 0, 1, 1) !important;
    animation-fill-mode: forwards !important;
  }

  /* PREVENT tremor and loop behavior */
  [data-radix-toast] {
    /* Force stable positioning */
    transform: translateY(0) !important;
    animation-duration: 300ms !important;
    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1) !important;
    animation-fill-mode: forwards !important;
    /* Prevent unwanted hardware acceleration issues */
    backface-visibility: hidden !important;
    perspective: 1000px !important;
    /* Ensure proper layering */
    contain: layout style paint !important;
  }

  /* Prevent multiple toasts from interfering */
  [data-radix-toast] + [data-radix-toast] {
    margin-top: 0.5rem !important;
  }

  /* Mobile responsive for toast - consistent with desktop positioning */
  @media (max-width: 640px) {
    [data-radix-toast-viewport] {
      width: calc(100vw - 1rem) !important;
      top: 1rem !important;
    }
  }

  /* Tablet responsive positioning */
  @media (min-width: 641px) and (max-width: 1024px) {
    [data-radix-toast-viewport] {
      top: 1.25rem !important;
    }
  }
}

/* Keyframe Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* 🚀 ENHANCED Toast Animations - STABLE & SMOOTH */
@keyframes toast-slide-in-top {
  from {
    opacity: 0;
    transform: translateY(-100%) scale(0.96);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

@keyframes toast-slide-out-top {
  from {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
  to {
    opacity: 0;
    transform: translateY(-100%) scale(0.95);
  }
}
===== ./client/src/lib/apiClient.ts =====
// client/src/lib/apiClient.ts

export class AuthError extends Error {
  public code?: string; 

  constructor(message = 'Authentication failed', code?: string) {
    super(message);
    this.name = 'AuthError';
    this.code = code;
  }
}

export type TokenType = 'personalAdmin' | 'aluno';

// 1. Definir o tipo da nova opção
interface FetchOptions extends RequestInit {
  returnAs?: 'json' | 'response'; // 'json' é o padrão, 'response' para downloads
}

let isRefreshing = false;
let failedQueue: Array<{ resolve: Function; reject: Function }> = [];

const RETRY_CONFIG = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 10000,
  backoffFactor: 2
};

const calculateBackoffDelay = (attempt: number): number => {
  const delay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffFactor, attempt);
  return Math.min(delay + Math.random() * 1000, RETRY_CONFIG.maxDelay);
};

const sleep = (ms: number): Promise<void> => new Promise(resolve => setTimeout(resolve, ms));

const validateAndCleanStorage = (tokenType: TokenType): boolean => {
  try {
    const tokenKey = tokenType === 'aluno' ? 'alunoAuthToken' : 'authToken';
    const refreshTokenKey = tokenType === 'aluno' ? 'alunoRefreshToken' : 'refreshToken';
    
    const token = localStorage.getItem(tokenKey);
    const refreshToken = localStorage.getItem(refreshTokenKey);
    
    console.log(`[validateAndCleanStorage] Validando storage para ${tokenType}...`);
    
    if (token === '' || token === 'null' || token === 'undefined') {
      console.warn(`[validateAndCleanStorage] Token ${tokenType} corrompido, limpando apenas este tipo...`);
      localStorage.removeItem(tokenKey);
      localStorage.removeItem(refreshTokenKey);
      
      if (tokenType === 'aluno') {
        localStorage.removeItem('alunoData');
      } else {
        localStorage.removeItem('userData');
      }
      return false;
    }
    
    if (refreshToken === '' || refreshToken === 'null' || refreshToken === 'undefined') {
      console.warn(`[validateAndCleanStorage] Refresh token ${tokenType} corrompido, limpando apenas este tipo...`);
      localStorage.removeItem(refreshTokenKey);
    }
    
    if (token && !token.includes('.')) {
      console.warn(`[validateAndCleanStorage] Token ${tokenType} não tem formato JWT válido, limpando...`);
      localStorage.removeItem(tokenKey);
      localStorage.removeItem(refreshTokenKey);
      return false;
    }
    
    console.log(`[validateAndCleanStorage] Storage para ${tokenType} validado com sucesso.`);
    return true;
  } catch (error) {
    console.error(`[validateAndCleanStorage] Erro ao validar storage para ${tokenType}:`, error);
    return false;
  }
};
const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(({ resolve, reject }) => {
    if (error) {
      reject(error);
    } else {
      resolve(token);
    }
  });
  
  failedQueue = [];
};

const refreshToken = async (tokenType: TokenType, retryAttempt: number = 0): Promise<string | null> => {
  if (!validateAndCleanStorage(tokenType)) {
    console.warn(`[refreshToken] Storage corrompido para ${tokenType}, abortando renovação`);
    return null;
  }

  const refreshTokenKey = tokenType === 'aluno' ? 'alunoRefreshToken' : 'refreshToken';
  const refreshTokenValue = localStorage.getItem(refreshTokenKey);
  
  if (!refreshTokenValue) {
    console.warn(`[refreshToken] Nenhum refresh token encontrado para ${tokenType}`);
    return null;
  }

  const endpoint = tokenType === 'aluno' ? '/api/auth/aluno/refresh' : '/api/auth/refresh';
  
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ refreshToken: refreshTokenValue }),
    });

    if (!response.ok) {
      const errorData = await response.text();
      let parsedError;
      try {
        parsedError = JSON.parse(errorData);
      } catch {
        parsedError = { message: errorData };
      }
      
      console.warn(`[refreshToken] Falha ao renovar token ${tokenType}:`, parsedError.message);
      
      if (response.status >= 500 && retryAttempt < RETRY_CONFIG.maxRetries) {
        const delay = calculateBackoffDelay(retryAttempt);
        console.log(`[refreshToken] Erro ${response.status}, tentativa ${retryAttempt + 1}/${RETRY_CONFIG.maxRetries + 1} em ${delay}ms`);
        await sleep(delay);
        return refreshToken(tokenType, retryAttempt + 1);
      }
      
      localStorage.removeItem(refreshTokenKey);
      if (tokenType === 'aluno') {
        localStorage.removeItem('alunoAuthToken');
      } else {
        localStorage.removeItem('authToken');
      }
      
      return null;
    }

    const data = await response.json();
    const newToken = data.token;
    
    if (tokenType === 'aluno') {
      localStorage.setItem('alunoAuthToken', newToken);
    } else {
      localStorage.setItem('authToken', newToken);
    }
    
    console.log(`[refreshToken] Token ${tokenType} renovado com sucesso`);
    return newToken;
    
  } catch (error) {
    console.error(`[refreshToken] Erro ao renovar token ${tokenType}:`, error);
    
    if (retryAttempt < RETRY_CONFIG.maxRetries) {
      const delay = calculateBackoffDelay(retryAttempt);
      console.log(`[refreshToken] Erro de rede, tentativa ${retryAttempt + 1}/${RETRY_CONFIG.maxRetries + 1} em ${delay}ms`);
      await sleep(delay);
      return refreshToken(tokenType, retryAttempt + 1);
    }
    
    return null;
  }
};

const fetchWithAuthInternal = async <T = any>(
  url: string,
  options: FetchOptions = {},
  tokenType: TokenType = 'personalAdmin'
): Promise<T> => {
  if (!url.startsWith('/api/auth/')) {
    validateAndCleanStorage(tokenType);
  }

  let token: string | null = null;
  const isPublicAuthRoute = url.startsWith('/api/auth/');
  
  if (!isPublicAuthRoute) {
      if (tokenType === 'aluno') {
          token = localStorage.getItem('alunoAuthToken');
      } else {
          token = localStorage.getItem('authToken');
      }
  }

  const headers = new Headers(options.headers || {});
  
  const isFormData = options.body instanceof FormData;
  if (!isFormData) {
    headers.set('Accept', 'application/json');
  } else {
    console.log(`[fetchWithAuth] FormData upload detected for ${url}`);
  }

  if (token) {
    headers.set('Authorization', `Bearer ${token}`);
    if (isFormData) {
      console.log(`[fetchWithAuth] Authorization header set for FormData upload`);
    }
  } else if (!isPublicAuthRoute) {
    console.warn(`[fetchWithAuth] Nenhum token encontrado para a rota protegida '${url}' (tipo esperado: ${tokenType})`);
  }

  if (options.body && typeof options.body === 'string') {
    if (!headers.has('Content-Type')) {
      headers.set('Content-Type', 'application/json');
    }
  }

  try {
    const response = await fetch(url, { ...options, headers });
    
    // 3. Lógica de retorno modificada
    if (options.returnAs === 'response') {
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: `Erro ${response.status} ao buscar o arquivo.` }));
            throw new Error(errorData.message);
        }
        return response as T;
    }

    if (response.status === 204) return null as T;

    const contentType = response.headers.get('content-type');
    const isJson = contentType && contentType.includes('application/json');

    let data;
    let responseText = await response.text();

    if (responseText && isJson) {
      try {
        data = JSON.parse(responseText);
      } catch (parseError) {
        console.error(`[fetchWithAuth] Erro ao parsear JSON da rota '${url}':`, parseError, `Conteúdo: ${responseText.substring(0, 200)}...`);
        throw new Error(`Erro ${response.status}: Resposta JSON inválida do servidor.`);
      }
    } else if (responseText) {
      data = { message: responseText };
    } else {
      data = null;
    }
    
    if (!response.ok) {
      const errorMessage = data?.message || data?.mensagem || data?.erro || `Erro ${response.status}: ${response.statusText || 'Ocorreu um erro na comunicação.'}`;
      const errorCode = data?.code;

      if (response.status === 401 || response.status === 403) {
          if (response.status === 401 && !isPublicAuthRoute) {
              if (isRefreshing) {
                  return new Promise((resolve, reject) => {
                      failedQueue.push({ resolve, reject });
                  }).then((token) => {
                      const newHeaders = new Headers(options.headers || {});
                      newHeaders.set('Authorization', `Bearer ${token}`);
                      if (!(options.body instanceof FormData)) {
                        newHeaders.set('Accept', 'application/json');
                      }
                      return fetch(url, { ...options, headers: newHeaders });
                  }).then(async (retryResponse) => {
                      if (retryResponse.status === 204) return null as T;
                      const retryData = await retryResponse.json();
                      if (!retryResponse.ok) {
                          throw new Error(retryData?.message || `Erro ${retryResponse.status}`);
                      }
                      return retryData as T;
                  });
              }

              isRefreshing = true;
              
              try {
                  const newToken = await refreshToken(tokenType);
                  
                  if (newToken) {
                      processQueue(null, newToken);
                      isRefreshing = false;
                      
                      const newHeaders = new Headers(options.headers || {});
                      newHeaders.set('Authorization', `Bearer ${newToken}`);
                      
                      if (!(options.body instanceof FormData)) {
                        newHeaders.set('Accept', 'application/json');
                      }
                      
                      const retryResponse = await fetch(url, { ...options, headers: newHeaders });
                      
                      if (retryResponse.status === 204) return null as T;
                      
                      const retryContentType = retryResponse.headers.get('content-type');
                      const retryIsJson = retryContentType && retryContentType.includes('application/json');
                      
                      let retryData;
                      const retryResponseText = await retryResponse.text();
                      
                      if (retryResponseText && retryIsJson) {
                          try {
                              retryData = JSON.parse(retryResponseText);
                          } catch (parseError) {
                              console.error(`[fetchWithAuth] Erro ao parsear JSON na tentativa de retry da rota '${url}':`, parseError);
                              throw new Error(`Erro ${retryResponse.status}: Resposta JSON inválida do servidor.`);
                          }
                      } else if (retryResponseText) {
                          retryData = { message: retryResponseText };
                      } else {
                          retryData = null;
                      }
                      
                      if (!retryResponse.ok) {
                          const retryErrorMessage = retryData?.message || retryData?.mensagem || retryData?.erro || `Erro ${retryResponse.status}: ${retryResponse.statusText || 'Ocorreu um erro na comunicação.'}`;
                          throw new Error(retryErrorMessage);
                      }
                      
                      return retryData as T;
                  } else {
                      const refreshError = new AuthError('Token expirado e não foi possível renovar', 'REFRESH_FAILED');
                      processQueue(refreshError, null);
                      isRefreshing = false;
                      
                      window.dispatchEvent(new CustomEvent('auth-failed', { 
                        detail: { 
                          status: response.status,
                          forAluno: tokenType === 'aluno', 
                          forPersonalAdmin: tokenType === 'personalAdmin',
                          code: 'REFRESH_FAILED'
                        } 
                      }));
                      
                      throw refreshError;
                  }
              } catch (refreshError) {
                  processQueue(refreshError, null);
                  isRefreshing = false;
                  
                  if (!(refreshError instanceof AuthError)) {
                      window.dispatchEvent(new CustomEvent('auth-failed', { 
                        detail: { 
                          status: response.status,
                          forAluno: tokenType === 'aluno', 
                          forPersonalAdmin: tokenType === 'personalAdmin',
                          code: errorCode
                        } 
                      }));
                  }
                  
                  throw refreshError;
              }
          } else {
              window.dispatchEvent(new CustomEvent('auth-failed', { 
                detail: { 
                  status: response.status,
                  forAluno: tokenType === 'aluno', 
                  forPersonalAdmin: tokenType === 'personalAdmin',
                  code: errorCode
                } 
              }));
              throw new AuthError(errorMessage, errorCode);
          }
      }
      
      if (response.status >= 500) {
        const serverError = new Error(`Erro ${response.status}: ${errorMessage}`);
        (serverError as any).status = response.status;
        (serverError as any).isServerError = true;
        throw serverError;
      }
      
      throw new Error(errorMessage);
    }

    return data as T;

  } catch (error) {
    console.error(`[fetchWithAuth] Erro de rede ou de requisição para a rota '${url}':`, error);
    if (error instanceof Error) {
      if (error.message.includes('Failed to fetch')) {
          throw new Error('Não foi possível conectar ao servidor. Verifique sua conexão com a internet.');
      }
      throw error;
    } else {
      throw new Error('Erro desconhecido durante a requisição.');
    }
  }
};

export const fetchWithAuth = async <T = any>(
    url: string,
    options: FetchOptions = {},
    tokenType: TokenType = 'personalAdmin'
  ): Promise<T> => {

    try {
      return await fetchWithAuthInternal<T>(url, options, tokenType);
    } catch (error: any) {
      if (error?.isServerError && error?.status >= 500) {
        console.log(`[fetchWithAuth] Erro ${error.status} detectado para ${url}, implementando retry com backoff`);
        
        for (let attempt = 0; attempt < RETRY_CONFIG.maxRetries; attempt++) {
          try {
            const delay = calculateBackoffDelay(attempt);
            console.log(`[fetchWithAuth] Tentativa ${attempt + 1}/${RETRY_CONFIG.maxRetries} em ${delay}ms`);
            await sleep(delay);
            
            return await fetchWithAuthInternal<T>(url, options, tokenType);
          } catch (retryError: any) {
            if (attempt === RETRY_CONFIG.maxRetries - 1) {
              console.error(`[fetchWithAuth] Todas as tentativas falharam para ${url}`);
              throw error;
            }
            if (!retryError?.isServerError || retryError?.status < 500) {
              throw retryError;
            }
          }
        }
      }
      
      throw error;
    }
  };

export const apiRequest = async <T = any>(
  method: string,
  url: string,
  body?: any,
  tokenType: TokenType = 'personalAdmin'
): Promise<T> => {
  const options: FetchOptions = {
    method,
    headers: {
      'Content-Type': 'application/json',
    },
  };

  if (body) {
    options.body = JSON.stringify(body);
  }

  return fetchWithAuth<T>(url, options, tokenType);
};
===== ./client/src/lib/handleApiError.ts =====
// client/src/lib/handleApiError.ts
// 👇 REMOVIDO 'Toast' ou 'ShowToastProps' do import, pois não é usado aqui 👇
import { showToast } from '@/lib/toastUtils';

// Interface interna para tentar parsear a resposta de erro
interface ApiErrorResponse {
    message?: string;
    erro?: string;
    errors?: string[] | Record<string, { message: string }>;
}

/**
 * Processa um erro capturado de uma chamada API (fetch, axios, react-query).
 * Exibe um toast com uma mensagem de erro útil.
 *
 * @param error O objeto de erro capturado.
 * @param fallbackTitle Título padrão para o toast se o erro não fornecer um.
 */
export function handleApiError(error: unknown, fallbackTitle: string = "Erro Inesperado"): void {
    let title = fallbackTitle;
    let description = "Ocorreu um problema. Tente novamente mais tarde.";

    console.error("API Error:", error); // Loga o erro completo

    if (error instanceof Error) {
        try {
            // Tenta parsear como JSON apenas se parecer um JSON
             if (typeof error.message === 'string' && error.message.trim().startsWith('{')) {
                const errorJson = JSON.parse(error.message) as ApiErrorResponse;
                description = errorJson.message || errorJson.erro || description;
            } else if (typeof error.message === 'string') {
                 description = error.message; // Usa a mensagem direta se não for JSON
            }
        } catch (parseError) {
            // Se não for JSON, usa a mensagem de erro direta
           if (typeof error.message === 'string') {
               description = error.message;
           }
        }

        // Tenta extrair status da mensagem (se existir)
        const statusMatch = typeof error.message === 'string' ? error.message.match(/Erro (\d+):?/) : null;
        if (statusMatch?.[1]) { // Usa optional chaining
            title = `Erro ${statusMatch[1]}`;
            if (statusMatch[1] === '401') title = "Não Autorizado";
            else if (statusMatch[1] === '403') title = "Acesso Proibido";
            else if (statusMatch[1] === '404') title = "Não Encontrado";
            // Adicionar outros códigos de status se necessário
        }

    } else if (typeof error === 'string') {
        description = error;
    }

    // Chama a função showToast importada
    showToast({
        title: title,
        description: description,
        variant: "destructive",
    });
}
===== ./client/src/lib/queryClient.ts =====
// client/lib/queryClient.ts
import { QueryClient } from "@tanstack/react-query";
// Etapa 1: Importar o AuthError que criamos no apiClient.
import { fetchWithAuth, AuthError, TokenType } from './apiClient';

const retryDelay = (attemptIndex: number) => {
  return Math.min(1000 * 2 ** attemptIndex, 30000); 
}

// Adicionamos um quarto parâmetro opcional 'tokenType' para especificar qual token usar.
export async function apiRequest<T = unknown>(
  method: string,
  url: string,
  data?: unknown | undefined,
  tokenType: TokenType = 'personalAdmin' // Valor padrão para manter a compatibilidade
): Promise<T> {
  const relativeUrl = url.startsWith('/') ? url : `/${url}`;
  const options: RequestInit = { method };
  if (data !== undefined) {
    options.body = JSON.stringify(data);
  }
  try {
    // Passamos o 'tokenType' para a função fetchWithAuth.
    return await fetchWithAuth<T>(relativeUrl, options, tokenType);
  } catch (error) {
    throw error;
  }
}

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Configuração otimizada para visão de aluno: reduzido de 2 minutos para 30 segundos
      // Isso garante que dados de progresso de treinos sejam atualizados mais frequentemente,
      // resolvendo problemas de cache no Vercel onde usuários precisavam pressionar F5
      staleTime: 1000 * 30, // 30 segundos

      // Etapa 2: Transformar a opção 'retry' em uma função inteligente.
      // Esta função recebe o número de tentativas e o objeto de erro.
      retry: (failureCount, error) => {
        // Se o erro for uma instância do nosso AuthError, a função retorna 'false'.
        // Isso diz ao React Query: "Não tente novamente. Esta é uma falha de autenticação."
        if (error instanceof AuthError) {
          // Adicionado tratamento específico para códigos de erro de autenticação
          if (error.code === 'TOKEN_NOT_PROVIDED' || error.code === 'TOKEN_EXPIRED') {
            // Se o token não foi fornecido ou expirou, não tentar novamente e redirecionar
            // Nota: O redirecionamento real para a página de login deve ser feito
            // por um listener global para o evento 'auth-failed' ou no componente de login.
            // Aqui, apenas impedimos o retry.
            console.warn(`[React Query Retry] Autenticação falhou com código: ${error.code}. Não retentando.`);
            return false; 
          }
          // Para outros AuthErrors (ex: INVALID_TOKEN, UNAUTHORIZED_ROLE, INVALID_CREDENTIALS)
          // também não retentamos, pois são erros que exigem ação do usuário (login correto, permissão).
          console.warn(`[React Query Retry] Erro de autenticação não retentável com código: ${error.code}`);
          return false;
        }

        // Para qualquer outro tipo de erro (ex: falha de rede), mantemos a lógica original.
        // Tenta novamente até 2 vezes (total de 3 tentativas).
        if (failureCount < 2) {
          return true;
        }

        return false;
      }, 

      retryDelay: retryDelay,

      // Garante atualização dos dados quando o usuário volta para a aba
      refetchOnWindowFocus: true,
      
      // Garante atualização dos dados quando a conexão é restabelecida
      // Importante para aplicações web que podem perder conexão temporariamente
      refetchOnReconnect: true,
    },
  },
});

===== ./client/src/lib/toastUtils.ts =====
// client/src/lib/toastUtils.ts
import { toast as toastInternal } from "@/hooks/use-toast"; // Importa a função interna do hook

// 👇 Definindo o tipo aqui baseado nas props esperadas pela função toast interna 👇
type ToastProps = Parameters<typeof toastInternal>[0];

// Função para disparar toasts de fora de componentes React
export function showToast(props: ToastProps) { // Usa o tipo definido acima
  // Chama a função toast interna exportada pelo hook
  toastInternal(props);
}

// Exporta o tipo para quem precisar usar showToast
export type { ToastProps as ShowToastProps }; // Exporta com um alias para evitar conflito se necessário

// Exemplo de uso em handleApiError.ts:
// import { showToast, ShowToastProps } from '@/lib/toastUtils';
// const toastOptions: ShowToastProps = { title: "Erro", description: "Falha", variant: "destructive"};
// showToast(toastOptions);
===== ./client/src/lib/utils.ts =====
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

===== ./client/src/lib/validators/exerciseSchema.ts =====
import { z } from 'zod';

// Schema Zod para validação do formulário de exercícios
export const exerciseFormSchema = z.object({
  nome: z.string()
    .min(3, { message: "O nome deve ter pelo menos 3 caracteres." })
    .max(100, { message: "O nome não pode exceder 100 caracteres." })
    .trim(),
  grupoMuscular: z.string()
    .min(1, { message: "Selecione ou digite um grupo muscular." })
    .trim(),
  descricao: z.string()
    .max(1000, { message: "A descrição não pode exceder 1000 caracteres." })
    .trim()
    .optional(),
  categoria: z.string()
    .trim()
    .optional(),
  videoUrl: z.string()
    .url({ message: "Por favor, insira uma URL de vídeo válida." })
    .trim()
    .optional()
    .or(z.literal('')),
  isCustom: z.boolean().default(false),
});

export type ExerciseFormData = z.infer<typeof exerciseFormSchema>;

export const gruposMuscularesOptions = [
  "Peito", "Costas", "Pernas", "Ombros", "Bíceps", "Tríceps", "Antebraço", "Abdômen", "Lombar", "Glúteos", "Panturrilha", "Cardio", "Corpo Inteiro", "Outro"
];

export const categoriasOptions = [
  "Força", "Resistência", "Hipertrofia", "Potência", "Cardiovascular", "Flexibilidade", "Mobilidade", "Funcional", "Calistenia", "Outro"
];

===== ./client/src/main.tsx =====
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

// Disable React.StrictMode for now to avoid duplicate renders during development
createRoot(document.getElementById("root")!).render(<App />);
===== ./client/src/pages/admin/AdminDashboardPage.tsx =====
// client/src/pages/admin/AdminDashboardPage.tsx
import { useQuery } from '@tanstack/react-query';
import { Link } from 'wouter';
import { apiRequest } from '@/lib/queryClient';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Badge } from '@/components/ui/badge';
import LoadingSpinner from '@/components/LoadingSpinner';
import ErrorMessage from '@/components/ErrorMessage';
import { Users, UserPlus, Mail, List, UserCheck, TrendingUp, Activity, Star, Zap } from 'lucide-react'; 
import { PersonalListadoItem } from '@/pages/admin/ListarPersonaisPage';

interface AdminDashboardData {
  totalPersonais: number;
  personaisAtivos: number;
  convitesPendentes: number;
  totalExercicios: number;
}

// Mock data for development when API is not available
const mockDashboardData: AdminDashboardData = {
  totalPersonais: 24,
  personaisAtivos: 18,
  convitesPendentes: 3,
  totalExercicios: 156
};

const mockPersonaisRecentes: PersonalListadoItem[] = [
  {
    _id: "1",
    nome: "Carlos Silva",
    email: "carlos@example.com",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    _id: "2",
    nome: "Ana Santos",
    email: "ana@example.com",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    _id: "3",
    nome: "João Oliveira",
    email: "joao@example.com",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  }
];

export default function AdminDashboardPage() {
  // Use mock data in development mode, real API in production
  const { data, isLoading, error } = useQuery<AdminDashboardData>({
    queryKey: ['adminDashboardStats'],
    queryFn: () => apiRequest('GET', '/api/admin/dashboard/stats'),
    // Provide mock data when API fails
    retry: false,
    staleTime: 0,
  });

  const { data: personaisRecentes, isLoading: isLoadingPersonais } = useQuery<PersonalListadoItem[]>({
      queryKey: ['adminRecentPersonals'],
      queryFn: () => apiRequest('GET', '/api/admin/personal-trainers?limit=5&sort=createdAt:desc'),
      retry: false,
      staleTime: 0,
  });

  // Use mock data when API fails or during development
  const dashboardData = data || mockDashboardData;
  const personaisData = personaisRecentes || mockPersonaisRecentes;
  const isPageLoading = isLoading || isLoadingPersonais;

  if (isPageLoading) {
    return (
      <div className="flex items-center justify-center min-h-[60vh]">
        <div className="text-center space-y-4">
          <div className="relative">
            <div className="w-16 h-16 mx-auto">
              <div className="absolute inset-0 bg-gradient-primary rounded-full animate-ping opacity-20"></div>
              <div className="relative w-16 h-16 bg-gradient-primary rounded-full flex items-center justify-center">
                <Activity className="w-8 h-8 text-white animate-pulse" />
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <h3 className="text-lg font-semibold text-foreground">Carregando Dashboard</h3>
            <p className="text-sm text-muted-foreground">Preparando seus dados...</p>
          </div>
        </div>
      </div>
    );
  }

  // Don't show error for development - just use mock data
  if (error && !data) {
    console.warn('API Error (using mock data for development):', error.message);
  }

  return (
    <div className="min-h-screen bg-gradient-subtle">
      <div className="container mx-auto p-4 md:p-6 lg:p-8 space-y-8">
        {/* Enhanced Header with Gradient Text */}
        <div className="space-y-2">
          <h1 className="text-3xl md:text-4xl lg:text-5xl font-bold bg-gradient-primary bg-clip-text text-transparent animate-fade-in">
            Dashboard do Administrador
          </h1>
          <p className="text-base md:text-lg text-muted-foreground">
            Gerencie sua plataforma e acompanhe o crescimento
          </p>
        </div>

        {/* Enhanced Statistics Cards with Gradients and Animations */}
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
          <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-blue-950/50 dark:to-indigo-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up">
            <div className="absolute inset-0 bg-gradient-primary opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
              <CardTitle className="text-sm font-medium text-foreground/80">Total de Personais</CardTitle>
              <div className="p-2 bg-blue-500/10 rounded-lg group-hover:bg-blue-500/20 transition-colors duration-300">
                <Users className="h-5 w-5 text-blue-600 dark:text-blue-400" />
              </div>
            </CardHeader>
            <CardContent className="space-y-2">
              <div className="text-2xl md:text-3xl font-bold text-foreground">{dashboardData?.totalPersonais ?? '0'}</div>
              <div className="flex items-center space-x-1">
                <TrendingUp className="h-3 w-3 text-green-500" />
                <p className="text-xs text-muted-foreground">Cadastrados na plataforma</p>
              </div>
            </CardContent>
          </Card>

          <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-green-50 to-emerald-100 dark:from-green-950/50 dark:to-emerald-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up [animation-delay:100ms]">
            <div className="absolute inset-0 bg-gradient-secondary opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
              <CardTitle className="text-sm font-medium text-foreground/80">Assinaturas Ativas</CardTitle>
              <div className="p-2 bg-green-500/10 rounded-lg group-hover:bg-green-500/20 transition-colors duration-300">
                <UserCheck className="h-5 w-5 text-green-600 dark:text-green-400" />
              </div>
            </CardHeader>
            <CardContent className="space-y-2">
              <div className="text-2xl md:text-3xl font-bold text-foreground">{dashboardData?.personaisAtivos ?? '0'}</div>
              <div className="flex items-center space-x-1">
                <Star className="h-3 w-3 text-green-500" />
                <p className="text-xs text-muted-foreground">Personais com plano ativo</p>
              </div>
            </CardContent>
          </Card>

          <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-orange-50 to-red-100 dark:from-orange-950/50 dark:to-red-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up [animation-delay:200ms]">
            <div className="absolute inset-0 bg-gradient-accent opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
              <CardTitle className="text-sm font-medium text-foreground/80">Convites Pendentes</CardTitle>
              <div className="p-2 bg-orange-500/10 rounded-lg group-hover:bg-orange-500/20 transition-colors duration-300">
                <Mail className="h-5 w-5 text-orange-600 dark:text-orange-400" />
              </div>
            </CardHeader>
            <CardContent className="space-y-2">
              <div className="text-2xl md:text-3xl font-bold text-foreground">{dashboardData?.convitesPendentes ?? '0'}</div>
              <div className="flex items-center space-x-1">
                <Activity className="h-3 w-3 text-orange-500" />
                <p className="text-xs text-muted-foreground">Aguardando aceite</p>
              </div>
            </CardContent>
          </Card>

          <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-purple-50 to-violet-100 dark:from-purple-950/50 dark:to-violet-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up [animation-delay:300ms]">
            <div className="absolute inset-0 bg-gradient-primary opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
              <CardTitle className="text-sm font-medium text-foreground/80">Exercícios na Base</CardTitle>
              <div className="p-2 bg-purple-500/10 rounded-lg group-hover:bg-purple-500/20 transition-colors duration-300">
                <List className="h-5 w-5 text-purple-600 dark:text-purple-400" />
              </div>
            </CardHeader>
            <CardContent className="space-y-2">
              <div className="text-2xl md:text-3xl font-bold text-foreground">{dashboardData?.totalExercicios ?? '0'}</div>
              <div className="flex items-center space-x-1">
                <Zap className="h-3 w-3 text-purple-500" />
                <p className="text-xs text-muted-foreground">Disponíveis para todos</p>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Enhanced Layout with Better Mobile Responsiveness */}
        <div className="grid gap-6 lg:gap-8 lg:grid-cols-3">
          {/* Enhanced Quick Actions Section */}
          <div className="lg:col-span-1 space-y-6">
            <div className="space-y-2">
              <h2 className="text-xl md:text-2xl font-semibold text-foreground">Ações Rápidas</h2>
              <p className="text-sm text-muted-foreground">Acesso rápido às principais funcionalidades</p>
            </div>
            <div className="space-y-3">
              <Link href="/admin/criar-personal">
                <Button className="w-full justify-start h-12 md:h-14 text-left bg-gradient-primary hover:bg-gradient-secondary border-0 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-0.5 group touch-target">
                  <div className="flex items-center space-x-3">
                    <div className="p-1.5 bg-white/20 rounded-md group-hover:bg-white/30 transition-colors duration-300">
                      <UserPlus className="h-4 w-4 md:h-5 md:w-5 text-white" />
                    </div>
                    <div className="text-left">
                      <div className="font-medium text-white">Criar Novo Personal</div>
                      <div className="text-xs text-white/80 hidden md:block">Adicionar personal trainer</div>
                    </div>
                  </div>
                </Button>
              </Link>
              
              <Link href="/admin/convites">
                <Button className="w-full justify-start h-12 md:h-14 text-left bg-gradient-secondary hover:bg-gradient-accent border-0 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-0.5 group touch-target">
                  <div className="flex items-center space-x-3">
                    <div className="p-1.5 bg-white/20 rounded-md group-hover:bg-white/30 transition-colors duration-300">
                      <Mail className="h-4 w-4 md:h-5 md:w-5 text-white" />
                    </div>
                    <div className="text-left">
                      <div className="font-medium text-white">Gerenciar Convites</div>
                      <div className="text-xs text-white/80 hidden md:block">Enviar e acompanhar convites</div>
                    </div>
                  </div>
                </Button>
              </Link>
              
              <Link href="/exercises">
                <Button className="w-full justify-start h-12 md:h-14 text-left bg-gradient-accent hover:bg-gradient-primary border-0 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-0.5 group touch-target">
                  <div className="flex items-center space-x-3">
                    <div className="p-1.5 bg-white/20 rounded-md group-hover:bg-white/30 transition-colors duration-300">
                      <List className="h-4 w-4 md:h-5 md:w-5 text-white" />
                    </div>
                    <div className="text-left">
                      <div className="font-medium text-white">Gerenciar Exercícios</div>
                      <div className="text-xs text-white/80 hidden md:block">Biblioteca de exercícios</div>
                    </div>
                  </div>
                </Button>
              </Link>
            </div>
          </div>

          {/* Enhanced Recent Personal Trainers Table */}
          <div className="lg:col-span-2 space-y-6">
            <div className="space-y-2">
              <h2 className="text-xl md:text-2xl font-semibold text-foreground">Personais Recentes</h2>
              <p className="text-sm text-muted-foreground">Últimos personal trainers cadastrados</p>
            </div>
            <Card className="border-0 shadow-elevated bg-card/50 backdrop-blur-sm">
              <CardContent className="p-0">
                {/* Mobile-optimized table */}
                <div className="hidden md:block">
                  <Table>
                    <TableHeader>
                      <TableRow className="border-b border-border/50">
                        <TableHead className="font-semibold text-foreground/80">Nome</TableHead>
                        <TableHead className="font-semibold text-foreground/80">Email</TableHead>
                        <TableHead className="font-semibold text-foreground/80">Status</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {personaisData && personaisData.length > 0 ? (
                        personaisData.map((p, index) => (
                          <TableRow 
                            key={p._id} 
                            className="border-b border-border/30 hover:bg-muted/30 transition-colors duration-200"
                          >
                            <TableCell className="font-medium text-foreground">{p.nome}</TableCell>
                            <TableCell className="text-muted-foreground">{p.email}</TableCell>
                            <TableCell>
                              <Badge 
                                variant="outline" 
                                className="bg-green-50 text-green-700 border-green-200 dark:bg-green-950/50 dark:text-green-400 dark:border-green-900"
                              >
                                Ativo
                              </Badge>
                            </TableCell>
                          </TableRow>
                        ))
                      ) : (
                        <TableRow>
                          <TableCell colSpan={3} className="text-center text-muted-foreground py-8">
                            <div className="flex flex-col items-center space-y-2">
                              <Users className="h-8 w-8 text-muted-foreground/50" />
                              <p>Nenhum personal encontrado.</p>
                            </div>
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </div>

                {/* Mobile card layout */}
                <div className="md:hidden space-y-3 p-4">
                  {personaisData && personaisData.length > 0 ? (
                    personaisData.map((p, index) => (
                      <div 
                        key={p._id}
                        className="p-4 rounded-lg bg-gradient-subtle border border-border/30 space-y-2 animate-slide-up"
                        style={{ animationDelay: `${index * 100}ms` }}
                      >
                        <div className="flex items-center justify-between">
                          <h3 className="font-medium text-foreground">{p.nome}</h3>
                          <Badge 
                            variant="outline" 
                            className="bg-green-50 text-green-700 border-green-200 dark:bg-green-950/50 dark:text-green-400 dark:border-green-900"
                          >
                            Ativo
                          </Badge>
                        </div>
                        <p className="text-sm text-muted-foreground">{p.email}</p>
                      </div>
                    ))
                  ) : (
                    <div className="text-center py-8">
                      <div className="flex flex-col items-center space-y-2">
                        <Users className="h-8 w-8 text-muted-foreground/50" />
                        <p className="text-muted-foreground">Nenhum personal encontrado.</p>
                      </div>
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
}
===== ./client/src/pages/admin/CriarPersonalPage.tsx =====
// client/src/pages/admin/CriarPersonalPage.tsx
import { useForm, Controller } from 'react-hook-form'; // 'React' foi removido
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { useLocation } from 'wouter';
import { useMutation, useQueryClient } from '@tanstack/react-query';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { Loader2, UserPlus } from 'lucide-react';

const criarPersonalSchema = z.object({
  nome: z.string().min(3, { message: "O nome completo é obrigatório (mínimo 3 caracteres)." }),
  email: z.string().email({ message: "Por favor, insira um e-mail válido." }),
  password: z.string().min(6, { message: "A senha deve ter pelo menos 6 caracteres." }),
  role: z.enum(["Personal Trainer", "Admin"], { required_error: "A função é obrigatória." }),
});

type CriarPersonalFormData = z.infer<typeof criarPersonalSchema>;

export default function CriarPersonalPage() {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [, setLocation] = useLocation();

  const {
    control,
    handleSubmit,
    formState: { errors },
    // 'reset' foi removido daqui
  } = useForm<CriarPersonalFormData>({
    resolver: zodResolver(criarPersonalSchema),
    defaultValues: {
      nome: "",
      email: "",
      password: "",
      role: "Personal Trainer",
    },
  });

  const createPersonalMutation = useMutation<any, Error, CriarPersonalFormData>({
    mutationFn: (data) => apiRequest("POST", "/api/admin/personal-trainers", data),
    onSuccess: (novoPersonal) => {
      toast({
        title: "Sucesso!",
        description: `Usuário "${novoPersonal.nome}" (${novoPersonal.email}) criado com a função de ${novoPersonal.role}.`,
      });
      queryClient.invalidateQueries({ queryKey: ['adminPersonalTrainersList'] });
      setLocation('/admin/gerenciar-personais');
    },
    onError: (error: any) => {
      console.error("Erro ao criar Personal Trainer:", error);
      toast({
        variant: "destructive",
        title: "Erro ao Criar Usuário",
        description: error.response?.data?.mensagem || error.message || "Ocorreu um problema ao tentar criar o usuário.",
      });
    }
  });

  const onSubmit = (data: CriarPersonalFormData) => {
    createPersonalMutation.mutate(data);
  };

  return (
    <div className="container mx-auto py-10 px-4 flex flex-col items-center">
      <Card className="w-full max-w-2xl shadow-xl">
        <CardHeader className="text-center">
          <div className="flex justify-center items-center mb-3">
            <UserPlus className="h-10 w-10 text-primary" />
          </div>
          <CardTitle className="text-3xl font-bold">Criar Novo Usuário</CardTitle>
          <CardDescription className="text-md text-muted-foreground">
            Preencha os dados abaixo para adicionar um novo Personal Trainer ou Administrador ao sistema.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="nome" className="font-semibold">Nome Completo</Label>
              <Input id="nome" placeholder="Ex: João da Silva Pereira" {...control.register("nome")} />
              {errors.nome && <p className="text-sm font-medium text-destructive">{errors.nome.message}</p>}
            </div>

            <div className="space-y-2">
              <Label htmlFor="email" className="font-semibold">Endereço de E-mail</Label>
              <Input id="email" type="email" placeholder="Ex: joao.silva@example.com" {...control.register("email")} />
              {errors.email && <p className="text-sm font-medium text-destructive">{errors.email.message}</p>}
            </div>

            <div className="space-y-2">
              <Label htmlFor="password">Senha Inicial</Label>
              <Input id="password" type="password" placeholder="Mínimo 6 caracteres" {...control.register("password")} />
              {errors.password && <p className="text-sm font-medium text-destructive">{errors.password.message}</p>}
            </div>

            <div className="space-y-2">
              <Label htmlFor="role" className="font-semibold">Função (Role)</Label>
              <Controller
                name="role"
                control={control}
                render={({ field }) => (
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <SelectTrigger id="role" className="w-full">
                      <SelectValue placeholder="Selecione uma função" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="Personal Trainer">Personal Trainer</SelectItem>
                      <SelectItem value="Admin">Administrador</SelectItem>
                    </SelectContent>
                  </Select>
                )}
              />
              {errors.role && <p className="text-sm font-medium text-destructive">{errors.role.message}</p>}
            </div>

            <CardFooter className="px-0 pt-8">
              <Button type="submit" className="w-full text-lg py-6" disabled={createPersonalMutation.isPending}>
                {createPersonalMutation.isPending && <Loader2 className="mr-2 h-5 w-5 animate-spin" />}
                {createPersonalMutation.isPending ? "Criando Usuário..." : "Criar Usuário"}
              </Button>
            </CardFooter>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
===== ./client/src/pages/admin/EditarPersonalPage.tsx =====
// client/src/pages/admin/EditarPersonalPage.tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useParams, Redirect, useLocation } from 'wouter'; // Importar useLocation
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';
import { useEffect } from 'react';

import { apiRequest } from '@/lib/queryClient';
import { PersonalDetalhes } from './ListarPersonaisPage'; 
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import LoadingSpinner from '@/components/LoadingSpinner';
import ErrorMessage from '@/components/ErrorMessage';
import { UserCog } from 'lucide-react';

const personalSchema = z.object({
  nome: z.string().min(3, 'O nome deve ter pelo menos 3 caracteres.'),
  email: z.string().email('Email inválido.'),
  role: z.enum(['personal-trainer', 'admin'], { errorMap: () => ({ message: "Função inválida."}) }),
});

type PersonalFormData = z.infer<typeof personalSchema>;

export default function EditarPersonalPage() {
  const { id } = useParams<{ id: string }>();
  const [, setLocation] = useLocation(); // Pegando a função para navegar
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const { data: personal, isLoading, error, isSuccess } = useQuery<PersonalDetalhes>({
    queryKey: ['personalDetails', id],
    queryFn: () => apiRequest('GET', `/api/admin/personal-trainers/${id}`),
    enabled: !!id,
  });

  const form = useForm<PersonalFormData>({
    resolver: zodResolver(personalSchema),
    defaultValues: {
        nome: '',
        email: '',
        role: 'personal-trainer',
    }
  });

  useEffect(() => {
    if (isSuccess && personal) {
      form.reset({
        nome: personal.nome,
        email: personal.email,
        role: personal.role.toLowerCase() === 'admin' ? 'admin' : 'personal-trainer',
      });
    }
  }, [isSuccess, personal, form]);

  const updateMutation = useMutation<PersonalDetalhes, Error, PersonalFormData>({
    mutationFn: (data) => apiRequest('PUT', `/api/admin/personal-trainers/${id}`, data),
    onSuccess: (updatedData) => {
      toast({ title: "Sucesso!", description: "Dados do personal atualizados." });
      queryClient.invalidateQueries({ queryKey: ['adminPersonalTrainersList'] });
      queryClient.setQueryData(['personalDetails', id], updatedData);
      
      // =======================================================
      // --- PASSO FINAL: REDIRECIONAR APÓS O SUCESSO ---
      setLocation('/admin/gerenciar-personais');
      // =======================================================
    },
    onError: (err) => {
      toast({ variant: 'destructive', title: "Erro ao atualizar", description: err.message });
    }
  });

  const onSubmit = (data: PersonalFormData) => {
    const dataToSend = {
      ...data,
      role: data.role === 'admin' ? 'Admin' : 'Personal Trainer',
    };
    updateMutation.mutate(dataToSend as any);
  };


  if (!id) return <Redirect to="/admin/gerenciar-personais" />;
  if (isLoading) return <LoadingSpinner text="Carregando dados do personal..." />;
  if (error) return <ErrorMessage title="Erro ao carregar" message={error.message} />;
  
  return (
    <div className="container mx-auto py-8 px-4">
      <Card className="max-w-2xl mx-auto">
        <CardHeader>
          <CardTitle className="flex items-center text-2xl">
            <UserCog className="mr-3 h-7 w-7 text-primary" />
            Editar Personal
          </CardTitle>
          <CardDescription>Altere os dados de {personal?.nome}.</CardDescription>
        </CardHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)}>
            <CardContent className="space-y-6">
              <FormField
                control={form.control}
                name="nome"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Nome Completo</FormLabel>
                    <FormControl>
                      <Input placeholder="Nome do Personal" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input type="email" placeholder="email@dominio.com" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="role"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Função (Role)</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                        <FormControl>
                            <SelectTrigger>
                                <SelectValue placeholder="Selecione a função" />
                            </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                            <SelectItem value="personal-trainer">Personal Trainer</SelectItem>
                            <SelectItem value="admin">Administrador</SelectItem>
                        </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            </CardContent>
            <CardFooter className="flex justify-end">
              <Button type="submit" disabled={updateMutation.isPending}>
                {updateMutation.isPending ? "Salvando..." : "Salvar Alterações"}
              </Button>
            </CardFooter>
          </form>
        </Form>
      </Card>
    </div>
  );
}
===== ./client/src/pages/admin/GerenciarConvitesPage.tsx =====
/// <reference types="vite/client" /> 
// Localização: client/src/pages/admin/GerenciarConvitesPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  TableCaption,
} from "@/components/ui/table";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from '@/lib/queryClient';
import { Copy, Check, Trash2, RefreshCw, Loader2 } from 'lucide-react';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';

interface ConviteCriadoResponse {
  mensagem: string;
  convite: ConviteDetalhes;
  linkConvite: string;
}

interface ConviteFormData {
  emailConvidado?: string;
  diasParaExpirar?: number;
  roleConvidado?: 'Personal Trainer' | 'Admin';
}

interface ConviteDetalhes {
  _id: string;
  token: string;
  emailConvidado?: string;
  roleConvidado: 'Personal Trainer' | 'Admin';
  status: 'pendente' | 'utilizado' | 'expirado';
  dataExpiracao?: string;
  criadoPor: string;
  usadoPor?: {
    _id: string;
    nome?: string;
    email?: string;
  } | null;
  dataUtilizacao?: string;
  createdAt: string;
  updatedAt: string;
}

const GerenciarConvitesPage: React.FC = () => {
  const [formData, setFormData] = useState<ConviteFormData>({
    emailConvidado: '',
    diasParaExpirar: 7,
    roleConvidado: 'Personal Trainer',
  });
  const [linkGerado, setLinkGerado] = useState<string | null>(null);
  const [isLoadingGeracao, setIsLoadingGeracao] = useState<boolean>(false);
  const [isCopiedForm, setIsCopiedForm] = useState<boolean>(false); 
  
  const [convites, setConvites] = useState<ConviteDetalhes[]>([]);
  const [isLoadingLista, setIsLoadingLista] = useState<boolean>(false);
  const [conviteParaRevogar, setConviteParaRevogar] = useState<ConviteDetalhes | null>(null);

  const { toast } = useToast();
  const frontendBaseUrl = import.meta.env.VITE_APP_BASE_URL || window.location.origin;

  const fetchConvites = useCallback(async () => {
    setIsLoadingLista(true);
    try {
      const data = await apiRequest<ConviteDetalhes[]>('GET', '/api/admin/convites/personal');
      setConvites(data);
    } catch (error: any) {
      toast({
        title: "Erro ao Buscar Convites",
        description: error.message || "Não foi possível carregar a lista de convites.",
        variant: "destructive",
      });
    } finally {
      setIsLoadingLista(false);
    }
  }, [toast]);

  useEffect(() => {
    fetchConvites();
  }, [fetchConvites]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prevState => ({
      ...prevState,
      [name]: name === 'diasParaExpirar' ? (value === '' ? undefined : Number(value)) : value,
    }));
  };

  const handleSubmitGerarConvite = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoadingGeracao(true);
    setLinkGerado(null);
    setIsCopiedForm(false);

    try {
      const payload: any = {
        roleConvidado: formData.roleConvidado || 'Personal Trainer',
      };
      if (formData.emailConvidado && formData.emailConvidado.trim() !== '') {
        payload.emailConvidado = formData.emailConvidado.trim();
      }
      if (formData.diasParaExpirar !== undefined && formData.diasParaExpirar > 0) {
        payload.diasParaExpirar = formData.diasParaExpirar;
      }

      const response = await apiRequest<ConviteCriadoResponse>('POST', '/api/admin/convites/personal', payload);
      
      setLinkGerado(response.linkConvite);
      toast({
        title: "Sucesso!",
        description: response.mensagem || "Convite criado e link gerado.",
      });
      fetchConvites(); 
    } catch (error: any) {
      const errorMessage = error.message || "Falha ao criar convite. Tente novamente.";
      toast({
        title: "Erro ao Criar Convite",
        description: errorMessage,
        variant: "destructive",
      });
    } finally {
      setIsLoadingGeracao(false);
    }
  };

  const handleCopyToClipboardForm = () => {
    if (linkGerado) {
      navigator.clipboard.writeText(linkGerado)
        .then(() => {
          setIsCopiedForm(true);
          toast({ description: "Link copiado para a área de transferência!" });
          setTimeout(() => setIsCopiedForm(false), 2000);
        })
        // =======================================================
        // --- AVISO CORRIGIDO: Variável 'err' removida ---
        .catch(() => {
          toast({ description: "Erro ao copiar o link.", variant: "destructive" });
        });
        // =======================================================
    }
  };

  const handleRevogarConvite = async () => {
    if (!conviteParaRevogar) return;
    setIsLoadingGeracao(true); 
    try {
      await apiRequest('DELETE', `/api/admin/convites/personal/${conviteParaRevogar._id}`);
      toast({
        title: "Convite Revogado",
        description: `O convite para ${conviteParaRevogar.emailConvidado || 'convidado genérico'} foi revogado.`,
      });
      fetchConvites(); 
    } catch (error: any) {
      toast({
        title: "Erro ao Revogar Convite",
        description: error.message || "Não foi possível revogar o convite.",
        variant: "destructive",
      });
    } finally {
      setIsLoadingGeracao(false);
      setConviteParaRevogar(null); 
    }
  };

  const formatarData = (dataISO?: string) => {
    if (!dataISO) return 'N/A';
    try {
      return format(new Date(dataISO), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR });
    } catch (e) {
      return 'Data inválida';
    }
  };

  const getStatusBadge = (status: ConviteDetalhes['status']) => {
    switch (status) {
      case 'pendente':
        return <span className="px-2 py-1 text-xs font-semibold text-yellow-800 bg-yellow-100 rounded-full dark:bg-yellow-700 dark:text-yellow-100">Pendente</span>;
      case 'utilizado':
        return <span className="px-2 py-1 text-xs font-semibold text-green-800 bg-green-100 rounded-full dark:bg-green-700 dark:text-green-100">Utilizado</span>;
      case 'expirado':
        return <span className="px-2 py-1 text-xs font-semibold text-red-800 bg-red-100 rounded-full dark:bg-red-700 dark:text-red-100">Expirado</span>;
      default:
        return <span className="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 rounded-full dark:bg-gray-700 dark:text-gray-100">{status}</span>;
    }
  };

  return (
    <TooltipProvider> 
      <div className="container mx-auto p-4 md:p-6 lg:p-8 space-y-8">
        <h1 className="text-3xl font-bold text-center text-gray-800 dark:text-gray-100 mb-8">
          Gerenciamento de Convites para Personais
        </h1>

        <Card className="max-w-2xl mx-auto shadow-xl border dark:border-gray-700">
          <CardHeader>
            <CardTitle className="text-xl font-semibold text-center">Gerar Novo Convite</CardTitle>
            <CardDescription className="text-center text-sm text-muted-foreground">
              Crie um link de convite para novos personais se cadastrarem.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleSubmitGerarConvite} className="space-y-6">
              <div className="space-y-2">
                <Label htmlFor="emailConvidado">Email do Convidado (Opcional)</Label>
                <Input id="emailConvidado" name="emailConvidado" type="email" placeholder="exemplo@email.com" value={formData.emailConvidado || ''} onChange={handleChange} className="bg-background" />
                <p className="text-xs text-muted-foreground">Se preenchido, o convite será específico para este email.</p>
              </div>
              <div className="space-y-2">
                <Label htmlFor="diasParaExpirar">Validade do Convite (em dias)</Label>
                <Input id="diasParaExpirar" name="diasParaExpirar" type="number" min="1" placeholder="7" value={formData.diasParaExpirar || ''} onChange={handleChange} className="bg-background" />
                <p className="text-xs text-muted-foreground">Padrão: 7 dias. Deixe em branco para usar o padrão do servidor.</p>
              </div>
              <div className="space-y-2">
                <Label htmlFor="roleConvidado">Tipo de Usuário</Label>
                <select id="roleConvidado" name="roleConvidado" value={formData.roleConvidado || 'Personal Trainer'} onChange={handleChange} className="flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50">
                  <option value="Personal Trainer">Personal Trainer</option>
                  <option value="Admin">Administrador</option>
                </select>
              </div>
              <Button type="submit" className="w-full font-semibold" disabled={isLoadingGeracao}>
                {isLoadingGeracao ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                {isLoadingGeracao ? 'Gerando...' : 'Gerar Convite'}
              </Button>
            </form>
          </CardContent>
          {linkGerado && (
            <CardFooter className="flex flex-col items-center space-y-3 pt-5 border-t dark:border-gray-700">
              <p className="text-sm font-medium text-center">Link de Convite Gerado:</p>
              <div className="flex w-full max-w-md items-center space-x-2 p-2 border rounded-md bg-muted dark:bg-gray-800">
                <Input type="text" value={linkGerado} readOnly className="flex-grow bg-transparent border-none focus:ring-0 text-sm" />
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="ghost" size="icon" onClick={handleCopyToClipboardForm} aria-label="Copiar link gerado">
                      {isCopiedForm ? <Check className="h-5 w-5 text-green-500" /> : <Copy className="h-5 w-5" />}
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Copiar link</p>
                  </TooltipContent>
                </Tooltip>
              </div>
              <p className="text-xs text-muted-foreground text-center">Envie este link para o personal.</p>
            </CardFooter>
          )}
        </Card>

        <Card className="shadow-xl border dark:border-gray-700">
          <CardHeader className="flex flex-row items-center justify-between pb-4">
            <div>
              <CardTitle className="text-xl font-semibold">Convites Enviados</CardTitle>
              <CardDescription className="text-sm text-muted-foreground">Lista de todos os convites gerados.</CardDescription>
            </div>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button variant="outline" size="icon" onClick={fetchConvites} disabled={isLoadingLista} aria-label="Atualizar lista de convites">
                  {isLoadingLista ? <Loader2 className="h-4 w-4 animate-spin" /> : <RefreshCw className="h-4 w-4" />}
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Atualizar lista</p>
              </TooltipContent>
            </Tooltip>
          </CardHeader>
          <CardContent>
            {isLoadingLista && convites.length === 0 && (
              <div className="flex justify-center items-center py-10 text-muted-foreground">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
                <p className="ml-3 text-sm">Carregando convites...</p>
              </div>
            )}
            {!isLoadingLista && convites.length === 0 && (
              <p className="text-center text-muted-foreground py-10 text-sm">Nenhum convite encontrado.</p>
            )}
            {convites.length > 0 && (
              <div className="overflow-x-auto">
                <Table>
                  <TableCaption className="mt-4">Um total de {convites.length} convite(s) encontrado(s).</TableCaption>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="min-w-[200px]">Email Convidado</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead className="min-w-[150px]">Expira Em</TableHead>
                      <TableHead className="min-w-[200px]">Utilizado Por</TableHead>
                      <TableHead className="min-w-[200px]">Link</TableHead>
                      <TableHead className="text-right">Ações</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {convites.map((convite) => (
                      <TableRow key={convite._id}>
                        <TableCell className="font-medium text-sm">{convite.emailConvidado || <span className="italic text-gray-500 dark:text-gray-400">Qualquer email</span>}</TableCell>
                        <TableCell>{getStatusBadge(convite.status)}</TableCell>
                        <TableCell className="text-sm">{formatarData(convite.dataExpiracao)}</TableCell>
                        <TableCell className="text-sm">
                          {convite.usadoPor ? 
                            `${convite.usadoPor.nome || 'Nome não disp.'} (${convite.usadoPor.email || 'Email não disp.'})` : 
                            <span className="italic text-gray-500 dark:text-gray-400">Ninguém</span>
                          }
                        </TableCell>
                        <TableCell>
                          <div className="flex items-center">
                            <Input 
                              type="text" 
                              value={`${frontendBaseUrl}/cadastrar-personal/convite/${convite.token}`} 
                              readOnly 
                              className="text-xs p-1 h-8 bg-transparent border-none focus:ring-0 mr-1 truncate flex-grow"
                              title={`${frontendBaseUrl}/cadastrar-personal/convite/${convite.token}`}
                            />
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <Button 
                                  variant="ghost" 
                                  size="icon" 
                                  className="h-8 w-8"
                                  onClick={() => navigator.clipboard.writeText(`${frontendBaseUrl}/cadastrar-personal/convite/${convite.token}`).then(() => toast({description: "Link do convite copiado!"}))}
                                  aria-label="Copiar link do convite"
                                >
                                  <Copy className="h-4 w-4" />
                                </Button>
                              </TooltipTrigger>
                              <TooltipContent><p>Copiar link</p></TooltipContent>
                            </Tooltip>
                          </div>
                        </TableCell>
                        <TableCell className="text-right">
                          {convite.status === 'pendente' && (
                            <AlertDialog>
                              <AlertDialogTrigger asChild>
                                <Button variant="destructive" size="sm" onClick={() => setConviteParaRevogar(convite)}>
                                  <Trash2 className="h-4 w-4 mr-1" />
                                  Revogar
                                </Button>
                              </AlertDialogTrigger>
                              <AlertDialogContent>
                                <AlertDialogHeader>
                                  <AlertDialogTitle>Confirmar Revogação</AlertDialogTitle>
                                  <AlertDialogDescription>
                                    Tem certeza que deseja revogar este convite? Esta ação não poderá ser desfeita.
                                    {conviteParaRevogar?.emailConvidado && ` O convite para ${conviteParaRevogar.emailConvidado} será invalidado.`}
                                  </AlertDialogDescription>
                                </AlertDialogHeader>
                                <AlertDialogFooter>
                                  <AlertDialogCancel onClick={() => setConviteParaRevogar(null)}>Cancelar</AlertDialogCancel>
                                  <AlertDialogAction onClick={handleRevogarConvite} disabled={isLoadingGeracao} className="bg-destructive hover:bg-destructive/90">
                                    {isLoadingGeracao ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                                    Revogar
                                  </AlertDialogAction>
                                </AlertDialogFooter>
                              </AlertDialogContent>
                            </AlertDialog>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </TooltipProvider>
  );
};

export default GerenciarConvitesPage;
===== ./client/src/pages/admin/GerenciarPlanosPersonalPage.tsx =====
// client/src/pages/admin/EnhancedGerenciarPlanosPersonalPage.tsx
import { useState, useEffect } from 'react';
import { Card, CardContent } from '../../components/ui/card';
import { Button } from '../../components/ui/button';
import { Input } from '../../components/ui/input';
import { Alert, AlertDescription } from '../../components/ui/alert';
import { Search, RefreshCw, Mail, User, AlertCircle, CheckCircle, Clock, Users, Trophy, Zap, Calendar, X } from 'lucide-react';
import { PlanoModal } from '../../components/dialogs/admin/PlanoModal';
import { PersonalTrainerWithStatus, AssignPlanForm, AddTokensForm } from '../../../../shared/types/planos';
import { usePersonalTrainers } from '../../hooks/usePersonalTrainers';
import { Badge } from '../../components/ui/badge';

export function GerenciarPlanosPersonalPage() {
    // Use the enhanced custom hook for centralized state management
    const {
        personalTrainers,
        planos,
        loading,
        error,
        lastUpdated,
        fetchData,
        assignPlan,
        addTokens,
        clearError,
        getPlanNameById,
        getPlanById,
    } = usePersonalTrainers();

    // Local UI state
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedPersonal, setSelectedPersonal] = useState<PersonalTrainerWithStatus | null>(null);
    const [modalOpen, setModalOpen] = useState(false);

    useEffect(() => {
        // Load initial data
        fetchData();
        
        // Add keyboard shortcut for manual refresh (F5 or Ctrl+R)
        const handleKeyPress = (event: KeyboardEvent) => {
            if (event.key === 'F5' || (event.ctrlKey && event.key === 'r')) {
                event.preventDefault();
                console.log('🔄 Manual refresh detected - reloading data...');
                fetchData();
            }
        };

        window.addEventListener('keydown', handleKeyPress);
        
        return () => {
            window.removeEventListener('keydown', handleKeyPress);
        };
    }, [fetchData]);

    const handleAssignPlan = async (personalId: string, data: AssignPlanForm) => {
        try {
            await assignPlan(personalId, data);
            
            // Close modal after successful operation
            setModalOpen(false);
            setSelectedPersonal(null);
        } catch (error) {
            // Error handling is done in the hook, just keep modal open for retry
            console.error('❌ Error in handleAssignPlan:', error);
        }
    };

    const handleAddTokens = async (personalId: string, data: AddTokensForm) => {
        try {
            await addTokens(personalId, data);
            
            // Close modal after successful operation
            setModalOpen(false);
            setSelectedPersonal(null);
        } catch (error) {
            // Error handling is done in the hook, just keep modal open for retry
            console.error('❌ Error in handleAddTokens:', error);
        }
    };

    const openModal = (personal: PersonalTrainerWithStatus) => {
        setSelectedPersonal(personal);
        setModalOpen(true);
    };

    const filteredPersonals = personalTrainers.filter(personal =>
        personal.nome.toLowerCase().includes(searchTerm.toLowerCase()) ||
        personal.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
        getPlanNameById(personal.planoId).toLowerCase().includes(searchTerm.toLowerCase())
    );

    const getStatusIcon = (percentual: number) => {
        if (percentual >= 90) return <AlertCircle className="w-4 h-4 text-red-500" />;
        if (percentual >= 70) return <Clock className="w-4 h-4 text-yellow-500" />;
        return <CheckCircle className="w-4 h-4 text-green-500" />;
    };

    const getStatusColor = (percentual: number) => {
        if (percentual >= 90) return 'bg-red-500';
        if (percentual >= 70) return 'bg-yellow-500';
        return 'bg-green-500';
    };

    const getStatusText = (percentual: number) => {
        if (percentual >= 90) return 'Crítico';
        if (percentual >= 70) return 'Atenção';
        return 'Normal';
    };

    const getPlanBadgeVariant = (planName: string, isExpired: boolean) => {
        if (isExpired) return 'destructive';
        if (planName === 'Sem plano') return 'outline';
        if (planName === 'Free') return 'secondary';
        return 'default';
    };

    const getCardClasses = (isExpired: boolean) => {
        if (isExpired) {
            return "group hover:shadow-xl transition-all duration-300 hover:-translate-y-1 border-red-300 bg-gradient-to-br from-red-50 to-red-100/50 relative overflow-hidden";
        }
        return "group hover:shadow-xl transition-all duration-300 hover:-translate-y-1 border-gray-200 bg-gradient-to-br from-white to-blue-50/30 relative overflow-hidden";
    };

    const getStatusIndicatorColor = (percentual: number, isExpired: boolean) => {
        if (isExpired) return 'bg-red-500';
        if (percentual >= 90) return 'bg-red-500';
        if (percentual >= 70) return 'bg-yellow-500';
        return 'bg-green-500';
    };

    // Statistics
    const stats = {
        total: personalTrainers.length,
        withPlans: personalTrainers.filter(p => p.hasActivePlan).length,
        expired: personalTrainers.filter(p => p.isExpired).length,
        critical: personalTrainers.filter(p => p.percentualUso >= 90 && !p.isExpired).length,
        warning: personalTrainers.filter(p => p.percentualUso >= 70 && p.percentualUso < 90 && !p.isExpired).length,
    };

    if (loading && personalTrainers.length === 0) {
        return (
            <div className="container mx-auto p-6">
                <div className="flex items-center justify-center h-64">
                    <div className="text-center">
                        <div className="w-8 h-8 border-4 border-blue-600 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                        <p className="text-lg font-medium">Carregando dados...</p>
                        <p className="text-sm text-gray-500 mt-1">Buscando personal trainers e planos</p>
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className="container mx-auto p-6 space-y-8">
            {/* Header */}
            <div className="flex items-center justify-between">
                <div>
                    <h1 className="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
                        Gerenciar Planos
                    </h1>
                    <p className="text-gray-600 mt-2">
                        Gerencie os planos dos personal trainers de forma simples e moderna
                    </p>
                    {lastUpdated && (
                        <p className="text-xs text-gray-400 mt-1">
                            Última atualização: {lastUpdated.toLocaleTimeString('pt-BR')}
                        </p>
                    )}
                </div>
                <Button
                    variant="outline"
                    onClick={fetchData}
                    disabled={loading}
                    className="flex items-center gap-2 hover:bg-blue-50 border-blue-200"
                >
                    <RefreshCw className={`w-4 h-4 ${loading ? 'animate-spin' : ''}`} />
                    {loading ? 'Atualizando...' : 'Atualizar'}
                </Button>
            </div>

            {/* Error Alert */}
            {error && (
                <Alert variant="destructive">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription className="flex items-center justify-between">
                        <span>{error}</span>
                        <Button variant="outline" size="sm" onClick={clearError}>
                            Dismiss
                        </Button>
                    </AlertDescription>
                </Alert>
            )}

            {/* Statistics Cards */}
            <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
                <Card className="border-blue-200 bg-gradient-to-br from-blue-50 to-blue-100">
                    <CardContent className="pt-6">
                        <div className="flex items-center justify-between">
                            <div>
                                <p className="text-sm font-medium text-blue-600">Total</p>
                                <p className="text-2xl font-bold text-blue-800">{stats.total}</p>
                            </div>
                            <Users className="w-8 h-8 text-blue-600" />
                        </div>
                    </CardContent>
                </Card>

                <Card className="border-green-200 bg-gradient-to-br from-green-50 to-green-100">
                    <CardContent className="pt-6">
                        <div className="flex items-center justify-between">
                            <div>
                                <p className="text-sm font-medium text-green-600">Com Planos</p>
                                <p className="text-2xl font-bold text-green-800">{stats.withPlans}</p>
                            </div>
                            <Trophy className="w-8 h-8 text-green-600" />
                        </div>
                    </CardContent>
                </Card>

                <Card className="border-red-200 bg-gradient-to-br from-red-50 to-red-100">
                    <CardContent className="pt-6">
                        <div className="flex items-center justify-between">
                            <div>
                                <p className="text-sm font-medium text-red-600">Expirados</p>
                                <p className="text-2xl font-bold text-red-800">{stats.expired}</p>
                            </div>
                            <Calendar className="w-8 h-8 text-red-600" />
                        </div>
                    </CardContent>
                </Card>

                <Card className="border-yellow-200 bg-gradient-to-br from-yellow-50 to-yellow-100">
                    <CardContent className="pt-6">
                        <div className="flex items-center justify-between">
                            <div>
                                <p className="text-sm font-medium text-yellow-600">Atenção</p>
                                <p className="text-2xl font-bold text-yellow-800">{stats.warning}</p>
                            </div>
                            <Clock className="w-8 h-8 text-yellow-600" />
                        </div>
                    </CardContent>
                </Card>

                <Card className="border-orange-200 bg-gradient-to-br from-orange-50 to-orange-100">
                    <CardContent className="pt-6">
                        <div className="flex items-center justify-between">
                            <div>
                                <p className="text-sm font-medium text-orange-600">Crítico</p>
                                <p className="text-2xl font-bold text-orange-800">{stats.critical}</p>
                            </div>
                            <AlertCircle className="w-8 h-8 text-orange-600" />
                        </div>
                    </CardContent>
                </Card>
            </div>

            {/* Search */}
            <Card className="border-blue-100 shadow-sm">
                <CardContent className="pt-6">
                    <div className="relative">
                        <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-blue-400 w-4 h-4" />
                        <Input
                            placeholder="Buscar por nome, email ou plano..."
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            className="pl-10 border-blue-200 focus:border-blue-400 focus:ring-blue-400"
                        />
                    </div>
                </CardContent>
            </Card>

            {/* Personal Trainers Grid */}
            <div className="space-y-4">
                <div className="flex items-center justify-between">
                    <h2 className="text-xl font-semibold text-gray-800">
                        Personal Trainers ({filteredPersonals.length})
                    </h2>
                    {searchTerm && (
                        <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => setSearchTerm('')}
                            className="text-gray-500 hover:text-gray-700"
                        >
                            Limpar filtro
                        </Button>
                    )}
                </div>

                {filteredPersonals.length === 0 ? (
                    <Card className="border-gray-200">
                        <CardContent className="py-16">
                            <div className="text-center text-gray-500">
                                <User className="w-12 h-12 mx-auto mb-4 text-gray-300" />
                                <p className="text-lg font-medium mb-2">
                                    {searchTerm ? 'Nenhum personal encontrado' : 'Nenhum personal trainer cadastrado'}
                                </p>
                                <p className="text-sm">
                                    {searchTerm ? 'Tente ajustar sua busca.' : 'Quando você adicionar personal trainers, eles aparecerão aqui.'}
                                </p>
                            </div>
                        </CardContent>
                    </Card>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                        {filteredPersonals.map((personal) => {
                            const planName = getPlanNameById(personal.planoId);
                            const plan = getPlanById(personal.planoId);
                            
                            return (
                                <Card 
                                    key={personal._id} 
                                    className={getCardClasses(personal.isExpired)}
                                >
                                    {/* Status indicator - red for expired plans */}
                                    <div className={`absolute top-0 left-0 w-full h-1 ${getStatusIndicatorColor(personal.percentualUso, personal.isExpired)}`} />
                                    
                                    <CardContent className="p-6">
                                        <div className="space-y-4">
                                            {/* Header with avatar and name */}
                                            <div className="flex items-center gap-3">
                                                <div className={`w-12 h-12 rounded-full flex items-center justify-center text-white font-semibold text-lg ${
                                                    personal.isExpired 
                                                        ? 'bg-gradient-to-br from-red-500 to-red-700' 
                                                        : 'bg-gradient-to-br from-blue-500 to-purple-600'
                                                }`}>
                                                    {personal.nome.charAt(0).toUpperCase()}
                                                </div>
                                                <div className="flex-1">
                                                    <h3 className={`font-semibold text-lg transition-colors ${
                                                        personal.isExpired 
                                                            ? 'text-red-800 group-hover:text-red-900' 
                                                            : 'text-gray-800 group-hover:text-blue-600'
                                                    }`}>
                                                        {personal.nome}
                                                    </h3>
                                                    <div className="flex items-center gap-2 mt-1">
                                                        <Mail className="w-3 h-3 text-gray-400" />
                                                        <span className="text-xs text-gray-500 truncate">{personal.email}</span>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Expired Plan Badge */}
                                            {personal.isExpired && (
                                                <div className="flex items-center gap-2 p-3 bg-red-100 border border-red-300 rounded-lg">
                                                    <X className="w-4 h-4 text-red-600" />
                                                    <div className="flex-1">
                                                        <p className="text-sm font-medium text-red-800">Plano Expirado</p>
                                                        {personal.dataVencimento && (
                                                            <p className="text-xs text-red-600">
                                                                Venceu em: {new Date(personal.dataVencimento).toLocaleDateString('pt-BR')}
                                                            </p>
                                                        )}
                                                    </div>
                                                </div>
                                            )}

                                            {/* Plan Information */}
                                            <div className="space-y-3">
                                                <div className="flex items-center justify-between">
                                                    <span className="text-sm text-gray-600">Plano Atual</span>
                                                    <Badge variant={getPlanBadgeVariant(planName, personal.isExpired)} className="text-xs">
                                                        {planName}
                                                    </Badge>
                                                </div>
                                                
                                                {plan && (
                                                    <div className="text-xs text-gray-500 grid grid-cols-2 gap-2">
                                                        <div>Limite: {plan.limiteAlunos}</div>
                                                        <div>Preço: R$ {plan.preco.toFixed(2)}</div>
                                                    </div>
                                                )}

                                                {/* Plan Dates for Expired Plans */}
                                                {personal.isExpired && personal.dataInicio && personal.dataVencimento && (
                                                    <div className="text-xs text-gray-500 grid grid-cols-2 gap-2 pt-2 border-t border-gray-200">
                                                        <div>
                                                            <span className="text-gray-400">Início:</span><br/>
                                                            {new Date(personal.dataInicio).toLocaleDateString('pt-BR')}
                                                        </div>
                                                        <div>
                                                            <span className="text-gray-400">Fim:</span><br/>
                                                            {new Date(personal.dataVencimento).toLocaleDateString('pt-BR')}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>

                                            {/* Usage Stats */}
                                            <div className="space-y-3">
                                                <div className="flex items-center justify-between text-sm">
                                                    <div className="flex items-center gap-2">
                                                        <Users className="w-4 h-4 text-blue-500" />
                                                        <span className="text-gray-600">Alunos</span>
                                                    </div>
                                                    <span className="font-medium">
                                                        {personal.alunosAtivos}/{personal.limiteAlunos}
                                                    </span>
                                                </div>

                                                <div className="space-y-2">
                                                    <div className="flex items-center justify-between text-sm">
                                                        <div className="flex items-center gap-2">
                                                            {getStatusIcon(personal.percentualUso)}
                                                            <span className="text-gray-600">Status</span>
                                                        </div>
                                                        <span className="font-medium">
                                                            {personal.isExpired ? 'Expirado' : `${personal.percentualUso}%`}
                                                        </span>
                                                    </div>
                                                    
                                                    <div className="w-full bg-gray-200 rounded-full h-2">
                                                        <div 
                                                            className={`h-2 rounded-full transition-all duration-300 ${getStatusIndicatorColor(personal.percentualUso, personal.isExpired)}`}
                                                            style={{ 
                                                                width: personal.isExpired ? '100%' : `${Math.min(personal.percentualUso, 100)}%` 
                                                            }}
                                                        />
                                                    </div>
                                                    
                                                    <div className="flex justify-between text-xs text-gray-500">
                                                        <span>0</span>
                                                        <span className="font-medium">
                                                            {personal.isExpired ? 'Expirado' : getStatusText(personal.percentualUso)}
                                                        </span>
                                                        <span>{personal.isExpired ? 'Renovar' : '100%'}</span>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            {/* Action Button */}
                                            <div className="pt-2">
                                                <Button
                                                    onClick={() => openModal(personal)}
                                                    className={`w-full border-0 shadow-md hover:shadow-lg transition-all duration-200 ${
                                                        personal.isExpired
                                                            ? 'bg-gradient-to-r from-red-500 to-red-700 hover:from-red-600 hover:to-red-800 text-white'
                                                            : 'bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white'
                                                    }`}
                                                    size="sm"
                                                >
                                                    <Zap className="w-4 h-4 mr-2" />
                                                    {personal.isExpired ? 'Renovar Plano' : 'Gerenciar Plano'}
                                                </Button>
                                            </div>
                                        </div>
                                    </CardContent>
                                </Card>
                            );
                        })}
                    </div>
                )}
            </div>

            {/* Enhanced Modal */}
            <PlanoModal
                isOpen={modalOpen}
                onClose={() => setModalOpen(false)}
                personal={selectedPersonal}
                planos={planos}
                onAssignPlan={handleAssignPlan}
                onAddTokens={handleAddTokens}
                getPlanNameById={getPlanNameById}
                getPlanById={getPlanById}
            />
        </div>
    );
}

export default GerenciarPlanosPersonalPage;
===== ./client/src/pages/admin/ListarPersonaisPage.tsx =====
// client/src/pages/admin/ListarPersonaisPage.tsx
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { MoreHorizontal, Trash2, Edit, Eye, Loader2, ShieldCheck, UserPlus, Users, UserCheck, Activity, TrendingUp, Calendar, Star } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/hooks/use-toast';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import LoadingSpinner from '@/components/LoadingSpinner';
import ErrorMessage from '@/components/ErrorMessage';
import { Link, useLocation } from 'wouter';
import VisualizarPersonalModal from '@/components/dialogs/admin/VisualizarPersonalModal';
// <<< INÍCIO DA CORREÇÃO: Tipos importados do local compartilhado para garantir consistência >>>
import { PersonalDetalhes, PersonalListadoItem, AlunoParaModal } from '@shared/types/personal';
// <<< FIM DA CORREÇÃO >>>

export default function ListarPersonaisPage() {
  const [, setLocation] = useLocation();
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [personalParaExcluir, setPersonalParaExcluir] = useState<PersonalListadoItem | null>(null);
  const [isConfirmDeleteOpen, setIsConfirmDeleteOpen] = useState(false);

  const [isViewModalOpen, setIsViewModalOpen] = useState(false);
  const [personalParaVisualizar, setPersonalParaVisualizar] = useState<PersonalDetalhes | null>(null);
  const [isLoadingPersonalDetails, setIsLoadingPersonalDetails] = useState(false);

  const { data: personais, isLoading, error: queryError } = useQuery<PersonalListadoItem[], Error>({
    queryKey: ['adminPersonalTrainersList'],
    queryFn: () => apiRequest<PersonalListadoItem[]>("GET", "/api/admin/personal-trainers"),
    staleTime: 1000 * 60 * 5, // Cache de 5 minutos
    refetchOnWindowFocus: true,
  });

  const statistics = {
    total: personais?.length || 0,
    admins: personais?.filter(p => (p.role?.toLowerCase() ?? '') === 'admin').length || 0,
    personals: personais?.filter(p => (p.role?.toLowerCase() ?? '') === 'personal trainer').length || 0,
    recent: personais?.filter(p => {
      const createdDate = new Date(p.createdAt);
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      return createdDate >= thirtyDaysAgo;
    }).length || 0,
  };

  const deletePersonalMutation = useMutation<any, Error, string>({
    mutationFn: (personalId: string) => apiRequest("DELETE", `/api/admin/personal-trainers/${personalId}`),
    onSuccess: (data) => {
      toast({ title: "Sucesso!", description: data.mensagem || "Personal trainer excluído." });
      queryClient.invalidateQueries({ queryKey: ['adminPersonalTrainersList'] });
    },
    onError: (err) => {
      toast({ variant: "destructive", title: "Erro ao Excluir", description: err.message || "Não foi possível excluir o personal trainer." });
    },
    onSettled: () => {
      setPersonalParaExcluir(null);
      setIsConfirmDeleteOpen(false);
    }
  });

  const handleExcluirClick = (personal: PersonalListadoItem) => {
    setPersonalParaExcluir(personal);
    setIsConfirmDeleteOpen(true);
  };

  const confirmarExclusao = () => {
    if (personalParaExcluir) {
      deletePersonalMutation.mutate(personalParaExcluir._id);
    }
  };

  const handleVisualizarClick = async (personalId: string) => {
    setIsLoadingPersonalDetails(true);
    setPersonalParaVisualizar(null); 
    setIsViewModalOpen(true);
    try {
      // <<< INÍCIO DA CORREÇÃO: Normaliza os dados da API para corresponder ao tipo esperado pelo modal >>>
      const data: any = await apiRequest("GET", `/api/admin/personal-trainers/${personalId}`);
      
      const normalized: PersonalDetalhes = {
        ...data,
        role: (data?.role?.toLowerCase?.() === 'admin' ? 'Admin' : 'Personal Trainer'),
        alunos: (data?.alunos ?? []) as AlunoParaModal[],
      };
      
      setPersonalParaVisualizar(normalized);
      // <<< FIM DA CORREÇÃO >>>
    } catch (err: any) {
      toast({ variant: "destructive", title: "Erro ao buscar detalhes", description: err.message || "Não foi possível carregar os dados do personal." });
      setIsViewModalOpen(false);
    } finally {
      setIsLoadingPersonalDetails(false);
    }
  };

  const handleModalClose = () => {
    setIsViewModalOpen(false);
    setPersonalParaVisualizar(null);
    queryClient.invalidateQueries({ queryKey: ['adminPersonalTrainersList'] });
  };

  if (isLoading) return <LoadingSpinner text="Carregando lista de personais..." />;
  if (queryError) return <ErrorMessage title="Erro ao Carregar Personais" message={queryError?.message || "Não foi possível buscar a lista."} />;

  return (
    <div className="min-h-screen bg-gradient-subtle">
      <div className="container mx-auto py-6 px-4 md:py-8 lg:px-6 space-y-8">
        <div className="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
          <div className="space-y-2">
            <h1 className="text-3xl md:text-4xl lg:text-5xl font-bold bg-gradient-primary bg-clip-text text-transparent animate-fade-in">
              Gerenciar Personais
            </h1>
            <p className="text-base md:text-lg text-muted-foreground">
              Administre personal trainers e monitore estatísticas
            </p>
          </div>
          <Link href="/admin/criar-personal">
            <Button className="w-full sm:w-auto h-12 md:h-14 bg-gradient-primary hover:bg-gradient-secondary border-0 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-0.5 group touch-target animate-slide-up">
              <div className="flex items-center space-x-2">
                <div className="p-1 bg-white/20 rounded-md group-hover:bg-white/30 transition-colors duration-300">
                  <UserPlus className="h-4 w-4 md:h-5 md:w-5 text-white" />
                </div>
                <span className="text-white font-medium">Criar Novo Personal</span>
              </div>
            </Button>
          </Link>
        </div>

        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
            <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-blue-950/50 dark:to-indigo-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up">
                <div className="absolute inset-0 bg-gradient-primary opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
                    <CardTitle className="text-sm font-medium text-foreground/80">Total de Usuários</CardTitle>
                    <div className="p-2 bg-blue-500/10 rounded-lg group-hover:bg-blue-500/20 transition-colors duration-300">
                        <Users className="h-5 w-5 text-blue-600 dark:text-blue-400" />
                    </div>
                </CardHeader>
                <CardContent className="space-y-2">
                    <div className="text-2xl md:text-3xl font-bold text-foreground">{statistics.total}</div>
                    <div className="flex items-center space-x-1">
                        <TrendingUp className="h-3 w-3 text-blue-500" />
                        <p className="text-xs text-muted-foreground">Usuários cadastrados</p>
                    </div>
                </CardContent>
            </Card>

            <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-green-50 to-emerald-100 dark:from-green-950/50 dark:to-emerald-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up [animation-delay:100ms]">
                <div className="absolute inset-0 bg-gradient-secondary opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
                    <CardTitle className="text-sm font-medium text-foreground/80">Personal Trainers</CardTitle>
                    <div className="p-2 bg-green-500/10 rounded-lg group-hover:bg-green-500/20 transition-colors duration-300">
                        <UserCheck className="h-5 w-5 text-green-600 dark:text-green-400" />
                    </div>
                </CardHeader>
                <CardContent className="space-y-2">
                    <div className="text-2xl md:text-3xl font-bold text-foreground">{statistics.personals}</div>
                    <div className="flex items-center space-x-1">
                        <Star className="h-3 w-3 text-green-500" />
                        <p className="text-xs text-muted-foreground">Profissionais ativos</p>
                    </div>
                </CardContent>
            </Card>

            <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-orange-50 to-red-100 dark:from-orange-950/50 dark:to-red-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up [animation-delay:200ms]">
                <div className="absolute inset-0 bg-gradient-accent opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
                    <CardTitle className="text-sm font-medium text-foreground/80">Administradores</CardTitle>
                    <div className="p-2 bg-orange-500/10 rounded-lg group-hover:bg-orange-500/20 transition-colors duration-300">
                        <ShieldCheck className="h-5 w-5 text-orange-600 dark:text-orange-400" />
                    </div>
                </CardHeader>
                <CardContent className="space-y-2">
                    <div className="text-2xl md:text-3xl font-bold text-foreground">{statistics.admins}</div>
                    <div className="flex items-center space-x-1">
                        <Activity className="h-3 w-3 text-orange-500" />
                        <p className="text-xs text-muted-foreground">Usuários admin</p>
                    </div>
                </CardContent>
            </Card>

            <Card className="group relative overflow-hidden border-0 bg-gradient-to-br from-purple-50 to-violet-100 dark:from-purple-950/50 dark:to-violet-950/50 shadow-elevated hover:shadow-glass transition-all duration-300 hover:-translate-y-1 animate-slide-up [animation-delay:300ms]">
                <div className="absolute inset-0 bg-gradient-primary opacity-0 group-hover:opacity-5 transition-opacity duration-300"></div>
                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-3">
                    <CardTitle className="text-sm font-medium text-foreground/80">Novos (30 dias)</CardTitle>
                    <div className="p-2 bg-purple-500/10 rounded-lg group-hover:bg-purple-500/20 transition-colors duration-300">
                        <Calendar className="h-5 w-5 text-purple-600 dark:text-purple-400" />
                    </div>
                </CardHeader>
                <CardContent className="space-y-2">
                    <div className="text-2xl md:text-3xl font-bold text-foreground">{statistics.recent}</div>
                    <div className="flex items-center space-x-1">
                        <TrendingUp className="h-3 w-3 text-purple-500" />
                        <p className="text-xs text-muted-foreground">Cadastros recentes</p>
                    </div>
                </CardContent>
            </Card>
        </div>

        {personais && personais.length > 0 ? (
          <Card className="border-0 shadow-elevated hover:shadow-glass transition-all duration-300 overflow-hidden">
            <Table>
              <TableHeader className="bg-gradient-to-r from-gray-50 to-gray-100 dark:from-gray-800 dark:to-gray-850">
                <TableRow className="border-b-2 border-gray-200 dark:border-gray-700">
                  <TableHead className="w-[250px] font-semibold text-gray-700 dark:text-gray-300 py-4">Nome</TableHead>
                  <TableHead className="font-semibold text-gray-700 dark:text-gray-300">Email</TableHead>
                  <TableHead className="font-semibold text-gray-700 dark:text-gray-300">Função (Role)</TableHead>
                  <TableHead className="font-semibold text-gray-700 dark:text-gray-300">Data de Criação</TableHead>
                  <TableHead className="text-right font-semibold text-gray-700 dark:text-gray-300">Ações</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {personais.map((personal) => (
                  <TableRow key={personal._id} className="dark:border-gray-700 hover:bg-gradient-to-r hover:from-gray-50/50 hover:to-transparent dark:hover:from-gray-700/30 dark:hover:to-transparent transition-all duration-200 group">
                    <TableCell className="font-medium text-gray-900 dark:text-gray-100 py-4">{personal.nome || 'Nome não informado'}</TableCell>
                    <TableCell className="text-gray-600 dark:text-gray-300">{personal.email || 'Email não informado'}</TableCell>
                    <TableCell>
                      <Badge variant={(personal.role?.toLowerCase() ?? '') === 'admin' ? 'destructive' : 'outline'}
                             className={`font-medium transition-all duration-200 ${(personal.role?.toLowerCase() ?? '') === 'admin' ? 
                                        'border-red-500 text-red-600 bg-red-100 dark:bg-red-900/60 dark:text-red-300 dark:border-red-700 hover:bg-red-200 dark:hover:bg-red-900/80' : 
                                        'border-blue-500 text-blue-600 bg-blue-100 dark:bg-sky-900/60 dark:text-sky-300 dark:border-sky-700 hover:bg-blue-200 dark:hover:bg-sky-900/80'}`}>
                          {(personal.role?.toLowerCase() ?? '') === 'admin' && <ShieldCheck className="mr-1.5 h-3.5 w-3.5" />}
                          {personal.role || 'Não definido'}
                      </Badge>
                    </TableCell>
                    <TableCell className="text-gray-600 dark:text-gray-300">
                      {new Date(personal.createdAt).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' })}
                    </TableCell>
                    <TableCell className="text-right">
                      <Popover>
                        <PopoverTrigger asChild>
                          <Button variant="ghost" className="h-8 w-8 p-0 opacity-70 group-hover:opacity-100 transition-opacity duration-200 hover:bg-gray-100 dark:hover:bg-gray-700">
                            <span className="sr-only">Abrir menu</span>
                            <MoreHorizontal className="h-4 w-4" />
                          </Button>
                        </PopoverTrigger>
                        <PopoverContent className="w-40 p-1">
                          <div className="flex flex-col space-y-1">
                              <Button variant="ghost" className="w-full justify-start text-sm hover:bg-blue-50 dark:hover:bg-blue-900/50 transition-colors duration-200" onClick={() => handleVisualizarClick(personal._id)}>
                                  <Eye className="mr-2 h-4 w-4 text-blue-600 dark:text-blue-400" /> Visualizar
                              </Button>
                              <Button variant="ghost" className="w-full justify-start text-sm hover:bg-green-50 dark:hover:bg-green-900/50 transition-colors duration-200" onClick={() => setLocation(`/admin/personais/editar/${personal._id}`)}>
                                  <Edit className="mr-2 h-4 w-4 text-green-600 dark:text-green-400" /> Editar
                              </Button>
                              <div className="border-t my-1"></div>
                              <Button variant="ghost" className="w-full justify-start text-sm text-red-600 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900/50 transition-colors duration-200" onClick={() => handleExcluirClick(personal)} disabled={deletePersonalMutation.isPending && personalParaExcluir?._id === personal._id}>
                                  {deletePersonalMutation.isPending && personalParaExcluir?._id === personal._id ? (
                                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                                  ) : (
                                      <Trash2 className="mr-2 h-4 w-4" />
                                  )}
                                  Excluir
                              </Button>
                          </div>
                        </PopoverContent>
                      </Popover>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </Card>
        ) : (
          <Card className="border-0 shadow-elevated">
            <CardContent className="py-16 text-center space-y-4">
              <div className="mx-auto w-16 h-16 bg-gradient-to-br from-gray-100 to-gray-200 dark:from-gray-800 dark:to-gray-700 rounded-full flex items-center justify-center">
                <Users className="h-8 w-8 text-gray-400" />
              </div>
              <div className="space-y-2">
                <h3 className="text-lg font-semibold text-foreground">Nenhum personal encontrado</h3>
                <p className="text-sm text-muted-foreground">Começe criando um novo personal trainer</p>
              </div>
              <Link href="/admin/criar-personal">
                <Button className="mt-4 bg-gradient-primary hover:bg-gradient-secondary transition-all duration-300">
                  <UserPlus className="mr-2 h-4 w-4" />
                  Criar Primeiro Personal
                </Button>
              </Link>
            </CardContent>
          </Card>
        )}

        <AlertDialog open={isConfirmDeleteOpen} onOpenChange={setIsConfirmDeleteOpen}>
          <AlertDialogContent className="border-0 shadow-glass">
            <AlertDialogHeader>
              <AlertDialogTitle className="text-xl font-semibold text-foreground">Confirmar Exclusão</AlertDialogTitle>
              <AlertDialogDescription className="text-base text-muted-foreground">
                Tem certeza que deseja excluir o personal trainer <span className="font-semibold">"{personalParaExcluir?.nome}"</span> ({personalParaExcluir?.email})? 
                <br />
                <span className="text-red-600 dark:text-red-400">Esta ação não pode ser desfeita.</span>
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter className="gap-3">
              <AlertDialogCancel 
                onClick={() => setIsConfirmDeleteOpen(false)} 
                disabled={deletePersonalMutation.isPending}
                className="touch-target"
              >
                Cancelar
              </AlertDialogCancel>
              <AlertDialogAction
                onClick={confirmarExclusao}
                disabled={deletePersonalMutation.isPending}
                className="bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 touch-target border-0 shadow-elevated hover:shadow-glass transition-all duration-300"
              >
                {deletePersonalMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Confirmar Exclusão
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        <VisualizarPersonalModal
          isOpen={isViewModalOpen}
          onClose={handleModalClose}
          personal={personalParaVisualizar}
          isLoading={isLoadingPersonalDetails}
          alunosDoPersonal={personalParaVisualizar?.alunos || []}
        />
      </div>
    </div>
  );
}
===== ./client/src/pages/admin/renewal-requests.tsx =====
// client/src/pages/admin/renewal-requests.tsx
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { fetchWithAuth, apiRequest } from "@/lib/apiClient";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/hooks/use-toast";
import { Download, Loader2, FileText } from "lucide-react";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";
import { Badge } from "@/components/ui/badge";
import { Label } from "@/components/ui/label";
// <<< CORREÇÃO: O import do Alert foi removido pois não estava sendo usado >>>

// --- Tipos de Dados e Constantes (Definidos localmente para este arquivo) ---

export const RStatus = {
  REQUESTED: 'requested',
  LINK_SENT: 'link_sent',
  PROOF_SUBMITTED: 'proof_submitted',
  APPROVED: 'approved',
  REJECTED: 'rejected',
  FULFILLED: 'fulfilled',
  CYCLE_ASSIGNMENT_PENDING: 'cycle_assignment_pending',
  // Status legados para compatibilidade
  PENDING: 'pending',
  PAYMENT_LINK_SENT: 'payment_link_sent',
  PAYMENT_PROOF_UPLOADED: 'payment_proof_uploaded',
} as const;

export type RenewalStatus = typeof RStatus[keyof typeof RStatus];

interface AdminRenewalRequest {
  _id: string;
  personalTrainerId: {
    _id: string;
    nome: string;
    email: string;
  };
  planIdRequested?: {
    _id: string;
    nome: string;
  } | null;
  status: RenewalStatus;
  paymentLink?: string;
  proof?: {
    kind: 'link' | 'file';
    url?: string;
    filename?: string;
    fileId?: string;
    contentType?: string;
  };
  notes?: string;
  linkSentAt?: string;
  proofUploadedAt?: string;
  paymentDecisionAt?: string;
  paymentDecisionNote?: string;
}

function statusLabel(status: string) {
    switch (status) {
      case RStatus.REQUESTED:
      case RStatus.PENDING:
        return "Aguardando envio de link";
      case RStatus.LINK_SENT:
      case RStatus.PAYMENT_LINK_SENT:
        return "Link enviado, aguardando comprovante";
      case RStatus.PROOF_SUBMITTED:
      case RStatus.PAYMENT_PROOF_UPLOADED:
        return "Comprovante enviado, aguardando validação";
      case RStatus.APPROVED:
      case RStatus.CYCLE_ASSIGNMENT_PENDING:
        return "Aprovado - Aguardando Ciclo";
      case RStatus.REJECTED:
        return "Rejeitado";
      case RStatus.FULFILLED:
        return "Concluído";
      default:
        return status;
    }
}

export default function AdminRenewalRequests() {
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [paymentLinks, setPaymentLinks] = useState<Record<string, string>>({});
  const [decisionNotes, setDecisionNotes] = useState<Record<string, string>>({});
  const [downloadingId, setDownloadingId] = useState<string | null>(null);

  const {
    data: requests = [],
    isLoading,
    error,
  } = useQuery<AdminRenewalRequest[]>({
    queryKey: ["adminRenewalRequests"],
    queryFn: () => fetchWithAuth("/api/admin/renewal-requests"),
  });

  const handleDownloadProof = async (requestId: string, filename?: string) => {
    setDownloadingId(requestId);
    try {
      const response = await fetchWithAuth<Response>(
        `/api/admin/renewal-requests/${requestId}/proof/download`,
        { method: 'GET', returnAs: 'response' },
        'personalAdmin'
      );

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename || `comprovante-${requestId}.pdf`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(url);

    } catch (err: any) {
      console.error("[Download] Erro ao baixar o arquivo:", err);
      toast({
        variant: "destructive",
        title: "Erro no Download",
        description: err.message || "Não foi possível baixar o comprovante.",
      });
    } finally {
      setDownloadingId(null);
    }
  };

  const sendLinkMutation = useMutation({
    mutationFn: ({ id, link }: { id: string; link: string }) =>
      apiRequest("PUT", `/api/admin/renewal-requests/${id}/payment-link`, { paymentLink: link }),
    onSuccess: () => {
      toast({ title: "Link enviado", description: "Link de pagamento enviado com sucesso." });
      queryClient.invalidateQueries({ queryKey: ["adminRenewalRequests"] });
    },
    onError: (err: any) => {
      toast({ variant: "destructive", title: "Erro ao enviar link", description: err?.message || "Erro inesperado." });
    },
  });

  const makeDecisionMutation = useMutation({
    mutationFn: async ({ id, approved, note }: { id: string; approved: boolean; note?: string }) => {
      if (approved) {
        return apiRequest("PUT", `/api/admin/renewal-requests/${id}/approve`, {
          motivo: note && note.trim() ? note.trim() : "Pagamento aprovado",
        });
      }
      return apiRequest("PATCH", `/api/admin/renewal-requests/${id}/decision`, { approved: false, note });
    },
    onSuccess: () => {
      toast({ title: "Decisão processada", description: "A decisão foi registrada com sucesso." });
      queryClient.invalidateQueries({ queryKey: ["adminRenewalRequests"] });
    },
    onError: (err: any) => {
      toast({ variant: "destructive", title: "Erro ao processar decisão", description: err?.message || "Erro inesperado." });
    },
  });

  if (isLoading) {
    return <LoadingSpinner text="Carregando solicitações..." />;
  }

  if (error) {
    return <ErrorMessage title="Erro ao carregar solicitações" message={(error as any)?.message} />;
  }

  return (
    <div className="p-4 md:p-6 lg:p-8">
      <h1 className="text-3xl font-bold mb-6">Solicitações de Renovação</h1>
      {requests.length === 0 ? (
        <p className="text-muted-foreground">Nenhuma solicitação pendente no momento.</p>
      ) : (
        <div className="space-y-6">
          {requests.map((req) => (
            <Card key={req._id}>
              <CardHeader>
                <div className="flex justify-between items-start">
                    <div>
                        <CardTitle>Solicitação #{req._id.slice(-6)}</CardTitle>
                        <CardDescription>
                          Personal: <strong>{req.personalTrainerId?.nome}</strong> ({req.personalTrainerId?.email})
                        </CardDescription>
                    </div>
                    <Badge variant={(req.status === RStatus.PROOF_SUBMITTED || req.status === RStatus.PAYMENT_PROOF_UPLOADED) ? 'default' : 'secondary'}>
                        {statusLabel(req.status)}
                    </Badge>
                </div>
              </CardHeader>
              <CardContent className="space-y-4">
                <p><strong>Plano solicitado:</strong> {req.planIdRequested?.nome || "Manter categoria"}</p>
                
                {(req.status === RStatus.REQUESTED || req.status === RStatus.PENDING) && (
                  <div className="mt-4 pt-4 border-t space-y-2">
                    <Label htmlFor={`link-${req._id}`} className="font-semibold">Enviar Link de Pagamento</Label>
                    <div className="flex gap-2">
                      <Input
                        id={`link-${req._id}`}
                        placeholder="https://seu-link-de-pagamento.com"
                        value={paymentLinks[req._id] || ""}
                        onChange={(e) => setPaymentLinks({ ...paymentLinks, [req._id]: e.target.value })}
                        disabled={sendLinkMutation.isPending}
                      />
                      <Button
                        onClick={() => {
                          const link = paymentLinks[req._id];
                          if (!link) {
                            toast({ variant: "destructive", title: "Campo vazio", description: "Insira um link antes de enviar." });
                            return;
                          }
                          sendLinkMutation.mutate({ id: req._id, link });
                        }}
                        disabled={sendLinkMutation.isPending}
                      >
                        {sendLinkMutation.isPending && <Loader2 className="w-4 h-4 animate-spin" />}
                        Enviar
                      </Button>
                    </div>
                  </div>
                )}

                {(req.status === RStatus.PROOF_SUBMITTED || req.status === RStatus.PAYMENT_PROOF_UPLOADED) && (
                  <div className="mt-4 pt-4 border-t space-y-4">
                    {req.proof && (
                      <div>
                        <Label className="font-semibold">Comprovante Enviado:</Label>
                        {req.proof.kind === 'link' && (
                          <a href={req.proof.url} target="_blank" rel="noopener noreferrer" className="text-primary underline break-all text-sm block mt-1">
                            {req.proof.url}
                          </a>
                        )}
                        {req.proof.kind === 'file' && (
                          <div className="text-sm flex items-center gap-2 mt-1">
                            <FileText className="w-4 h-4 text-muted-foreground" />
                            <span>{req.proof.filename}</span>
                            <Button
                              variant="link"
                              size="sm"
                              className="p-0 h-auto text-primary"
                              onClick={() => handleDownloadProof(req._id, req.proof?.filename)}
                              disabled={downloadingId === req._id}
                            >
                              {downloadingId === req._id ? <Loader2 className="h-4 h-4 animate-spin" /> : <Download className="h-3 w-3" />}
                              {downloadingId === req._id ? 'Baixando...' : 'Baixar'}
                            </Button>
                          </div>
                        )}
                      </div>
                    )}
                    
                    <div>
                      <Label htmlFor={`note-${req._id}`} className="font-semibold">Observação (Opcional)</Label>
                      <Textarea
                        id={`note-${req._id}`}
                        placeholder="Adicione uma nota sobre a aprovação ou rejeição..."
                        value={decisionNotes[req._id] || ""}
                        onChange={(e) => setDecisionNotes({ ...decisionNotes, [req._id]: e.target.value })}
                        disabled={makeDecisionMutation.isPending}
                        className="mt-1"
                      />
                    </div>
                    
                    <div className="flex gap-2">
                      <Button
                        onClick={() => makeDecisionMutation.mutate({ id: req._id, approved: true, note: decisionNotes[req._id] })}
                        disabled={makeDecisionMutation.isPending}
                        className="bg-green-600 hover:bg-green-700"
                      >
                        {makeDecisionMutation.isPending && <Loader2 className="w-4 h-4 animate-spin mr-2" />}
                        Aprovar Pagamento
                      </Button>
                      <Button
                        onClick={() => makeDecisionMutation.mutate({ id: req._id, approved: false, note: decisionNotes[req._id] })}
                        disabled={makeDecisionMutation.isPending}
                        variant="destructive"
                      >
                        {makeDecisionMutation.isPending && <Loader2 className="w-4 h-4 animate-spin mr-2" />}
                        Rejeitar
                      </Button>
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
===== ./client/src/pages/alunos/AlunoDashboardPage.tsx =====
// client/src/pages/alunos/AlunoDashboardPage.tsx
import React, { useState, useEffect } from 'react';
import { useAluno } from '../../context/AlunoContext';
import { Button } from '../../components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '../../components/ui/card';
import { Progress } from '../../components/ui/progress';
import { Alert, AlertDescription, AlertTitle } from "../../components/ui/alert";
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '../../lib/queryClient';
import { Loader2, AlertTriangle, PlayCircle, Zap, History, Dumbbell, TrendingUp, ClipboardList, BookOpenCheck, Replace, Eye } from 'lucide-react';
import { useLocation } from 'wouter';
import { format, parseISO, isValid as isDateValidFn, nextDay, Day, differenceInDays } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import FrequenciaSemanal from '../../components/alunos/FrequenciaSemanal';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "@/components/ui/dialog";
import { Skeleton } from '@/components/ui/skeleton';


// --- Interfaces ---
interface ExercicioDetalhePopulado { _id: string; nome: string; grupoMuscular?: string; urlVideo?: string; descricao?: string; categoria?: string; tipo?: string; }
interface ExercicioEmDiaDeTreinoPopulado { _id: string; exercicioId: ExercicioDetalhePopulado | string; series?: string; repeticoes?: string; carga?: string; descanso?: string; observacoes?: string; ordemNoDia: number; concluido?: boolean; }
interface DiaDeTreinoPopulado { _id: string; identificadorDia: string; nomeSubFicha?: string; ordemNaRotina: number; exerciciosDoDia: ExercicioEmDiaDeTreinoPopulado[]; dataSugeridaFormatada?: string; concluidoNestaSemana?: boolean; }
interface RotinaDeTreinoAluno { _id: string; titulo: string; descricao?: string; tipo: "modelo" | "individual"; alunoId?: { _id: string; nome: string; email?: string; } | string | null; criadorId?: { _id: string; nome: string; email?: string; } | string; tipoOrganizacaoRotina: 'diasDaSemana' | 'numerico' | 'livre'; diasDeTreino: DiaDeTreinoPopulado[]; pastaId?: { _id: string; nome: string; } | string | null; statusModelo?: "ativo" | "rascunho" | "arquivado"; ordemNaPasta?: number; dataValidade?: string | null; totalSessoesRotinaPlanejadas?: number | null; sessoesRotinaConcluidas: number; criadoEm: string; atualizadoEm?: string; }
interface SessaoConcluidaParaFrequencia { _id: string; sessionDate: string | Date; tipoCompromisso?: string; }
interface ProgressoStats {
  totalTreinosConcluidos: number;
  mediaPSE: string | number;
  diasConsecutivos: number;
}

const DiaDetalhesModal: React.FC<{
  isOpen: boolean;
  onClose: () => void;
  onStart: () => void;
  diaDeTreino: DiaDeTreinoPopulado | null;
}> = ({ isOpen, onClose, onStart, diaDeTreino }) => {
  if (!diaDeTreino) return null;

  const exercicios = diaDeTreino.exerciciosDoDia
    .filter(ex => ex.exercicioId && typeof ex.exercicioId === 'object')
    .sort((a, b) => a.ordemNoDia - b.ordemNoDia);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>{diaDeTreino.identificadorDia}{diaDeTreino.nomeSubFicha && ` - ${diaDeTreino.nomeSubFicha}`}</DialogTitle>
          <DialogDescription>Lista de exercícios para este dia.</DialogDescription>
        </DialogHeader>
        <div className="max-h-[60vh] overflow-y-auto pr-4 my-4">
          <ul className="space-y-3">
            {exercicios.map(ex => (
              <li key={ex._id} className="text-sm p-2 bg-slate-50 rounded-md">
                {(ex.exercicioId as ExercicioDetalhePopulado).nome}
              </li>
            ))}
          </ul>
        </div>
        <DialogFooter className="flex-col-reverse sm:flex-row sm:justify-between gap-2">
          <Button type="button" variant="secondary" onClick={onClose}>Fechar</Button>
          <Button type="button" onClick={onStart}>
            <PlayCircle className="mr-2 h-4 w-4" /> Iniciar Treino
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

const weekDayMap: { [key: string]: Day } = { 'domingo': 0, 'segunda-feira': 1, 'terca-feira': 2, 'quarta-feira': 3, 'quinta-feira': 4, 'sexta-feira': 5, 'sabado': 6 };
const getNextDateForWeekday = (weekdayName: string): Date | null => {
    const lowerWeekdayName = weekdayName.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace("-feira", "");
    const targetDayIndex = weekDayMap[lowerWeekdayName];
    if (targetDayIndex === undefined) { return null; }
    return nextDay(new Date(), targetDayIndex as Day);
};

const AlunoDashboardPage: React.FC = () => {
  const { aluno } = useAluno();
  const [, navigate] = useLocation();
  const [activeRotinaId, setActiveRotinaId] = useState<string | null>(() => {
    if (aluno) { return localStorage.getItem(`activeRotinaId_${aluno.id}`); }
    return null;
  });
  const [diaParaVerDetalhes, setDiaParaVerDetalhes] = useState<DiaDeTreinoPopulado | null>(null);

  const { data: minhasRotinas, isLoading: isLoadingRotinas, error: errorRotinas } = useQuery<RotinaDeTreinoAluno[], Error>({
    queryKey: ['minhasRotinasAluno', aluno?.id],
    queryFn: async () => {
      if (!aluno?.id) throw new Error("Aluno não autenticado.");
      // <<< INÍCIO DA CORREÇÃO >>>
      const rotinasDoAluno = await apiRequest<RotinaDeTreinoAluno[]>('GET', '/api/aluno/meus-treinos', undefined, 'aluno');
      // <<< FIM DA CORREÇÃO >>>
      return rotinasDoAluno.sort((a, b) => new Date(b.atualizadoEm || b.criadoEm).getTime() - new Date(a.atualizadoEm || a.criadoEm).getTime());
    },
    enabled: !!aluno,
    staleTime: 1000 * 60 * 5,
  });

  const { data: statsProgresso, isLoading: isLoadingStats } = useQuery<ProgressoStats, Error>({
    queryKey: ['statsProgressoAluno', aluno?.id],
    // <<< INÍCIO DA CORREÇÃO >>>
    queryFn: () => apiRequest<ProgressoStats>('GET', '/api/aluno/stats-progresso', undefined, 'aluno'),
    // <<< FIM DA CORREÇÃO >>>
    enabled: !!aluno,
    staleTime: 1000 * 60 * 5,
  });

  useEffect(() => {
    if (!aluno) return;

    const handleSyncActiveRotina = () => {
      if (minhasRotinas && minhasRotinas.length > 0) {
        const currentId = localStorage.getItem(`activeRotinaId_${aluno.id}`);
        const rotinaExiste = minhasRotinas.some(r => r._id === currentId);
        if (!currentId || !rotinaExiste) {
          const defaultActiveId = minhasRotinas[0]._id;
          localStorage.setItem(`activeRotinaId_${aluno.id}`, defaultActiveId);
          setActiveRotinaId(defaultActiveId);
        } else {
          setActiveRotinaId(currentId);
        }
      }
    };

    handleSyncActiveRotina();

    const handleStorageChange = (event: StorageEvent) => {
      if (event.key === `activeRotinaId_${aluno.id}`) {
        setActiveRotinaId(event.newValue);
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [minhasRotinas, aluno]);

  const { data: sessoesConcluidasNaSemanaGeral, isLoading: isLoadingFrequencia } = useQuery<SessaoConcluidaParaFrequencia[], Error>({
    queryKey: ['frequenciaSemanalAluno', aluno?.id],
    queryFn: async () => {
      if (!aluno?.id) throw new Error("Aluno não autenticado.");
      // <<< INÍCIO DA CORREÇÃO >>>
      return apiRequest<SessaoConcluidaParaFrequencia[]>('GET', '/api/aluno/minhas-sessoes-concluidas-na-semana', undefined, 'aluno');
      // <<< FIM DA CORREÇÃO >>>
    },
    enabled: !!aluno,
    staleTime: 1000 * 60 * 1,
  });
  
  const rotinaAtiva = (minhasRotinas && activeRotinaId) 
    ? minhasRotinas.find(r => r._id === activeRotinaId) || minhasRotinas[0] || null
    : null;

  const getProximoDiaEAlerta = () => {
    if (!rotinaAtiva || !rotinaAtiva.diasDeTreino || rotinaAtiva.diasDeTreino.length === 0) {
      return { proximoDiaSugerido: null, alertaRotina: { tipo: 'warning' as const, mensagem: 'Sua rotina ativa está vazia. Fale com seu personal ou escolha outra rotina.' } };
    }
    const diasDaRotinaComData = [...rotinaAtiva.diasDeTreino].map(dia => {
      let dataSugeridaFormatada;
      if (rotinaAtiva.tipoOrganizacaoRotina === 'diasDaSemana' && dia.identificadorDia) {
        const nextDate = getNextDateForWeekday(dia.identificadorDia);
        if (nextDate) {
          dataSugeridaFormatada = format(nextDate, "EEEE, dd/MM", { locale: ptBR });
        }
      }
      return { ...dia, dataSugeridaFormatada };
    }).sort((a, b) => a.ordemNaRotina - b.ordemNaRotina);

    let alerta: { tipo: 'warning' | 'info'; mensagem: string } | null = null;
    if (rotinaAtiva.dataValidade) {
      const dataValidadeDate = parseISO(rotinaAtiva.dataValidade);
      const hoje = new Date();
      if (isDateValidFn(dataValidadeDate)) {
        const diasParaExpirar = differenceInDays(dataValidadeDate, hoje);
        if (diasParaExpirar < 0) {
          alerta = { tipo: 'warning' as const, mensagem: 'Esta rotina expirou! Fale com seu personal para obter uma nova.' };
        } else if (diasParaExpirar <= 7) {
          alerta = { tipo: 'warning' as const, mensagem: `Atenção: Sua rotina expira em ${diasParaExpirar + 1} dia(s)!` };
        }
      }
    }
    if (!alerta && rotinaAtiva.totalSessoesRotinaPlanejadas && rotinaAtiva.sessoesRotinaConcluidas >= rotinaAtiva.totalSessoesRotinaPlanejadas) {
      alerta = { tipo: 'info' as const, mensagem: 'Parabéns, você concluiu esta rotina! Fale com seu personal para os próximos passos.' };
    }
    const proximoDia = diasDaRotinaComData[0] || null;
    return { proximoDiaSugerido: proximoDia, alertaRotina: alerta };
  };

  const { proximoDiaSugerido, alertaRotina } = getProximoDiaEAlerta();

  if (isLoadingRotinas || isLoadingFrequencia || !aluno || isLoadingStats) {
    return (
      // Alterado de "flex h-screen w-full" para "fixed inset-0 z-50 flex" para criar um overlay verdadeiro
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-gradient-to-br from-indigo-600 to-blue-400">
        <Loader2 className="h-10 w-10 animate-spin text-white" />
        <span className="ml-4 text-lg text-white">Carregando seu painel...</span>
      </div>
    );
  }

  if (errorRotinas) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-indigo-600 to-blue-400 p-4 text-white">
        <Alert variant="destructive" className="bg-red-800/80 border-red-500 text-white">
          <AlertTitle>Erro de Conexão</AlertTitle>
          <AlertDescription>Não foi possível carregar suas rotinas de treino. Por favor, tente novamente mais tarde.</AlertDescription>
        </Alert>
      </div>
    );
  }
  return (
    <div className="min-h-screen text-white"> 
      <div className="mb-6">
          <h1 className="text-3xl font-bold">Olá, {aluno.nome?.split(' ')[0] || 'Aluno'}!</h1>
          <p className="text-lg mt-1 opacity-90">Pronto para o seu próximo desafio?</p>
      </div>
      <div className="space-y-6">
        <Card className="bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg border-0">
          <CardHeader>
            <div className="flex items-center gap-3">
              <Dumbbell className="w-6 h-6 text-indigo-600" />
              <CardTitle className="text-xl font-bold">Seu Treino de Hoje</CardTitle>
            </div>
            <CardDescription className="!mt-2">
              Sua rotina ativa é: <span className="font-semibold text-indigo-600">{rotinaAtiva?.titulo || "Nenhuma"}</span>
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {alertaRotina && (
                <Alert variant={alertaRotina.tipo === 'warning' ? 'destructive' : 'default'} className={alertaRotina.tipo === 'info' ? 'bg-blue-50 border-blue-200' : ''}>
                    <AlertTriangle className="h-4 w-4" />
                    <AlertTitle>{alertaRotina.tipo === 'warning' ? 'Atenção!' : 'Aviso'}</AlertTitle>
                    <AlertDescription>{alertaRotina.mensagem}</AlertDescription>
                </Alert>
            )}
            {rotinaAtiva && proximoDiaSugerido && !alertaRotina?.mensagem.includes("expirou") && !alertaRotina?.mensagem.includes("concluiu") ? (
                <>
                    <div>
                        <p className="text-sm text-gray-600">Próximo treino sugerido:</p>
                        <p className="text-lg font-bold text-gray-900">
                            {proximoDiaSugerido.identificadorDia}
                            {proximoDiaSugerido.nomeSubFicha ? ` - ${proximoDiaSugerido.nomeSubFicha}` : ''}
                        </p>
                    </div>

                    {rotinaAtiva.totalSessoesRotinaPlanejadas != null && rotinaAtiva.totalSessoesRotinaPlanejadas > 0 && (
                        <div>
                            <p className="text-sm font-medium mb-1 text-gray-700">Progresso da Rotina ({rotinaAtiva.sessoesRotinaConcluidas} de {rotinaAtiva.totalSessoesRotinaPlanejadas})</p>
                            <Progress value={(rotinaAtiva.sessoesRotinaConcluidas / rotinaAtiva.totalSessoesRotinaPlanejadas) * 100} className="h-2.5" />
                        </div>
                    )}
                </>
            ) : (
                <div className="text-center py-4">
                    <p className="text-gray-600">{rotinaAtiva ? 'Fale com seu personal ou ative outra rotina.' : 'Você não possui uma rotina ativa.'}</p>
                </div>
            )}
          </CardContent>
          <CardFooter className="flex-col items-stretch gap-3 pt-4">
            {rotinaAtiva && proximoDiaSugerido && !alertaRotina?.mensagem.includes("expirou") && !alertaRotina?.mensagem.includes("concluiu") ? (
              <>
                <div className="flex flex-col sm:flex-row gap-2">
                    <Button variant="outline" className="w-full sm:w-auto" onClick={() => setDiaParaVerDetalhes(proximoDiaSugerido)}>
                        <Eye className="w-4 h-4 mr-2" /> Ver Detalhes
                    </Button>
                    <Button size="lg" className="w-full sm:flex-1 font-bold text-base bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl shadow-md" onClick={() => navigate(`/aluno/ficha/${rotinaAtiva._id}?diaId=${proximoDiaSugerido._id}`)}>
                        <PlayCircle className="w-5 h-5 mr-2" /> Iniciar Treino
                    </Button>
                </div>
                <Button variant="link" className="text-sm text-gray-600 hover:text-indigo-600 h-auto" onClick={() => navigate(`/aluno/ficha/${rotinaAtiva._id}`)}>
                    <Replace className="w-4 h-4 mr-2" />
                    Escolher outro treino
                </Button>
              </>
            ) : (
                <Button size="lg" className="w-full font-bold text-base bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl shadow-md" onClick={() => navigate('/aluno/meus-treinos')}>
                    <BookOpenCheck className="w-5 h-5 mr-2" />
                    Ativar uma Rotina
                </Button>
            )}
          </CardFooter>
        </Card>
        <Card className="bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg border-0">
            <CardHeader>
                <div className="flex items-center gap-3">
                    <Zap className="w-6 h-6 text-yellow-500" />
                    <CardTitle className="text-xl font-bold">Sua Frequência Semanal</CardTitle>
                </div>
            </CardHeader>
            <CardContent>
                <FrequenciaSemanal sessoesConcluidasNaSemana={sessoesConcluidasNaSemanaGeral || []} isLoading={isLoadingFrequencia} />
            </CardContent>
            <CardFooter>
                <Button variant="outline" className="w-full border-gray-300 text-gray-700 hover:bg-gray-100 hover:text-gray-900" onClick={() => navigate('/aluno/historico')}>
                    <History className="w-4 h-4 mr-2" />
                    Ver Histórico Completo
                </Button>
            </CardFooter>
        </Card>
        <Card className="bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg border-0">
            <CardHeader>
                <div className="flex items-center gap-3">
                    <TrendingUp className="w-6 h-6 text-green-500" />
                    <CardTitle className="text-xl font-bold">Seu Progresso</CardTitle>
                </div>
            </CardHeader>
            <CardContent className="space-y-2 text-sm">
                {isLoadingStats ? (
                    <>
                        <div className="flex justify-between items-center p-3">
                            <Skeleton className="h-5 w-40" />
                            <Skeleton className="h-6 w-10" />
                        </div>
                        <div className="flex justify-between items-center p-3">
                            <Skeleton className="h-5 w-24" />
                            <Skeleton className="h-6 w-10" />
                        </div>
                        <div className="flex justify-between items-center p-3">
                            <Skeleton className="h-5 w-32" />
                            <Skeleton className="h-6 w-10" />
                        </div>
                    </>
                ) : (
                    <>
                        <div className="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                            <span className="text-gray-600">Total de Treinos Concluídos</span>
                            <span className="font-bold text-lg text-gray-800">{statsProgresso?.totalTreinosConcluidos ?? 0}</span>
                        </div>
                        <div className="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                            <span className="text-gray-600">Média de PSE</span>
                            <span className="font-bold text-lg text-gray-800">{statsProgresso?.mediaPSE ?? 'N/D'}</span>
                        </div>
                        <div className="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                            <span className="text-gray-600">Dias Consecutivos</span>
                            <span className="font-bold text-lg text-gray-800">{statsProgresso?.diasConsecutivos ?? 0}</span>
                        </div>
                    </>
                )}
            </CardContent>
            <CardFooter>
                <Button variant="outline" className="w-full border-gray-300 text-gray-700" disabled>
                    <TrendingUp className="w-4 h-4 mr-2" />
                    Análise de Progresso (Em breve)
                </Button>
            </CardFooter>
        </Card>
        <Card className="bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg border-0">
            <CardHeader>
                <div className="flex items-center gap-3">
                    <ClipboardList className="w-6 h-6 text-blue-500" />
                    <CardTitle className="text-xl font-bold">Suas Fichas de Treino</CardTitle>
                </div>
            </CardHeader>
            <CardContent>
                <p className="text-sm text-gray-600 text-center">
                    Gerencie todas as suas rotinas e escolha qual seguir.
                </p>
            </CardContent>
            <CardFooter>
                <Button className="w-full bg-blue-600 hover:bg-blue-700 text-white rounded-xl" onClick={() => navigate('/aluno/meus-treinos')}>
                    <BookOpenCheck className="w-4 h-4 mr-2" />
                    Ver Todas as Rotinas
                </Button>
            </CardFooter>
        </Card>
      </div>
      
      <DiaDetalhesModal
        isOpen={!!diaParaVerDetalhes}
        onClose={() => setDiaParaVerDetalhes(null)}
        onStart={() => {
            if (diaParaVerDetalhes && rotinaAtiva) {
                navigate(`/aluno/ficha/${rotinaAtiva._id}?diaId=${diaParaVerDetalhes._id}`);
                setDiaParaVerDetalhes(null);
            }
        }}
        diaDeTreino={diaParaVerDetalhes}
      />
    </div>
  );
};

export default AlunoDashboardPage;

===== ./client/src/pages/alunos/AlunoFichaDetalhePage.tsx =====
// Caminho: ./client/src/pages/alunos/AlunoFichaDetalhePage.tsx
import React, { useState, useMemo, useEffect } from 'react';
import { useParams, Link as WouterLink, useLocation, useSearch } from 'wouter';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { useAluno } from '@/context/AlunoContext';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from "@/components/ui/dialog";
import { Loader2, ArrowLeft, ListChecks, Dumbbell, Calendar, PlayCircle, XCircle, Timer, Zap, MessageSquare, Award, Eye } from 'lucide-react';
import VideoPlayerModal from '@/components/dialogs/VideoPlayerModal';
import { useToast } from '@/hooks/use-toast';
import { format, parseISO } from 'date-fns';
import { useWorkoutPlayer } from '@/context/WorkoutPlayerContext';
import { WorkoutExerciseCard } from '@/components/alunos/WorkoutExerciseCard';
import { CombinedExerciseCard } from '@/components/alunos/CombinedExerciseCard';

// --- Interfaces ---
interface ExercicioDetalhePopulado { _id: string; nome: string; urlVideo?: string; }
interface ExercicioEmDiaDeTreinoPopulado { _id: string; exercicioId: ExercicioDetalhePopulado | string | null; series?: string; repeticoes?: string; carga?: string; descanso?: string; ordemNoDia: number; grupoCombinado?: string; }
interface DiaDeTreinoPopulado { _id: string; identificadorDia: string; nomeSubFicha?: string; ordemNaRotina: number; exerciciosDoDia: ExercicioEmDiaDeTreinoPopulado[]; }
interface RotinaDeTreinoAluno { _id: string; titulo: string; descricao?: string; diasDeTreino: DiaDeTreinoPopulado[]; dataValidade?: string | null; sessoesRotinaConcluidas: number; }
type ExercicioRenderizavel = Omit<ExercicioEmDiaDeTreinoPopulado, 'exercicioId'> & { _id: string; exercicioDetalhes: ExercicioDetalhePopulado | null; };
const OPCOES_PSE_FRONTEND = [ 'Muito Leve', 'Leve', 'Moderado', 'Intenso', 'Muito Intenso', 'Máximo Esforço'] as const;
type OpcaoPSEFrontend = typeof OPCOES_PSE_FRONTEND[number];
interface ConcluirSessaoPayload { rotinaId: string; diaDeTreinoId: string; pseAluno?: OpcaoPSEFrontend | null; comentarioAluno?: string | null; duracaoSegundos: number; cargas: Record<string, string>; dataInicio: string; }
interface ConcluirSessaoResponse { _id: string; }
// --- Fim das Interfaces ---

// --- Subcomponentes ---
interface FeedbackModalProps { isOpen: boolean; onClose: () => void; onSubmit: (feedback: { pse: OpcaoPSEFrontend | null, comentario: string | null }) => void; isSubmitting: boolean; stats: { inicio: Date; fim: Date; tempoTotal: number; }; }
const FeedbackModal: React.FC<FeedbackModalProps> = ({ isOpen, onClose, onSubmit, isSubmitting, stats }) => {
    const [pse, setPse] = useState<OpcaoPSEFrontend | ''>('');
    const [comentario, setComentario] = useState('');
    const formatTime = (seconds: number) => { const m = Math.floor(seconds / 60).toString().padStart(2, '0'); const s = (seconds % 60).toString().padStart(2, '0'); return `${m}m ${s}s`; };
    const handleSubmit = () => { onSubmit({ pse: pse || null, comentario: comentario.trim() || null }); };
    return (<Dialog open={isOpen} onOpenChange={onClose}><DialogContent className="sm:max-w-md"><DialogHeader className="text-center items-center"><div className="bg-green-100 rounded-full p-3 w-fit mb-4"><Award className="w-8 h-8 text-green-600" /></div><DialogTitle className="text-2xl font-bold">Parabéns!</DialogTitle><DialogDescription>Você concluiu seu treino!</DialogDescription></DialogHeader><div className="grid grid-cols-2 gap-4 py-4 text-center border-y my-4"><div><p className="text-sm text-gray-500">Início</p><p className="font-semibold">{format(stats.inicio, 'HH:mm')}</p></div><div><p className="text-sm text-gray-500">Fim</p><p className="font-semibold">{format(stats.fim, 'HH:mm')}</p></div><div className="col-span-2"><p className="text-sm text-gray-500">Tempo de Treino</p><p className="font-semibold">{formatTime(stats.tempoTotal)}</p></div></div><div className="grid gap-4"><Label htmlFor="pse">O que você achou dessa atividade?</Label><Select value={pse} onValueChange={(v) => setPse(v as OpcaoPSEFrontend)}><SelectTrigger><SelectValue placeholder="Selecione..." /></SelectTrigger><SelectContent>{OPCOES_PSE_FRONTEND.map(o => (<SelectItem key={o} value={o}>{o}</SelectItem>))}</SelectContent></Select><Label htmlFor="comentario">Se quiser, deixe seu comentário aqui:</Label><Textarea id="comentario" placeholder="..." value={comentario} onChange={(e) => setComentario(e.target.value)} /></div><DialogFooter className="mt-4"><Button type="button" onClick={handleSubmit} disabled={isSubmitting} className="w-full">{isSubmitting ? <Loader2 className="w-4 h-4 mr-2 animate-spin" /> : <MessageSquare className="w-4 h-4 mr-2" />}Concluir</Button></DialogFooter></DialogContent></Dialog>);
};


const PreWorkoutDialog: React.FC<{ isOpen: boolean; onClose: () => void; onConfirm: () => void; diaDeTreino: DiaDeTreinoPopulado; }> = ({ isOpen, onClose, onConfirm, diaDeTreino }) => (
    <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent>
            <DialogHeader>
                <DialogTitle>Pronto para começar?</DialogTitle>
                <DialogDescription>Você está prestes a iniciar o treino: <span className="font-bold">{diaDeTreino.identificadorDia}{diaDeTreino.nomeSubFicha && ` - ${diaDeTreino.nomeSubFicha}`}</span></DialogDescription>
            </DialogHeader>
            <DialogFooter className="sm:justify-between gap-2">
                <DialogClose asChild><Button type="button" variant="secondary">Cancelar</Button></DialogClose>
                <Button type="button" onClick={onConfirm}><PlayCircle className="mr-2 h-4 w-4" /> Iniciar Treino</Button>
            </DialogFooter>
        </DialogContent>
    </Dialog>
);

const DiaDetalhesModal: React.FC<{ isOpen: boolean; onClose: () => void; diaDeTreino: DiaDeTreinoPopulado; }> = ({ isOpen, onClose, diaDeTreino }) => {
    const exercicios = diaDeTreino.exerciciosDoDia
        .filter(ex => ex.exercicioId && typeof ex.exercicioId === 'object')
        .sort((a, b) => a.ordemNoDia - b.ordemNoDia);

    // Group exercises for display
    const groupedExercises = exercicios.reduce((acc, ex) => {
        if (ex.grupoCombinado) {
            if (!acc.grouped[ex.grupoCombinado]) {
                acc.grouped[ex.grupoCombinado] = [];
            }
            acc.grouped[ex.grupoCombinado].push(ex);
        } else {
            acc.ungrouped.push(ex);
        }
        return acc;
    }, { grouped: {} as Record<string, typeof exercicios>, ungrouped: [] as typeof exercicios });

    return (
        <Dialog open={isOpen} onOpenChange={onClose}>
            <DialogContent className="sm:max-w-md">
                <DialogHeader>
                    <DialogTitle>{diaDeTreino.identificadorDia}{diaDeTreino.nomeSubFicha && ` - ${diaDeTreino.nomeSubFicha}`}</DialogTitle>
                    <DialogDescription>Lista de exercícios para este dia.</DialogDescription>
                </DialogHeader>
                <div className="max-h-[60vh] overflow-y-auto pr-4 my-4">
                    <div className="space-y-4">
                        {/* Render grouped exercises */}
                        {Object.entries(groupedExercises.grouped).map(([groupId, groupExercises]) => (
                            <div key={`modal-group-${groupId}`} className="bg-blue-50 p-3 rounded-lg border-l-4 border-blue-500">
                                <div className="flex items-center gap-2 mb-2 text-sm text-blue-700 font-medium">
                                    <span>🔗</span>
                                    <span>Exercícios Conjugados ({groupExercises.length})</span>
                                    <span className="text-xs bg-blue-200 px-2 py-1 rounded-full">Executar em sequência</span>
                                </div>
                                <ul className="space-y-1">
                                    {groupExercises.map((ex, index) => (
                                        <li key={ex._id} className="text-sm p-2 bg-white rounded-md">
                                            {index + 1}. {(ex.exercicioId as ExercicioDetalhePopulado).nome}
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        ))}
                        
                        {/* Render ungrouped exercises */}
                        {groupedExercises.ungrouped.length > 0 && (
                            <ul className="space-y-2">
                                {groupedExercises.ungrouped.map(ex => (
                                    <li key={ex._id} className="text-sm p-2 bg-slate-50 rounded-md">
                                        {(ex.exercicioId as ExercicioDetalhePopulado).nome}
                                    </li>
                                ))}
                            </ul>
                        )}
                    </div>
                </div>
                <DialogFooter>
                    <Button type="button" onClick={onClose}>Fechar</Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
    );
};

const WorkoutExecutionView: React.FC<{ diaAtivo: DiaDeTreinoPopulado; rotinaId: string; onFinishWorkout: (payload: { duracao: number; cargas: Record<string, string>; dataInicio: Date }) => void; }> = ({ diaAtivo, rotinaId, onFinishWorkout }) => {
    const { stopWorkout, elapsedTime, activeExerciseId, completedExercises, getExerciseLoad, workoutStartTime } = useWorkoutPlayer();
    const [videoModalUrl, setVideoModalUrl] = useState<string | null>(null);

    const exerciciosParaRenderizar = useMemo(() => diaAtivo.exerciciosDoDia.map((ex): ExercicioRenderizavel | null => (ex.exercicioId && typeof ex.exercicioId === 'object') ? { ...ex, _id: ex._id, exercicioDetalhes: ex.exercicioId } : null).filter((ex): ex is ExercicioRenderizavel => ex !== null).sort((a, b) => a.ordemNoDia - b.ordemNoDia), [diaAtivo.exerciciosDoDia]);

    // Group exercises by grupoCombinado for rendering
    const exerciseGroupsInfo = useMemo(() => {
        const groupsMap = new Map<string, ExercicioRenderizavel[]>();
        const ungroupedExercises: ExercicioRenderizavel[] = [];
        
        exerciciosParaRenderizar.forEach(ex => {
            if (ex.grupoCombinado) {
                if (!groupsMap.has(ex.grupoCombinado)) {
                    groupsMap.set(ex.grupoCombinado, []);
                }
                groupsMap.get(ex.grupoCombinado)!.push(ex);
            } else {
                ungroupedExercises.push(ex);
            }
        });
        
        return { groupsMap, ungroupedExercises };
    }, [exerciciosParaRenderizar]);

    const renderExerciseCard = (ex: ExercicioRenderizavel, groupInfo?: { totalInGroup: number; positionInGroup: number; groupId: string }) => (
        <WorkoutExerciseCard 
            key={ex._id} 
            exercise={ex} 
            isActive={ex._id === activeExerciseId} 
            isCompleted={completedExercises.has(ex._id)} 
            onOpenVideo={() => abrirVideo(ex.exercicioDetalhes?.urlVideo)}
            isInGroup={!!groupInfo}
            groupInfo={groupInfo}
        />
    );

    const handleStopAndFinish = () => {
        if (!workoutStartTime) {
            console.error("Tentativa de finalizar o treino sem uma data de início registrada.");
            return;
        }
        const cargas = exerciciosParaRenderizar.reduce((acc, ex) => { acc[ex._id] = getExerciseLoad(ex._id); return acc; }, {} as Record<string, string>);
        stopWorkout();
        onFinishWorkout({ duracao: elapsedTime, cargas, dataInicio: workoutStartTime });
    };
    
    const formatTime = (seconds: number) => { const h = Math.floor(seconds / 3600).toString().padStart(2, '0'); const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0'); const s = (seconds % 60).toString().padStart(2, '0'); return h !== '00' ? `${h}:${m}:${s}` : `${m}:${s}`; };
    const abrirVideo = (url?: string) => { if (!url) return; setVideoModalUrl(url.includes("watch?v=") ? url.replace("watch?v=", "embed/") : url); };
    
    return (
        <Card className="bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg border-0 h-full flex flex-col">
            <CardHeader className="flex-shrink-0">
                <WouterLink href={`/aluno/ficha/${rotinaId}`}><Button variant="outline" size="sm" className="mb-2"><XCircle className="w-4 h-4 mr-2" /> Cancelar Treino</Button></WouterLink>
                <div className="flex justify-between items-center pt-2"><h3 className="font-bold text-lg">{diaAtivo.identificadorDia}</h3><div className="flex items-center gap-2 font-mono text-lg bg-gray-800 text-white px-3 py-1 rounded-lg"><Timer size={20} /><span>{formatTime(elapsedTime)}</span></div></div>
                <p className="text-sm text-gray-600 mt-1">Exercícios Concluídos: {completedExercises.size} / {exerciciosParaRenderizar.length}</p>
            </CardHeader>
            <CardContent className="flex-grow overflow-y-auto px-4 pb-4 space-y-3">
                {/* Render grouped exercises with CombinedExerciseCard */}
                {Array.from(exerciseGroupsInfo.groupsMap.entries()).map(([groupId, groupExercises]) => {
                    const isGroupActive = groupExercises.some(ex => ex._id === activeExerciseId);
                    const allGroupCompleted = groupExercises.every(ex => completedExercises.has(ex._id));
                    
                    return (
                        <CombinedExerciseCard
                            key={`combined-group-${groupId}`}
                            exercises={groupExercises}
                            isActive={isGroupActive}
                            allCompleted={allGroupCompleted}
                            onOpenVideo={(url) => abrirVideo(url)}
                            groupId={groupId}
                        />
                    );
                })}
                
                {/* Render ungrouped exercises */}
                {exerciseGroupsInfo.ungroupedExercises.map(ex => renderExerciseCard(ex))}
            </CardContent>
            <CardFooter className="flex-shrink-0 p-4 mt-4 border-t sticky bottom-0 bg-white"><Button onClick={handleStopAndFinish} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl shadow-md" size="lg"><Zap className="w-5 h-5 mr-2" /> Finalizar e Salvar Treino</Button></CardFooter>
            <VideoPlayerModal videoUrl={videoModalUrl} onClose={() => setVideoModalUrl(null)} />
        </Card>
    );
};

const SummaryView: React.FC<{ rotina: RotinaDeTreinoAluno; onSelectDiaParaIniciar: (dia: DiaDeTreinoPopulado) => void; onSelectDiaParaVer: (dia: DiaDeTreinoPopulado) => void; }> = ({ rotina, onSelectDiaParaIniciar, onSelectDiaParaVer }) => {
    
    const diasDeTreinoOrdenados = useMemo(() => 
        [...(rotina.diasDeTreino || [])].sort((a, b) => a.ordemNaRotina - b.ordemNaRotina), 
    [rotina.diasDeTreino]);

    return (
        <div>
            <div className="mb-6"><WouterLink href="/aluno/dashboard"><Button variant="outline" size="sm" className="bg-white/20 hover:bg-white/30 border-white/50 text-white rounded-lg"><ArrowLeft className="w-4 h-4 mr-2" />Voltar ao Painel</Button></WouterLink></div>
            <Card className="bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg border-0">
                <CardHeader><CardTitle className="text-2xl sm:text-3xl font-bold text-indigo-700 flex items-center gap-3"><ListChecks className="w-8 h-8" />{rotina.titulo}</CardTitle>{rotina.descricao && <CardDescription className="pt-1">{rotina.descricao}</CardDescription>}{rotina.dataValidade && (<p className="text-sm text-muted-foreground pt-2 flex items-center gap-2"><Calendar className="w-4 h-4" /> Válida até: {format(parseISO(rotina.dataValidade), 'dd/MM/yyyy')}</p>)}</CardHeader>
                <CardContent>
                    <h3 className="text-xl font-semibold mb-4 mt-2 flex items-center text-gray-800"><Dumbbell className="w-5 h-5 mr-2" /> Dias da Rotina </h3>
                    <div className="space-y-3">
                        {diasDeTreinoOrdenados.map(dia => (
                            <Card key={dia._id} className="w-full text-left bg-white hover:bg-slate-50 transition-colors duration-200 shadow-sm">
                                <CardContent className="p-4">
                                    <div className="flex justify-between items-start">
                                        <div>
                                            <p className="font-semibold text-gray-800">{dia.identificadorDia}{dia.nomeSubFicha && ` - ${dia.nomeSubFicha}`}</p>
                                            <p className="text-xs text-gray-500">{dia.exerciciosDoDia.length} exercícios</p>
                                        </div>
                                        <div className="flex gap-2 flex-shrink-0">
                                            <Button size="icon" variant="outline" onClick={() => onSelectDiaParaVer(dia)} aria-label="Ver detalhes do treino">
                                                <Eye className="w-4 h-4" />
                                            </Button>
                                            <Button size="icon" onClick={() => onSelectDiaParaIniciar(dia)} aria-label="Iniciar treino">
                                                <PlayCircle className="w-4 h-4" />
                                            </Button>
                                        </div>
                                    </div>
                                </CardContent>
                            </Card>
                        ))}
                    </div>
                </CardContent>
            </Card>
        </div>
    );
};

// ============================================================================
// LÓGICA PRINCIPAL DA PÁGINA
// ============================================================================
const AlunoFichaDetalhePage: React.FC = () => {
    const params = useParams<{ fichaId?: string }>();
    const rotinaIdUrl = params.fichaId;
    const [, navigateWouter] = useLocation();
    const search = useSearch();
    const diaIdUrl = new URLSearchParams(search).get('diaId');
    const { aluno, isLoadingAluno } = useAluno();
    const { toast } = useToast();
    const queryClientHook = useQueryClient();
    const { resetWorkout, stopWorkout, startWorkout, isWorkoutActive } = useWorkoutPlayer();

    const [pendingWorkoutData, setPendingWorkoutData] = useState<{ duracao: number; cargas: Record<string, string>; dataInicio: Date } | null>(null);
    const [diaParaIniciar, setDiaParaIniciar] = useState<DiaDeTreinoPopulado | null>(null);
    const [diaParaVer, setDiaParaVer] = useState<DiaDeTreinoPopulado | null>(null);

    const { data: rotinaDetalhes, isLoading: isLoadingRotina, error: errorRotina } = useQuery({
        queryKey: ['alunoRotinaDetalhe', rotinaIdUrl],
        queryFn: () => apiRequest<RotinaDeTreinoAluno>('GET', `/api/aluno/meus-treinos/${rotinaIdUrl}`, undefined, 'aluno'),
        enabled: !!rotinaIdUrl && !!aluno && !isLoadingAluno,
    });
    
    const diaDeTreinoAtivo = useMemo(() => {
        if (!rotinaDetalhes || !diaIdUrl) return null;
        return rotinaDetalhes.diasDeTreino.find(d => d._id === diaIdUrl) || null;
    }, [rotinaDetalhes, diaIdUrl]);
    
    useEffect(() => {
        // Don't auto-start workout if user has just completed one (pendingWorkoutData exists)
        if (diaDeTreinoAtivo && !isWorkoutActive && !pendingWorkoutData) {
            console.log('[PAGE_EFFECT] A URL indica um treino ativo, mas o contexto não. Iniciando o treino...');
            const exerciciosParaIniciar = diaDeTreinoAtivo.exerciciosDoDia
                .map((ex): ExercicioRenderizavel | null => (ex.exercicioId && typeof ex.exercicioId === 'object') ? { ...ex, _id: ex._id, exercicioDetalhes: ex.exercicioId } : null)
                .filter((ex): ex is ExercicioRenderizavel => ex !== null)
                .sort((a, b) => a.ordemNoDia - b.ordemNoDia);
            
            if (rotinaIdUrl) {
                startWorkout(exerciciosParaIniciar, diaDeTreinoAtivo._id, rotinaIdUrl);
            }
        }
    }, [diaDeTreinoAtivo, isWorkoutActive, startWorkout, rotinaIdUrl, pendingWorkoutData]);
    
    const handleConfirmStartWorkout = () => {
        if (!diaParaIniciar || !rotinaIdUrl) {
            return;
        }
        
        const exerciciosParaIniciar = diaParaIniciar.exerciciosDoDia
            .map((ex): ExercicioRenderizavel | null => (ex.exercicioId && typeof ex.exercicioId === 'object') ? { ...ex, _id: ex._id, exercicioDetalhes: ex.exercicioId } : null)
            .filter((ex): ex is ExercicioRenderizavel => ex !== null)
            .sort((a, b) => a.ordemNoDia - b.ordemNoDia);
        
        startWorkout(exerciciosParaIniciar, diaParaIniciar._id, rotinaIdUrl);
        
        navigateWouter(`/aluno/ficha/${rotinaIdUrl}?diaId=${diaParaIniciar._id}`);
        setDiaParaIniciar(null);
    };

    const atualizarCargasFichaMutation = useMutation<any, Error, { cargas: Record<string, string> }>({
        mutationFn: ({ cargas }) => apiRequest('PATCH', `/api/aluno/meus-treinos/${rotinaIdUrl}/cargas`, { diaDeTreinoId: diaIdUrl, cargas }, 'aluno'),
        onSuccess: () => { queryClientHook.invalidateQueries({ queryKey: ['alunoRotinaDetalhe', rotinaIdUrl] }); },
        onError: (error) => { console.error("Erro ao atualizar cargas na ficha:", error.message); }
    });

    const finalizarDiaDeTreinoMutation = useMutation<ConcluirSessaoResponse, Error, { payload: ConcluirSessaoPayload }, { previousRotinas: RotinaDeTreinoAluno[] | undefined }>({
        onMutate: async () => {
            await queryClientHook.cancelQueries({ queryKey: ['minhasRotinasAluno', aluno?.id] });
            const previousRotinas = queryClientHook.getQueryData<RotinaDeTreinoAluno[]>(['minhasRotinasAluno', aluno?.id]);
            if (previousRotinas) {
                const novasRotinas = previousRotinas.map(rotina => {
                    if (rotina._id === rotinaIdUrl) {
                        const diasAtuais = rotina.diasDeTreino;
                        if (!diasAtuais || diasAtuais.length === 0) return rotina;
                        const maxOrdem = Math.max(...diasAtuais.map(d => d.ordemNaRotina));
                        const diasDeTreinoAtualizados = diasAtuais.map(dia => {
                            if (dia._id === diaIdUrl) { return { ...dia, ordemNaRotina: maxOrdem + 1 }; }
                            return dia;
                        });
                        const sessoesConcluidasAtualizado = (rotina.sessoesRotinaConcluidas || 0) + 1;
                        return { ...rotina, sessoesRotinaConcluidas: sessoesConcluidasAtualizado, diasDeTreino: diasDeTreinoAtualizados };
                    }
                    return rotina;
                });
                queryClientHook.setQueryData(['minhasRotinasAluno', aluno?.id], novasRotinas);
            }
            return { previousRotinas };
        },
        onError: (err, _newTodo, context) => {
            if (context?.previousRotinas) { queryClientHook.setQueryData(['minhasRotinasAluno', aluno?.id], context.previousRotinas); }
            toast({ title: "Erro ao Salvar Treino", description: err.message, variant: "destructive" });
        },
        onSettled: () => { },
        mutationFn: (vars) => apiRequest('POST', `/api/sessions/aluno/concluir-dia`, vars.payload, 'aluno'),
        onSuccess: (_data, variables) => {
            toast({ title: "Treino Salvo!", description: "Redirecionando para o painel..." });
            atualizarCargasFichaMutation.mutate({ cargas: variables.payload.cargas });
            queryClientHook.invalidateQueries({ queryKey: ['frequenciaSemanalAluno', aluno?.id] });
            queryClientHook.invalidateQueries({ queryKey: ['statsProgressoAluno', aluno?.id] });
            setPendingWorkoutData(null); 
            resetWorkout();
            // Navigate immediately to prevent useEffect from auto-restarting workout
            navigateWouter('/aluno/dashboard');
        },
    });
    
    const handleFinishWorkout = (payload: { duracao: number; cargas: Record<string, string>; dataInicio: Date }) => {
        if (!rotinaIdUrl || !diaIdUrl) return;
        setPendingWorkoutData(payload); 
    };

    const handleEnviarFeedback = (feedback: { pse: OpcaoPSEFrontend | null, comentario: string | null }) => {
        if (!pendingWorkoutData || !rotinaIdUrl || !diaIdUrl) return;

        const finalPayload: ConcluirSessaoPayload = {
            rotinaId: rotinaIdUrl,
            diaDeTreinoId: diaIdUrl,
            dataInicio: pendingWorkoutData.dataInicio.toISOString(),
            duracaoSegundos: pendingWorkoutData.duracao,
            cargas: pendingWorkoutData.cargas,
            pseAluno: feedback.pse,
            comentarioAluno: feedback.comentario,
        };

        finalizarDiaDeTreinoMutation.mutate({ payload: finalPayload });
    };

    if (isLoadingAluno || isLoadingRotina) {
        return <div className="min-h-screen w-full flex items-center justify-center"><Loader2 className="h-10 w-10 animate-spin text-white" /></div>;
    }
    if (errorRotina) {
        return <div>Erro: {errorRotina.message}</div>;
    }
    if (!rotinaDetalhes) {
        return <div>Rotina não encontrada.</div>;
    }

    const renderContent = () => {
        if (diaIdUrl && isWorkoutActive && diaDeTreinoAtivo) {
            return <WorkoutExecutionView diaAtivo={diaDeTreinoAtivo} rotinaId={rotinaIdUrl!} onFinishWorkout={handleFinishWorkout} />;
        }
        return <SummaryView rotina={rotinaDetalhes} onSelectDiaParaIniciar={setDiaParaIniciar} onSelectDiaParaVer={setDiaParaVer} />; 
    };

    const workoutSummaryForModal = pendingWorkoutData ? {
        stats: {
            inicio: pendingWorkoutData.dataInicio,
            fim: new Date(),
            tempoTotal: pendingWorkoutData.duracao,
        }
    } : null;

    const handleCloseFeedbackModal = () => {
        setPendingWorkoutData(null);
        resetWorkout(); // Use resetWorkout instead of just stopWorkout to fully clean state
        // Navigate away to prevent auto-restart
        navigateWouter('/aluno/dashboard');
    };

    return (
        <div className="h-full">
            {renderContent()}

            {diaParaIniciar && (
                <PreWorkoutDialog isOpen={!!diaParaIniciar} onClose={() => setDiaParaIniciar(null)} onConfirm={handleConfirmStartWorkout} diaDeTreino={diaParaIniciar} />
            )}

            {diaParaVer && (
                <DiaDetalhesModal isOpen={!!diaParaVer} onClose={() => setDiaParaVer(null)} diaDeTreino={diaParaVer} />
            )}

            {workoutSummaryForModal && (
                <FeedbackModal 
                    isOpen={!!workoutSummaryForModal} 
                    onClose={handleCloseFeedbackModal} 
                    onSubmit={handleEnviarFeedback} 
                    isSubmitting={finalizarDiaDeTreinoMutation.isPending} 
                    stats={workoutSummaryForModal.stats} 
                />
            )}
        </div>
    );
};

export default AlunoFichaDetalhePage;
===== ./client/src/pages/alunos/AlunoHistoricoPage.tsx =====
// Caminho: ./client/src/pages/alunos/AlunoHistoricoPage.tsx
import { useState } from 'react';
import { useAluno } from '@/context/AlunoContext';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Loader2, ArrowLeft, History, MessageSquareText, Star, AlertTriangle, ChevronLeft, ChevronRight, Eye, TrendingUp } from 'lucide-react';
import { Link as WouterLink } from 'wouter';
import { format, parseISO } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { Badge } from '@/components/ui/badge';
import SessaoDetalheModal from '@/components/dialogs/SessaoDetalheModal'; 

// --- Interfaces e Helpers (sem alterações) ---
const OPCOES_PSE_FRONTEND = ['Muito Leve', 'Leve', 'Moderado', 'Intenso', 'Muito Intenso', 'Máximo Esforço'] as const;
type OpcaoPSEFrontend = typeof OPCOES_PSE_FRONTEND[number];
interface SessaoHistorico { _id: string; sessionDate: string; concluidaEm: string; tipoCompromisso: string; status: string; rotinaId?: { _id: string; titulo: string; } | null; diaDeTreinoId?: string | null; diaDeTreinoIdentificador?: string | null; nomeSubFichaDia?: string | null; personalId?: { _id: string; nome: string; } | null; pseAluno?: OpcaoPSEFrontend | null; comentarioAluno?: string | null; aumentouCarga?: boolean; }
interface HistoricoSessoesResponse { sessoes: SessaoHistorico[]; currentPage: number; totalPages: number; totalSessoes: number; }
const getPseBadgeVariant = (pse: OpcaoPSEFrontend | null | undefined): "default" | "secondary" | "destructive" | "outline" => { if (!pse) return "secondary"; switch (pse) { case 'Muito Leve': case 'Leve': return "default"; case 'Moderado': return "secondary"; case 'Intenso': case 'Muito Intenso': return "outline"; case 'Máximo Esforço': return "destructive"; default: return "secondary"; } };

const AlunoHistoricoPage: React.FC = () => {
  const { aluno } = useAluno();
  const [currentPage, setCurrentPage] = useState(1);
  const SESSIONS_PER_PAGE = 5;
  const [sessaoSelecionada, setSessaoSelecionada] = useState<SessaoHistorico | null>(null);

  const { data: historicoData, isLoading: isLoadingHistorico, error: errorHistorico, isFetching: isFetchingHistorico, } = useQuery<HistoricoSessoesResponse, Error>({
    queryKey: ['alunoHistoricoSessoes', aluno?.id, currentPage, SESSIONS_PER_PAGE],
    // <<< INÍCIO DA CORREÇÃO >>>
    queryFn: async () => {
      if (!aluno?.id) throw new Error("Aluno não autenticado.");
      return apiRequest<HistoricoSessoesResponse>(
        'GET',
        `/api/aluno/meu-historico-sessoes?page=${currentPage}&limit=${SESSIONS_PER_PAGE}`,
        undefined,
        'aluno' // Especifica que o token de aluno deve ser usado
      );
    },
    // <<< FIM DA CORREÇÃO >>>
    enabled: !!aluno,
    placeholderData: (previousData) => previousData,
  });

  if (isLoadingHistorico && !historicoData) { return ( <div className="min-h-screen w-full flex items-center justify-center"> <div className="flex flex-col items-center"> <Loader2 className="h-10 w-10 animate-spin text-white mb-3" /> <p className="text-lg text-white">Carregando seu histórico...</p> </div> </div> ); }
  if (errorHistorico) { return ( <div className="p-4"> <div className="bg-red-800/80 border border-red-500 text-white p-4 rounded-lg flex items-center"> <AlertTriangle className="w-5 h-5 mr-3" /> <span>Erro: {errorHistorico.message}</span> </div> </div> ); }
  
  const formatarDataHora = (dataISO?: string): string => { if (!dataISO) return 'N/A'; try { return format(parseISO(dataISO), "dd/MM/yy 'às' HH:mm", { locale: ptBR }); } catch (e) { return 'Data inválida'; } };

  return (
    <div>
      <div className="mb-6">
        <WouterLink href="/aluno/dashboard">
            <Button variant="outline" size="sm" className="bg-white/20 hover:bg-white/30 border-white/50 text-white rounded-lg">
                <ArrowLeft className="w-4 h-4 mr-2" />
                Voltar ao Painel
            </Button>
        </WouterLink>
      </div>

      <Card className="bg-slate-50 text-gray-800 rounded-2xl shadow-lg border-0">
        <CardHeader>
          <CardTitle className="text-2xl sm:text-3xl font-bold text-indigo-700 flex items-center gap-3"><History className="w-8 h-8" />Meu Histórico de Treinos</CardTitle>
          <CardDescription>Revise seus treinos concluídos e seu feedback.</CardDescription>
        </CardHeader>
        <CardContent>
          {!historicoData || historicoData.sessoes.length === 0 ? (
            <div className="text-center py-12">
              <p className="text-gray-600">Você ainda não concluiu nenhum treino.</p>
              <p className="text-sm mt-2 text-gray-500">Comece um treino no seu painel para ver seu progresso aqui!</p>
            </div>
          ) : (
            <div className="space-y-5">
              {historicoData.sessoes.map(sessao => (
                <Card key={sessao._id} className="bg-card border border-slate-200 shadow-sm rounded-xl">
                  <CardHeader className="flex flex-row justify-between items-start pb-3">
                    <div>
                      <CardTitle className="text-lg leading-tight text-gray-900">{sessao.rotinaId?.titulo || 'Sessão Avulsa'}</CardTitle>
                      <CardDescription className="text-sm mt-1">{sessao.diaDeTreinoIdentificador || 'Detalhes não especificados'}{sessao.nomeSubFichaDia && ` - ${sessao.nomeSubFichaDia}`}</CardDescription>
                    </div>
                    {sessao.rotinaId && sessao.diaDeTreinoId && (
                      <Button variant="ghost" size="sm" className="text-xs h-8 text-indigo-600 hover:text-indigo-700" onClick={() => setSessaoSelecionada(sessao)}>
                        Ver Detalhes <Eye className="w-3 h-3 ml-1.5"/>
                      </Button>
                    )}
                  </CardHeader>
                  <CardContent className="space-y-3">
                    {sessao.pseAluno && (
                      <div className="flex items-center gap-2">
                        <Star className="w-4 h-4 text-yellow-500" />
                        <span className="font-semibold text-sm text-gray-800">PSE:</span>
                        <Badge variant={getPseBadgeVariant(sessao.pseAluno)}>{sessao.pseAluno}</Badge>
                      </div>
                    )}
                    {sessao.comentarioAluno && (
                      <div className="flex items-start gap-2">
                        <MessageSquareText className="w-4 h-4 text-blue-500 mt-1 shrink-0" />
                        <div className="text-sm">
                          <span className="font-semibold text-gray-800">Seu comentário:</span>
                          <blockquote className="mt-1 text-xs italic text-gray-600 border-l-2 pl-3">{sessao.comentarioAluno}</blockquote>
                        </div>
                      </div>
                    )}
                    <div className="flex items-center gap-2">
                      <TrendingUp className="w-4 h-4 text-green-500" />
                      <span className="font-semibold text-sm text-gray-800">Aumentou Carga:</span>
                      <span className={`text-sm font-semibold ${(sessao.aumentouCarga || false) ? 'text-green-600' : 'text-gray-500'}`}>
                        {(sessao.aumentouCarga || false) ? 'Sim' : 'Não'}
                      </span>
                    </div>
                  </CardContent>
                  <CardFooter className="text-xs text-gray-500 pt-3 pb-4 border-t">
                    <p>Finalizado em: {formatarDataHora(sessao.concluidaEm)}</p>
                  </CardFooter>
                </Card>
              ))}
            </div>
          )}

          {historicoData && historicoData.totalPages > 1 && (
            <div className="pt-6 flex items-center justify-between border-t mt-6">
              <Button variant="outline" className="border-gray-300 text-gray-700" size="sm" onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))} disabled={currentPage === 1 || isFetchingHistorico}><ChevronLeft className="w-4 h-4 mr-1" /> Anterior</Button>
              <span className="text-sm text-gray-500">Página {historicoData.currentPage} de {historicoData.totalPages}</span>
              <Button variant="outline" className="border-gray-300 text-gray-700" size="sm" onClick={() => setCurrentPage(prev => Math.min(historicoData.totalPages, prev + 1))} disabled={currentPage === historicoData.totalPages || isFetchingHistorico}>Próxima <ChevronRight className="w-4 h-4 ml-1" /></Button>
            </div>
          )}
        </CardContent>
      </Card>

      <SessaoDetalheModal 
        sessao={sessaoSelecionada} 
        onClose={() => setSessaoSelecionada(null)} 
      />

    </div>
  );
};

export default AlunoHistoricoPage;
===== ./client/src/pages/alunos/MeusTreinosPage.tsx =====
// client/src/pages/alunos/MeusTreinosPage.tsx
import { useState, useEffect } from 'react';
import { useAluno } from '../../context/AlunoContext';
import { Button } from '../../components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '../../components/ui/card';
import { Progress } from '../../components/ui/progress';
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '../../lib/queryClient';
import { Loader2, AlertTriangle, ListChecks, Star, Eye, ArrowLeft } from 'lucide-react';
import { useLocation } from 'wouter';
import { format, parseISO, isValid as isDateValidFn } from 'date-fns';
import { ptBR } from 'date-fns/locale';

// --- Interfaces e Helpers (sem alterações) ---
interface RotinaDeTreinoAluno { _id: string; titulo: string; descricao?: string; tipoOrganizacaoRotina: 'diasDaSemana' | 'numerico' | 'livre'; criadorId?: { _id: string; nome: string; } | string; dataValidade?: string | null; totalSessoesRotinaPlanejadas?: number | null; sessoesRotinaConcluidas: number; criadoEm: string; atualizadoEm?: string; }
const MeusTreinosPage: React.FC = () => {
  const { aluno, tokenAluno } = useAluno();
  const [, navigate] = useLocation();
  const [activeRotinaId, setActiveRotinaId] = useState<string | null>(() => { return localStorage.getItem(`activeRotinaId_${aluno?.id}`); });
  const { data: minhasRotinas, isLoading: isLoadingRotinas, error: errorRotinas, } = useQuery<RotinaDeTreinoAluno[], Error>({ queryKey: ['minhasRotinasAluno', aluno?.id], queryFn: async () => { if (!aluno?.id) throw new Error("Aluno não autenticado."); const rotinas = await apiRequest<RotinaDeTreinoAluno[]>('GET', '/api/aluno/meus-treinos', undefined, 'aluno'); return rotinas.sort((a, b) => new Date(b.atualizadoEm || b.criadoEm).getTime() - new Date(a.atualizadoEm || a.criadoEm).getTime()); }, enabled: !!aluno && !!tokenAluno, });
  useEffect(() => { if (minhasRotinas && minhasRotinas.length > 0) { const rotinaAtivaExiste = minhasRotinas.some(r => r._id === activeRotinaId); if (!activeRotinaId || !rotinaAtivaExiste) { const defaultActiveId = minhasRotinas[0]._id; setActiveRotinaId(defaultActiveId); if (aluno?.id) { localStorage.setItem(`activeRotinaId_${aluno.id}`, defaultActiveId); } } } }, [minhasRotinas, activeRotinaId, aluno?.id]);
  const handleSetRotinaAtiva = (id: string) => { setActiveRotinaId(id); if (aluno?.id) { localStorage.setItem(`activeRotinaId_${aluno.id}`, id); } };
  const formatarDataSimples = (dataISO?: string | null): string => { if (!dataISO) return 'N/A'; try { const dateObj = parseISO(dataISO); return isDateValidFn(dateObj) ? format(dateObj, "dd/MM/yyyy", { locale: ptBR }) : 'Data inválida'; } catch (e) { return 'Data inválida'; } };

  // --- Estados de Carregamento e Erro (Mantidos com fundo para cobrir a tela) ---
  if (isLoadingRotinas) {
    return (
      <div className="min-h-screen w-full flex items-center justify-center">
        <div className="flex flex-col items-center">
            <Loader2 className="h-10 w-10 animate-spin text-white mb-3" />
            <span className="text-lg text-white">Carregando suas rotinas...</span>
        </div>
      </div>
    );
  }
  if (errorRotinas) {
    return (
      <div className="p-4">
        <div className="bg-red-800/80 border border-red-500 text-white p-4 rounded-lg flex items-center">
          <AlertTriangle className="w-5 h-5 mr-3" />
          <span>Erro ao carregar rotinas: {errorRotinas.message}</span>
        </div>
      </div>
    );
  }

  // --- RENDERIZAÇÃO DA PÁGINA ---
  return (
    // <<< CORREÇÃO: Removidas classes de fundo e padding daqui >>>
    <div>
      <div className="flex items-center gap-4 mb-6">
         <Button variant="outline" size="icon" className="bg-white/20 hover:bg-white/30 border-white/50 text-white" onClick={() => navigate('/aluno/dashboard')}>
            <ArrowLeft className="h-4 w-4" />
         </Button>
        <div className="text-white">
            <h1 className="text-2xl md:text-3xl font-bold">Minhas Rotinas de Treino</h1>
            <p className="text-md opacity-90">Veja todas as suas fichas e escolha qual deseja seguir.</p>
        </div>
      </div>

      {minhasRotinas && minhasRotinas.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {minhasRotinas.map((rotina) => {
            const isAtiva = rotina._id === activeRotinaId;
            const progresso = rotina.totalSessoesRotinaPlanejadas ? (rotina.sessoesRotinaConcluidas / rotina.totalSessoesRotinaPlanejadas) * 100 : 0;

            return (
              <Card key={rotina._id} className={`flex flex-col transition-all bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg border-2 ${isAtiva ? 'border-indigo-500' : 'border-transparent'}`}>
                <CardHeader>
                  {isAtiva && (
                     <div className="flex items-center gap-2 text-sm font-semibold text-indigo-600 px-3 py-1 bg-indigo-100 rounded-full mb-2 w-fit-content">
                        <Star className="w-4 h-4" />
                        <span>Rotina Ativa</span>
                    </div>
                  )}
                  <CardTitle className="text-gray-900">{rotina.titulo}</CardTitle>
                  <CardDescription>{rotina.descricao || 'Sem descrição detalhada.'}</CardDescription>
                </CardHeader>
                <CardContent className="flex-grow space-y-3 text-sm text-gray-600">
                    {rotina.totalSessoesRotinaPlanejadas != null && (
                        <div>
                             <p className="font-medium text-xs mb-1 text-gray-700">
                                Progresso: <strong>{rotina.sessoesRotinaConcluidas}</strong> de <strong>{rotina.totalSessoesRotinaPlanejadas}</strong> sessões
                            </p>
                            <Progress value={progresso} className="h-2" />
                        </div>
                    )}
                    <p><strong>Organização:</strong> <span className="capitalize">{rotina.tipoOrganizacaoRotina}</span></p>
                    {rotina.dataValidade && <p><strong>Válida até:</strong> {formatarDataSimples(rotina.dataValidade)}</p>}
                </CardContent>
                <CardFooter className="flex flex-col sm:flex-row sm:flex-wrap justify-end gap-2 pt-4">
                   <Button variant="outline" className="w-full sm:w-auto border-gray-300 text-gray-700 hover:bg-gray-100 hover:text-gray-900 rounded-lg" onClick={() => navigate(`/aluno/ficha/${rotina._id}`)}>
                      <Eye className="w-4 h-4 mr-2" />
                      Ver Detalhes
                    </Button>
                  <Button className={`w-full sm:w-auto rounded-lg ${isAtiva ? 'bg-gray-400' : 'bg-indigo-600 hover:bg-indigo-700 text-white'}`} disabled={isAtiva} onClick={() => handleSetRotinaAtiva(rotina._id)}>
                    <Star className={`w-4 h-4 mr-2 ${isAtiva ? 'text-yellow-400 fill-current' : ''}`} />
                    {isAtiva ? "Já está Ativa" : "Tornar Ativa"}
                  </Button>
                </CardFooter>
              </Card>
            );
          })}
        </div>
      ) : (
        <Card className="bg-white/95 backdrop-blur-sm text-gray-800 rounded-2xl shadow-lg text-center py-12">
            <CardHeader>
                <CardTitle className="flex justify-center items-center text-xl"><ListChecks className="w-8 h-8 mr-3 text-gray-400" /></CardTitle>
            </CardHeader>
            <CardContent>
                <p className="text-lg text-gray-600">Nenhuma rotina de treino foi encontrada.</p>
                <p className="text-sm mt-2">Fale com seu personal trainer para criar uma ficha para você.</p>
            </CardContent>
        </Card>
      )}
    </div>
  );
};

export default MeusTreinosPage;
===== ./client/src/pages/alunos/[id].tsx =====
import React, { useEffect, useState } from 'react';
import { useLocation, Link } from "wouter";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { ArrowLeft, Dumbbell, Edit, Trash2, Calendar, Weight, Ruler, Target, Phone, UserCircle, Info, StickyNote, Loader2, Eye } from "lucide-react";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";
import { Aluno } from '@/types/aluno';
import { useConfirmDialog } from '@/hooks/useConfirmDialog';
import { ModalConfirmacao } from '@/components/ui/modal-confirmacao';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import TreinoFormModal from '@/components/dialogs/TreinoFormModal';
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import FichaViewModal, { FichaTreinoView } from "@/components/dialogs/FichaViewModal"; // Será renomeado para RotinaViewModal depois
import AssociarModeloAlunoModal from "@/components/dialogs/AssociarModeloAlunoModal";
import { RotinaListagemItem, DiaDeTreinoDetalhado, ExercicioEmDiaDeTreinoDetalhado } from '@/types/treinoOuRotinaTypes';

interface StudentDetailProps {
  id?: string;
}

const StudentDetail: React.FC<StudentDetailProps> = ({ id }) => {
  const studentId = id;
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { isOpen: isConfirmOpen, options: confirmOptions, openConfirmDialog, closeConfirmDialog, confirm: confirmDeleteAction } = useConfirmDialog();
  const [, navigate] = useLocation();

  const [isTreinoFormModalOpen, setIsTreinoFormModalOpen] = useState(false);
  const [fichaParaEditarOuCriar, setFichaParaEditarOuCriar] = useState<RotinaListagemItem | null>(null);
  const [isViewFichaModalOpen, setIsViewFichaModalOpen] = useState(false);
  const [fichaParaVisualizar, setFichaParaVisualizar] = useState<FichaTreinoView | null>(null);
  const [isAssociarModalOpen, setIsAssociarModalOpen] = useState(false);
  const [fichaOriginalParaAssociar, setFichaOriginalParaAssociar] = useState<{id: string; titulo: string} | null>(null);

  const isEditing = !!(fichaParaEditarOuCriar && fichaParaEditarOuCriar._id); 

  const { data: student, isLoading: isLoadingStudent, error: errorLoadingStudent } = useQuery<Aluno | null, Error>({
    queryKey: ["aluno", studentId],
    queryFn: async (): Promise<Aluno | null> => {
      if (!studentId) return null;
      try {
        const data = await apiRequest<Aluno>("GET", `/api/alunos/gerenciar/${studentId}`);
        return data;
      } catch (err: any) {
        if (err.response?.status === 404 || err.message?.includes("404")) return null;
        throw err;
      }
    },
    enabled: !!studentId,
    retry: 1,
  });

  const { data: studentWorkouts = [], isLoading: isLoadingWorkouts, error: errorLoadingWorkouts, refetch: refetchFichasAluno } = useQuery<RotinaListagemItem[], Error>({
    queryKey: ["fichasAluno", studentId],
    queryFn: async (): Promise<RotinaListagemItem[]> => {
      if (!studentId) return [];
      try {
        const dataFromApi = await apiRequest<any[]>("GET", `/api/treinos/aluno/${studentId}`);
        
        if (!Array.isArray(dataFromApi)) {
            console.warn(`API /api/treinos/aluno/${studentId} não retornou um array. Retornado:`, dataFromApi);
            return [];
        }

        return dataFromApi.map((fichaApi: any): RotinaListagemItem => {
          const diasDeTreinoProcessados = (fichaApi.diasDeTreino || []).map((diaApi: any): DiaDeTreinoDetalhado => {
            const exerciciosDoDiaProcessados = (diaApi.exerciciosDoDia || []).map((exApi: any): ExercicioEmDiaDeTreinoDetalhado => ({
              ...exApi,
              _id: exApi._id, 
              exercicioId: exApi.exercicioId, 
              series: exApi.series !== undefined ? String(exApi.series) : undefined, 
              repeticoes: exApi.repeticoes !== undefined ? String(exApi.repeticoes) : undefined, 
              carga: exApi.carga !== undefined ? String(exApi.carga) : undefined, 
              descanso: exApi.descanso !== undefined ? String(exApi.descanso) : undefined, 
              ordemNoDia: exApi.ordemNoDia ?? 0, 
              concluido: exApi.concluido ?? false, 
            }));
            return {
              ...diaApi,
              _id: diaApi._id, 
              identificadorDia: diaApi.identificadorDia, 
              ordemNaRotina: diaApi.ordemNaRotina ?? 0, 
              exerciciosDoDia: exerciciosDoDiaProcessados, 
            };
          });

          return {
            _id: fichaApi._id, 
            titulo: fichaApi.titulo, 
            descricao: fichaApi.descricao, 
            tipo: fichaApi.tipo, 
            alunoId: fichaApi.alunoId, 
            criadorId: fichaApi.criadorId, 
            tipoOrganizacaoRotina: fichaApi.tipoOrganizacaoRotina || 'numerico', 
            diasDeTreino: diasDeTreinoProcessados, 
            pastaId: fichaApi.pastaId, 
            statusModelo: fichaApi.statusModelo, 
            ordemNaPasta: fichaApi.ordemNaPasta, 
            dataValidade: fichaApi.dataValidade, 
            totalSessoesRotinaPlanejadas: fichaApi.totalSessoesRotinaPlanejadas, 
            sessoesRotinaConcluidas: fichaApi.sessoesRotinaConcluidas ?? 0, 
            criadoEm: fichaApi.criadoEm, 
            atualizadoEm: fichaApi.atualizadoEm, 
          };
        });
      } catch (err: any) {
        if (err.message?.includes("404") || (typeof err === 'object' && err !== null && 'response' in err && (err as any).response?.status === 404) ) {
            console.warn(`Nenhuma rotina encontrada para o aluno ${studentId} ou erro 404 na API (queryFn).`);
            return []; 
        }
        console.error("Erro ao buscar rotinas do aluno (queryFn):", err);
        throw err;
      }
    },
    enabled: !!studentId, 
    retry: 1, 
    initialData: [], 
  });

  const deleteMutation = useMutation<any, Error, string>({
    mutationFn: (rotinaId) => apiRequest("DELETE", `/api/treinos/${rotinaId}`), 
    onSuccess: () => {
      toast({ title: "Sucesso", description: "Rotina de treino excluída." }); 
      refetchFichasAluno(); 
    },
    onError: (error) => {
      toast({ variant: "destructive", title: "Erro ao Excluir", description: error.message || "Não foi possível excluir a rotina." }); 
    },
    onSettled: () => closeConfirmDialog(), 
  });

  const handleEditFichaClick = (rotina: RotinaListagemItem) => {
    console.log("[StudentDetail] handleEditFichaClick - Rotina recebida:", JSON.parse(JSON.stringify(rotina)));
    setFichaParaEditarOuCriar(rotina); 
    setIsTreinoFormModalOpen(true); 
  };

  const handleCreateFichaClick = () => {
    setFichaParaEditarOuCriar(null); 
    setIsTreinoFormModalOpen(true); 
  };

  const handleDeleteClick = (rotina: RotinaListagemItem) => {
    openConfirmDialog({
        titulo: "Excluir Rotina de Treino", 
        mensagem: `Tem certeza que deseja excluir a rotina "${rotina.titulo}"?`, 
        textoConfirmar: "Excluir Rotina", 
        textoCancelar: "Cancelar", 
        onConfirm: () => deleteMutation.mutate(rotina._id), 
    });
  };

  const handleViewFichaClick = (rotina: RotinaListagemItem) => {
    const todosExerciciosPlanos: ExercicioEmDiaDeTreinoDetalhado[] = (rotina.diasDeTreino || []).flatMap(
      (dia: DiaDeTreinoDetalhado) => (dia.exerciciosDoDia || []).map(
        (ex: ExercicioEmDiaDeTreinoDetalhado): ExercicioEmDiaDeTreinoDetalhado => ({ ...ex })
      )
    );
    const fichaViewData: FichaTreinoView = {
        _id: rotina._id, 
        titulo: rotina.titulo, 
        descricao: rotina.descricao, 
        tipo: rotina.tipo, 
        alunoId: rotina.alunoId, 
        criadorId: rotina.criadorId, 
        diasDeTreino: rotina.diasDeTreino || [], 
        exercicios: todosExerciciosPlanos,  
        criadoEm: rotina.criadoEm, 
        atualizadoEm: rotina.atualizadoEm, 
        statusModelo: rotina.statusModelo, 
        tipoOrganizacaoRotina: rotina.tipoOrganizacaoRotina, 
    };
    setFichaParaVisualizar(fichaViewData); 
    setIsViewFichaModalOpen(true); 
  };

  const handleTriggerEditFichaFromView = (fichaFromView: FichaTreinoView) => {
      setIsViewFichaModalOpen(false); 
      const fichaOriginal = studentWorkouts.find(f => f._id === fichaFromView._id); 
      if (fichaOriginal) {
        handleEditFichaClick(fichaOriginal); 
      } else {
        toast({ title: "Erro", description: "Não foi possível encontrar a rotina original para edição.", variant: "destructive"}); 
      }
  };

  const handleTriggerCopyFichaFromView = (fichaId: string, fichaTitulo: string, tipoFichaOriginal?: "modelo" | "individual") => {
    setIsViewFichaModalOpen(false); 
    setFichaOriginalParaAssociar({ id: fichaId, titulo: fichaTitulo }); 
    setIsAssociarModalOpen(true); 
  };

  const handleTreinoFormSuccess = () => {
      refetchFichasAluno(); 
      setIsTreinoFormModalOpen(false); 
      setFichaParaEditarOuCriar(null); 
  };

  if (isLoadingStudent) return <LoadingSpinner text="Carregando dados do aluno..." />; 
  if (!studentId) return <ErrorMessage title="Erro" message="ID do aluno não fornecido na URL."/>; 
  if (!isLoadingStudent && !errorLoadingStudent && !student) { return <ErrorMessage title="Não Encontrado" message={`Aluno com ID "${studentId}" não encontrado.`} />; 
  }
  if (errorLoadingStudent) { return <ErrorMessage title="Erro ao Carregar Aluno" message={errorLoadingStudent.message} />; 
  }

  const formatDate = (dateString?: string): string => {
      if (!dateString) return 'Não informado'; 
      try {
          const date = new Date(dateString); 
          if (isNaN(date.getTime())) return dateString; 
          return date.toLocaleDateString('pt-BR', { timeZone: 'UTC' }); 
      } catch (e) {
          return dateString; 
      }
  };

  const renderFichasContent = () => {
    if (isLoadingWorkouts) {
      return <LoadingSpinner text="Carregando rotinas..." />; 
    }
    if (errorLoadingWorkouts) {
      return <ErrorMessage title="Erro ao Carregar Rotinas" message={errorLoadingWorkouts.message} />; 
    }
    if (Array.isArray(studentWorkouts) && studentWorkouts.length > 0) { 
      return (
        <div className="space-y-4">
          {studentWorkouts.map((rotina) => ( 
            <div key={rotina._id} className="border rounded-lg p-4 shadow-sm dark:border-gray-700 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3">
              <div className="flex-grow">
                <h3 className="font-semibold text-lg text-gray-900 dark:text-gray-100 mb-1">{rotina.titulo}</h3> 
                {rotina.descricao && <p className="text-sm text-muted-foreground mb-2">{rotina.descricao}</p>} 
                <p className="text-xs text-muted-foreground">
                  Criada em: {formatDate(rotina.criadoEm)}
                </p>
              </div>
       
              <div className="flex-shrink-0 flex gap-2 self-start sm:self-center"> 
                <Button variant="outline" size="icon" className="h-8 w-8" title="Visualizar Rotina" onClick={() => handleViewFichaClick(rotina)}> <Eye className="w-4 h-4" /> </Button> 
                <Button variant="outline" size="icon" className="h-8 w-8" title="Editar Rotina" onClick={() => handleEditFichaClick(rotina)} disabled={deleteMutation.isPending} > <Edit className="w-4 h-4" /> </Button> 
                <Button variant="destructive" size="icon" className="h-8 w-8" title="Excluir Rotina" onClick={() => handleDeleteClick(rotina)} 
                  disabled={deleteMutation.isPending && deleteMutation.variables === rotina._id} > 
                  {deleteMutation.isPending && deleteMutation.variables === rotina._id ? ( <Loader2 className="w-4 h-4 animate-spin" /> ) : ( <Trash2 className="w-4 h-4" /> )} 
                </Button>
              </div>
            </div>
          ))}
        </div>
      );
    }
    return <p className="text-center py-6 text-gray-600 dark:text-gray-400">Este aluno ainda não possui rotinas de treino atribuídas.</p>; 
  };

  return (
    <div className="container mx-auto py-8 px-4"> 
      <div className="mb-6">
        <Button variant="outline" onClick={() => navigate("/alunos")} >
          <ArrowLeft className="w-4 h-4 mr-2" />
           Voltar para Lista de Alunos
        </Button>
      </div>

      <Card className="mb-8">
        <CardHeader>
          <CardTitle className="flex items-center justify-between"> 
             <span>Detalhes de {student?.nome}</span>
             <Link href={`/alunos/editar/${studentId}`}>
               <Button variant="outline" size="sm">
                 <Edit className="w-4 h-4 mr-2" /> Editar Aluno
               </Button>
             </Link>
          </CardTitle> 
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-3 text-sm">
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <UserCircle className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Nome:</strong> {student?.nome ?? 'Não informado'}</span> 
              </div>
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-gray-500 dark:text-gray-400 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}> <path strokeLinecap="round" strokeLinejoin="round" d="M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.206" /> </svg>
                <span><strong>Email:</strong> {student?.email ?? 'Não informado'}</span> 
              </div>
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <Phone className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Telefone:</strong> {student?.phone ?? 'Não informado'}</span> 
              </div>
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <Calendar className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Data de Nasc.:</strong> {formatDate(student?.birthDate)}</span>
              </div>
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300"> 
                <Info className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Gênero:</strong> {student?.gender ?? 'Não informado'}</span> 
              </div>
          </div>
           <Separator className="my-4" />
           <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-3 text-sm">
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <Weight className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Peso:</strong> {student?.weight ? `${student.weight} kg` : 'Não informado'}</span> 
              </div>
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <Ruler className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Altura:</strong> {student?.height ? `${student.height} cm` : 'Não informado'}</span> 
              </div>
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <Target className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Objetivo:</strong> {student?.goal ?? 'Não informado'}</span> 
              </div>
              <div className="flex items-center gap-2 text-gray-700 dark:text-gray-300">
                <Calendar className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                <span><strong>Data de Início:</strong> {formatDate(student?.startDate)}</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-gray-700 dark:text-gray-300"> 
                 <Info className="w-5 h-5 text-gray-500 dark:text-gray-400 flex-shrink-0" />
                 <strong>Status:</strong>
                 <Badge variant={student?.status === 'active' ? 'success' : 'secondary'} className="ml-1"> 
                     {student?.status === 'active' ? 'Ativo' : 'Inativo'} 
                 </Badge>
              </div>
            </div>
           {student?.notes && (
               <>
                  <Separator className="my-4" />
                  <div className="flex items-start gap-2 text-sm text-gray-700 dark:text-gray-300"> 
                      <StickyNote className="w-5 h-5 text-gray-500 dark:text-gray-400 mt-1 flex-shrink-0" />
                      <div>
                          <strong>Observações:</strong>
                          <p className="mt-1 whitespace-pre-wrap">{student.notes}</p> 
                      </div>
                  </div>
               </>
           )}
        </CardContent>
      </Card> 

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            Rotinas de Treino Atribuídas
            <Button size="sm" onClick={handleCreateFichaClick} disabled={!studentId || !student}> 
              <Dumbbell className="w-4 h-4 mr-2" /> Nova Rotina para {student?.nome?.split(' ')[0]}
            </Button> 
          </CardTitle>
        </CardHeader>
        <CardContent>
          {renderFichasContent()}
        </CardContent>
      </Card> 

      {isTreinoFormModalOpen && (
          <TreinoFormModal
              open={isTreinoFormModalOpen}
              onClose={() => {setIsTreinoFormModalOpen(false); setFichaParaEditarOuCriar(null);}}
              onSuccess={handleTreinoFormSuccess}
              alunos={student ? [student] : []}
              rotinaParaEditar={fichaParaEditarOuCriar} 
              alunoId={!(fichaParaEditarOuCriar && fichaParaEditarOuCriar._id) ? studentId : undefined}
          />
      )}
      {isViewFichaModalOpen && fichaParaVisualizar && (
          <FichaViewModal
              isOpen={isViewFichaModalOpen}
              onClose={() => setIsViewFichaModalOpen(false)}
              ficha={fichaParaVisualizar} 
              onEditFicha={handleTriggerEditFichaFromView}
              onUseOuCopiarFicha={handleTriggerCopyFichaFromView}
          />
      )}
      {isAssociarModalOpen && fichaOriginalParaAssociar && (
        <AssociarModeloAlunoModal
            isOpen={isAssociarModalOpen}
            onClose={() => setIsAssociarModalOpen(false)} 
            fichaModeloId={fichaOriginalParaAssociar.id} 
            fichaModeloTitulo={fichaOriginalParaAssociar.titulo} 
        />
      )}
      <ModalConfirmacao
        isOpen={isConfirmOpen}
        onClose={closeConfirmDialog}
        onConfirm={confirmDeleteAction}
        titulo={confirmOptions.titulo}
        mensagem={confirmOptions.mensagem}
        textoConfirmar={confirmOptions.textoConfirmar}
        textoCancelar={confirmOptions.textoCancelar} 
        isLoadingConfirm={deleteMutation.isPending} 
      />
    </div>
  );
}

export default StudentDetail; 
===== ./client/src/pages/alunos/edit.tsx =====
// client/src/pages/alunos/edit.tsx
import React from 'react';
import { Link, useLocation, useParams } from 'wouter'; 
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { StudentForm, StudentFormDataProcessed } from '@/forms/student-form';
import { ChevronLeft } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { fetchWithAuth } from '@/lib/apiClient';
import { Aluno } from '@/types/aluno';
import ErrorMessage from '@/components/ErrorMessage';
import LoadingSpinner from '@/components/LoadingSpinner';

const EditStudentPage: React.FC = () => {
    const params = useParams<{ id: string }>();
    const studentId = params.id;
    const [, setLocation] = useLocation();
    const queryClient = useQueryClient();
    const { toast } = useToast();

    // <<< CORREÇÃO AQUI: Atualizado o caminho da API e a queryKey >>>
    const { data: studentData, isLoading, isError, error } = useQuery<Aluno, Error>({
        queryKey: ['aluno', studentId], // Chave mais específica
        queryFn: () => fetchWithAuth<Aluno>(`/api/aluno/gerenciar/${studentId}`),
        enabled: !!studentId,
    });

    // <<< CORREÇÃO AQUI: Atualizado o caminho da API >>>
    const mutation = useMutation<Aluno, Error, StudentFormDataProcessed>({
        mutationFn: (updatedData) => fetchWithAuth<Aluno>(`/api/aluno/gerenciar/${studentId}`, {
            method: 'PUT',
            body: JSON.stringify(updatedData),
        }),
        onSuccess: (updatedStudent) => {
            toast({ title: "Sucesso!", description: `${updatedStudent.nome} atualizado com sucesso.` });
            queryClient.invalidateQueries({ queryKey: ['/api/aluno/gerenciar'] });
            queryClient.invalidateQueries({ queryKey: ['aluno', studentId] });
            setLocation('/alunos');
        },
        onError: (error) => {
            toast({ variant: "destructive", title: "Erro ao atualizar", description: error.message });
        },
    });

    if (isLoading) return <LoadingSpinner text="Carregando dados do aluno..." />;
    if (isError) return <ErrorMessage title="Erro ao carregar" message={error?.message || "Não foi possível encontrar o aluno."} />;

    return (
        <div className="p-4 md:p-6 lg:p-8">
            <Link href="/alunos" className="inline-flex items-center mb-4 text-sm text-primary hover:text-primary/90">
                <ChevronLeft className="w-4 h-4 mr-1" /> Voltar para Alunos
            </Link>

            <Card className="max-w-3xl mx-auto">
                <CardHeader>
                    <CardTitle>Editar Aluno</CardTitle>
                    <CardDescription>Atualize os dados de {studentData?.nome}.</CardDescription>
                </CardHeader>
                <CardContent>
                    <StudentForm
                        initialData={studentData}
                        isEditing={true}
                        onSubmit={(formData) => mutation.mutate(formData)}
                        isLoading={mutation.isPending}
                    />
                </CardContent>
            </Card>
        </div>
    );
}

export default EditStudentPage;
===== ./client/src/pages/alunos/index.tsx =====
// client/src/pages/alunos/index.tsx
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Link } from "wouter";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Eye, Pencil, Plus, Search, UserX, Mail, MoreVertical } from "lucide-react";
import { fetchWithAuth } from "@/lib/apiClient";
import { useToast } from "@/hooks/use-toast";
import { ModalConfirmacao } from "@/components/ui/modal-confirmacao";
import { useConfirmDialog } from "@/hooks/useConfirmDialog";
import ErrorMessage from "@/components/ErrorMessage";
import { Aluno } from "@/types/aluno";
import AlunoViewModal from "@/components/dialogs/AlunoViewModal";
import GerarConviteAlunoModal from "@/components/dialogs/GerarConviteAlunoModal";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";

const AlunoCard = ({ student, onView, onDelete }: { student: Aluno, onView: (s: Aluno) => void, onDelete: (s: Aluno) => void }) => {
    const getInitials = (nome: string) => {
        const partes = nome.split(' ').filter(Boolean);
        if (partes.length > 1) return `${partes[0][0]}${partes[partes.length - 1][0]}`.toUpperCase();
        return partes[0] ? partes[0].substring(0, 2).toUpperCase() : '?';
    };

    return (
        <div className="group relative flex items-center justify-between p-4 md:p-5 border-b last:border-b-0
                       hover:bg-gradient-to-r hover:from-blue-50/80 hover:via-indigo-50/40 hover:to-purple-50/80 
                       dark:hover:from-blue-900/20 dark:hover:via-indigo-900/10 dark:hover:to-purple-900/20 
                       transition-all duration-300 ease-out
                       hover:shadow-md hover:-translate-y-0.5 rounded-lg mx-2">
            
            {/* Background gradient overlay on hover */}
            <div className="absolute inset-0 bg-gradient-to-r from-blue-500/5 via-indigo-500/5 to-purple-500/5 
                           opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg" />
            
            <div className="relative flex items-center gap-3 md:gap-4 flex-1 min-w-0">
                <Avatar className="ring-2 ring-blue-100 dark:ring-blue-900/30 
                                 group-hover:ring-blue-200 dark:group-hover:ring-blue-800/50
                                 group-hover:scale-110 transition-all duration-300 
                                 shadow-lg group-hover:shadow-xl">
                    <AvatarFallback className="bg-gradient-to-br from-blue-500 via-indigo-500 to-purple-600 
                                             text-white font-semibold text-xs md:text-sm
                                             group-hover:from-blue-600 group-hover:via-indigo-600 group-hover:to-purple-700">
                        {getInitials(student.nome)}
                    </AvatarFallback>
                </Avatar>
                <div className="flex flex-col flex-1 min-w-0 space-y-1">
                    <h4 className="font-semibold text-sm md:text-base text-gray-800 dark:text-gray-100 
                                  group-hover:text-blue-700 dark:group-hover:text-blue-300 
                                  transition-colors duration-300 truncate">
                        {student.nome}
                    </h4>
                    <p className="text-xs md:text-sm text-gray-500 dark:text-gray-400 
                                 group-hover:text-gray-600 dark:group-hover:text-gray-300 
                                 transition-colors duration-300 truncate">
                        {student.email}
                    </p>
                </div>
            </div>
            
            <div className="relative flex items-center gap-2">
                <Badge variant={student.status === "active" ? "default" : "destructive"} 
                       className={`hidden sm:inline-flex px-3 py-1 text-xs font-semibold rounded-full
                                 ${student.status === "active" 
                                   ? 'bg-gradient-to-r from-emerald-500 to-green-600 text-white shadow-emerald-500/25' 
                                   : 'bg-gradient-to-r from-red-500 to-pink-600 text-white shadow-red-500/25'
                                 }
                                 transition-all duration-300 group-hover:scale-105`}>
                    {student.status === "active" ? "Ativo" : "Inativo"}
                </Badge>
                
                <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                        <Button variant="ghost" 
                                size="icon" 
                                className="relative h-9 w-9 md:h-10 md:w-10 min-h-[44px] min-w-[44px] 
                                         hover:bg-white/80 dark:hover:bg-slate-700/80 
                                         hover:shadow-lg hover:scale-110 
                                         active:scale-95 transition-all duration-200 
                                         group-hover:bg-white/50 dark:group-hover:bg-slate-600/50
                                         backdrop-blur-sm border border-transparent
                                         hover:border-blue-200 dark:hover:border-blue-700 rounded-lg">
                            <MoreVertical className="h-4 w-4 text-gray-600 dark:text-gray-300 
                                                   hover:text-blue-600 dark:hover:text-blue-400 
                                                   transition-colors duration-200" />
                        </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end" 
                                       className="bg-white/95 dark:bg-slate-800/95 backdrop-blur-md 
                                                border border-white/20 dark:border-slate-700/50 
                                                shadow-xl rounded-lg animate-in fade-in-0 zoom-in-95 
                                                slide-in-from-top-2 duration-200">
                        <DropdownMenuItem onClick={() => onView(student)}
                                        className="hover:bg-blue-50 dark:hover:bg-blue-900/30 
                                                 focus:bg-blue-50 dark:focus:bg-blue-900/30 
                                                 transition-colors duration-200 cursor-pointer">
                            <Eye className="mr-2 h-4 w-4 text-blue-600 dark:text-blue-400" /> 
                            <span className="font-medium">Visualizar</span>
                        </DropdownMenuItem>
                        
                        <Link href={`/alunos/editar/${student._id}`} 
                              className="flex items-center px-2 py-1.5 text-sm rounded-md 
                                       hover:bg-indigo-50 dark:hover:bg-indigo-900/30 
                                       transition-colors duration-200 cursor-pointer">
                            <Pencil className="mr-2 h-4 w-4 text-indigo-600 dark:text-indigo-400" /> 
                            <span className="font-medium">Editar</span>
                        </Link>
                        
                        <DropdownMenuItem className="text-red-600 dark:text-red-400 
                                                   hover:bg-red-50 dark:hover:bg-red-900/30 
                                                   focus:bg-red-50 dark:focus:bg-red-900/30
                                                   transition-colors duration-200" 
                                        onClick={() => onDelete(student)}>
                            <UserX className="mr-2 h-4 w-4" /> 
                            <span className="font-medium">Remover</span>
                        </DropdownMenuItem>
                    </DropdownMenuContent>
                </DropdownMenu>
            </div>
        </div>
    );
};


export default function StudentsIndex() {
    const { toast } = useToast();
    const queryClient = useQueryClient();
    const { isOpen: isConfirmOpen, options: confirmOptions, openConfirmDialog, closeConfirmDialog, confirm: confirmAction } = useConfirmDialog();
    const [searchQuery, setSearchQuery] = useState("");
    const [selectedStudent, setSelectedStudent] = useState<Aluno | null>(null);
    const [isViewModalOpen, setIsViewModalOpen] = useState(false);
    const [isInviteModalOpen, setIsInviteModalOpen] = useState(false);

    console.log("Fetching students data...");
    const { data: students = [], isLoading, isError, error } = useQuery<Aluno[], Error>({
        queryKey: ['/api/aluno/gerenciar'],
        queryFn: () => {
            console.log("Executing fetchWithAuth for /api/aluno/gerenciar");
            return fetchWithAuth<Aluno[]>("/api/aluno/gerenciar");
        },
        retry: 1,
    });
    console.log("Students data:", students);
    console.log("Is Loading:", isLoading);
    console.log("Is Error:", isError);
    if (isError) {
        console.error("Error fetching students:", error);
    }

    const deleteStudentMutation = useMutation<any, Error, string>({
        mutationFn: (alunoId: string) => {
            console.log("Deleting student with ID:", alunoId);
            return fetchWithAuth(`/api/aluno/gerenciar/${alunoId}`, { method: 'DELETE' });
        },
        onSuccess: () => {
            console.log("Student deleted successfully.");
            toast({ title: "Aluno Removido", description: `O aluno foi removido com sucesso.` });
            queryClient.invalidateQueries({ queryKey: ['/api/aluno/gerenciar'] });
        },
        onError: (error) => {
            console.error("Error deleting student:", error);
            toast({ variant: "destructive", title: "Erro ao Remover", description: error.message || "Não foi possível remover o aluno." });
        },
        onSettled: () => closeConfirmDialog(),
    });

    const filteredStudents = students.filter((student) => {
        return (student.nome || "").toLowerCase().includes(searchQuery.toLowerCase()) ||
               (student.email || "").toLowerCase().includes(searchQuery.toLowerCase());
    });
    console.log("Filtered students:", filteredStudents);

    const handleDeleteClick = (aluno: Aluno) => {
        console.log("Handle delete click for student:", aluno.nome);
        openConfirmDialog({
            titulo: "Remover Aluno",
            mensagem: `Tem certeza que deseja remover o aluno ${aluno.nome}?`,
            onConfirm: () => deleteStudentMutation.mutate(aluno._id),
        });
    };

    const handleViewClick = (student: Aluno) => {
        console.log("Handle view click for student:", student.nome);
        setSelectedStudent(student);
        setIsViewModalOpen(true);
    };

    return (
        <div className="p-4 md:p-6 lg:p-8 min-h-screen 
                       bg-gradient-to-br from-blue-50/60 via-indigo-50/40 to-purple-50/60 
                       dark:from-slate-900 dark:via-slate-800/95 dark:to-indigo-900/80">
            <Card className="relative overflow-hidden border-0 shadow-2xl hover:shadow-3xl 
                           bg-white/90 dark:bg-slate-800/90 backdrop-blur-md 
                           transition-all duration-500 rounded-xl">
                
                {/* Gradient background overlay */}
                <div className="absolute inset-0 bg-gradient-to-br from-blue-50/30 via-indigo-50/20 to-purple-50/30 
                               dark:from-blue-900/10 dark:via-indigo-900/5 dark:to-purple-900/10" />
                
                <CardHeader className="relative flex flex-col sm:flex-row sm:items-center sm:justify-between 
                                     px-6 py-6 md:px-8 md:py-8 border-b border-gray-100 dark:border-slate-700/50 
                                     bg-white/50 dark:bg-slate-800/50 backdrop-blur-sm">
                    <div className="space-y-2 mb-4 sm:mb-0">
                        <CardTitle className="text-2xl md:text-3xl font-bold bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 
                                           dark:from-blue-400 dark:via-indigo-400 dark:to-purple-400 
                                           bg-clip-text text-transparent">
                            Gerenciar Alunos
                        </CardTitle>
                        <p className="text-gray-600 dark:text-gray-400 text-sm md:text-base leading-relaxed">
                            Visualize e gerencie todos os seus alunos cadastrados.
                        </p>
                    </div>
                    
                    <div className="flex flex-col sm:flex-row gap-3 sm:gap-4 w-full sm:w-auto">
                        <div className="relative flex-1 sm:flex-none">
                            <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400 h-4 w-4" />
                            <Input type="search" 
                                   placeholder="Pesquisar alunos..." 
                                   className="pl-10 w-full sm:w-64 md:w-72 h-11 
                                            bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm
                                            border border-gray-200/60 dark:border-slate-700/60 
                                            rounded-lg shadow-sm hover:shadow-md
                                            focus:ring-2 focus:ring-blue-500/30 dark:focus:ring-blue-400/30
                                            focus:border-blue-400 dark:focus:border-blue-500
                                            transition-all duration-300 ease-out
                                            hover:bg-white dark:hover:bg-slate-800" 
                                   value={searchQuery} 
                                   onChange={(e) => setSearchQuery(e.target.value)} />
                        </div>
                        
                        <Button variant="outline" 
                                onClick={() => setIsInviteModalOpen(true)}
                                className="min-h-[44px] px-4 py-2 border-2 border-indigo-200 dark:border-indigo-700
                                         bg-gradient-to-r from-indigo-50 to-purple-50 
                                         dark:from-indigo-900/30 dark:to-purple-900/30 
                                         hover:from-indigo-100 hover:to-purple-100
                                         dark:hover:from-indigo-800/40 dark:hover:to-purple-800/40
                                         text-indigo-700 dark:text-indigo-400
                                         hover:border-indigo-300 dark:hover:border-indigo-600
                                         shadow-md hover:shadow-lg transition-all duration-300
                                         hover:scale-105 active:scale-95 rounded-lg">
                            <Mail className="h-4 w-4 mr-2" /> 
                            Convidar Aluno
                        </Button>
                        
                        <Link href="/alunos/novo">
                            <Button className="min-h-[44px] px-4 py-2 font-semibold
                                             bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-600 
                                             hover:from-blue-600 hover:via-indigo-600 hover:to-purple-700 
                                             text-white shadow-lg hover:shadow-xl 
                                             transition-all duration-300 ease-out
                                             hover:scale-105 active:scale-95 
                                             border-0 rounded-lg">
                                <Plus className="h-4 w-4 mr-2" /> 
                                <span className="hidden sm:inline">Adicionar</span> Aluno
                            </Button>
                        </Link>
                    </div>
                </CardHeader>
                <CardContent className="relative p-0">
                    {/* Desktop Table View */}
                    <div className="hidden md:block overflow-x-auto">
                        <Table>
                            <TableHeader className="bg-gradient-to-r from-gray-50 to-gray-100 
                                                  dark:from-slate-800/50 dark:to-slate-700/50 
                                                  backdrop-blur-sm">
                                <TableRow className="border-b border-gray-200 dark:border-slate-700">
                                    <TableHead className="pl-6 py-4 text-sm font-semibold text-gray-700 dark:text-gray-300">
                                        Aluno
                                    </TableHead>
                                    <TableHead className="py-4 text-sm font-semibold text-gray-700 dark:text-gray-300">
                                        Email
                                    </TableHead>
                                    <TableHead className="py-4 text-sm font-semibold text-gray-700 dark:text-gray-300">
                                        Status
                                    </TableHead>
                                    <TableHead className="text-right pr-6 py-4 text-sm font-semibold text-gray-700 dark:text-gray-300">
                                        Ações
                                    </TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody className="divide-y divide-gray-100 dark:divide-slate-700/50">
                                {isLoading ? (
                                    // Enhanced skeleton loader for desktop table
                                    [...Array(5)].map((_, i) => (
                                        <TableRow key={`skeleton-table-${i}`} 
                                                className="hover:bg-gray-50/50 dark:hover:bg-slate-800/50">
                                            <TableCell className="pl-6 py-6">
                                                <div className="flex items-center gap-3">
                                                    <Skeleton className="h-10 w-10 rounded-full bg-gradient-to-br from-gray-200 to-gray-300 
                                                                       dark:from-slate-600 dark:to-slate-700" />
                                                    <Skeleton className="h-5 w-32 bg-gradient-to-r from-gray-200 to-gray-300 
                                                                       dark:from-slate-600 dark:to-slate-700 rounded-full" />
                                                </div>
                                            </TableCell>
                                            <TableCell className="py-6">
                                                <Skeleton className="h-4 w-48 bg-gradient-to-r from-gray-200 to-gray-300 
                                                                   dark:from-slate-600 dark:to-slate-700 rounded-full" />
                                            </TableCell>
                                            <TableCell className="py-6">
                                                <Skeleton className="h-6 w-16 bg-gradient-to-r from-gray-200 to-gray-300 
                                                                   dark:from-slate-600 dark:to-slate-700 rounded-full" />
                                            </TableCell>
                                            <TableCell className="text-right pr-6 py-6">
                                                <div className="flex justify-end gap-1">
                                                    <Skeleton className="h-9 w-9 bg-gradient-to-br from-gray-200 to-gray-300 
                                                                       dark:from-slate-600 dark:to-slate-700 rounded-lg" />
                                                    <Skeleton className="h-9 w-9 bg-gradient-to-br from-gray-200 to-gray-300 
                                                                       dark:from-slate-600 dark:to-slate-700 rounded-lg" />
                                                    <Skeleton className="h-9 w-9 bg-gradient-to-br from-gray-200 to-gray-300 
                                                                       dark:from-slate-600 dark:to-slate-700 rounded-lg" />
                                                </div>
                                            </TableCell>
                                        </TableRow>
                                    ))
                                ) : isError ? (
                                    // Error message for desktop table
                                    <TableRow>
                                        <TableCell colSpan={4} className="py-12">
                                            <ErrorMessage title="Erro ao Carregar" message={error.message} />
                                        </TableCell>
                                    </TableRow>
                                ) : (
                                    // Actual data for desktop table
                                    filteredStudents.map((student, index) => (
                                        <TableRow key={student._id} 
                                                className="group hover:bg-gradient-to-r hover:from-blue-50/50 hover:to-indigo-50/50 
                                                         dark:hover:from-blue-900/10 dark:hover:to-indigo-900/10 
                                                         transition-all duration-300 animate-in fade-in-0 slide-in-from-bottom-2"
                                                style={{ animationDelay: `${index * 50}ms` }}>
                                            <TableCell className="pl-6 py-5">
                                                <div className="flex items-center gap-3">
                                                    <Avatar className="ring-2 ring-blue-100 dark:ring-blue-900/30 
                                                                     group-hover:ring-blue-200 dark:group-hover:ring-blue-800/50
                                                                     transition-all duration-300 shadow-sm group-hover:shadow-md">
                                                        <AvatarFallback className="bg-gradient-to-br from-blue-500 via-indigo-500 to-purple-600 
                                                                                 text-white font-semibold text-sm">
                                                            {student.nome.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2)}
                                                        </AvatarFallback>
                                                    </Avatar>
                                                    <span className="font-semibold text-gray-800 dark:text-gray-100 
                                                                   group-hover:text-blue-700 dark:group-hover:text-blue-300 
                                                                   transition-colors duration-300">
                                                        {student.nome}
                                                    </span>
                                                </div>
                                            </TableCell>
                                            <TableCell className="py-5 text-gray-600 dark:text-gray-400 
                                                               group-hover:text-gray-700 dark:group-hover:text-gray-300 
                                                               transition-colors duration-300">
                                                {student.email}
                                            </TableCell>
                                            <TableCell className="py-5">
                                                <Badge variant={student.status === "active" ? "default" : "destructive"} 
                                                       className={`px-3 py-1 text-xs font-semibold rounded-full transition-all duration-300
                                                                 ${student.status === "active" 
                                                                   ? 'bg-gradient-to-r from-emerald-500 to-green-600 text-white shadow-emerald-500/25' 
                                                                   : 'bg-gradient-to-r from-red-500 to-pink-600 text-white shadow-red-500/25'
                                                                 }
                                                                 group-hover:scale-105`}>
                                                    {student.status === "active" ? "Ativo" : "Inativo"}
                                                </Badge>
                                            </TableCell>
                                            <TableCell className="pr-6 py-5 text-right">
                                                <div className="flex justify-end items-center gap-1">
                                                    <Button variant="ghost" 
                                                            size="icon" 
                                                            onClick={() => handleViewClick(student)} 
                                                            title="Visualizar"
                                                            className="h-9 w-9 hover:bg-blue-100 dark:hover:bg-blue-900/30 
                                                                     hover:text-blue-700 dark:hover:text-blue-400
                                                                     transition-all duration-200 rounded-lg
                                                                     hover:scale-110 active:scale-95">
                                                        <Eye className="h-4 w-4" />
                                                    </Button>
                                                    
                                                    <Link href={`/alunos/editar/${student._id}`} 
                                                          className="inline-flex items-center justify-center h-9 w-9 
                                                                   rounded-lg text-sm font-medium transition-all duration-200
                                                                   hover:bg-indigo-100 dark:hover:bg-indigo-900/30 
                                                                   hover:text-indigo-700 dark:hover:text-indigo-400
                                                                   hover:scale-110 active:scale-95" 
                                                          title="Editar">
                                                        <Pencil className="h-4 w-4" />
                                                    </Link>

                                                    <Button variant="ghost" 
                                                            size="icon" 
                                                            className="h-9 w-9 hover:bg-red-100 dark:hover:bg-red-900/30 
                                                                     hover:text-red-700 dark:hover:text-red-400
                                                                     transition-all duration-200 rounded-lg
                                                                     hover:scale-110 active:scale-95" 
                                                            onClick={() => handleDeleteClick(student)} 
                                                            title="Remover">
                                                        <UserX className="h-4 w-4" />
                                                    </Button>
                                                </div>
                                            </TableCell>
                                        </TableRow>
                                    ))
                                )}
                            </TableBody>
                        </Table>
                    </div>

                    {/* Mobile Card View */}
                    <div className="md:hidden">
                        {isLoading ? (
                            // Enhanced skeleton loader for mobile cards
                            <div className="p-4 space-y-4">
                                {[...Array(5)].map((_, i) => (
                                    <div key={`skeleton-card-${i}`} 
                                         className="flex items-center justify-between p-4 bg-gray-50/50 dark:bg-slate-700/30 
                                                  rounded-lg animate-pulse">
                                        <div className="flex items-center gap-3">
                                            <Skeleton className="h-12 w-12 rounded-full bg-gradient-to-br from-gray-200 to-gray-300 
                                                               dark:from-slate-600 dark:to-slate-700" />
                                            <div className="flex flex-col gap-2">
                                                <Skeleton className="h-4 w-28 bg-gradient-to-r from-gray-200 to-gray-300 
                                                                   dark:from-slate-600 dark:to-slate-700 rounded-full" />
                                                <Skeleton className="h-3 w-36 bg-gradient-to-r from-gray-200 to-gray-300 
                                                                   dark:from-slate-600 dark:to-slate-700 rounded-full" />
                                            </div>
                                        </div>
                                        <Skeleton className="h-10 w-10 bg-gradient-to-br from-gray-200 to-gray-300 
                                                           dark:from-slate-600 dark:to-slate-700 rounded-lg" />
                                    </div>
                                ))}
                            </div>
                        ) : isError ? (
                            // Error message for mobile cards
                            <div className="p-6">
                                <ErrorMessage title="Erro ao Carregar" message={error.message} />
                            </div>
                        ) : (
                            // Actual data for mobile cards
                            <div className="divide-y divide-gray-100 dark:divide-slate-700/50">
                                {filteredStudents.map((student, index) => (
                                    <div key={student._id} 
                                         className="animate-in fade-in-0 slide-in-from-bottom-2 duration-300"
                                         style={{ animationDelay: `${index * 100}ms` }}>
                                        <AlunoCard student={student} onView={handleViewClick} onDelete={handleDeleteClick} />
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* Empty State */}
                    {!isLoading && !isError && filteredStudents.length === 0 && (
                        <div className="flex flex-col items-center justify-center py-16 px-4">
                            <div className="text-center space-y-4 max-w-md">
                                <div className="mx-auto w-20 h-20 bg-gradient-to-br from-gray-100 to-gray-200 
                                               dark:from-slate-700 dark:to-slate-800 rounded-full flex items-center justify-center">
                                    <Search className="h-8 w-8 text-gray-400 dark:text-slate-500" />
                                </div>
                                <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-300">
                                    {students.length > 0 ? "Nenhum aluno encontrado" : "Nenhum aluno cadastrado"}
                                </h3>
                                <p className="text-sm text-gray-500 dark:text-gray-400 leading-relaxed">
                                    {students.length > 0 
                                        ? "Tente ajustar sua busca para encontrar o aluno desejado."
                                        : "Comece adicionando seus primeiros alunos para gerenciar seus treinos."
                                    }
                                </p>
                                {students.length === 0 && (
                                    <Link href="/alunos/novo" className="inline-block mt-4">
                                        <Button className="min-h-[44px] bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-600 
                                                         hover:from-blue-600 hover:via-indigo-600 hover:to-purple-700 
                                                         text-white shadow-lg hover:shadow-xl 
                                                         transition-all duration-300 ease-out
                                                         hover:scale-105 active:scale-95 border-0 rounded-lg">
                                            <Plus className="h-4 w-4 mr-2" />
                                            Adicionar Primeiro Aluno
                                        </Button>
                                    </Link>
                                )}
                            </div>
                        </div>
                    )}
                </CardContent>
            </Card>

            <AlunoViewModal aluno={selectedStudent} open={isViewModalOpen} onOpenChange={setIsViewModalOpen} />
            <ModalConfirmacao isOpen={isConfirmOpen} onClose={closeConfirmDialog} onConfirm={confirmAction} titulo={confirmOptions.titulo} mensagem={confirmOptions.mensagem} isLoadingConfirm={deleteStudentMutation.isPending}/>
            
            <GerarConviteAlunoModal isOpen={isInviteModalOpen} onClose={() => setIsInviteModalOpen(false)} />
        </div>
    );
}

===== ./client/src/pages/alunos/new.tsx =====
// client/src/pages/alunos/new.tsx
import { useEffect, useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { StudentForm, StudentFormDataProcessed } from "@/forms/student-form";
import { Link, useLocation } from "wouter";
import { ChevronLeft } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { fetchWithAuth } from "@/lib/apiClient";
import { Aluno } from "@/types/aluno";

export default function NewStudent() {
    const [, navigate] = useLocation();
    const queryClient = useQueryClient();
    const { toast } = useToast();

    // Estado que controla se já checamos o limite de vagas
    const [loadingCheck, setLoadingCheck] = useState(true);

    useEffect(() => {
        // Verifica se o personal tem vagas disponíveis antes de mostrar o formulário
        async function checkSlots() {
            try {
                const res: any = await fetchWithAuth("/api/personal/can-activate/1");
                if (!res?.canActivate) {
                    toast({
                        variant: "destructive",
                        title: "Limite de alunos atingido",
                        description: "Seu plano atual não permite adicionar mais alunos. Faça upgrade ou compre tokens avulsos."
                    });
                    // Redireciona para a lista de alunos
                    navigate("/alunos");
                } else {
                    setLoadingCheck(false);
                }
            } catch (error) {
                console.error("Erro ao verificar limite de alunos:", error);
            }
        }
        checkSlots();
        // desabilita warning do eslint caso esteja usando
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const mutation = useMutation<Aluno, Error, StudentFormDataProcessed>({
        mutationFn: (newStudentData: StudentFormDataProcessed) => {
            return fetchWithAuth<Aluno>("/api/aluno/gerenciar", {
                method: 'POST',
                body: JSON.stringify(newStudentData),
            });
        },
        onSuccess: (createdStudent) => {
            toast({ title: "Aluno Cadastrado!", description: `${createdStudent?.nome || 'Aluno'} adicionado com sucesso.` });
            queryClient.invalidateQueries({ queryKey: ['/api/aluno/gerenciar'] });
            navigate("/alunos");
        },
        onError: (error) => {
            toast({ variant: "destructive", title: "Erro ao Cadastrar", description: error.message || "Não foi possível adicionar o aluno." });
        },
    });

    // Enquanto verifica o limite, mostra uma mensagem simples
    if (loadingCheck) {
        return (
            <div className="p-4 md:p-6 lg:p-8">
                <p className="text-sm text-muted-foreground">Verificando disponibilidade de vagas...</p>
            </div>
        );
    }

    return (
        <div className="p-4 md:p-6 lg:p-8">
            <Link href="/alunos" className="inline-flex items-center mb-4 text-sm text-primary hover:text-primary/90">
                <ChevronLeft className="w-4 h-4 mr-1" /> Voltar para Alunos
            </Link>

            <Card className="max-w-3xl mx-auto">
                <CardHeader>
                    <CardTitle>Adicionar Novo Aluno</CardTitle>
                    <CardDescription>Insira os dados do novo aluno para começar.</CardDescription>
                </CardHeader>
                <CardContent>
                    <StudentForm
                        onSubmit={(formData) => mutation.mutate(formData)}
                        isLoading={mutation.isPending}
                        isEditing={false}
                    />
                </CardContent>
            </Card>
        </div>
    );
}

===== ./client/src/pages/dashboard.tsx =====
// client/src/pages/dashboard.tsx
import React, { Suspense, lazy } from "react";
import { useQuery } from "@tanstack/react-query";
import { Link } from "wouter";
import { useUser } from "@/context/UserContext";
import { apiRequest } from "@/lib/queryClient"; 
import { useThrottle } from "@/hooks/useDebounce";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { StatsCard } from "@/components/ui/dashboard/stats-card";

import { Button } from "@/components/ui/button";
import { Plus, LayoutDashboard, Zap } from "lucide-react";
import LoadingSpinner from "@/components/LoadingSpinner"; 
import ErrorMessage from "@/components/ErrorMessage"; 
import ErrorBoundary from "@/components/ErrorBoundary"; 
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

// Lazy load heavy components for better performance
const AlunosAtivosList = lazy(() => import("@/components/ui/dashboard/AlunosAtivosList").then(module => ({
  default: module.AlunosAtivosList
})));

// <<< ALTERAÇÃO: Interface de dados atualizada >>>
interface DashboardStatsData {
  totalAlunos: number;
  treinosAtivos: number; 
  totalTreinosModelo?: number;
  feedbacksHojeCount?: number; // Novo campo para feedbacks
}

export default function Dashboard() {
  const { user } = useUser();
  const trainerId = user?.id; 
  const saudacaoNome = user?.firstName || user?.username || "Personal";

  const { 
    data: dashboardStats, 
    isLoading: isLoadingStats, 
    error: errorStats 
  } = useQuery<DashboardStatsData, Error>({
    queryKey: ["dashboardGeral", trainerId], 
    queryFn: async () => {
      if (!trainerId) throw new Error("Trainer ID não encontrado para buscar estatísticas.");
      // O backend precisará ser ajustado para retornar 'feedbacksHojeCount'
      return apiRequest<DashboardStatsData>("GET", `/api/dashboard/geral?trainerId=${trainerId}`);
    },
    enabled: !!trainerId, 
  });

  // <<< ALTERAÇÃO: Texto de saudação melhorado >>>
  const saudacaoSubtexto = isLoadingStats
    ? "Carregando um resumo do seu dia..."
    : "Aqui está um resumo da sua atividade e administração de alunos.";

  if (!user) {
    return <div className="bg-blue-50 dark:bg-slate-900 h-full"><LoadingSpinner text="Carregando dados do usuário..." /></div>;
  }

  return (
    <ErrorBoundary>
      <div className="flex flex-col h-full overflow-y-auto p-4 md:p-6 lg:p-8 
                     bg-gradient-to-br from-blue-50/80 via-indigo-50/40 to-purple-50/80 
                     dark:from-slate-900 dark:via-slate-800/95 dark:to-indigo-900/80 
                     min-h-screen">
        
        {/* Enhanced Header with Modern Typography */}
        <header className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 mb-8 md:mb-10">
          <div className="space-y-2">
            <h1 className="text-3xl md:text-4xl lg:text-5xl font-bold leading-tight
                         bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 
                         dark:from-blue-400 dark:via-indigo-400 dark:to-purple-400 
                         bg-clip-text text-transparent
                         animate-in fade-in-0 slide-in-from-bottom-4 duration-700">
              Bem-vindo(a) de volta, {saudacaoNome}! 👋
            </h1>
            <p className="text-gray-600 dark:text-gray-400 text-sm md:text-base leading-relaxed max-w-2xl
                        animate-in fade-in-0 slide-in-from-bottom-4 duration-700 delay-150">
              {saudacaoSubtexto}
            </p>
          </div>
        </header>

      {errorStats && (
        <ErrorMessage title="Erro ao Carregar Estatísticas" message={errorStats.message} />
      )}

      <Tabs defaultValue="overview" className="space-y-8 md:space-y-10">
        <TabsList className="grid w-full grid-cols-2 bg-white/70 dark:bg-slate-800/70 backdrop-blur-md 
                           border border-white/30 dark:border-slate-700/50 shadow-lg rounded-xl p-1
                           animate-in fade-in-0 slide-in-from-bottom-4 duration-700 delay-300">
          <TabsTrigger value="overview" 
                      className="data-[state=active]:bg-white dark:data-[state=active]:bg-slate-700 
                               data-[state=active]:shadow-md data-[state=active]:text-blue-700 
                               dark:data-[state=active]:text-blue-400
                               transition-all duration-300 rounded-lg py-3 px-4 
                               font-semibold text-sm md:text-base
                               hover:bg-white/50 dark:hover:bg-slate-700/50">
            <LayoutDashboard className="w-4 h-4 mr-2 sm:mr-3"/> 
            <span className="hidden xs:inline">Visão Geral</span>
            <span className="xs:hidden">Geral</span>
          </TabsTrigger>
          <TabsTrigger value="actions" 
                      className="data-[state=active]:bg-white dark:data-[state=active]:bg-slate-700 
                               data-[state=active]:shadow-md data-[state=active]:text-purple-700 
                               dark:data-[state=active]:text-purple-400
                               transition-all duration-300 rounded-lg py-3 px-4 
                               font-semibold text-sm md:text-base
                               hover:bg-white/50 dark:hover:bg-slate-700/50">
            <Zap className="w-4 h-4 mr-2 sm:mr-3"/> 
            <span className="hidden xs:inline">Ações Rápidas</span>
            <span className="xs:hidden">Ações</span>
          </TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-8 md:space-y-10">
          {/* Enhanced Stats Cards with Responsive Grid */}
          <div className="grid grid-cols-1 xs:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6">
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-100">
              <StatsCard 
                title="Total de Alunos" 
                value={isLoadingStats ? "..." : (dashboardStats?.totalAlunos ?? 0).toString()} 
                icon="students" 
                isLoading={isLoadingStats} 
              />
            </div>
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-200">
              <StatsCard 
                title="Alunos Ativos" 
                value={isLoadingStats ? "..." : (dashboardStats?.treinosAtivos ?? 0).toString()} 
                icon="activity" 
                isLoading={isLoadingStats} 
              />
            </div>
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-300">
              <StatsCard 
                title="Fichas Modelo" 
                value={isLoadingStats ? "..." : (dashboardStats?.totalTreinosModelo ?? 0).toString()} 
                icon="workouts" 
                isLoading={isLoadingStats} 
              />
            </div>
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-400">
              <StatsCard 
                title="Feedbacks Hoje" 
                value={isLoadingStats ? "..." : (dashboardStats?.feedbacksHojeCount ?? 0).toString()} 
                icon="sessions" 
                isLoading={isLoadingStats} 
              />
            </div>
          </div>
          
          <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-700 delay-500">
            <Suspense fallback={<LoadingSpinner text="Carregando lista de alunos..." />}>
              <AlunosAtivosList trainerId={trainerId!} />
            </Suspense>
          </div>
        </TabsContent>

        <TabsContent value="actions" className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500">
          <Card className="bg-white/90 dark:bg-slate-800/90 backdrop-blur-md 
                         border border-white/30 dark:border-slate-700/50 shadow-2xl 
                         hover:shadow-3xl transition-all duration-500 rounded-xl overflow-hidden">
            
            {/* Gradient background overlay */}
            <div className="absolute inset-0 bg-gradient-to-br from-blue-50/30 via-indigo-50/20 to-purple-50/30 
                           dark:from-blue-900/10 dark:via-indigo-900/5 dark:to-purple-900/10" />
            
            <CardHeader className="relative pb-6">
              <CardTitle className="text-xl md:text-2xl font-bold bg-gradient-to-r from-purple-600 via-blue-600 to-indigo-600 
                                 dark:from-purple-400 dark:via-blue-400 dark:to-indigo-400 
                                 bg-clip-text text-transparent">
                O que você gostaria de fazer agora?
              </CardTitle>
              <p className="text-gray-600 dark:text-gray-400 text-sm md:text-base leading-relaxed">
                Acesse rapidamente as principais funcionalidades do sistema.
              </p>
            </CardHeader>
            
            <CardContent className="relative grid grid-cols-1 sm:grid-cols-2 gap-4 md:gap-6 p-6">
              
              {/* Add Student Button */}
              <Link href="/alunos/novo" className="group">
                <Button variant="outline" 
                        className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                                 bg-gradient-to-br from-blue-50 to-indigo-50 
                                 dark:from-blue-900/30 dark:to-indigo-900/30 
                                 hover:from-blue-100 hover:to-indigo-100
                                 dark:hover:from-blue-800/40 dark:hover:to-indigo-800/40
                                 border-2 border-blue-200 dark:border-blue-700
                                 hover:border-blue-300 dark:hover:border-blue-600
                                 shadow-lg hover:shadow-xl
                                 transition-all duration-300 ease-out
                                 hover:scale-105 hover:-translate-y-1
                                 active:scale-95 active:transition-transform active:duration-75
                                 text-blue-700 dark:text-blue-400
                                 rounded-xl group">
                  <div className="flex items-center justify-center">
                    <div className="font-bold">Adicionar Aluno +</div>
                  </div>
                </Button>
              </Link>
              
              {/* Create Workout Button */}
              <Link href="/treinos" className="group">
                <Button variant="outline" 
                        className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                                 bg-gradient-to-br from-indigo-50 to-purple-50 
                                 dark:from-indigo-900/30 dark:to-purple-900/30 
                                 hover:from-indigo-100 hover:to-purple-100
                                 dark:hover:from-indigo-800/40 dark:hover:to-purple-800/40
                                 border-2 border-indigo-200 dark:border-indigo-700
                                 hover:border-indigo-300 dark:hover:border-indigo-600
                                 shadow-lg hover:shadow-xl
                                 transition-all duration-300 ease-out
                                 hover:scale-105 hover:-translate-y-1
                                 active:scale-95 active:transition-transform active:duration-75
                                 text-indigo-700 dark:text-indigo-400
                                 rounded-xl group">
                  <div className="flex items-center justify-center">
                    <div className="font-bold">Criar Ficha Modelo +</div>
                  </div>
                </Button>
              </Link>
              
              {/* New Exercise Button */}
              <Link href="/exercises" className="group">
                <Button variant="outline" 
                        className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                                 bg-gradient-to-br from-purple-50 to-pink-50 
                                 dark:from-purple-900/30 dark:to-pink-900/30 
                                 hover:from-purple-100 hover:to-pink-100
                                 dark:hover:from-purple-800/40 dark:hover:to-pink-800/40
                                 border-2 border-purple-200 dark:border-purple-700
                                 hover:border-purple-300 dark:hover:border-purple-600
                                 shadow-lg hover:shadow-xl
                                 transition-all duration-300 ease-out
                                 hover:scale-105 hover:-translate-y-1
                                 active:scale-95 active:transition-transform active:duration-75
                                 text-purple-700 dark:text-purple-400
                                 rounded-xl group">
                  <div className="flex items-center justify-center">
                    <div className="font-bold">Novo Exercício +</div>
                  </div>
                </Button>
              </Link>
              
              {/* New Assessment Button (Disabled) */}
              <div className="group">
                <Button variant="outline" 
                        disabled
                        className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                                 bg-gradient-to-br from-gray-50 to-gray-100 
                                 dark:from-gray-800/50 dark:to-gray-700/50 
                                 border-2 border-gray-200 dark:border-gray-600
                                 shadow-md cursor-not-allowed opacity-60
                                 text-gray-500 dark:text-gray-400
                                 rounded-xl">
                  <div className="flex items-center justify-center">
                    <div className="font-bold">Nova Avaliação +</div>
                  </div>
                </Button>
              </div>
              
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
    </ErrorBoundary>
  );
}
===== ./client/src/pages/demo-dashboard.tsx =====
// Temporary demo page to showcase UI improvements without authentication
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { StatsCard } from "@/components/ui/dashboard/stats-card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { Plus, LayoutDashboard, Zap, UserPlus, Search, Eye, Pencil, MoreVertical, Mail } from "lucide-react";

// Mock data for demonstration
const mockStudents = [
  { _id: "1", nome: "João Silva", email: "joao@exemplo.com", status: "active" },
  { _id: "2", nome: "Maria Santos", email: "maria@exemplo.com", status: "active" },
  { _id: "3", nome: "Pedro Oliveira", email: "pedro@exemplo.com", status: "inactive" },
];

// Mock AlunosAtivosList component with the new styling
const DemoAlunosAtivosList = () => {
  const [searchQuery, setSearchQuery] = React.useState("");
  
  const filteredStudents = mockStudents.filter(student => 
    student.nome.toLowerCase().includes(searchQuery.toLowerCase())
  );

  const getInitials = (nome: string) => {
    const partes = nome.split(' ').filter(Boolean);
    if (partes.length > 1) return `${partes[0][0]}${partes[partes.length - 1][0]}`.toUpperCase();
    return partes[0] ? partes[0].substring(0, 2).toUpperCase() : '?';
  };

  const AlunoAtivoCard = ({ student }: { student: any }) => (
    <div className="group relative flex items-center justify-between p-4 md:p-5 border-b last:border-b-0 
                    hover:bg-gradient-to-r hover:from-blue-50/80 hover:via-indigo-50/40 hover:to-purple-50/80 
                    dark:hover:from-blue-900/20 dark:hover:via-indigo-900/10 dark:hover:to-purple-900/20 
                    transition-all duration-300 ease-out cursor-pointer
                    hover:shadow-md hover:-translate-y-0.5 hover:scale-[1.01]
                    active:scale-[0.99] active:transition-transform active:duration-75">
      
      <div className="absolute inset-0 bg-gradient-to-r from-blue-500/5 via-indigo-500/5 to-purple-500/5 
                      opacity-0 group-hover:opacity-100 transition-opacity duration-300 rounded-lg" />
      
      <div className="relative flex items-center gap-3 md:gap-4 flex-1 min-w-0">
        <Avatar className="ring-2 ring-blue-100 dark:ring-blue-900/30 
                         group-hover:ring-blue-200 dark:group-hover:ring-blue-800/50
                         group-hover:scale-110 transition-all duration-300 
                         shadow-lg group-hover:shadow-xl">
          <AvatarFallback className="bg-gradient-to-br from-blue-500 via-indigo-500 to-purple-600 
                                   text-white font-semibold text-xs md:text-sm
                                   group-hover:from-blue-600 group-hover:via-indigo-600 group-hover:to-purple-700
                                   transition-all duration-300">
            {getInitials(student.nome)}
          </AvatarFallback>
        </Avatar>
        <div className="flex-1 min-w-0 space-y-1">
          <h4 className="font-semibold text-sm md:text-base text-gray-800 dark:text-gray-100 
                         group-hover:text-blue-700 dark:group-hover:text-blue-300 
                         transition-colors duration-300 truncate">
            {student.nome}
          </h4>
          <p className="text-xs md:text-sm text-gray-500 dark:text-gray-400 
                        group-hover:text-gray-600 dark:group-hover:text-gray-300 
                        transition-colors duration-300 truncate">
            {student.email}
          </p>
        </div>
      </div>
      
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" 
                  size="icon" 
                  className="relative h-9 w-9 md:h-10 md:w-10 min-h-[44px] min-w-[44px] 
                           hover:bg-white/80 dark:hover:bg-slate-700/80 
                           hover:shadow-lg hover:scale-110 
                           active:scale-95 transition-all duration-200 
                           group-hover:bg-white/50 dark:group-hover:bg-slate-600/50
                           backdrop-blur-sm border border-transparent
                           hover:border-blue-200 dark:hover:border-blue-700">
            <MoreVertical className="h-4 w-4 text-gray-600 dark:text-gray-300 
                                   hover:text-blue-600 dark:hover:text-blue-400 
                                   transition-colors duration-200" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end" 
                           className="bg-white/95 dark:bg-slate-800/95 backdrop-blur-md 
                                    border border-white/20 dark:border-slate-700/50 
                                    shadow-xl rounded-lg">
          <DropdownMenuItem className="hover:bg-blue-50 dark:hover:bg-blue-900/30">
            <Eye className="mr-2 h-4 w-4 text-blue-600 dark:text-blue-400" /> 
            <span className="font-medium">Visualizar</span>
          </DropdownMenuItem>
          <DropdownMenuItem className="hover:bg-indigo-50 dark:hover:bg-indigo-900/30">
            <Pencil className="mr-2 h-4 w-4 text-indigo-600 dark:text-indigo-400" /> 
            <span className="font-medium">Editar Aluno</span>
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );

  return (
    <Card className="relative overflow-hidden bg-white/90 dark:bg-slate-800/90 backdrop-blur-md 
                   border border-white/30 dark:border-slate-700/50 shadow-2xl 
                   hover:shadow-3xl transition-all duration-500 hover:-translate-y-1">
      
      <div className="absolute inset-0 bg-gradient-to-br from-blue-50/50 via-indigo-50/30 to-purple-50/50 
                     dark:from-blue-900/10 dark:via-indigo-900/5 dark:to-purple-900/10" />
      
      <CardHeader className="relative pb-4">
        <div className="flex flex-col gap-4 sm:gap-6">
          <div className="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-3 sm:gap-4">
            <div className="space-y-2">
              <CardTitle className="text-xl md:text-2xl font-bold bg-gradient-to-r from-blue-700 via-indigo-600 to-purple-600 
                                 dark:from-blue-400 dark:via-indigo-400 dark:to-purple-400 
                                 bg-clip-text text-transparent">
                Alunos Ativos
              </CardTitle>
              <p className="text-sm md:text-base text-gray-600 dark:text-gray-400 leading-relaxed max-w-md">
                Gerencie seus alunos com planos de treino em andamento.
              </p>
            </div>
            <Button size="sm" 
                    className="min-h-[44px] px-4 md:px-6 py-2 md:py-3 text-sm md:text-base font-semibold
                             bg-gradient-to-r from-blue-500 via-indigo-500 to-purple-600 
                             hover:from-blue-600 hover:via-indigo-600 hover:to-purple-700 
                             text-white shadow-lg hover:shadow-xl 
                             transition-all duration-300 ease-out
                             hover:scale-105 hover:-translate-y-0.5
                             border-0 rounded-lg">
              <UserPlus className="h-4 w-4 mr-2" /> 
              <span className="hidden sm:inline">Adicionar</span> Aluno
            </Button>
          </div>
          
          <div className="relative">
            <div className="relative group">
              <Search className="absolute left-3 md:left-4 top-1/2 -translate-y-1/2 
                              text-gray-400 dark:text-gray-500 h-4 w-4 md:h-5 md:w-5
                              group-focus-within:text-blue-500 dark:group-focus-within:text-blue-400
                              transition-colors duration-300" />
              <Input 
                type="search" 
                placeholder="Buscar aluno ativo..." 
                className="pl-10 md:pl-12 pr-4 py-3 md:py-4 w-full text-sm md:text-base
                         bg-white/80 dark:bg-slate-800/80 backdrop-blur-sm
                         border border-gray-200/60 dark:border-slate-700/60 
                         rounded-lg shadow-sm hover:shadow-md
                         focus:ring-2 focus:ring-blue-500/30 dark:focus:ring-blue-400/30
                         focus:border-blue-400 dark:focus:border-blue-500
                         transition-all duration-300 ease-out
                         hover:bg-white dark:hover:bg-slate-800" 
                value={searchQuery} 
                onChange={(e) => setSearchQuery(e.target.value)} 
              />
            </div>
          </div>
        </div>
      </CardHeader>
      
      <CardContent className="relative p-0">
        <div className="divide-y divide-gray-100 dark:divide-slate-700/50">
          {filteredStudents.map((student, index) => (
            <div key={student._id} 
                 className="animate-in fade-in-0 slide-in-from-bottom-4 duration-300"
                 style={{ animationDelay: `${index * 100}ms` }}>
              <AlunoAtivoCard student={student} />
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

export default function DemoDashboard() {
  return (
    <div className="flex flex-col h-full overflow-y-auto p-4 md:p-6 lg:p-8 
                   bg-gradient-to-br from-blue-50/80 via-indigo-50/40 to-purple-50/80 
                   dark:from-slate-900 dark:via-slate-800/95 dark:to-indigo-900/80 
                   min-h-screen">
      
      <header className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 mb-8 md:mb-10">
        <div className="space-y-2">
          <h1 className="text-3xl md:text-4xl lg:text-5xl font-bold leading-tight
                       bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 
                       dark:from-blue-400 dark:via-indigo-400 dark:to-purple-400 
                       bg-clip-text text-transparent
                       animate-in fade-in-0 slide-in-from-bottom-4 duration-700">
            Bem-vindo(a) de volta, Personal! 👋
          </h1>
          <p className="text-gray-600 dark:text-gray-400 text-sm md:text-base leading-relaxed max-w-2xl
                      animate-in fade-in-0 slide-in-from-bottom-4 duration-700 delay-150">
            Aqui está um resumo da sua atividade e administração de alunos.
          </p>
        </div>
      </header>

      <Tabs defaultValue="overview" className="space-y-8 md:space-y-10">
        <TabsList className="grid w-full grid-cols-2 bg-white/70 dark:bg-slate-800/70 backdrop-blur-md 
                           border border-white/30 dark:border-slate-700/50 shadow-lg rounded-xl p-1
                           animate-in fade-in-0 slide-in-from-bottom-4 duration-700 delay-300">
          <TabsTrigger value="overview" 
                      className="data-[state=active]:bg-white dark:data-[state=active]:bg-slate-700 
                               data-[state=active]:shadow-md data-[state=active]:text-blue-700 
                               dark:data-[state=active]:text-blue-400
                               transition-all duration-300 rounded-lg py-3 px-4 
                               font-semibold text-sm md:text-base">
            <LayoutDashboard className="w-4 h-4 mr-2 sm:mr-3"/> 
            <span className="hidden xs:inline">Visão Geral</span>
            <span className="xs:hidden">Geral</span>
          </TabsTrigger>
          <TabsTrigger value="actions" 
                      className="data-[state=active]:bg-white dark:data-[state=active]:bg-slate-700 
                               data-[state=active]:shadow-md data-[state=active]:text-purple-700 
                               dark:data-[state=active]:text-purple-400
                               transition-all duration-300 rounded-lg py-3 px-4 
                               font-semibold text-sm md:text-base">
            <Zap className="w-4 h-4 mr-2 sm:mr-3"/> 
            <span className="hidden xs:inline">Ações Rápidas</span>
            <span className="xs:hidden">Ações</span>
          </TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-8 md:space-y-10">
          <div className="grid grid-cols-1 xs:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6">
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-100">
              <StatsCard title="Total de Alunos" value="12" icon="students" />
            </div>
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-200">
              <StatsCard title="Alunos Ativos" value="8" icon="activity" />
            </div>
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-300">
              <StatsCard title="Fichas Modelo" value="15" icon="workouts" />
            </div>
            <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500 delay-400">
              <StatsCard title="Feedbacks Hoje" value="3" icon="sessions" />
            </div>
          </div>
          
          <div className="animate-in fade-in-0 slide-in-from-bottom-4 duration-700 delay-500">
            <DemoAlunosAtivosList />
          </div>
        </TabsContent>

        <TabsContent value="actions" className="animate-in fade-in-0 slide-in-from-bottom-4 duration-500">
          <Card className="bg-white/90 dark:bg-slate-800/90 backdrop-blur-md 
                         border border-white/30 dark:border-slate-700/50 shadow-2xl 
                         hover:shadow-3xl transition-all duration-500 rounded-xl overflow-hidden">
            
            <div className="absolute inset-0 bg-gradient-to-br from-blue-50/30 via-indigo-50/20 to-purple-50/30 
                           dark:from-blue-900/10 dark:via-indigo-900/5 dark:to-purple-900/10" />
            
            <CardHeader className="relative pb-6">
              <CardTitle className="text-xl md:text-2xl font-bold bg-gradient-to-r from-purple-600 via-blue-600 to-indigo-600 
                                 dark:from-purple-400 dark:via-blue-400 dark:to-indigo-400 
                                 bg-clip-text text-transparent">
                O que você gostaria de fazer agora?
              </CardTitle>
              <p className="text-gray-600 dark:text-gray-400 text-sm md:text-base leading-relaxed">
                Acesse rapidamente as principais funcionalidades do sistema.
              </p>
            </CardHeader>
            
            <CardContent className="relative grid grid-cols-1 sm:grid-cols-2 gap-4 md:gap-6 p-6">
              <Button variant="outline" 
                      className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                               bg-gradient-to-br from-blue-50 to-indigo-50 
                               dark:from-blue-900/30 dark:to-indigo-900/30 
                               hover:from-blue-100 hover:to-indigo-100
                               border-2 border-blue-200 dark:border-blue-700
                               text-blue-700 dark:text-blue-400
                               shadow-lg hover:shadow-xl
                               transition-all duration-300 ease-out
                               hover:scale-105 hover:-translate-y-1
                               rounded-xl group">
                <div className="flex items-center justify-center">
                  <div className="font-bold">Adicionar Aluno +</div>
                </div>
              </Button>
              
              <Button variant="outline" 
                      className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                               bg-gradient-to-br from-indigo-50 to-purple-50 
                               dark:from-indigo-900/30 dark:to-purple-900/30 
                               hover:from-indigo-100 hover:to-purple-100
                               border-2 border-indigo-200 dark:border-indigo-700
                               text-indigo-700 dark:text-indigo-400
                               shadow-lg hover:shadow-xl
                               transition-all duration-300 ease-out
                               hover:scale-105 hover:-translate-y-1
                               rounded-xl group">
                <div className="flex items-center justify-center">
                  <div className="font-bold">Criar Ficha Modelo +</div>
                </div>
              </Button>
              
              <Button variant="outline" 
                      className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                               bg-gradient-to-br from-purple-50 to-pink-50 
                               dark:from-purple-900/30 dark:to-pink-900/30 
                               hover:from-purple-100 hover:to-pink-100
                               border-2 border-purple-200 dark:border-purple-700
                               text-purple-700 dark:text-purple-400
                               shadow-lg hover:shadow-xl
                               transition-all duration-300 ease-out
                               hover:scale-105 hover:-translate-y-1
                               rounded-xl group">
                <div className="flex items-center justify-center">
                  <div className="font-bold">Novo Exercício +</div>
                </div>
              </Button>
              
              <Button variant="outline" 
                      disabled
                      className="w-full min-h-[60px] md:min-h-[70px] text-base md:text-lg font-semibold p-4 md:p-6
                               bg-gradient-to-br from-gray-50 to-gray-100 
                               dark:from-gray-800/50 dark:to-gray-700/50 
                               border-2 border-gray-200 dark:border-gray-600
                               text-gray-500 dark:text-gray-400
                               cursor-not-allowed opacity-60
                               rounded-xl">
                <div className="flex items-center justify-center">
                  <div className="font-bold">Nova Avaliação +</div>
                </div>
              </Button>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}
===== ./client/src/pages/exercises/index.tsx =====
// client/src/pages/exercises/index.tsx
import { useState, useMemo } from 'react';
import { Button } from "@/components/ui/button";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Star, BrainCircuit, User, SearchX, SlidersHorizontal } from "lucide-react"; // <<< CORREÇÃO: 'FilterX' removido
import ExerciseFormModal from "@/components/dialogs/ExerciseFormModal";
import ExerciseEditModal from "@/components/dialogs/ExerciseEditModal";
import ExerciseDeleteButton from "@/components/buttons/ExerciseDeleteButton";
import { useToast } from "@/hooks/use-toast";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Badge } from "@/components/ui/badge";
import { useUser } from "@/context/UserContext";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { fetchWithAuth } from "@/lib/apiClient";
import LiteYouTubeEmbed from "@/components/LiteYouTubeEmbed";
import LiteGoogleDriveEmbed from "@/components/LiteGoogleDriveEmbed";
import { Drawer, DrawerContent, DrawerHeader, DrawerTitle, DrawerTrigger, DrawerDescription, DrawerFooter, DrawerClose } from "@/components/ui/drawer";
import ExerciseFilters from '@/components/ExerciseFilters'; // <<< CORREÇÃO: Caminho da importação ajustado

// --- Interfaces, Funções e Constantes (sem alteração) ---
interface Exercicio { _id: string; nome: string; descricao?: string; grupoMuscular?: string; categoria?: string; urlVideo?: string; isCustom: boolean; isFavoritedByCurrentUser?: boolean; }
type AbaSelecionada = "todos" | "app" | "meus" | "favoritos";
const ALL_FILTER_VALUE = "all";
const getYouTubeId = (url?: string): string | undefined => { if (!url) return undefined; const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/; const match = url.match(regExp); return (match && match[2].length === 11) ? match[2] : undefined; };
const getGoogleDriveId = (url?: string): string | undefined => { if (!url) return undefined; const patterns = [ /drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/, /drive\.google\.com\/open\?id=([a-zA-Z0-9_-]+)/, ]; for (const pattern of patterns) { const match = url.match(pattern); if (match && match[1]) { return match[1]; } } return undefined; };
const grupos = ["Peitoral", "Pernas", "Costas", "Ombros", "Bíceps", "Tríceps", "Abdômen", "Lombar", "Glúteos", "Panturrilha", "Cardio", "Corpo Inteiro", "Outro"].sort();
const categorias = ["Força", "Resistência", "Hipertrofia", "Potência", "Cardiovascular", "Flexibilidade", "Mobilidade", "Funcional", "Calistenia", "Outro"].sort();

// --- Componente ExerciseList (sem alteração) ---
const ExerciseList = ({ exercicios, onFavoriteToggle, onFetch, isAdmin }: { exercicios: Exercicio[], onFavoriteToggle: (id: string, isFavorited: boolean) => void, onFetch: () => void, isAdmin: boolean }) => (
  <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
    {exercicios.map((ex) => {
      const isFavorited = ex.isFavoritedByCurrentUser ?? false;
      const youtubeId = getYouTubeId(ex.urlVideo);
      const googleDriveId = getGoogleDriveId(ex.urlVideo);
      const canEditOrDelete = ex.isCustom || isAdmin;
      return (
        <Card key={ex._id} className="rounded-xl border bg-card text-card-foreground shadow-sm flex flex-col overflow-hidden transition-transform transform hover:-translate-y-1">
          <div className="w-full h-40 bg-gray-200 dark:bg-gray-700 relative">
            {youtubeId ? ( <LiteYouTubeEmbed id={youtubeId} title={ex.nome} /> ) : googleDriveId ? ( <LiteGoogleDriveEmbed id={googleDriveId} title={ex.nome} /> ) : ( <div className="w-full h-full flex items-center justify-center text-muted-foreground text-sm">Sem Vídeo</div> )}
          </div>
          <CardContent className="p-4 flex-grow flex flex-col">
            <div className="flex gap-1 mb-2 flex-wrap">
              {ex.grupoMuscular && <Badge variant="secondary">{ex.grupoMuscular}</Badge>}
              {ex.categoria && <Badge variant="outline">{ex.categoria}</Badge>}
            </div>
            <h2 className="font-semibold text-base truncate mb-1" title={ex.nome}>{ex.nome}</h2>
            <p className="text-xs text-muted-foreground line-clamp-2 flex-grow mb-2" title={ex.descricao ?? ''}>{ex.descricao || 'Nenhuma descrição.'}</p>
            <div className="flex gap-1 items-center justify-end mt-auto pt-2 border-t">
              <TooltipProvider delayDuration={100}>
                {ex.isCustom ? ( <Tooltip><TooltipTrigger><User className="w-4 h-4 text-blue-500" /></TooltipTrigger><TooltipContent><p>Exercício Personalizado</p></TooltipContent></Tooltip> ) : ( <Tooltip><TooltipTrigger><BrainCircuit className="w-4 h-4 text-purple-500" /></TooltipTrigger><TooltipContent><p>Exercício do App</p></TooltipContent></Tooltip> )}
              </TooltipProvider>
              {canEditOrDelete && ( <> <ExerciseEditModal exercicio={ex} onUpdated={onFetch} gruposMusculares={grupos} categoriasExercicio={categorias} /> <ExerciseDeleteButton exercicioId={ex._id} onDeleted={onFetch} /> </> )}
              <Button variant="ghost" size="icon" onClick={() => onFavoriteToggle(ex._id, isFavorited)} title={isFavorited ? "Desfavoritar" : "Favoritar"} className="h-7 w-7"><Star className={`w-4 h-4 ${isFavorited ? 'fill-yellow-400 text-yellow-500' : 'text-muted-foreground hover:text-yellow-500'}`} /></Button>
            </div>
          </CardContent>
        </Card>
      );
    })}
  </div>
);

export default function ExercisesPage() {
  const { user } = useUser();
  const isAdmin = !!user && user.role.toLowerCase() === 'admin';
  const queryClient = useQueryClient();
  const { toast } = useToast();

  const [aba, setAba] = useState<AbaSelecionada>(isAdmin ? 'app' : 'todos');
  const [filters, setFilters] = useState({
    searchTerm: "",
    grupo: ALL_FILTER_VALUE,
    categoria: ALL_FILTER_VALUE,
  });

  const { data, isLoading } = useQuery<Exercicio[]>({
    queryKey: ['exercicios', aba, filters.grupo, filters.categoria],
    queryFn: () => {
      const params = new URLSearchParams({ tipo: aba, grupo: filters.grupo, categoria: filters.categoria });
      return fetchWithAuth(`/api/exercicios/biblioteca?${params.toString()}`);
    },
    placeholderData: (prev) => prev,
  });

  const filteredExercises = useMemo(() => {
    if (!data) return [];
    return data.filter(ex => ex.nome.toLowerCase().includes(filters.searchTerm.toLowerCase())).sort((a, b) => a.nome.localeCompare(b.nome, 'pt-BR'));
  }, [data, filters.searchTerm]);

  const handleFilterChange = (newFilters: Partial<typeof filters>) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  };

  const handleClearFilters = () => {
    setFilters({ searchTerm: "", grupo: ALL_FILTER_VALUE, categoria: ALL_FILTER_VALUE });
  };
  
  const activeFilterCount = Object.values(filters).filter(value => value !== "" && value !== ALL_FILTER_VALUE).length;

  const handleFavoriteToggle = async (id: string, isFavorited: boolean) => { try { await fetchWithAuth(`/api/exercicios/${id}/favorite`, { method: isFavorited ? "DELETE" : "POST" }); toast({ title: "Sucesso", description: `Exercício ${isFavorited ? 'desfavoritado' : 'favoritado'}.` }); queryClient.invalidateQueries({ queryKey: ['exercicios'] }); } catch (err: any) { toast({ title: "Erro", description: err.message, variant: "destructive" }); } };
  const handleFetch = () => { queryClient.invalidateQueries({ queryKey: ['exercicios', aba] }); };

  return (
    <div className="container mx-auto p-4 md:p-6 lg:p-8 space-y-6">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Biblioteca de Exercícios</h1>
          <p className="text-muted-foreground">Encontre, crie e gerencie os exercícios para seus treinos.</p>
        </div>
        <div className="flex-shrink-0">
          {isAdmin ? <ExerciseFormModal onCreated={handleFetch} creationType="app" triggerButtonText="Criar Exercício do App" /> : <ExerciseFormModal onCreated={handleFetch} creationType="personal" triggerButtonText="Criar Meu Exercício" />}
        </div>
      </div>

      <Tabs defaultValue={isAdmin ? 'app' : 'todos'} onValueChange={(v) => setAba(v as AbaSelecionada)} className="w-full">
        <div className="overflow-x-auto pb-2">
            <TabsList className="min-w-full sm:min-w-0 sm:grid sm:w-full sm:grid-cols-4">
            {!isAdmin && <TabsTrigger value="todos">Todos</TabsTrigger>}
            <TabsTrigger value="app">Exercícios do App</TabsTrigger>
            {!isAdmin && <TabsTrigger value="meus">Meus Exercícios</TabsTrigger>}
            <TabsTrigger value="favoritos">Favoritos</TabsTrigger>
            </TabsList>
        </div>
      </Tabs>
      
      <Card className="hidden sm:block">
        <CardHeader>
            <CardTitle className="text-lg">Filtros</CardTitle>
            <CardDescription>Refine sua busca para encontrar exercícios específicos.</CardDescription>
        </CardHeader>
        <CardContent>
            <ExerciseFilters 
                grupos={grupos} 
                categorias={categorias}
                filters={filters}
                onFilterChange={handleFilterChange}
                onClearFilters={handleClearFilters}
            />
        </CardContent>
      </Card>

      <div className="sm:hidden">
        <Drawer>
            <DrawerTrigger asChild>
                <Button variant="outline" className="w-full justify-center relative">
                    <SlidersHorizontal className="w-4 h-4 mr-2" />
                    Filtros
                    {activeFilterCount > 0 && <span className="absolute top-0 right-0 -mt-1 -mr-1 h-4 w-4 rounded-full bg-primary text-primary-foreground text-xs flex items-center justify-center">{activeFilterCount}</span>}
                </Button>
            </DrawerTrigger>
            <DrawerContent>
                <DrawerHeader>
                    <DrawerTitle>Filtrar Exercícios</DrawerTitle>
                    <DrawerDescription>Selecione os filtros para refinar os resultados.</DrawerDescription>
                </DrawerHeader>
                <div className="p-4">
                    <ExerciseFilters 
                        grupos={grupos} 
                        categorias={categorias}
                        filters={filters}
                        onFilterChange={handleFilterChange}
                        onClearFilters={handleClearFilters}
                    />
                </div>
                <DrawerFooter>
                    <DrawerClose asChild>
                        <Button>Ver Resultados</Button>
                    </DrawerClose>
                </DrawerFooter>
            </DrawerContent>
        </Drawer>
      </div>

      {isLoading ? (
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 mt-6">
          {[...Array(8)].map((_, i) => <Skeleton key={i} className="h-72 w-full rounded-xl" />)}
        </div>
      ) : filteredExercises.length === 0 ? (
        <div className="text-center text-muted-foreground mt-6 py-16 border-2 border-dashed rounded-lg">
          <SearchX className="mx-auto h-12 w-12 text-gray-400" />
          <h3 className="mt-4 text-lg font-medium">Nenhum exercício encontrado</h3>
          <p className="mt-1 text-sm">Tente ajustar seus filtros ou crie um novo exercício.</p>
        </div>
      ) : (
        <div className="mt-6">
          <ExerciseList exercicios={filteredExercises} onFavoriteToggle={handleFavoriteToggle} onFetch={handleFetch} isAdmin={isAdmin} />
        </div>
      )}
    </div>
  );
}
===== ./client/src/pages/index.tsx =====
// client/src/pages/index.tsx
import { Redirect } from "wouter";

// Este componente serve como uma rota "catch-all" ou raiz que foi depreciada.
// Ele simplesmente redireciona o usuário para a página de login, que é o
// ponto de entrada correto para a aplicação.
export default function RootRedirectPage() {
    return <Redirect to="/login" />;
}
===== ./client/src/pages/login.tsx =====
// client/src/pages/login.tsx
import React, { useState, useContext } from 'react';
import { useLocation, Link } from 'wouter';
import { UserContext, User } from '@/context/UserContext';
import { useToast } from "@/hooks/use-toast";
import { Loader2, ArrowLeft, Mail, Lock, Shield } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { fetchWithAuth } from '@/lib/apiClient';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

interface LoginApiResponse {
    message: string;
    token: string;
    refreshToken: string;
    user: { id: string; username: string; firstName: string; lastName: string; email: string; role: string; };
}

// Função para validar e limpar dados corrompidos no localStorage
const validateAndCleanAuthData = (): void => {
    try {
        // Lista de chaves que precisam ser validadas
        const authKeys = ['authToken', 'refreshToken', 'userData'];
        
        authKeys.forEach(key => {
            const value = localStorage.getItem(key);
            if (value === 'null' || value === 'undefined' || value === '') {
                console.warn(`[Login] Removendo valor corrompido para ${key}:`, value);
                localStorage.removeItem(key);
            }
        });
        
        // Validação específica para userData
        const userData = localStorage.getItem('userData');
        if (userData) {
            try {
                const parsed = JSON.parse(userData);
                if (!parsed || !parsed.id || !parsed.email) {
                    console.warn('[Login] userData malformado, removendo...');
                    localStorage.removeItem('userData');
                }
            } catch (e) {
                console.warn('[Login] userData com JSON inválido, removendo...');
                localStorage.removeItem('userData');
            }
        }
    } catch (error) {
        console.error('[Login] Erro ao validar localStorage:', error);
    }
};

export default function LoginPage() {
    const [, setLocation] = useLocation();
    const userContext = useContext(UserContext);
    const { toast } = useToast();
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState("");

    // Limpa dados corrompidos quando o componente é montado
    React.useEffect(() => {
        validateAndCleanAuthData();
    }, []);

    const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setError("");
        setIsLoading(true);
        
        try {
            // Limpa dados corrompidos antes de tentar o login
            validateAndCleanAuthData();
            
            const loginData = await fetchWithAuth<LoginApiResponse>('/api/auth/login', {
                method: 'POST',
                body: JSON.stringify({ email: email.toLowerCase(), password }),
            });
            localStorage.setItem('authToken', loginData.token);
            localStorage.setItem('refreshToken', loginData.refreshToken);
            const loggedInUser: User = { ...loginData.user, role: loginData.user.role || 'Personal Trainer' };
            localStorage.setItem("userData", JSON.stringify(loggedInUser));
            userContext?.setUser(loggedInUser);
            toast({ title: "Login bem-sucedido!", description: `Bem-vindo(a) de volta, ${loggedInUser.firstName}!` });
            setLocation("/");
        } catch (err: any) {
            console.error('[Login] Erro durante o login:', err);
            
            // Tratamento específico de erros
            let errorMessage = 'Ocorreu um erro inesperado.';
            
            if (err.message) {
                if (err.message.includes('servidor')) {
                    errorMessage = 'Erro temporário no servidor. Tente novamente em alguns instantes.';
                } else if (err.message.includes('conexão') || err.message.includes('conectar')) {
                    errorMessage = 'Problemas de conexão. Verifique sua internet e tente novamente.';
                } else if (err.message.includes('Credenciais inválidas')) {
                    errorMessage = 'Email ou senha incorretos.';
                } else {
                    errorMessage = err.message;
                }
            }
            
            setError(errorMessage);
            toast({ 
                title: "Erro no Login", 
                description: errorMessage, 
                variant: "destructive" 
            });
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-indigo-900 lg:grid lg:grid-cols-2">
            {/* Left Side - Login Form */}
            <div className="flex items-center justify-center py-12 px-4 sm:px-6 lg:px-8">
                <div className="w-full max-w-md space-y-8">
                    {/* Logo and Title Section */}
                    <div className="text-center space-y-6 animate-fade-in">
                        <div className="flex items-center justify-center">
                            <img 
                                src="/images/logo-branco.png" 
                                alt="DyFit Logo" 
                                className="h-16 w-auto object-contain"
                            />
                        </div>
                        <div>
                            <h1 className="text-3xl font-bold text-white">Entrar como Personal</h1>
                            <p className="text-slate-300 mt-2">Gerencie seus alunos e rotinas com eficiência</p>
                        </div>
                    </div>

                    {/* Login Form Card */}
                    <Card className="glass border-white/20 shadow-glass animate-slide-up">
                        <CardContent className="p-6">
                            <form onSubmit={handleLogin} className="space-y-6">
                                {error && (
                                    <div className="p-3 bg-destructive/10 border border-destructive/20 rounded-xl text-destructive text-sm animate-slide-down">
                                        {error}
                                    </div>
                                )}
                                
                                <div className="space-y-4">
                                    <div className="relative">
                                        <Mail className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
                                        <Input 
                                            id="email-login" 
                                            type="email" 
                                            placeholder="seu.email@exemplo.com" 
                                            required 
                                            value={email} 
                                            onChange={(e) => setEmail(e.target.value)} 
                                            disabled={isLoading} 
                                            autoComplete="email" 
                                            className="pl-12 h-12 text-base bg-background/95 backdrop-blur-sm" 
                                        />
                                    </div>
                                    
                                    <div className="relative">
                                        <Lock className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
                                        <Input 
                                            id="password-login" 
                                            type="password" 
                                            placeholder="Sua senha" 
                                            required 
                                            value={password} 
                                            onChange={(e) => setPassword(e.target.value)} 
                                            disabled={isLoading} 
                                            autoComplete="current-password" 
                                            className="pl-12 h-12 text-base bg-background/95 backdrop-blur-sm" 
                                        />
                                    </div>
                                </div>

                                <Button 
                                    type="submit" 
                                    size="lg"
                                    className="w-full" 
                                    disabled={isLoading}
                                    loading={isLoading}
                                >
                                    Entrar
                                </Button>
                            </form>
                            
                            <div className="mt-6 text-center">
                                <Link 
                                    href="/login" 
                                    className="inline-flex items-center text-muted-foreground hover:text-white transition-colors group"
                                >
                                    <ArrowLeft className="mr-2 h-4 w-4 group-hover:-translate-x-1 transition-transform" />
                                    Voltar para seleção de perfil
                                </Link>
                            </div>
                        </CardContent>
                    </Card>
                </div>
            </div>

            {/* Right Side - Visual Element (Desktop only) */}
            <div className="hidden lg:flex items-center justify-center p-8">
                <div className="w-full h-full rounded-2xl bg-gradient-to-br from-primary/20 to-secondary/20 glass border border-white/10 flex items-center justify-center animate-scale-in">
                    <div className="text-center text-white space-y-6">
                        <div className="w-32 h-32 mx-auto bg-gradient-primary rounded-full flex items-center justify-center mb-8 shadow-glass">
                            <Shield className="h-16 w-16" />
                        </div>
                        <div className="space-y-3">
                            <h2 className="text-2xl font-bold">Bem-vindo de volta!</h2>
                            <p className="text-slate-300 max-w-sm">
                                Acesse sua conta e continue transformando vidas através do fitness
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
}
===== ./client/src/pages/meu-plano.tsx =====
// client/src/pages/meu-plano.tsx
import React from "react";
import { useQuery } from "@tanstack/react-query";
import { useUser } from "@/context/UserContext";
import { apiRequest } from "@/lib/queryClient"; 
import { useThrottle } from "@/hooks/useDebounce";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { 
    CalendarDays, 
    Users, 
    Crown, 
    AlertTriangle, 
    CheckCircle, 
    Clock,
    TrendingUp,
    Zap,
    Briefcase,
    RocketIcon
} from "lucide-react";
import LoadingSpinner from "@/components/LoadingSpinner"; 
import ErrorMessage from "@/components/ErrorMessage"; 
import ErrorBoundary from "@/components/ErrorBoundary"; 
import { PersonalPlanStatus } from "../../../shared/types/planos";

export default function MeuPlano() {
  const { user } = useUser();
  const trainerId = user?.id;

  // Throttled upgrade handler to prevent multiple rapid clicks
  const handleUpgradeClick = useThrottle(() => {
    console.log('Upgrade clicked');
    // TODO: Navigate to upgrade page or show modal
    // Example: setLocationWouter("/upgrade") or openUpgradeModal()
  }, 1000);

  // Query for plan status
  const { 
    data: planStatus, 
    isLoading: isLoadingPlan, 
    error: errorPlan 
  } = useQuery<PersonalPlanStatus, Error>({
    queryKey: ["planStatus", trainerId], 
    queryFn: async () => {
      if (!trainerId) throw new Error("Trainer ID não encontrado para buscar status do plano.");
      return apiRequest<PersonalPlanStatus>("GET", "/api/personal/meu-plano");
    },
    enabled: !!trainerId, 
  });

  if (!user) {
    return <div className="bg-blue-50 dark:bg-slate-900 h-full"><LoadingSpinner text="Carregando dados do usuário..." /></div>;
  }

  if (isLoadingPlan) {
    return (
      <div className="flex flex-col h-full overflow-y-auto p-4 md:p-6 lg:p-8 bg-gradient-to-br from-sky-50 via-white to-amber-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
        <div className="flex items-center justify-center flex-1">
          <div className="text-center">
            <RocketIcon className="w-12 h-12 text-sky-500 animate-pulse mx-auto mb-4" />
            <LoadingSpinner text="Carregando informações do seu plano..." />
          </div>
        </div>
      </div>
    );
  }

  if (errorPlan) {
    return (
      <ErrorBoundary>
        <div className="flex flex-col h-full overflow-y-auto p-4 md:p-6 lg:p-8 bg-gradient-to-br from-sky-50 via-white to-amber-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
          <ErrorMessage title="Erro ao Carregar Status do Plano" message={errorPlan.message} />
        </div>
      </ErrorBoundary>
    );
  }

  if (!planStatus) {
    return (
      <ErrorBoundary>
        <div className="flex flex-col h-full overflow-y-auto p-4 md:p-6 lg:p-8 bg-gradient-to-br from-sky-50 via-white to-amber-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
          <ErrorMessage title="Plano não encontrado" message="Não foi possível carregar as informações do seu plano." />
        </div>
      </ErrorBoundary>
    );
  }

  const {
    plano,
    personalPlano,
    limiteAtual,
    alunosAtivos,
    tokensAvulsos,
    percentualUso = 0,
    podeAtivarMais = false,
    vagasDisponiveis = 0
  } = planStatus;

  // Ensure percentualUso displays properly - show 0% when null/undefined
  const displayPercentualUso = percentualUso ?? 0;

  const getStatusInfo = () => {
    if (displayPercentualUso >= 90) {
      return {
        variant: 'destructive' as const,
        icon: AlertTriangle,
        text: 'Crítico',
        color: 'text-red-600',
        bgColor: 'bg-red-50',
        borderColor: 'border-red-200'
      };
    }
    if (displayPercentualUso >= 70) {
      return {
        variant: 'default' as const,
        icon: Clock,
        text: 'Atenção',
        color: 'text-yellow-600',
        bgColor: 'bg-yellow-50',
        borderColor: 'border-yellow-200'
      };
    }
    return {
      variant: 'secondary' as const,
      icon: CheckCircle,
      text: 'Normal',
      color: 'text-green-600',
      bgColor: 'bg-green-50',
      borderColor: 'border-green-200'
    };
  };

  const statusInfo = getStatusInfo();
  const StatusIcon = statusInfo.icon;

  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString('pt-BR');
  };

  const getDaysUntilExpiration = () => {
    if (!personalPlano?.dataVencimento) return null;
    const today = new Date();
    const expiration = new Date(personalPlano.dataVencimento);
    const diffTime = expiration.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
  };

  const daysUntilExpiration = getDaysUntilExpiration();

  return (
    <ErrorBoundary>
      <div className="flex flex-col h-full overflow-y-auto p-4 md:p-6 lg:p-8 bg-gradient-to-br from-sky-50 via-white to-amber-50 dark:from-slate-900 dark:via-slate-800 dark:to-slate-900">
        {/* Header */}
        <header className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2 mb-6">
          <div>
            <h1 className="text-2xl md:text-3xl font-bold text-gray-800 dark:text-gray-100 bg-gradient-to-r from-sky-600 to-amber-600 bg-clip-text text-transparent flex items-center gap-2">
              <Briefcase className="w-8 h-8 text-sky-600" />
              Meu Plano
            </h1>
            <p className="text-gray-500 dark:text-gray-400 text-sm mt-1">
              Gerencie e acompanhe o status do seu plano de assinatura
            </p>
          </div>
        </header>

        {/* Main Plan Card */}
        <Card className={`${statusInfo.bgColor} ${statusInfo.borderColor} border-2 mb-6 shadow-md`}>
          <CardHeader>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Crown className="w-5 h-5 text-sky-600" />
                <CardTitle className="text-lg">Status do Plano</CardTitle>
              </div>
              <Badge variant={statusInfo.variant} className="flex items-center gap-1">
                <StatusIcon className="w-3 h-3" />
                {statusInfo.text}
              </Badge>
            </div>
            {plano && (
              <p className="text-gray-600 dark:text-gray-400">
                Plano <span className="font-semibold">{plano.nome}</span> ativo
              </p>
            )}
          </CardHeader>

          <CardContent className="space-y-6">
            {/* Usage Statistics */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="text-center">
                <div className="flex items-center justify-center w-12 h-12 bg-white shadow-md rounded-xl mx-auto mb-3">
                  <Users className="w-6 h-6 text-sky-600" />
                </div>
                <p className="text-sm text-gray-600 mb-1">Alunos Ativos</p>
                <p className="text-2xl font-bold text-gray-800">{alunosAtivos}</p>
              </div>

              <div className="text-center">
                <div className="flex items-center justify-center w-12 h-12 bg-white shadow-md rounded-xl mx-auto mb-3">
                  <TrendingUp className="w-6 h-6 text-purple-600" />
                </div>
                <p className="text-sm text-gray-600 mb-1">Limite</p>
                <p className="text-2xl font-bold text-gray-800">{limiteAtual}</p>
              </div>

              <div className="text-center">
                <div className="flex items-center justify-center w-12 h-12 bg-white shadow-md rounded-xl mx-auto mb-3">
                  <CheckCircle className="w-6 h-6 text-green-600" />
                </div>
                <p className="text-sm text-gray-600 mb-1">Disponível</p>
                <p className="text-2xl font-bold text-gray-800">{vagasDisponiveis}</p>
              </div>

              {tokensAvulsos > 0 && (
                <div className="text-center">
                  <div className="flex items-center justify-center w-12 h-12 bg-white shadow-md rounded-xl mx-auto mb-3">
                    <Zap className="w-6 h-6 text-amber-600" />
                  </div>
                  <p className="text-sm text-gray-600 mb-1">Tokens</p>
                  <p className="text-2xl font-bold text-gray-800">{tokensAvulsos}</p>
                </div>
              )}
            </div>

            {/* Usage Progress */}
            <div className="bg-white/70 p-4 rounded-xl">
              <div className="flex justify-between items-center mb-3">
                <span className="text-sm font-medium text-gray-700">Utilização do Plano</span>
                <span className="text-sm text-gray-600">{displayPercentualUso}%</span>
              </div>
              <Progress 
                value={displayPercentualUso} 
                className="h-3"
              />
              <div className="flex justify-between text-xs text-gray-500 mt-2">
                <span>{alunosAtivos} usados</span>
                <span>{limiteAtual} total</span>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Plan Details Cards */}
        {plano && personalPlano && (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            {/* Plan Information Card */}
            <Card className="bg-white shadow-md border border-zinc-100">
              <CardHeader>
                <CardTitle className="text-lg flex items-center gap-2">
                  <RocketIcon className="w-5 h-5 text-sky-500" />
                  Informações do Plano
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <span className="text-sm text-gray-600">Nome do Plano:</span>
                  <p className="font-semibold text-gray-800">{plano.nome}</p>
                </div>
                <div>
                  <span className="text-sm text-gray-600">Valor:</span>
                  <p className="font-semibold text-gray-800">
                    {plano.preco === 0 ? 'Gratuito' : `R$ ${plano.preco.toFixed(2)}`}
                  </p>
                </div>
                <div>
                  <span className="text-sm text-gray-600">Descrição:</span>
                  <p className="text-gray-700 text-sm">{plano.descricao || 'Sem descrição disponível'}</p>
                </div>
              </CardContent>
            </Card>

            {/* Dates Card */}
            <Card className="bg-white shadow-md border border-zinc-100">
              <CardHeader>
                <CardTitle className="text-lg flex items-center gap-2">
                  <CalendarDays className="w-5 h-5 text-amber-500" />
                  Datas Importantes
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <span className="text-sm text-gray-600">Data de Início:</span>
                  <p className="font-semibold text-gray-800">{formatDate(personalPlano.dataInicio)}</p>
                </div>
                <div>
                  <span className="text-sm text-gray-600">Data de Vencimento:</span>
                  <p className="font-semibold text-gray-800">
                    {formatDate(personalPlano.dataVencimento)}
                    {daysUntilExpiration !== null && (
                      <span className={`ml-2 text-xs px-2 py-1 rounded-full ${
                        daysUntilExpiration <= 7 ? 'bg-red-100 text-red-600' : 
                        daysUntilExpiration <= 30 ? 'bg-yellow-100 text-yellow-600' : 'bg-green-100 text-green-600'
                      }`}>
                        {daysUntilExpiration > 0 ? `${daysUntilExpiration} dias restantes` : 'Vencido'}
                      </span>
                    )}
                  </p>
                </div>
              </CardContent>
            </Card>
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex gap-4 mb-6">
          {!podeAtivarMais && (
            <Button 
              onClick={handleUpgradeClick}
              className="flex-1 py-6"
              variant={displayPercentualUso >= 90 ? "destructive" : "default"}
              size="lg"
            >
              <RocketIcon className="w-4 h-4 mr-2" />
              {displayPercentualUso >= 90 ? 'Upgrade Urgente' : 'Fazer Upgrade'}
            </Button>
          )}
          
          {!plano && (
            <Button onClick={handleUpgradeClick} className="flex-1 py-6" size="lg">
              <Crown className="w-4 h-4 mr-2" />
              Ativar Plano
            </Button>
          )}
        </div>

        {/* Warnings */}
        {daysUntilExpiration !== null && daysUntilExpiration <= 7 && daysUntilExpiration > 0 && (
          <Card className="bg-yellow-50 border-yellow-200 border-2 mb-4">
            <CardContent className="pt-6">
              <div className="flex items-center gap-3 text-yellow-800">
                <AlertTriangle className="w-5 h-5" />
                <span className="font-medium">
                  Seu plano vence em {daysUntilExpiration} dia{daysUntilExpiration !== 1 ? 's' : ''}
                </span>
              </div>
            </CardContent>
          </Card>
        )}

        {!podeAtivarMais && limiteAtual > 0 && (
          <Card className="bg-red-50 border-red-200 border-2">
            <CardContent className="pt-6">
              <div className="flex items-center gap-3 text-red-800">
                <AlertTriangle className="w-5 h-5" />
                <span className="font-medium">
                  Limite de alunos atingido. Faça upgrade para adicionar mais alunos.
                </span>
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    </ErrorBoundary>
  );
}
===== ./client/src/pages/not-found.tsx =====
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}

===== ./client/src/pages/perfil/editar.tsx =====
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useUser, User } from '@/context/UserContext'; // Importa User
import { useToast } from '@/hooks/use-toast'; // Usa o hook correto
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Loader2 } from 'lucide-react';

// Interface para os dados a serem enviados para a API
interface UpdateProfilePayload {
    firstName: string;
    lastName: string;
    // avatarUrl?: string; // Para quando implementar upload de foto
}

export default function ProfileEditPage() {
    const { user, setUser, isLoading: isLoadingUserContext } = useUser();
    const { toast } = useToast(); // Usa o hook
    const queryClient = useQueryClient();

    // Estados locais do formulário
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    // const [avatarFile, setAvatarFile] = useState<File | null>(null);
    // const [avatarPreview, setAvatarPreview] = useState<string | null>(null);

    // Efeito para preencher o formulário quando o usuário do contexto carregar/mudar
    useEffect(() => {
        if (user) {
            setFirstName(user.firstName || '');
            setLastName(user.lastName || '');
            // setAvatarPreview(user.avatarUrl || null);
        }
    }, [user]);

    // Função de formatação de URL (CORRIGIDA com retorno explícito)
    const formatVideoUrl = (url: string): string | undefined => {
        if (!url) return undefined;
        let embedUrl: string | undefined = undefined;
        try { // Adiciona try/catch para robustez em caso de URL malformada
            if (url.includes("youtu.be/")) {
                const id = url.split("youtu.be/")[1]?.split(/[?&]/)[0];
                if (id) {
                    const time = url.includes("?t=") ? url.split("?t=")[1]?.split("&")[0] : "";
                    embedUrl = `https://www.youtube.com/embed/${id}${time ? `?start=${time}` : ""}`;
                }
            } else if (url.includes("youtube.com/watch?v=")) {
                const id = url.split("v=")[1]?.split("&")[0];
                 if (id) {
                    const time = url.includes("?t=") ? url.split("?t=")[1]?.split("&")[0] : "";
                    embedUrl = `https://www.youtube.com/embed/${id}${time ? `?start=${time}` : ""}`;
                 }
            } else if (url.includes("drive.google.com/file/d/")) {
                const id = url.split("/d/")[1]?.split("/")[0];
                if (id) {
                   embedUrl = `https://drive.google.com/file/d/${id}/preview`;
                }
            }
        } catch (e) {
             console.error("Erro ao formatar URL de vídeo:", e);
             embedUrl = undefined; // Retorna undefined em caso de erro
        }

        // Retorna a URL original apenas se for um link válido e NÃO foi convertida
        if (!embedUrl && (url.startsWith('http://') || url.startsWith('https://'))) {
            return url;
        }
        // Retorna a URL convertida ou undefined
        return embedUrl;
    }

    // Mutação para atualizar o perfil
    const updateProfileMutation = useMutation<
        { message: string; user: User },
        Error,
        UpdateProfilePayload
    >({
        mutationFn: (payload) => {
            return apiRequest<{ message: string; user: User }>("PATCH", "/api/profile/me", payload);
        },
        onSuccess: (data) => {
            setUser(data.user);
            toast({ title: "Sucesso", description: data.message || "Perfil atualizado." });
            // queryClient.invalidateQueries({ queryKey: ['algumaQueryDoUsuario'] }); // Se necessário
        },
        onError: (error) => {
            toast({ variant: "destructive", title: "Erro ao Atualizar", description: error.message || "Não foi possível salvar as alterações." });
        }
    });

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (file) {
            toast({ title: "Upload de Foto", description: "Funcionalidade de upload de foto em breve.", variant: "default"});
        }
    };

    const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        if (!firstName.trim() || !lastName.trim()) {
             toast({ variant: "destructive", title: "Erro", description: "Nome e Sobrenome são obrigatórios." });
            return;
        }
        const payload: UpdateProfilePayload = {
            firstName: firstName.trim(),
            lastName: lastName.trim(),
        };
        updateProfileMutation.mutate(payload);
    };

    // Função para gerar iniciais
     const getInitials = (fName: string = "", lName: string = ""): string => {
        const firstInitial = fName?.[0] || '';
        const lastInitial = lName?.[0] || '';
        return `${firstInitial}${lastInitial}`.toUpperCase() || '?';
     };

    // Renderização de Loading ou Erro se usuário não carregado
    if (isLoadingUserContext) {
        return (
             <div className="flex justify-center items-center h-full pt-20"> {/* Ajuste no h-full */}
                 <Loader2 className="h-8 w-8 animate-spin text-primary" />
                 <p className="ml-2">Carregando perfil...</p>
             </div>
        );
    }
    if (!user) {
        return <div className="text-center py-10">Usuário não encontrado. Por favor, faça login novamente.</div>;
    }

    // Renderização principal
    return (
        <div className="container mx-auto max-w-3xl py-8 px-4">
            <Card>
                <CardHeader>
                    <CardTitle>Editar Perfil</CardTitle>
                    <CardDescription>Atualize suas informações pessoais.</CardDescription>
                </CardHeader>
                <form onSubmit={handleSubmit}>
                    <CardContent className="space-y-6">
                        {/* Seção da Foto */}
                        <div className="flex flex-col items-center gap-4">
                            <Avatar className="h-24 w-24 border-2 border-primary/20">
                                {/* <AvatarImage src={avatarPreview || user.avatarUrl} alt="Foto de Perfil" /> */}
                                <AvatarFallback className="text-3xl bg-primary/10 text-primary dark:bg-primary/20">
                                    {getInitials(user.firstName, user.lastName)}
                                </AvatarFallback>
                            </Avatar>
                            {/* Input de Arquivo (Comentado) */}
                            {/* <Input id="picture" type="file" accept="image/*" onChange={handleFileChange} className="max-w-xs ..." /> */}
                             <p className="text-xs text-muted-foreground">(Upload de foto em breve)</p>
                        </div>

                        {/* Campos de Nome */}
                        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div className="space-y-2">
                                <Label htmlFor="firstName">Nome</Label>
                                <Input
                                    id="firstName"
                                    value={firstName}
                                    onChange={(e) => setFirstName(e.target.value)}
                                    required
                                    disabled={updateProfileMutation.isPending}
                                />
                            </div>
                            <div className="space-y-2">
                                <Label htmlFor="lastName">Sobrenome</Label>
                                <Input
                                    id="lastName"
                                    value={lastName}
                                    onChange={(e) => setLastName(e.target.value)}
                                    required
                                    disabled={updateProfileMutation.isPending}
                                />
                            </div>
                        </div>
                        {/* Campo Email (Desabilitado) */}
                         <div className="space-y-2">
                             <Label htmlFor="email">Email</Label>
                             <Input id="email" value={user.email} disabled />
                             <p className="text-xs text-muted-foreground">O email não pode ser alterado.</p>
                         </div>

                    </CardContent>
                    <CardFooter>
                        <Button type="submit" disabled={updateProfileMutation.isPending}>
                            {updateProfileMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                            Salvar Alterações
                        </Button>
                    </CardFooter>
                </form>
            </Card>
        </div>
    );
}
===== ./client/src/pages/public/AlunoLoginPage.tsx =====
// Localização: client/src/pages/public/AlunoLoginPage.tsx
import React, { useState, useContext, useEffect } from 'react';
import { useLocation, Link } from 'wouter';
import { AlunoContext } from '@/context/AlunoContext';
import { useToast } from "@/hooks/use-toast";
import { Loader2, ArrowLeft, Mail, Lock, User, GraduationCap } from "lucide-react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from '@/components/ui/card';
import { apiRequest } from '@/lib/queryClient';

interface AlunoLoginApiResponse {
    message: string;
    token: string;
    refreshToken: string;
    aluno: { id: string; nome: string; email: string; role: 'Aluno'; personalId: string; };
    code?: string;
}

export default function AlunoLoginPage() {
    const [, navigate] = useLocation();
    const alunoContext = useContext(AlunoContext);
    const { toast } = useToast();
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState("");

    const { loginAluno, aluno: alunoLogado, isLoadingAluno } = alunoContext || {};

    useEffect(() => {
        if (!isLoadingAluno && alunoLogado) {
            navigate("/aluno/dashboard", { replace: true }); 
        }
    }, [alunoLogado, isLoadingAluno, navigate]);

    const handleLoginAluno = async (e: React.FormEvent) => {
        e.preventDefault();
        setError("");
        setIsLoading(true);
        try {
            const response = await apiRequest<AlunoLoginApiResponse>(
                'POST',
                '/api/auth/aluno/login', 
                { email: email.toLowerCase().trim(), password }
            );
            localStorage.setItem('alunoRefreshToken', response.refreshToken);
            loginAluno?.(response.token);
            toast({ title: "Login bem-sucedido!", description: `Bem-vindo(a) de volta, ${response.aluno.nome || 'Aluno'}!` });
        } catch (err: any) {
            const errorMessage = err.message || 'Credenciais inválidas ou erro no servidor.';
            const errorCode = err.code;

            if (errorCode === 'ACCOUNT_INACTIVE') {
                setError('Sua conta está inativa. Por favor, entre em contato com seu personal trainer para reativá-la.');
            } else {
                setError(errorMessage);
            }
            toast({ title: "Erro no Login", description: errorMessage, variant: "destructive" });
        } finally {
            setIsLoading(false);
        }
    };
    
    if (isLoadingAluno) {
        return (
            <div className="flex h-screen w-full items-center justify-center bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500">
                <div className="text-white text-center space-y-4">
                    <Loader2 className="h-10 w-10 animate-spin mx-auto" />
                    <span className="text-lg">Verificando sessão...</span>
                </div>
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500 lg:grid lg:grid-cols-2">
            {/* Left Side - Login Form */}
            <div className="flex items-center justify-center py-12 px-4 sm:px-6 lg:px-8">
                <div className="w-full max-w-md space-y-8">
                    {/* Logo and Title Section */}
                    <div className="text-center space-y-6 animate-fade-in">
                        <div className="flex items-center justify-center">
                            <img 
                                src="/images/logo-branco.png" 
                                alt="DyFit Logo" 
                                className="h-16 w-auto object-contain"
                            />
                        </div>
                        <div>
                            <h1 className="text-3xl font-bold text-white">Entrar como Aluno</h1>
                            <p className="text-white/80 mt-2">Acesse seus treinos e acompanhe seu progresso</p>
                        </div>
                    </div>

                    {/* Login Form Card */}
                    <Card className="glass border-white/20 shadow-glass animate-slide-up">
                        <CardContent className="p-6">
                            <form onSubmit={handleLoginAluno} className="space-y-6">
                                {error && (
                                    <div className="p-3 bg-destructive/10 border border-destructive/20 rounded-xl text-destructive text-sm animate-slide-down">
                                        {error}
                                    </div>
                                )}
                                
                                <div className="space-y-4">
                                    <div className="relative">
                                        <Mail className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
                                        <Input 
                                            id="email-aluno" 
                                            type="email" 
                                            placeholder="seu.email@exemplo.com" 
                                            required 
                                            value={email} 
                                            onChange={(e) => setEmail(e.target.value)} 
                                            disabled={isLoading} 
                                            autoComplete="email" 
                                            className="pl-12 h-12 text-base bg-background/95 backdrop-blur-sm" 
                                        />
                                    </div>
                                    
                                    <div className="relative">
                                        <Lock className="absolute left-4 top-1/2 -translate-y-1/2 h-5 w-5 text-muted-foreground" />
                                        <Input 
                                            id="password-aluno" 
                                            type="password" 
                                            placeholder="Sua senha" 
                                            required 
                                            value={password} 
                                            onChange={(e) => setPassword(e.target.value)} 
                                            disabled={isLoading} 
                                            autoComplete="current-password" 
                                            className="pl-12 h-12 text-base bg-background/95 backdrop-blur-sm" 
                                        />
                                    </div>
                                </div>

                                <Button 
                                    type="submit" 
                                    size="lg"
                                    className="w-full bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700" 
                                    disabled={isLoading}
                                    loading={isLoading}
                                >
                                    Entrar
                                </Button>
                            </form>
                            
                            <div className="mt-6 text-center">
                                <Link 
                                    href="/login" 
                                    className="inline-flex items-center text-muted-foreground hover:text-white transition-colors group"
                                >
                                    <ArrowLeft className="mr-2 h-4 w-4 group-hover:-translate-x-1 transition-transform" />
                                    Voltar para seleção de perfil
                                </Link>
                            </div>
                        </CardContent>
                    </Card>
                </div>
            </div>

            {/* Right Side - Visual Element (Desktop only) */}
            <div className="hidden lg:flex items-center justify-center p-8">
                <div className="w-full h-full rounded-2xl bg-gradient-to-br from-white/10 to-white/5 glass border border-white/10 flex items-center justify-center animate-scale-in">
                    <div className="text-center text-white space-y-6">
                        <div className="w-32 h-32 mx-auto bg-gradient-to-r from-white/20 to-white/10 rounded-full flex items-center justify-center mb-8 shadow-glass border border-white/20">
                            <GraduationCap className="h-16 w-16" />
                        </div>
                        <div className="space-y-3">
                            <h2 className="text-2xl font-bold">Sua jornada fitness continua!</h2>
                            <p className="text-white/80 max-w-sm">
                                Acesse seus treinos personalizados e acompanhe sua evolução
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
}
===== ./client/src/pages/public/CadastroAlunoPorConvitePage.tsx =====
// client/src/pages/public/CadastroAlunoPorConvitePage.tsx
import React, { useState } from 'react'; // 'useEffect' removido daqui
import { useLocation, useParams } from 'wouter';
import { useQuery, useMutation } from '@tanstack/react-query';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

import { apiRequest } from '@/lib/queryClient';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { Loader2 } from 'lucide-react';
import ErrorMessage from '@/components/ErrorMessage';
import LoadingSpinner from '@/components/LoadingSpinner';
import { formatDateForInput } from '@/utils/dateUtils';

const formSchema = z.object({
  email: z.string().email("Por favor, insira um e-mail válido.").optional(),
  nome: z.string().min(3, "Nome completo é obrigatório."),
  password: z.string().min(6, "A senha deve ter no mínimo 6 caracteres."),
  confirmPassword: z.string(),
  phone: z.string().optional(),
  birthDate: z.string().min(1, "Data de nascimento é obrigatória."),
  gender: z.enum(['masculino', 'feminino', 'outro']),
  goal: z.string().min(1, "Objetivo é obrigatório."),
  weight: z.string().min(1, "Peso é obrigatório.").refine(val => !isNaN(parseFloat(val.replace(',', '.'))), "Deve ser um número."),
  height: z.string().min(1, "Altura é obrigatória.").refine(val => /^\d+$/.test(val), "Deve ser um número inteiro."),
  startDate: z.string(),
}).refine(data => data.password === data.confirmPassword, {
  message: "As senhas não coincidem.",
  path: ["confirmPassword"],
}).refine(data => {
    // Torna o e-mail obrigatório apenas se não for fornecido pela API
    if (!data.email) return false;
    return true;
}, {
    message: "O e-mail é obrigatório.",
    path: ["email"],
});

type FormValues = z.infer<typeof formSchema>;

const CadastroAlunoPorConvitePage: React.FC = () => {
  const params = useParams<{ token: string }>();
  const token = params.token;
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const [emailConvidado, setEmailConvidado] = useState<string | null>(null);
  const [personalName, setPersonalName] = useState<string | null>(null);

  // Debug logging for production troubleshooting
  const isDebugMode = import.meta.env.VITE_DEBUG_INVITATIONS === 'true';
  
  React.useEffect(() => {
    if (isDebugMode || import.meta.env.DEV) {
      console.log('[CadastroAlunoPorConvitePage] Página carregada com token:', token);
      console.log('[CadastroAlunoPorConvitePage] URL atual:', window.location.href);
      console.log('[CadastroAlunoPorConvitePage] Pathname:', window.location.pathname);
      console.log('[CadastroAlunoPorConvitePage] Environment:', import.meta.env.MODE);
    }
  }, [token, isDebugMode]);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: "", nome: "", password: "", confirmPassword: "", phone: "", birthDate: "",
      goal: "", weight: "", height: "", startDate: formatDateForInput(new Date().toISOString())
    },
  });

  const { isLoading: isValidating, isError, error: validationError } = useQuery({
    queryKey: ['validateAlunoInvite', token],
    queryFn: async () => {
      if (isDebugMode || import.meta.env.DEV) {
        console.log('[CadastroAlunoPorConvitePage] Validando token:', token);
      }
      try {
        const data = await apiRequest<{ email?: string; personalName: string }>('GET', `/api/public/convite-aluno/${token}`);
        if (isDebugMode || import.meta.env.DEV) {
          console.log('[CadastroAlunoPorConvitePage] Token validado com sucesso:', data);
        }
        
        if (data.email) {
          setEmailConvidado(data.email);
          form.setValue('email', data.email); // Pré-popula o formulário com o e-mail
        }
        setPersonalName(data.personalName);
        return data;
      } catch (error) {
        if (isDebugMode || import.meta.env.DEV) {
          console.error('[CadastroAlunoPorConvitePage] Erro na validação do token:', error);
        }
        throw error;
      }
    },
    enabled: !!token,
    retry: false,
  });

  const registerMutation = useMutation({
    mutationFn: (data: FormValues) => {
        const { confirmPassword, ...payload } = data;
        return apiRequest('POST', '/api/public/convite-aluno/registrar', {
          token,
          ...payload,
          weight: parseFloat(payload.weight.replace(',', '.')),
          height: parseInt(payload.height, 10),
        })
    },
    onSuccess: () => {
      toast({
        title: "Cadastro realizado com sucesso!",
        description: "Você já pode fazer login com seu e-mail e senha.",
      });
      setLocation('/aluno/login');
    },
    onError: (error: Error) => {
      toast({ variant: "destructive", title: "Erro no Cadastro", description: error.message });
    },
  });

  const onSubmit = (data: FormValues) => registerMutation.mutate(data);
  
  if (!token) {
    return (
      <ErrorMessage 
        title="Link de Convite Inválido" 
        message="O link de convite está malformado ou incompleto. Verifique se você acessou o link correto enviado pelo seu personal trainer." 
      />
    );
  }
  
  if (isValidating) return <LoadingSpinner text="Validando convite..." />;
  if (isError) return <ErrorMessage title="Convite Inválido" message={validationError?.message || "O link de convite que você usou é inválido ou já expirou."} />;

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 p-4">
      <Card className="w-full max-w-lg bg-white text-gray-800 shadow-lg">
        <CardHeader className="text-center pb-4">
          <img src="/logodyfit.png" alt="DyFit Logo" className="mx-auto mb-4 h-12 w-auto" />
          <CardTitle className="text-2xl font-bold text-primary">Bem-vindo(a) ao DyFit!</CardTitle>
          {personalName && (
            <CardDescription className="text-lg text-gray-600 mt-2">
              Seu personal, <span className="font-semibold text-primary">{personalName}</span>, te convidou.
            </CardDescription>
          )}
          <CardDescription className="text-gray-600">Complete seus dados para acessar a plataforma.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {emailConvidado ? (
                  <FormItem>
                    <FormLabel className="text-gray-700">Email</FormLabel>
                    <FormControl><Input value={emailConvidado} disabled className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                  </FormItem>
                ) : (
                  <FormField control={form.control} name="email" render={({ field }) => ( 
                    <FormItem>
                      <FormLabel className="text-gray-700">Email*</FormLabel>
                      <FormControl><Input placeholder="seu.email@exemplo.com" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                      <FormMessage />
                    </FormItem> 
                  )} />
                )}
                <FormField control={form.control} name="nome" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Nome Completo*</FormLabel>
                    <FormControl><Input placeholder="Seu nome completo" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
                {/* ... outros campos do formulário permanecem iguais ... */}
                <FormField control={form.control} name="password" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Crie uma Senha*</FormLabel>
                    <FormControl><Input type="password" placeholder="Mínimo de 6 caracteres" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="confirmPassword" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Confirme sua Senha*</FormLabel>
                    <FormControl><Input type="password" placeholder="Repita a senha" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="phone" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Telefone</FormLabel>
                    <FormControl><Input placeholder="(00) 00000-0000" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="birthDate" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Data de Nascimento*</FormLabel>
                    <FormControl><Input type="date" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="gender" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Gênero*</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary">
                          <SelectValue placeholder="Selecione..." />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="bg-white text-gray-800 border-gray-300">
                        <SelectItem value="masculino">Masculino</SelectItem>
                        <SelectItem value="feminino">Feminino</SelectItem>
                        <SelectItem value="outro">Outro</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="goal" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Objetivo Principal*</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary">
                          <SelectValue placeholder="Selecione..." />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="bg-white text-gray-800 border-gray-300">
                        <SelectItem value="Hipertrofia">Hipertrofia</SelectItem>
                        <SelectItem value="Emagrecimento">Emagrecimento</SelectItem>
                        <SelectItem value="Outros">Outros</SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="weight" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Peso (kg)*</FormLabel>
                    <FormControl><Input placeholder="Ex: 75.5" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="height" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Altura (cm)*</FormLabel>
                    <FormControl><Input placeholder="Ex: 178" {...field} className="bg-gray-50 border-gray-300 text-gray-800 focus:ring-primary" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
                <FormField control={form.control} name="startDate" render={({ field }) => ( 
                  <FormItem>
                    <FormLabel className="text-gray-700">Data de Início</FormLabel>
                    <FormControl><Input type="date" {...field} disabled className="bg-gray-50 border-gray-300 text-gray-800" /></FormControl>
                    <FormMessage />
                  </FormItem> 
                )} />
              </div>
              <Button type="submit" className="w-full mt-6 bg-primary text-primary-foreground hover:bg-primary/90" disabled={registerMutation.isPending}>
                {registerMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Finalizar Cadastro
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
};

export default CadastroAlunoPorConvitePage;
===== ./client/src/pages/public/CadastroPersonalPorConvitePage.tsx =====
// Localização: client/src/pages/public/CadastroPersonalPorConvitePage.tsx
import React, { useState } from 'react';
import { useParams, useLocation } from 'wouter';
import { useQuery, useMutation } from '@tanstack/react-query';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from '@/lib/queryClient';
import { Loader2, ShieldCheck, Users, BarChart, User, Mail, KeyRound } from 'lucide-react';

const formSchema = z.object({
  nome: z.string().min(3, { message: "O nome completo é obrigatório." }),
  email: z.string().email({ message: "Por favor, insira um e-mail válido." }),
  password: z.string().min(6, { message: "A senha deve ter no mínimo 6 caracteres." }),
  confirmPassword: z.string(),
}).refine(data => data.password === data.confirmPassword, {
  message: "As senhas não coincidem.",
  path: ["confirmPassword"],
});

type FormValues = z.infer<typeof formSchema>;
type ValidacaoTokenResponse = { emailConvidado?: string };

const CadastroPersonalPorConvitePage: React.FC = () => {
  const params = useParams<{ tokenDeConvite?: string }>();
  const tokenDeConvite = params.tokenDeConvite;
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  
  const [emailConvidado, setEmailConvidado] = useState<string | undefined>();
  const [registrationSuccess, setRegistrationSuccess] = useState(false);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: { nome: '', email: '', password: '', confirmPassword: '' },
  });

  const validationQuery = useQuery({
    queryKey: ['validatePersonalInvite', tokenDeConvite],
    queryFn: async () => {
      const data = await apiRequest<ValidacaoTokenResponse>('GET', `/api/public/convites/validar/${tokenDeConvite}`);
      if (data.emailConvidado) {
        setEmailConvidado(data.emailConvidado);
        form.setValue('email', data.emailConvidado);
      }
      return data;
    },
    enabled: !!tokenDeConvite,
    retry: false,
  });

  const registrationMutation = useMutation({
    mutationFn: (data: FormValues) => {
      const { confirmPassword, ...payload } = data;
      return apiRequest('POST', `/api/public/convites/registrar/${tokenDeConvite}`, payload);
    },
    onSuccess: () => {
      toast({
        title: "Cadastro Realizado com Sucesso!",
        description: "Sua conta foi criada. Você já pode fazer o login.",
      });
      setRegistrationSuccess(true);
    },
    onError: (error: Error) => {
      toast({
        variant: "destructive",
        title: "Erro no Cadastro",
        description: error.message || "Não foi possível completar o cadastro.",
      });
    },
  });

  const onSubmit = (data: FormValues) => {
    registrationMutation.mutate(data);
  };

  if (validationQuery.isLoading) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-slate-100 p-4">
        <Loader2 className="h-12 w-12 animate-spin text-primary mb-4" />
        <p className="text-lg text-slate-700">Validando seu convite...</p>
      </div>
    );
  }

  if (validationQuery.isError) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-slate-100 p-4">
        <Card className="w-full max-w-md shadow-xl text-center">
          <CardHeader>
            <CardTitle className="text-2xl text-destructive">Convite Inválido</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-destructive-foreground bg-destructive/10 p-3 rounded-md">{validationQuery.error.message || "O link é inválido, expirou ou já foi utilizado."}</p>
            <p className="mt-4 text-sm text-slate-600">Por favor, solicite um novo link ao administrador da plataforma.</p>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (registrationSuccess) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-slate-100 p-4">
        <Card className="w-full max-w-md shadow-xl text-center">
          <CardHeader>
            <CardTitle className="text-2xl text-green-600">Cadastro Concluído!</CardTitle>
            <CardDescription className="text-base pt-2">Sua jornada no DyFit começa agora!</CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-slate-700">Sua conta foi criada com sucesso e está pronta para uso.</p>
          </CardContent>
          <CardFooter>
            <Button onClick={() => setLocation('/login')} className="w-full">
              Ir para a tela de Login
            </Button>
          </CardFooter>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-slate-100 flex items-center justify-center p-4 lg:p-8">
      <div className="w-full max-w-6xl mx-auto grid lg:grid-cols-2 gap-8 lg:gap-16 items-center bg-white shadow-2xl rounded-xl overflow-hidden">
        {/* Coluna Esquerda: Visual */}
        <div className="hidden lg:flex flex-col justify-center p-12 bg-gradient-to-br from-gray-900 to-gray-800 h-full text-primary-foreground">
          <img src="/logodyfit.png" alt="Logo DyFit" className="w-28 h-auto mb-8" />
          <h1 className="text-4xl font-bold leading-tight">Dê um upgrade na sua carreira.</h1>
          <p className="mt-4 text-lg text-primary-foreground/90">Junte-se a uma comunidade de personais que estão transformando a maneira de treinar.</p>
          <ul className="mt-8 space-y-4 text-base">
            <li className="flex items-center gap-3">
              <ShieldCheck className="h-6 w-6 text-green-300" />
              <span>Gestão completa e segura de alunos.</span>
            </li>
            <li className="flex items-center gap-3">
              <Users className="h-6 w-6 text-green-300" />
              <span>Crie e personalize treinos com facilidade.</span>
            </li>
            <li className="flex items-center gap-3">
              <BarChart className="h-6 w-6 text-green-300" />
              <span>Acompanhe o progresso com relatórios visuais.</span>
            </li>
          </ul>
        </div>

        {/* Coluna Direita: Formulário */}
        <div className="p-8 lg:p-12">
          <div className="lg:hidden text-center mb-8">
             <img src="/logodyfit.png" alt="Logo DyFit" className="w-20 h-auto mx-auto mb-4" />
          </div>
          <h2 className="text-3xl font-bold text-slate-800">Bem-vindo(a) ao DyFit!</h2>
          <p className="text-slate-600 mt-2">Parabéns por se juntar à mais completa ferramenta de gestão para Personal Trainers. Crie sua conta para começar.</p>
          
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="mt-8 space-y-6">
              <FormField control={form.control} name="nome" render={({ field }) => (
                <FormItem>
                  <FormLabel>Nome Completo</FormLabel>
                  <FormControl>
                    <div className="relative">
                      <User className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400" />
                      <Input placeholder="Seu nome completo" {...field} className="pl-10" />
                    </div>
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}/>
              
              <FormField control={form.control} name="email" render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <div className="relative">
                       <Mail className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400" />
                       <Input placeholder="seu.email@exemplo.com" {...field} disabled={!!emailConvidado} className="pl-10 disabled:opacity-70 disabled:cursor-not-allowed" />
                    </div>
                  </FormControl>
                  {emailConvidado && <p className="text-xs text-muted-foreground mt-1">Este e-mail foi pré-definido pelo convite.</p>}
                  <FormMessage />
                </FormItem>
              )}/>

              <div className="grid sm:grid-cols-2 gap-6">
                <FormField control={form.control} name="password" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Crie sua Senha</FormLabel>
                    <FormControl>
                       <div className="relative">
                          <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400" />
                          <Input type="password" placeholder="Mín. 6 caracteres" {...field} className="pl-10" />
                       </div>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}/>

                <FormField control={form.control} name="confirmPassword" render={({ field }) => (
                  <FormItem>
                    <FormLabel>Confirme a Senha</FormLabel>
                    <FormControl>
                      <div className="relative">
                        <KeyRound className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-slate-400" />
                        <Input type="password" placeholder="Repita a senha" {...field} className="pl-10" />
                      </div>
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}/>
              </div>

              <Button type="submit" className="w-full text-lg font-semibold py-6" disabled={registrationMutation.isPending}>
                {registrationMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Criar Minha Conta
              </Button>
            </form>
          </Form>
        </div>
      </div>
    </div>
  );
};

export default CadastroPersonalPorConvitePage;
===== ./client/src/pages/public/LandingLoginPage.tsx =====
// client/src/pages/public/LandingLoginPage.tsx
import { Link } from 'wouter';
import { Shield, User, Download, Dumbbell, TrendingUp, Users } from 'lucide-react';
import { usePWAInstall } from '@/context/PWAInstallContext';

const ProfileButton = ({ href, text, icon: Icon, description }: { 
  href: string; 
  text: string; 
  icon: React.ElementType; 
  description: string;
}) => (
  <Link 
    href={href}
    className="group relative overflow-hidden bg-gradient-to-r from-primary to-primary/80 hover:from-primary/90 hover:to-primary text-primary-foreground rounded-xl p-6 min-h-[80px] transition-all duration-300 hover:shadow-xl hover:shadow-primary/25 hover:-translate-y-1 interactive touch-target block"
  >
    <div className="flex items-center gap-4">
      <div className="p-3 bg-white/20 rounded-lg group-hover:bg-white/30 transition-colors flex-shrink-0">
        <Icon className="h-6 w-6" />
      </div>
      <div className="flex-1 text-left">
        <h3 className="font-semibold text-lg leading-tight">{text}</h3>
        <p className="text-primary-foreground/80 text-sm mt-1 leading-relaxed">{description}</p>
      </div>
    </div>
    <div className="absolute inset-0 bg-gradient-to-r from-white/0 to-white/5 opacity-0 group-hover:opacity-100 transition-opacity" />
  </Link>
);

const ActionButton = ({ onClick, text, icon: Icon, className }: { 
  onClick: () => void; 
  text: string; 
  icon: React.ElementType; 
  className: string;
}) => (
  <button
    onClick={onClick}
    className={`flex items-center justify-center gap-3 w-full font-semibold py-4 px-6 min-h-[56px] rounded-xl text-center shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1 interactive touch-target ${className}`}
  >
    <Icon className="h-5 w-5" />
    <span>{text}</span>
  </button>
);


export default function LandingLoginPage() {
    const { canInstall, triggerInstallPrompt } = usePWAInstall();

    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-indigo-900 text-white antialiased">
            {/* LAYOUT DESKTOP */}
            <div className="hidden lg:flex min-h-screen flex-col items-center justify-center px-4 py-8">
                <main className="w-full max-w-6xl mx-auto grid grid-cols-2 gap-12 items-center">
                    {/* Left Side - Hero Content */}
                    <div className="space-y-8 animate-fade-in">
                        <div className="space-y-6">
                            <div className="flex items-center gap-3 mb-6">
                                <img 
                                    src="/logodyfit.png" 
                                    alt="DyFit Logo" 
                                    className="h-12 w-auto object-contain"
                                />
                            </div>
                            
                            <h1 className="text-5xl lg:text-6xl font-bold leading-tight">
                                Sua jornada fitness,{' '}
                                <span className="text-gradient">simplificada</span>
                            </h1>
                            
                            <p className="text-xl text-slate-300 leading-relaxed max-w-lg">
                                A plataforma completa que conecta personal trainers e alunos. 
                                Gerencie treinos, acompanhe progressos e alcance seus objetivos.
                            </p>
                        </div>

                        {/* Feature highlights */}
                        <div className="grid grid-cols-2 gap-4 pt-6">
                            <div className="flex items-center gap-3 text-slate-300">
                                <TrendingUp className="h-5 w-5 text-primary" />
                                <span className="text-sm">Acompanhamento em tempo real</span>
                            </div>
                            <div className="flex items-center gap-3 text-slate-300">
                                <Users className="h-5 w-5 text-primary" />
                                <span className="text-sm">Comunicação direta</span>
                            </div>
                        </div>
                    </div>

                    {/* Right Side - Action Cards */}
                    <div className="space-y-6 animate-slide-up">
                        <div className="bg-card/20 backdrop-blur-md border border-white/10 rounded-2xl p-8 shadow-glass">
                            <h2 className="text-2xl font-semibold mb-6 text-center">Escolha seu perfil</h2>
                            <div className="space-y-4">
                                <ProfileButton 
                                    href="/login/personal" 
                                    text="Personal Trainer" 
                                    icon={Shield} 
                                    description="Gerencie seus alunos e treinos"
                                />
                                <ProfileButton 
                                    href="/login/aluno" 
                                    text="Aluno" 
                                    icon={User} 
                                    description="Acesse seus treinos e progresso"
                                />
                                {canInstall && (
                                    <ActionButton 
                                        onClick={triggerInstallPrompt} 
                                        text="Instalar Aplicativo" 
                                        icon={Download} 
                                        className="bg-gradient-to-r from-success to-success/80 hover:from-success/90 hover:to-success text-success-foreground" 
                                    />
                                )}
                            </div>
                        </div>
                    </div>
                </main>
                
                <footer className="w-full pt-8 text-center text-sm text-slate-400">
                    <p>© {new Date().getFullYear()} DyFit. Todos os direitos reservados.</p>
                </footer>
            </div>

            {/* LAYOUT MOBILE */}
            <div className="lg:hidden min-h-screen flex flex-col relative p-6">
                <main className="flex-grow flex flex-col justify-center items-center text-center space-y-8 px-4">
                    <div className="animate-fade-in space-y-6">
                        <div className="flex items-center justify-center mb-8">
                            <img 
                                src="/logodyfit.png" 
                                alt="DyFit Logo" 
                                className="h-16 w-auto object-contain"
                            />
                        </div>
                        
                        <h1 className="text-4xl font-bold leading-tight px-4">
                            Seu treino{' '}
                            <span className="text-gradient">começa aqui</span>
                        </h1>
                        
                        <p className="text-lg text-slate-300 max-w-xs mx-auto leading-relaxed">
                            Escolha como deseja entrar na plataforma
                        </p>
                    </div>

                    <div className="w-full max-w-sm space-y-4 animate-slide-up">
                        <ProfileButton 
                            href="/login/personal" 
                            text="Personal Trainer" 
                            icon={Shield} 
                            description="Gerencie seus alunos"
                        />
                        <ProfileButton 
                            href="/login/aluno" 
                            text="Aluno" 
                            icon={User} 
                            description="Acesse seus treinos"
                        />
                        {canInstall && (
                            <ActionButton 
                                onClick={triggerInstallPrompt} 
                                text="Instalar App" 
                                icon={Download} 
                                className="bg-gradient-to-r from-success to-success/80 hover:from-success/90 hover:to-success text-success-foreground" 
                            />
                        )}
                    </div>
                </main>
                
                <footer className="w-full pt-6 text-center text-sm text-slate-400">
                    <p>© {new Date().getFullYear()} DyFit. Todos os direitos reservados.</p>
                </footer>
            </div>
        </div>
    );
}
===== ./client/src/pages/renovar-plano.tsx =====
// client/src/pages/renovar-plano.tsx
import { useState, useEffect, useMemo } from "react";
import { useQuery } from "@tanstack/react-query";
import { fetchWithAuth } from "@/lib/apiClient";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { useToast } from "@/hooks/use-toast";
import { Link, useLocation } from "wouter";
import { Aluno } from "@/types/aluno";
import { PersonalPlanStatus } from "../../../shared/types/planos";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Info, Crown, Loader2, Users, ArrowLeft } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { useFinalizeRenewalCycle, QK_RENEWALS_APPROVED } from "@/hooks/useFinalizeRenewalCycle";

interface RenewalRequest {
  _id: string;
  status: string;
}

export default function RenovarPlanoPage() {
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const [selectedAlunos, setSelectedAlunos] = useState<Set<string>>(new Set());

  // Hook customizado para a lógica de finalização
  const { finalizarCiclo, isFinalizando } = useFinalizeRenewalCycle();

  // Query para buscar o status do plano atual do personal
  const { data: planStatus, isLoading: loadingPlan, error: planError } = useQuery<PersonalPlanStatus, Error>({
    queryKey: ["meuPlanoParaRenovacao"],
    queryFn: () => fetchWithAuth("/api/personal/meu-plano"),
  });

  // Query para buscar todos os alunos do personal (ativos e inativos)
  const { data: todosAlunos = [], isLoading: loadingAlunos, error: alunosError } = useQuery<Aluno[], Error>({
    queryKey: ["todosAlunosParaRenovacao"],
    queryFn: () => fetchWithAuth("/api/aluno/gerenciar?status=all"),
    enabled: !!planStatus,
  });

  // Query para verificar se existe uma solicitação aprovada (guarda da página)
  const { data: approvedRequests, isLoading: loadingApproved } = useQuery<RenewalRequest[], Error>({
    queryKey: QK_RENEWALS_APPROVED,
    queryFn: () => fetchWithAuth("/api/personal/renewal-requests?status=approved,cycle_assignment_pending", {}, "personalAdmin"),
    refetchInterval: 2000, // Refetch a cada 2 segundos para detectar mudanças de status
    refetchIntervalInBackground: false,
    staleTime: 0, // Sempre considerar os dados como stale para garantir fresh data
  });

  // Efeito de guarda: se não houver solicitação aprovada, redireciona
  useEffect(() => {
    if (!loadingApproved && (!approvedRequests || approvedRequests.length === 0)) {
      toast({
        variant: "destructive",
        title: "Nenhuma renovação pendente",
        description: "Você não tem uma renovação de plano aprovada para finalizar.",
      });
      navigate("/solicitar-renovacao", { replace: true });
    }
  }, [approvedRequests, loadingApproved, navigate, toast]);

  // Efeito adicional: se finalização estiver em progresso ou concluída e não há mais requests aprovados, redirecionar
  useEffect(() => {
    if (isFinalizando) return; // Se está finalizando, não redirecionar ainda
    
    if (!loadingApproved && (!approvedRequests || approvedRequests.length === 0)) {
      // Se não há mais solicitações aprovadas, significa que a finalização foi bem-sucedida
      navigate("/solicitar-renovacao", { replace: true });
    }
  }, [approvedRequests, loadingApproved, navigate, isFinalizando]);

  // Efeito para pré-selecionar os alunos que já estão ativos
  useEffect(() => {
    if (todosAlunos.length > 0) {
      const activeStudentIds = todosAlunos.filter(a => a.status === "active").map(a => a._id);
      setSelectedAlunos(new Set(activeStudentIds));
    }
  }, [todosAlunos]);

  const toggleAluno = (alunoId: string) => {
    setSelectedAlunos(prev => {
      const newSet = new Set(prev);
      if (newSet.has(alunoId)) {
        newSet.delete(alunoId);
      } else {
        newSet.add(alunoId);
      }
      return newSet;
    });
  };

  const limiteTotal = useMemo(() => {
    if (!planStatus) return 0;
    return planStatus.limiteAtual || 0;
  }, [planStatus]);

  const handleFinalizar = () => {
    const keepStudentIds = Array.from(selectedAlunos);
    
    if (keepStudentIds.length > limiteTotal) {
      toast({
        variant: "destructive",
        title: "Limite de vagas excedido",
        description: `Seu novo limite é ${limiteTotal}, mas você selecionou ${keepStudentIds.length} alunos.`,
      });
      return;
    }

    // Apenas os alunos que estavam ativos, mas não foram selecionados, precisam ser explicitamente removidos.
    const removeStudentIds = todosAlunos
      .filter(aluno => aluno.status === 'active' && !selectedAlunos.has(aluno._id))
      .map(aluno => aluno._id);

    finalizarCiclo({ keepStudentIds, removeStudentIds });
  };
  
  if (loadingPlan || loadingAlunos || loadingApproved) {
    return <LoadingSpinner text="Carregando informações para renovação do ciclo..." />;
  }
  if (planError) return <ErrorMessage title="Erro ao carregar plano" message={planError.message} />;
  if (alunosError) return <ErrorMessage title="Erro ao carregar alunos" message={alunosError.message} />;

  if (!planStatus) {
    return <ErrorMessage title="Plano não encontrado" message="Não foi possível obter o status do seu plano." />;
  }

  const usados = selectedAlunos.size;

  return (
    <div className="max-w-5xl mx-auto p-4 md:p-6 lg:p-8 space-y-6">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Crown className="h-6 w-6 text-primary" />
            Finalizar Renovação de Plano
          </h1>
          <p className="text-muted-foreground mt-1">
            Selecione os alunos que continuarão ativos no seu novo ciclo.
          </p>
        </div>
        <Link href="/solicitar-renovacao">
          <Button variant="outline"><ArrowLeft className="w-4 h-4 mr-2" />Voltar</Button>
        </Link>
      </div>

      <Card className="shadow-lg border-primary/20">
        <CardHeader>
          <CardTitle>Seu Novo Plano: {planStatus.plano?.nome || 'N/A'}</CardTitle>
          <CardDescription>
            Limite base de {planStatus.plano?.limiteAlunos || 0} alunos
            {planStatus.tokensAvulsos > 0 && ` + ${planStatus.tokensAvulsos} tokens avulsos.`}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center gap-3 p-3 rounded-lg bg-muted/50">
            <div className={`flex items-center justify-center h-10 w-10 rounded-full ${usados > limiteTotal ? 'bg-destructive/20 text-destructive' : 'bg-primary/20 text-primary'}`}>
              <Users className="w-5 h-5" />
            </div>
            <div>
              <p className="font-bold text-2xl">{usados} / {limiteTotal}</p>
              <p className="text-sm text-muted-foreground">Vagas Selecionadas</p>
            </div>
          </div>

          <Alert variant={usados > limiteTotal ? "destructive" : "default"}>
            <Info className="h-4 w-4" />
            <AlertTitle>{usados > limiteTotal ? "Atenção: Limite Excedido!" : "Confirmação Importante"}</AlertTitle>
            <AlertDescription>
              {usados > limiteTotal 
                ? `Você selecionou mais alunos do que o seu limite permite. Por favor, desmarque ${usados - limiteTotal} aluno(s).`
                : "Ao confirmar, todos os seus alunos ativos atuais serão desativados. Apenas os alunos marcados nesta lista serão reativados para o novo ciclo."
              }
            </AlertDescription>
          </Alert>

          <div>
            <h3 className="font-semibold mb-3">Selecione os Alunos</h3>
            <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-3 max-h-96 overflow-y-auto p-1">
              {todosAlunos.length > 0 ? (
                todosAlunos.map((aluno) => (
                  <label key={aluno._id} className={`flex items-center gap-3 p-3 border rounded-lg hover:bg-muted cursor-pointer transition-all ${selectedAlunos.has(aluno._id) ? 'border-primary bg-primary/5' : ''}`}>
                    <Checkbox
                      checked={selectedAlunos.has(aluno._id)}
                      onCheckedChange={() => toggleAluno(aluno._id)}
                      id={`aluno-${aluno._id}`}
                    />
                    <div className="flex flex-col">
                      <span className="font-medium">{aluno.nome}</span>
                      <Badge variant={aluno.status === "active" ? "secondary" : "outline"} className="w-fit text-xs mt-1">{aluno.status === "active" ? "Atualmente Ativo" : "Inativo"}</Badge>
                    </div>
                  </label>
                ))
              ) : (
                <p className="col-span-full text-center text-muted-foreground p-4">Você não possui alunos cadastrados.</p>
              )}
            </div>
          </div>
        </CardContent>
        <CardFooter className="flex justify-between items-center pt-4">
            <Button variant="outline" onClick={() => setSelectedAlunos(new Set())}>Limpar Seleção</Button>
            <Button onClick={handleFinalizar} disabled={isFinalizando || usados > limiteTotal}>
              {isFinalizando && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Confirmar e Finalizar Ciclo
            </Button>
        </CardFooter>
      </Card>
    </div>
  );
}
===== ./client/src/pages/sessoes/index.tsx =====
// client/src/pages/sessoes/index.tsx
import React, { useState } from 'react'; // Adicionado React
import { useToast } from '@/hooks/use-toast';
import { Button } from "@/components/ui/button"; // <<< ADICIONADO IMPORT DO BOTÃO

export default function SessionsPage() {
    const { toast } = useToast();

    // Exemplo de onde você poderia usar o toast
    const algumaFuncao = () => {
        try {
            // ... faz algo ...
            // Exemplo de sucesso
            toast({ title: "Sucesso", description: "Sessão agendada!" });

            // Exemplo de erro simulado
            // throw new Error("Falha ao agendar sessão.");

        } catch (error: any) {
            toast({ variant: "destructive", title: "Erro", description: error.message });
        }
    };

    return (
        <div className="p-4 md:p-6 lg:p-8"> {/* Adicionado padding */}
            <h1 className="text-2xl font-bold mb-4">Página de Sessões</h1>
            {/* TODO: Adicionar o conteúdo real da sua página aqui */}
            <p className='mb-4'>Conteúdo da página de gerenciamento de sessões...</p>

            {/* O botão é apenas um exemplo de como usar o toast neste componente */}
            <Button onClick={algumaFuncao}>Testar Toast na Página</Button>
        </div>
    );
}
===== ./client/src/pages/solicitar-renovacao.tsx =====
// client/src/pages/solicitar-renovacao.tsx
import React, { useState, useMemo, useRef } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
// <<< CORREÇÃO: apiRequest foi re-adicionado ao import >>>
import { fetchWithAuth, apiRequest } from "@/lib/apiClient";
import { useLocation } from "wouter";
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
// <<< CORREÇÃO: Info foi re-adicionado ao import >>>
import { Info, Loader2, Link as LinkIcon, Upload, CheckCircle, Clock, XCircle } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';

// --- Tipos de Dados e Constantes (Alinhados com o Backend) ---

export const RStatus = {
  REQUESTED: 'requested',
  LINK_SENT: 'link_sent',
  PROOF_SUBMITTED: 'proof_submitted',
  APPROVED: 'approved',
  REJECTED: 'rejected',
  FULFILLED: 'fulfilled',
  CYCLE_ASSIGNMENT_PENDING: 'cycle_assignment_pending',
  // Status legados para compatibilidade
  PENDING: 'pending',
  PAYMENT_LINK_SENT: 'payment_link_sent',
  PAYMENT_PROOF_UPLOADED: 'payment_proof_uploaded',
} as const;

export type RenewalStatus = typeof RStatus[keyof typeof RStatus];

interface PlanoDisponivel {
  _id: string;
  nome: string;
  descricao?: string;
  limiteAlunos: number;
  preco?: number | string;
  duracao?: number | string;
}

interface RenewalRequest {
  _id: string;
  status: RenewalStatus;
  planIdRequested?: { nome?: string; } | null;
  createdAt?: string;
  notes?: string;
  paymentLink?: string;
  paymentDecisionNote?: string;
  proof?: { kind: 'link' | 'file'; url?: string; filename?: string; };
}

function statusLabel(status: RenewalRequest["status"]) {
  switch (status) {
    case RStatus.REQUESTED:
    case RStatus.PENDING:
      return "Aguardando envio de link";
    case RStatus.LINK_SENT:
    case RStatus.PAYMENT_LINK_SENT:
      return "Link enviado, aguardando comprovante";
    case RStatus.PROOF_SUBMITTED:
    case RStatus.PAYMENT_PROOF_UPLOADED:
      return "Comprovante enviado, aguardando validação";
    case RStatus.APPROVED:
    case RStatus.CYCLE_ASSIGNMENT_PENDING:
      return "Aprovado — defina o ciclo de alunos";
    case RStatus.REJECTED:
      return "Rejeitado";
    case RStatus.FULFILLED:
      return "Concluído";
    default:
      return status;
  }
}

// --- Componentes da Página ---

const StatusCard: React.FC<{ request: RenewalRequest; onProofSubmit: (payload: { id: string; proof: { link?: string, file?: File } }) => void; isSubmittingProof: boolean }> = ({ request, onProofSubmit, isSubmittingProof }) => {
  const { toast } = useToast();
  const [proofLink, setProofLink] = useState('');
  const [proofFile, setProofFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleSubmitProof = () => {
    if (!proofLink && !proofFile) {
      toast({ variant: 'destructive', title: 'Nenhum comprovante', description: 'Por favor, insira um link ou anexe um arquivo.' });
      return;
    }
    onProofSubmit({ id: request._id, proof: { link: proofLink, file: proofFile || undefined } });
  };

  const statusInfoMap: Record<RenewalStatus, { title: string; description: string; icon: React.ElementType; color: string }> = {
    [RStatus.REQUESTED]: { title: "Solicitação Enviada", description: "Sua solicitação foi enviada para o administrador. Aguarde o envio do link para pagamento.", icon: Clock, color: "text-blue-600" },
    [RStatus.PENDING]: { title: "Solicitação Enviada", description: "Sua solicitação foi enviada para o administrador. Aguarde o envio do link para pagamento.", icon: Clock, color: "text-blue-600" },
    [RStatus.LINK_SENT]: { title: "Aguardando Pagamento", description: "O administrador enviou o link para pagamento. Efetue o pagamento e anexe o comprovante abaixo.", icon: LinkIcon, color: "text-orange-600" },
    [RStatus.PAYMENT_LINK_SENT]: { title: "Aguardando Pagamento", description: "O administrador enviou o link para pagamento. Efetue o pagamento e anexe o comprovante abaixo.", icon: LinkIcon, color: "text-orange-600" },
    [RStatus.PROOF_SUBMITTED]: { title: "Comprovante Enviado", description: "Seu comprovante foi enviado. Aguarde a validação pelo administrador.", icon: Upload, color: "text-purple-600" },
    [RStatus.PAYMENT_PROOF_UPLOADED]: { title: "Comprovante Enviado", description: "Seu comprovante foi enviado. Aguarde a validação pelo administrador.", icon: Upload, color: "text-purple-600" },
    [RStatus.APPROVED]: { title: "Pagamento Aprovado!", description: "Seu pagamento foi aprovado! Agora você precisa definir quais alunos continuarão no seu plano.", icon: CheckCircle, color: "text-green-600" },
    [RStatus.CYCLE_ASSIGNMENT_PENDING]: { title: "Pagamento Aprovado!", description: "Seu pagamento foi aprovado! Agora você precisa definir quais alunos continuarão no seu plano.", icon: CheckCircle, color: "text-green-600" },
    [RStatus.REJECTED]: { title: "Pagamento Rejeitado", description: "Seu comprovante foi analisado e rejeitado. Verifique a observação do administrador.", icon: XCircle, color: "text-red-600" },
    [RStatus.FULFILLED]: { title: "Ciclo Concluído", description: "Este ciclo de renovação foi finalizado com sucesso.", icon: CheckCircle, color: "text-green-700" }
  };

  const statusInfo = statusInfoMap[request.status] || { title: "Status Desconhecido", description: "Ocorreu um problema ao identificar o status.", icon: Info, color: "text-gray-600" };
  const Icon = statusInfo.icon;

  return (
    <Card className="border-2 border-primary/20 bg-primary/5 shadow-lg">
      <CardHeader>
        <div className="flex items-center gap-3">
          <Icon className={`w-6 h-6 ${statusInfo.color}`} />
          <div>
            <CardTitle className={statusInfo.color}>{statusInfo.title}</CardTitle>
            <CardDescription>{statusInfo.description}</CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {request.paymentLink && (
          <div className="space-y-2">
            <Label className="font-semibold">Link para Pagamento:</Label>
            <a href={request.paymentLink} target="_blank" rel="noopener noreferrer" className="block text-sm text-primary underline break-all">{request.paymentLink}</a>
          </div>
        )}
        
        {(request.status === RStatus.LINK_SENT || request.status === RStatus.PAYMENT_LINK_SENT) && (
          <div className="p-4 border-t space-y-4">
            <Label className="font-semibold">Anexar Comprovante</Label>
            <div className="space-y-2">
              <Input placeholder="Cole o link do comprovante aqui" value={proofLink} onChange={(e) => { setProofLink(e.target.value); setProofFile(null); }} disabled={isSubmittingProof} />
              <p className="text-xs text-center text-muted-foreground my-2">OU</p>
              <Button variant="outline" onClick={() => fileInputRef.current?.click()} className="w-full" disabled={isSubmittingProof}>
                <Upload className="w-4 h-4 mr-2" /> Anexar Arquivo
              </Button>
              <Input type="file" ref={fileInputRef} className="hidden" onChange={(e) => { setProofFile(e.target.files?.[0] || null); setProofLink(''); }} accept="image/jpeg,image/png,application/pdf" />
              {proofFile && <p className="text-sm text-muted-foreground">Arquivo selecionado: {proofFile.name}</p>}
            </div>
            <Button onClick={handleSubmitProof} disabled={isSubmittingProof} className="w-full">
              {isSubmittingProof && <Loader2 className="w-4 h-4 mr-2 animate-spin" />}
              Enviar Comprovante
            </Button>
          </div>
        )}
        
        {request.status === RStatus.REJECTED && request.paymentDecisionNote && (
          <Alert variant="destructive">
            <AlertTitle>Motivo da Rejeição</AlertTitle>
            <AlertDescription>{request.paymentDecisionNote}</AlertDescription>
          </Alert>
        )}
      </CardContent>
    </Card>
  );
};

const PlanCard: React.FC<{ plano: PlanoDisponivel; onSelect: (id: string) => void; isSubmitting: boolean }> = ({ plano, onSelect, isSubmitting }) => (
  <Card className="flex flex-col">
    <CardHeader>
      <CardTitle>{plano.nome}</CardTitle>
      <CardDescription>{plano.descricao}</CardDescription>
    </CardHeader>
    <CardContent className="flex-grow space-y-2">
      <p><strong>Limite:</strong> {plano.limiteAlunos} alunos</p>
      <p><strong>Preço:</strong> {typeof plano.preco === 'number' ? `R$ ${plano.preco.toFixed(2)}` : plano.preco}</p>
      <p><strong>Duração:</strong> {plano.duracao} dias</p>
    </CardContent>
    <CardFooter>
      <Button className="w-full" onClick={() => onSelect(plano._id)} disabled={isSubmitting}>
        Solicitar Plano
      </Button>
    </CardFooter>
  </Card>
);

// --- Página Principal ---
export default function SolicitarRenovacaoPage() {
  const [, navigate] = useLocation();
  const queryClient = useQueryClient();
  const { toast } = useToast();

  const { data: renewals = [], isLoading: loadingList, error: errorList } = useQuery<RenewalRequest[]>({
    queryKey: ["personal-renewals", "list"],
    queryFn: () => fetchWithAuth(`/api/personal/renewal-requests`, {}, "personalAdmin"),
    refetchOnWindowFocus: true,
  });

  const { data: planos = [], isLoading: loadingPlanos, error: errorPlanos } = useQuery<PlanoDisponivel[]>({
    queryKey: ["planosDisponiveis"],
    queryFn: () => fetchWithAuth(`/api/personal/planos-disponiveis`, {}, "personalAdmin"),
    staleTime: 5 * 60 * 1000,
  });

  const openRequest = useMemo(() => {
    const OPEN_STATUSES: RenewalStatus[] = [
      RStatus.REQUESTED, RStatus.LINK_SENT, RStatus.PROOF_SUBMITTED,
      RStatus.APPROVED, RStatus.CYCLE_ASSIGNMENT_PENDING,
      RStatus.PENDING, RStatus.PAYMENT_LINK_SENT, RStatus.PAYMENT_PROOF_UPLOADED,
    ];
    return renewals.find(r => OPEN_STATUSES.includes(r.status));
  }, [renewals]);

  const hasOpenCycleRequest = useMemo(() => {
    if (!openRequest) return false;
    const cycleStatuses: RenewalStatus[] = [RStatus.APPROVED, RStatus.CYCLE_ASSIGNMENT_PENDING];
    return cycleStatuses.includes(openRequest.status);
  }, [openRequest]);
  
  const closedRequests = useMemo(() => {
    const closedStatuses: RenewalStatus[] = [RStatus.FULFILLED, RStatus.REJECTED];
    return renewals.filter(r => closedStatuses.includes(r.status));
  }, [renewals]);

  const solicitarMutation = useMutation({
    mutationFn: (planId: string) => apiRequest("POST", `/api/personal/renewal-requests`, { planIdRequested: planId }),
    onSuccess: async () => {
      toast({ title: "Solicitação enviada", description: "Aguarde o administrador enviar o link de pagamento." });
      await queryClient.invalidateQueries({ queryKey: ["personal-renewals", "list"] });
    },
    onError: (error: any) => {
      toast({ variant: "destructive", title: "Erro ao solicitar", description: error?.message || "Não foi possível criar a solicitação." });
    },
  });
  
  const submitProofMutation = useMutation({
    mutationFn: async ({ id, proof }: { id: string; proof: { link?: string; file?: File } }) => {
      const formData = new FormData();
      if (proof.link) {
        formData.append('paymentProofUrl', proof.link);
      }
      if (proof.file) {
        formData.append('paymentProof', proof.file);
      }
      return fetchWithAuth(`/api/personal/renewal-requests/${id}/proof`, {
        method: "POST",
        body: formData,
      }, "personalAdmin");
    },
    onSuccess: async () => {
      toast({ title: "Comprovante enviado!", description: "Aguarde a validação do administrador." });
      await queryClient.invalidateQueries({ queryKey: ["personal-renewals", "list"] });
    },
    onError: (error: any) => {
      toast({ variant: "destructive", title: "Erro ao enviar", description: error?.message || "Não foi possível enviar o comprovante." });
    }
  });

  if (loadingList || loadingPlanos) {
    return <LoadingSpinner text="Carregando dados de renovação..." />;
  }

  if (errorList || errorPlanos) {
    return <ErrorMessage title="Erro ao Carregar" message={errorList?.message || errorPlanos?.message || "Não foi possível carregar a página."} />;
  }

  return (
    <div className="max-w-6xl mx-auto px-4 py-6 space-y-8">
      <div>
        <h1 className="text-3xl font-bold">Renovação de Plano</h1>
        <p className="text-muted-foreground mt-1">Gerencie suas solicitações e escolha seu próximo plano.</p>
      </div>

      {hasOpenCycleRequest && (
        <Card className="border-green-400 bg-green-50 shadow-lg">
          <CardHeader>
            <CardTitle className="text-green-800 flex items-center gap-2"><CheckCircle /> Solicitação Aprovada</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-green-700 mb-4">
              Seu pagamento foi aprovado! O próximo passo é selecionar quais dos seus alunos continuarão ativos neste novo ciclo.
            </p>
            <Button size="lg" onClick={() => navigate("/renovar-plano")}>
              Definir Alunos do Novo Ciclo
            </Button>
          </CardContent>
        </Card>
      )}

      {openRequest && !hasOpenCycleRequest && (
        <div>
          <h2 className="text-xl font-semibold mb-4">Solicitação em Andamento</h2>
          <StatusCard request={openRequest} onProofSubmit={submitProofMutation.mutate} isSubmittingProof={submitProofMutation.isPending} />
        </div>
      )}

      {!openRequest && (
        <div>
          <h2 className="text-xl font-semibold mb-4">Escolha um Plano para Solicitar</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {planos.map(plano => (
              <PlanCard key={plano._id} plano={plano} onSelect={solicitarMutation.mutate} isSubmitting={solicitarMutation.isPending} />
            ))}
          </div>
        </div>
      )}
      
      {closedRequests.length > 0 && (
        <div>
          <h2 className="text-xl font-semibold mb-4 mt-12">Histórico de Solicitações</h2>
          <div className="space-y-4">
            {closedRequests.map(req => (
              <Card key={req._id} className="bg-muted/50">
                 <CardHeader>
                   <div className="flex justify-between items-center">
                      <CardTitle className="text-base font-semibold">
                        Plano: {req.planIdRequested?.nome || 'N/A'}
                      </CardTitle>
                      <Badge variant={req.status === RStatus.REJECTED ? 'destructive' : 'default'}>
                        {statusLabel(req.status)}
                      </Badge>
                   </div>
                   <CardDescription>
                     Solicitado em: {req.createdAt ? format(new Date(req.createdAt), "dd/MM/yyyy 'às' HH:mm", { locale: ptBR }) : 'N/A'}
                   </CardDescription>
                 </CardHeader>
                 { (req.paymentDecisionNote || req.notes) && 
                    <CardContent className="pt-0">
                      {req.notes && <p className="text-sm"><strong>Sua observação:</strong> {req.notes}</p>}
                      {req.paymentDecisionNote && <p className="text-sm"><strong>Obs. do Admin:</strong> {req.paymentDecisionNote}</p>}
                    </CardContent>
                 }
              </Card>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
===== ./client/src/pages/treinos/index.tsx =====
// client/src/pages/treinos/index.tsx
import { useState, useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Dumbbell, Plus, Folder, FolderPlus, Edit, Trash2, Search, Loader2 } from "lucide-react";
import RotinaFormModal, { RotinaParaEditar } from "@/components/dialogs/RotinaFormModal"; 
import PageLoader from "@/components/PageLoader";
import ErrorMessage from "@/components/ErrorMessage";
import { Aluno } from "@/types/aluno";
import { useToast } from "@/hooks/use-toast";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { apiRequest } from "@/lib/queryClient";
import AssociarModeloAlunoModal from "@/components/dialogs/AssociarModeloAlunoModal";
import type { RotinaListagemItem } from '@/types/treinoOuRotinaTypes'; 
import { RotinaCard } from '@/components/rotinas/RotinaCard';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import RotinaViewModal from "@/components/dialogs/RotinaViewModal";
import PastaFormModal, { PastaExistente } from "@/components/dialogs/PastaFormModal";
import { Badge } from "@/components/ui/badge";
import VideoPlayerModal from "@/components/dialogs/VideoPlayerModal";
import { Input } from "@/components/ui/input";
import { useUser } from "@/context/UserContext";
import { useModalPersistence } from "@/hooks/useModalPersistence";

export interface Pasta { _id: string; nome: string; ordem?: number; }

export default function TreinosPage() {
    // Modal persistence hooks with route validation
    const rotinaModal = useModalPersistence({ 
        modalKey: 'nova_rotina',
        expectedRoute: '/treinos', // Only restore modal when on treinos page
        onRestore: () => {
            // When modal is restored, ensure we have the right editing state
            const savedRotinaId = localStorage.getItem('rotina_editando_id');
            if (savedRotinaId && rotinas) {
                const rotinaEncontrada = rotinas.find(r => r._id === savedRotinaId);
                if (rotinaEncontrada) {
                    setRotinaParaEditar(rotinaEncontrada);
                }
            }
        }
    });
    
    const viewModal = useModalPersistence({ 
        modalKey: 'view_rotina',
        expectedRoute: '/treinos',
        onRestore: () => {
            const savedRotinaId = localStorage.getItem('rotina_visualizando_id');
            if (savedRotinaId && rotinas) {
                const rotinaEncontrada = rotinas.find(r => r._id === savedRotinaId);
                if (rotinaEncontrada) {
                    setRotinaParaVisualizar(rotinaEncontrada);
                }
            }
        }
    });
    
    const associarModal = useModalPersistence({ 
        modalKey: 'associar_modelo',
        expectedRoute: '/treinos',
        onRestore: () => {
            const savedModeloData = localStorage.getItem('modelo_associando');
            if (savedModeloData) {
                try {
                    const modeloData = JSON.parse(savedModeloData);
                    setRotinaModeloParaAssociar(modeloData);
                } catch (error) {
                    localStorage.removeItem('modelo_associando');
                }
            }
        }
    });
    
    const pastaModal = useModalPersistence({ 
        modalKey: 'pasta_form',
        expectedRoute: '/treinos',
        onRestore: () => {
            const savedPastaData = localStorage.getItem('pasta_editando');
            if (savedPastaData) {
                try {
                    const pastaData = JSON.parse(savedPastaData);
                    setPastaParaEditar(pastaData);
                } catch (error) {
                    localStorage.removeItem('pasta_editando');
                }
            }
        }
    });

    const [rotinaParaEditar, setRotinaParaEditar] = useState<RotinaParaEditar | null>(null); 
    const [rotinaParaVisualizar, setRotinaParaVisualizar] = useState<RotinaListagemItem | null>(null);
    const [rotinaModeloParaAssociar, setRotinaModeloParaAssociar] = useState<{id: string; titulo: string} | null>(null);
    const [pastaParaEditar, setPastaParaEditar] = useState<PastaExistente | null>(null);
    const [aba, setAba] = useState<'modelos' | 'individuais'>('modelos');
    const [isDeleteAlertOpen, setIsDeleteAlertOpen] = useState(false);
    const [itemParaExcluir, setItemParaExcluir] = useState<{ id: string; nome: string; tipo: 'rotina' | 'pasta' } | null>(null);
    const [videoUrlToPlay, setVideoUrlToPlay] = useState<string | null>(null);
    const [buscaAluno, setBuscaAluno] = useState("");

    const [isConvertToModelAlertOpen, setIsConvertToModelAlertOpen] = useState(false);
    const [rotinaParaConverterEmModelo, setRotinaParaConverterEmModelo] = useState<RotinaListagemItem | null>(null);

    const queryClient = useQueryClient();
    const { toast } = useToast();
    const { user } = useUser();
    const trainerId = user?.id;

    const { data: rotinas = [], isLoading: isLoadingRotinas, error: errorRotinas } = useQuery<RotinaListagemItem[], Error>({ queryKey: ["/api/treinos"], queryFn: () => apiRequest("GET", "/api/treinos") });
    const { data: alunos = [], isLoading: isLoadingAlunos } = useQuery<Aluno[], Error>({ queryKey: ["/api/aluno/gerenciar"], queryFn: () => apiRequest("GET", "/api/aluno/gerenciar"), staleTime: 1000 * 60 * 5 });
    const { data: pastas = [], isLoading: isLoadingPastas } = useQuery<Pasta[], Error>({ queryKey: ["/api/pastas/treinos"], queryFn: () => apiRequest("GET", "/api/pastas/treinos")});
    
    const deleteMutation = useMutation<any, Error, { id: string; tipo: 'rotina' | 'pasta' }>({ 
        mutationFn: ({ id, tipo }) => apiRequest("DELETE", tipo === 'rotina' ? `/api/treinos/${id}` : `/api/pastas/treinos/${id}`), 
        onSuccess: (_, variables) => { 
            const itemTipo = variables.tipo === 'rotina' ? 'Rotina' : 'Pasta'; 
            toast({ title: "Sucesso!", description: `${itemTipo} excluída com sucesso.` }); 
            queryClient.invalidateQueries({ queryKey: ["/api/treinos"] }); 
            queryClient.invalidateQueries({ queryKey: ["/api/pastas/treinos"] });
            if (trainerId) {
                queryClient.invalidateQueries({ queryKey: ["dashboardGeral", trainerId] });
            }
        }, 
        onError: (err) => toast({ variant: "destructive", title: "Erro ao Excluir", description: err.message }), 
        onSettled: () => setIsDeleteAlertOpen(false), 
    });

    const moveRotinaMutation = useMutation<RotinaListagemItem, Error, { rotinaId: string; pastaId: string | null }>({ mutationFn: ({ rotinaId, pastaId }) => apiRequest("PUT", `/api/treinos/${rotinaId}/pasta`, { pastaId }), onSuccess: (updatedRotina) => { toast({ title: "Sucesso!", description: `Rotina "${updatedRotina.titulo}" movida.` }); queryClient.setQueryData<RotinaListagemItem[]>(["/api/treinos"], (oldData) => { if (!oldData) return [updatedRotina]; return oldData.map(r => r._id === updatedRotina._id ? updatedRotina : r); }); }, onError: (err) => toast({ variant: "destructive", title: "Erro ao Mover", description: err.message }), });

    // <<< INÍCIO DA ALTERAÇÃO >>>
    const convertToModelMutation = useMutation<RotinaListagemItem, Error, string>({
      // 1. URL da API corrigida para a rota unificada.
      mutationFn: (rotinaId) => apiRequest("POST", `/api/treinos/${rotinaId}/tornar-modelo`),
      onSuccess: (newModelRotina) => {
        toast({ title: "Sucesso!", description: `Rotina "${newModelRotina.titulo}" criada como modelo.` });
        
        // 2. Implementada a atualização manual e instantânea do cache.
        queryClient.setQueryData<RotinaListagemItem[]>(['/api/treinos'], (oldData) => {
            if (oldData) {
                return [newModelRotina, ...oldData];
            }
            return [newModelRotina];
        });
      },
      onError: (err) => toast({ variant: "destructive", title: "Erro ao Converter", description: err.message }),
      onSettled: () => setIsConvertToModelAlertOpen(false),
    });
    // <<< FIM DA ALTERAÇÃO >>>

    const handleOpenCreateModal = () => { 
        setRotinaParaEditar(null); 
        localStorage.removeItem('rotina_editando_id');
        rotinaModal.openModal(); 
    };
    
    const handleOpenEditModal = (r: RotinaListagemItem) => { 
        viewModal.closeModal(); 
        setRotinaParaEditar(r); 
        localStorage.setItem('rotina_editando_id', r._id);
        rotinaModal.openModal(); 
    };
    
    const handleOpenViewModal = (r: RotinaListagemItem) => { 
        setRotinaParaVisualizar(r); 
        localStorage.setItem('rotina_visualizando_id', r._id);
        viewModal.openModal(); 
    };
    
    const handleAssignClick = (id: string, t: string) => { 
        viewModal.closeModal(); 
        const modeloData = { id, titulo: t };
        setRotinaModeloParaAssociar(modeloData); 
        localStorage.setItem('modelo_associando', JSON.stringify(modeloData));
        associarModal.openModal(); 
    };
    
    const handleOpenPastaModal = (p?: PastaExistente) => { 
        setPastaParaEditar(p || null); 
        if (p) {
            localStorage.setItem('pasta_editando', JSON.stringify(p));
        } else {
            localStorage.removeItem('pasta_editando');
        }
        pastaModal.openModal(); 
    };

    // Improved modal close handlers with proper cleanup
    const handleCloseRotinaModal = () => {
        rotinaModal.closeModal();
        setRotinaParaEditar(null);
        localStorage.removeItem('rotina_editando_id');
    };

    const handleCloseViewModal = () => {
        viewModal.closeModal();
        setRotinaParaVisualizar(null);
        localStorage.removeItem('rotina_visualizando_id');
    };

    const handleCloseAssociarModal = () => {
        associarModal.closeModal();
        setRotinaModeloParaAssociar(null);
        localStorage.removeItem('modelo_associando');
    };

    const handleClosePastaModal = () => {
        pastaModal.closeModal(); 
        setPastaParaEditar(null);
        localStorage.removeItem('pasta_editando');
    };
    const handleDeleteRotinaClick = (rotina: RotinaListagemItem) => { setItemParaExcluir({ id: rotina._id, nome: rotina.titulo, tipo: 'rotina' }); setIsDeleteAlertOpen(true); };
    const handleDeletePastaClick = (pasta: Pasta) => { setItemParaExcluir({ id: pasta._id, nome: pasta.nome, tipo: 'pasta' }); setIsDeleteAlertOpen(true); };
    const handleConfirmDelete = () => { if (itemParaExcluir) deleteMutation.mutate(itemParaExcluir); };
    const handleMoveToFolder = (rotinaId: string, pastaId: string) => moveRotinaMutation.mutate({ rotinaId, pastaId });
    const handleRemoveFromFolder = (rotinaId: string) => moveRotinaMutation.mutate({ rotinaId, pastaId: null });
    const handlePastaSuccess = () => { 
        queryClient.invalidateQueries({ queryKey: ["/api/pastas/treinos"] }); 
        pastaModal.closeModal(); 
        setPastaParaEditar(null); 
        localStorage.removeItem('pasta_editando');
    };
    const handlePlayVideo = (url: string) => setVideoUrlToPlay(url);

    const handleConvertToModelClick = (rotina: RotinaListagemItem) => {
      setRotinaParaConverterEmModelo(rotina);
      setIsConvertToModelAlertOpen(true);
    };

    const handleConfirmConvertToModel = () => {
      if (rotinaParaConverterEmModelo) {
        convertToModelMutation.mutate(rotinaParaConverterEmModelo._id);
      }
    };

    const rotinasIndividuaisFiltradas = useMemo(() => {
        const rotinasBase = rotinas.filter(r => r.tipo === 'individual');
        if (!buscaAluno.trim()) { return rotinasBase; }
        const lowerCaseBusca = buscaAluno.toLowerCase();
        return rotinasBase.filter(rotina => {
            const aluno = alunos.find(a => a._id === (typeof rotina.alunoId === 'string' ? rotina.alunoId : rotina.alunoId?._id));
            return aluno?.nome.toLowerCase().includes(lowerCaseBusca) || rotina.titulo.toLowerCase().includes(lowerCaseBusca);
        });
    }, [rotinas, alunos, buscaAluno]);


    if (isLoadingRotinas || isLoadingPastas || isLoadingAlunos) return <PageLoader message="Carregando suas rotinas..." submessage="Organizando seus treinos e dados..." />;
    if (errorRotinas) return <ErrorMessage title="Erro ao Carregar Dados" message={errorRotinas.message} />;

    const rotinasModelo = rotinas.filter(r => r.tipo === 'modelo');
    const rotinasPorPasta = pastas.sort((a, b) => (a.ordem || 0) - (b.ordem || 0)).map(p => ({ ...p, rotinas: rotinasModelo.filter(r => (typeof r.pastaId === 'string' ? r.pastaId : r.pastaId?._id) === p._id) }));
    const rotinasSemPasta = rotinasModelo.filter(r => !r.pastaId);

    const cardHandlers = { 
      onView: handleOpenViewModal, 
      onEdit: handleOpenEditModal, 
      onDelete: handleDeleteRotinaClick, 
      onAssign: handleAssignClick, 
      onMoveToFolder: handleMoveToFolder, 
      onRemoveFromFolder: handleRemoveFromFolder,
      onConvertToModel: handleConvertToModelClick,
    };

    return (
        <div className="container mx-auto py-6 px-4 md:py-8 max-w-7xl">
            {/* Header Section with improved spacing and gradient */}
            <div className="flex flex-col gap-6 sm:gap-4 md:flex-row md:justify-between md:items-center mb-8">
                <div className="flex items-center space-x-4">
                    <div className="p-3 rounded-2xl bg-gradient-to-br from-primary/10 to-secondary/10 border border-primary/20">
                        <Dumbbell className="h-8 w-8 text-primary"/>
                    </div>
                    <div>
                        <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent">
                            Gerenciar Rotinas
                        </h1>
                        <p className="text-muted-foreground text-sm mt-1">
                            Organize e gerencie suas rotinas de treino
                        </p>
                    </div>
                </div>
                
                {/* Action buttons with improved mobile layout */}
                <div className="flex flex-col sm:flex-row w-full sm:w-auto gap-3">
                    <Button 
                        variant="outline" 
                        onClick={() => handleOpenPastaModal()} 
                        className="flex-1 sm:flex-none h-11 border-primary/20 hover:border-primary/40 hover:bg-primary/5 transition-all duration-200"
                    >
                        <FolderPlus className="mr-2 h-4 w-4"/> 
                        Nova Pasta
                    </Button>
                    <Button 
                        onClick={handleOpenCreateModal} 
                        className="flex-1 sm:flex-none h-11 bg-gradient-to-r from-primary to-secondary hover:from-primary/90 hover:to-secondary/90 shadow-lg hover:shadow-xl transition-all duration-200"
                    >
                        <Plus className="mr-2 h-4 w-4" /> 
                        Nova Rotina
                    </Button>
                </div>
            </div>
            
            {/* Tabs with improved styling */}
            <Tabs value={aba} onValueChange={(v) => setAba(v as any)} className="mb-8">
                <TabsList className="grid w-full grid-cols-2 h-12 p-1 bg-gradient-to-r from-muted/50 to-muted/30 backdrop-blur-sm border border-border/50">
                    <TabsTrigger 
                        value="modelos" 
                        className="h-10 font-medium data-[state=active]:bg-gradient-to-r data-[state=active]:from-primary data-[state=active]:to-secondary data-[state=active]:text-primary-foreground transition-all duration-200"
                    >
                        Rotinas Modelo
                    </TabsTrigger>
                    <TabsTrigger 
                        value="individuais"
                        className="h-10 font-medium data-[state=active]:bg-gradient-to-r data-[state=active]:from-primary data-[state=active]:to-secondary data-[state=active]:text-primary-foreground transition-all duration-200"
                    >
                        Rotinas Individuais
                    </TabsTrigger>
                </TabsList>
                
                <TabsContent value="modelos" className="mt-8 space-y-6">
                    <div className="space-y-6">
                        <Accordion type="multiple" className="w-full space-y-4">
                            {rotinasPorPasta.map(pasta => (
                                <AccordionItem 
                                    value={pasta._id} 
                                    key={pasta._id} 
                                    className="border border-border/60 rounded-xl bg-gradient-to-br from-card/80 to-card/40 backdrop-blur-sm shadow-lg hover:shadow-xl transition-all duration-300"
                                >
                                    <AccordionTrigger className="px-6 py-4 hover:no-underline font-semibold text-lg group">
                                        <div className="flex-grow flex items-center gap-4">
                                            <div className="p-2 rounded-lg bg-gradient-to-br from-primary/10 to-secondary/10 group-hover:from-primary/20 group-hover:to-secondary/20 transition-all duration-200">
                                                <Folder className="h-5 w-5 text-primary"/> 
                                            </div>
                                            <span className="font-semibold">{pasta.nome}</span>
                                            <Badge 
                                                variant="secondary" 
                                                className="bg-gradient-to-r from-primary/10 to-secondary/10 border border-primary/20 text-primary font-medium"
                                            >
                                                {pasta.rotinas.length}
                                            </Badge>
                                        </div>
                                        <div className="flex-shrink-0 flex items-center gap-2">
                                            <Button
                                                variant="ghost"
                                                size="sm"
                                                className="h-8 w-8 p-0 hover:bg-primary/10 transition-colors"
                                                onClick={(e) => { e.stopPropagation(); handleOpenPastaModal(pasta); }}
                                                title="Editar Pasta"
                                            >
                                                <Edit className="h-4 w-4"/>
                                            </Button>
                                            <Button
                                                variant="ghost"
                                                size="sm"
                                                className="h-8 w-8 p-0 hover:bg-destructive/10 text-destructive hover:text-destructive transition-colors"
                                                onClick={(e) => { e.stopPropagation(); handleDeletePastaClick(pasta); }}
                                                title="Excluir Pasta"
                                            >
                                                <Trash2 className="h-4 w-4"/>
                                            </Button>
                                        </div>
                                    </AccordionTrigger>
                                    <AccordionContent className="px-6 pb-6 border-t border-border/30">
                                        <div className="grid grid-responsive pt-4 min-h-[120px]">
                                            {pasta.rotinas.map(rotina => 
                                                <RotinaCard 
                                                    key={rotina._id} 
                                                    rotina={rotina} 
                                                    pastas={pastas} 
                                                    {...cardHandlers} 
                                                />
                                            )}
                                        </div>
                                    </AccordionContent>
                                </AccordionItem>
                            ))}
                        </Accordion>
                        
                        {rotinasSemPasta.length > 0 && (
                            <div className="border border-dashed border-border/60 rounded-xl bg-gradient-to-br from-muted/30 to-muted/10 p-6">
                                <div className="flex items-center gap-3 mb-6">
                                    <div className="p-2 rounded-lg bg-gradient-to-br from-muted to-muted/50">
                                        <Folder className="h-5 w-5 text-muted-foreground"/>
                                    </div>
                                    <h3 className="text-lg font-semibold">Rotinas Sem Pasta</h3>
                                    <Badge variant="outline" className="border-border/60">
                                        {rotinasSemPasta.length}
                                    </Badge>
                                </div>
                                <div className="grid grid-responsive">
                                    {rotinasSemPasta.map(rotina => 
                                        <RotinaCard 
                                            key={rotina._id} 
                                            rotina={rotina} 
                                            pastas={pastas} 
                                            {...cardHandlers} 
                                        />
                                    )}
                                </div>
                            </div>
                        )}
                    </div>
                </TabsContent>

                <TabsContent value="individuais" className="mt-8 space-y-6">
                    {/* Enhanced search section */}
                    <div className="relative group">
                        <div className="absolute inset-0 bg-gradient-to-r from-primary/5 to-secondary/5 rounded-xl opacity-0 group-hover:opacity-100 transition-opacity duration-200" />
                        <div className="relative bg-card/50 backdrop-blur-sm border border-border/60 rounded-xl p-4">
                            <div className="relative max-w-md">
                                <Search className="absolute left-3 top-1/2 -translate-y-1/2 text-muted-foreground h-4 w-4" />
                                <Input 
                                    type="search" 
                                    placeholder="Buscar por nome do aluno ou título da rotina..." 
                                    className="pl-10 h-11 bg-background/80 border-border/60 focus:border-primary/60 transition-colors" 
                                    value={buscaAluno} 
                                    onChange={(e) => setBuscaAluno(e.target.value)} 
                                />
                            </div>
                        </div>
                    </div>
                    
                    {/* Results grid with responsive classes */}
                    <div className="grid grid-responsive">
                        {rotinasIndividuaisFiltradas.map(rotina => {
                            const aluno = alunos.find(a => a._id === (typeof rotina.alunoId === 'string' ? rotina.alunoId : rotina.alunoId?._id)); 
                            return (
                                <RotinaCard 
                                    key={rotina._id} 
                                    rotina={rotina} 
                                    pastas={[]} 
                                    alunoNome={aluno?.nome} 
                                    {...cardHandlers} 
                                />
                            )
                        })}
                    </div>
                    
                    {/* Empty state with better styling */}
                    {rotinasIndividuaisFiltradas.length === 0 && (
                        <div className="text-center py-16 px-4">
                            <div className="mx-auto w-24 h-24 rounded-full bg-gradient-to-br from-muted/50 to-muted/20 flex items-center justify-center mb-6">
                                <Search className="h-10 w-10 text-muted-foreground/60" />
                            </div>
                            <h3 className="text-lg font-semibold mb-2">Nenhuma rotina encontrada</h3>
                            <p className="text-muted-foreground max-w-md mx-auto">
                                {buscaAluno.trim() 
                                    ? `Não encontramos rotinas que correspondam à sua busca "${buscaAluno}".`
                                    : "Ainda não há rotinas individuais criadas."
                                }
                            </p>
                        </div>
                    )}
                </TabsContent>
            </Tabs>
            
            <RotinaFormModal 
                open={rotinaModal.isOpen} 
                onClose={handleCloseRotinaModal}
                onSuccess={(rotinaSalva) => {
                    handleCloseRotinaModal(); // Use centralized handler
                    queryClient.invalidateQueries({ queryKey: ["/api/treinos"] });
                    if (trainerId) {
                        queryClient.invalidateQueries({ queryKey: ["dashboardGeral", trainerId] });
                    }
                }} 
                alunos={alunos} 
                rotinaParaEditar={rotinaParaEditar} 
            />
            <RotinaViewModal 
                isOpen={viewModal.isOpen} 
                onClose={handleCloseViewModal}
                rotina={rotinaParaVisualizar} 
                onEdit={handleOpenEditModal} 
                onAssign={handleAssignClick} 
                onPlayVideo={handlePlayVideo} 
                onConvertToModel={handleConvertToModelClick}
            />
            {associarModal.isOpen && rotinaModeloParaAssociar && 
                <AssociarModeloAlunoModal 
                    isOpen={associarModal.isOpen} 
                    onClose={handleCloseAssociarModal}
                    fichaModeloId={rotinaModeloParaAssociar.id} 
                    fichaModeloTitulo={rotinaModeloParaAssociar.titulo}
                />
            }
            <PastaFormModal 
                isOpen={pastaModal.isOpen} 
                onClose={handleClosePastaModal}
                onSuccessCallback={handlePastaSuccess} 
                initialData={pastaParaEditar} 
            />
            
            <AlertDialog open={isDeleteAlertOpen} onOpenChange={(open) => !open && setIsDeleteAlertOpen(false)}>
              <AlertDialogContent>
                <AlertDialogHeader>
                  <AlertDialogTitle>Confirmar Exclusão</AlertDialogTitle>
                  <AlertDialogDescription>Tem certeza que deseja excluir "{itemParaExcluir?.nome}"?</AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                  <AlertDialogCancel>Cancelar</AlertDialogCancel>
                  <AlertDialogAction onClick={handleConfirmDelete} disabled={deleteMutation.isPending} className="bg-red-600 hover:bg-red-700">Confirmar</AlertDialogAction>
                </AlertDialogFooter>
              </AlertDialogContent>
            </AlertDialog>

            <AlertDialog open={isConvertToModelAlertOpen} onOpenChange={(open) => !open && setIsConvertToModelAlertOpen(false)}>
              <AlertDialogContent>
                <AlertDialogHeader>
                  <AlertDialogTitle>Tornar Rotina Modelo?</AlertDialogTitle>
                  <AlertDialogDescription>
                    Tem certeza que deseja criar uma cópia da rotina "{rotinaParaConverterEmModelo?.titulo}" e transformá-la em uma rotina modelo? A rotina original permanecerá inalterada.
                  </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                  <AlertDialogCancel>Cancelar</AlertDialogCancel>
                  <AlertDialogAction onClick={handleConfirmConvertToModel} disabled={convertToModelMutation.isPending}>
                    {convertToModelMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                    Confirmar
                  </AlertDialogAction>
                </AlertDialogFooter>
              </AlertDialogContent>
            </AlertDialog>

            <VideoPlayerModal videoUrl={videoUrlToPlay} onClose={() => setVideoUrlToPlay(null)} />
        </div>
    );
}
===== ./client/src/pages/treinos/new.tsx =====
// client/src/pages/treinos/new.tsx
import { Link } from "wouter";
import { ChevronLeft } from "lucide-react";
import { useQuery } from "@tanstack/react-query";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { WorkoutForm } from "@/forms/workout-form";
import { apiRequest } from "@/lib/queryClient";
import { Aluno } from "@/types/aluno";
import LoadingSpinner from "@/components/LoadingSpinner";
import ErrorMessage from "@/components/ErrorMessage";

export default function NewWorkoutPage() {
  // Busca a lista de alunos para popular o select no formulário
  const { data: alunos = [], isLoading, error } = useQuery<Aluno[], Error>({
    queryKey: ["/api/aluno/gerenciar"],
    queryFn: () => apiRequest("GET", "/api/aluno/gerenciar"),
    staleTime: 1000 * 60 * 5, // Cache de 5 minutos
  });

  return (
    <div className="flex flex-col items-center p-4 sm:p-6 lg:p-8">
      <div className="w-full max-w-4xl">
        <Button asChild variant="ghost" className="mb-4 -ml-4">
          <Link href="/treinos">
            <ChevronLeft className="h-4 w-4 mr-2" />
            Voltar para Rotinas
          </Link>
        </Button>

        <Card className="shadow-lg overflow-hidden">
          <CardHeader className="bg-gradient-to-r from-indigo-600 to-purple-700 text-white">
            <CardTitle className="text-2xl font-bold">
              Criar Nova Rotina de Treino
            </CardTitle>
            <CardDescription className="text-indigo-100">
              Crie um plano de treino detalhado com dias e exercícios.
            </CardDescription>
          </CardHeader>
          <CardContent className="p-6">
            {isLoading && <LoadingSpinner text="Carregando alunos..." />}
            {error && <ErrorMessage message={error.message} />}
            {!isLoading && !error && <WorkoutForm alunos={alunos} />}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
===== ./client/src/pages/workouts/[id].tsx =====
import { useEffect, useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { Link, useLocation } from "wouter";
import { ArrowLeft, ChevronDown, ChevronUp, Dumbbell, Plus, Trash2 } from "lucide-react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";

interface WorkoutDetailProps {
  id: string;
}

export default function WorkoutDetail({ id }: WorkoutDetailProps) {
  const workoutId = parseInt(id);
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState("details");
  
  // Form state
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [duration, setDuration] = useState("");
  const [status, setStatus] = useState("active");
  
  // Exercises management
  const [addExerciseDialogOpen, setAddExerciseDialogOpen] = useState(false);
  const [selectedExercise, setSelectedExercise] = useState<number | null>(null);
  const [sets, setSets] = useState("");
  const [reps, setReps] = useState("");
  const [restTime, setRestTime] = useState("");
  const [notes, setNotes] = useState("");
  
  const trainerId = 1; // Using default trainer ID

  // Fetch workout plan details
  const { data: workoutPlan, isLoading: isWorkoutLoading } = useQuery({
    queryKey: [`/api/workout-plans/${workoutId}`],
    queryFn: async () => {
      const res = await fetch(`/api/workout-plans/${workoutId}`);
      if (!res.ok) throw new Error("Failed to fetch workout plan");
      return res.json();
    }
  });

  // Fetch workout exercises
  const { data: workoutExercises, isLoading: isExercisesLoading, refetch: refetchExercises } = useQuery({
    queryKey: [`/api/workout-plans/${workoutId}/exercises`],
    queryFn: async () => {
      const res = await fetch(`/api/workout-plans/${workoutId}/exercises`);
      if (!res.ok) throw new Error("Failed to fetch workout exercises");
      return res.json();
    },
    enabled: !!workoutId
  });

  // Fetch all available exercises
  const { data: exerciseLibrary, isLoading: isLibraryLoading } = useQuery({
    queryKey: ["/api/exercises"],
    queryFn: async () => {
      const res = await fetch("/api/exercises");
      if (!res.ok) throw new Error("Failed to fetch exercises");
      return res.json();
    }
  });

  // Set form values once workout plan data is loaded
  useEffect(() => {
    if (workoutPlan) {
      setName(workoutPlan.name);
      setDescription(workoutPlan.description || "");
      setDuration(workoutPlan.duration.toString());
      setStatus(workoutPlan.status);
    }
  }, [workoutPlan]);

  // Get exercise details by ID
  const getExerciseDetails = (id: number) => {
    if (!exerciseLibrary) return null;
    return exerciseLibrary.find((ex: any) => ex.id === id);
  };

  // Handle form submission
  const handleSave = async () => {
    if (!name.trim()) {
      toast({
        variant: "destructive",
        title: "Error",
        description: "Workout name is required"
      });
      return;
    }
    
    try {
      await apiRequest("PUT", `/api/workout-plans/${workoutId}`, {
        name,
        description,
        duration: parseInt(duration),
        status,
        trainerId
      });
      
      await queryClient.invalidateQueries({ queryKey: [`/api/workout-plans/${workoutId}`] });
      await queryClient.invalidateQueries({ queryKey: ["/api/workout-plans"] });
      
      toast({
        title: "Success",
        description: "Workout plan has been updated"
      });
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to update workout plan"
      });
    }
  };

  // Handle adding a new exercise to the workout
  const handleAddExercise = async () => {
    if (!selectedExercise) {
      toast({
        variant: "destructive",
        title: "Error",
        description: "Please select an exercise"
      });
      return;
    }
    
    try {
      const nextOrder = workoutExercises ? workoutExercises.length + 1 : 1;
      
      await apiRequest("POST", `/api/workout-exercises`, {
        workoutPlanId: workoutId,
        exerciseId: selectedExercise,
        sets: sets ? parseInt(sets) : null,
        reps: reps ? parseInt(reps) : null,
        rest: restTime ? parseInt(restTime) : null,
        notes,
        order: nextOrder
      });
      
      await refetchExercises();
      
      // Reset form
      setSelectedExercise(null);
      setSets("");
      setReps("");
      setRestTime("");
      setNotes("");
      setAddExerciseDialogOpen(false);
      
      toast({
        title: "Success",
        description: "Exercise added to workout plan"
      });
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to add exercise"
      });
    }
  };

  // Handle removing an exercise from the workout
  const handleRemoveExercise = async (exerciseId: number) => {
    try {
      await apiRequest("DELETE", `/api/workout-exercises/${exerciseId}`, undefined);
      await refetchExercises();
      
      toast({
        title: "Success",
        description: "Exercise removed from workout plan"
      });
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to remove exercise"
      });
    }
  };

  // Loading state
  if (isWorkoutLoading) {
    return (
      <div className="p-4 md:p-6 lg:p-8">
        <div className="animate-pulse">
          <div className="h-6 w-32 bg-gray-200 rounded mb-6"></div>
          <Card className="border border-gray-100">
            <CardHeader className="px-6 pt-6 pb-4">
              <div className="h-7 bg-gray-200 rounded w-48 mb-2"></div>
              <div className="h-4 bg-gray-200 rounded w-64"></div>
            </CardHeader>
            <CardContent className="px-6 pb-6">
              <div className="space-y-4">
                <div className="space-y-2">
                  <div className="h-4 bg-gray-200 rounded w-32"></div>
                  <div className="h-10 bg-gray-200 rounded"></div>
                </div>
                <div className="space-y-2">
                  <div className="h-4 bg-gray-200 rounded w-32"></div>
                  <div className="h-24 bg-gray-200 rounded"></div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }

  // Not found state
  if (!workoutPlan && !isWorkoutLoading) {
    return (
      <div className="p-4 md:p-6 lg:p-8">
        <div className="text-center py-12">
          <h2 className="text-xl font-semibold mb-2">Workout plan not found</h2>
          <p className="text-gray-500 mb-6">The workout plan you're looking for doesn't exist or has been removed.</p>
          <Link href="/workouts">
            <Button>
              <ArrowLeft className="mr-2 h-4 w-4" />
              Back to Workouts
            </Button>
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="p-4 md:p-6 lg:p-8">
      <Link
        href="/workouts"
        className="inline-flex items-center mb-6 text-sm text-primary hover:text-primary-dark"
      >
        <ArrowLeft className="w-4 h-4 mr-1" />
        Back to Workouts
      </Link>

      <Card className="border border-gray-100 mb-6">
        <CardHeader className="px-6 pt-6 pb-4 flex flex-col md:flex-row md:items-start md:justify-between gap-4">
          <div>
            <CardTitle className="text-xl font-semibold">Edit Workout Plan</CardTitle>
            <CardDescription>
              Update workout details and exercises
            </CardDescription>
          </div>
          <div className="flex gap-2">
            <Button variant="outline" onClick={() => navigate("/workouts")}>
              Cancel
            </Button>
            <Button onClick={handleSave}>
              Save Changes
            </Button>
          </div>
        </CardHeader>
        <CardContent className="px-6 pb-6">
          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="mb-6">
              <TabsTrigger value="details">Plan Details</TabsTrigger>
              <TabsTrigger value="exercises">Exercises</TabsTrigger>
              <TabsTrigger value="students">Assigned Students</TabsTrigger>
            </TabsList>
            
            <TabsContent value="details" className="mt-0">
              <div className="space-y-4">
                <div className="grid gap-4 sm:grid-cols-2">
                  <div className="space-y-2">
                    <Label htmlFor="name">Workout Name*</Label>
                    <Input 
                      id="name" 
                      value={name} 
                      onChange={(e) => setName(e.target.value)}
                      placeholder="e.g. Strength Training" 
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="status">Status</Label>
                    <Select value={status} onValueChange={setStatus}>
                      <SelectTrigger id="status">
                        <SelectValue placeholder="Select status" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="active">Active</SelectItem>
                        <SelectItem value="draft">Draft</SelectItem>
                        <SelectItem value="archived">Archived</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                
                <div className="space-y-2">
                  <Label htmlFor="description">Description</Label>
                  <Textarea 
                    id="description" 
                    value={description} 
                    onChange={(e) => setDescription(e.target.value)}
                    placeholder="Describe the workout plan" 
                    rows={3}
                  />
                </div>
                
                <div className="space-y-2 max-w-xs">
                  <Label htmlFor="duration">Duration (weeks)</Label>
                  <Input 
                    id="duration" 
                    type="number" 
                    min="1" 
                    value={duration} 
                    onChange={(e) => setDuration(e.target.value)}
                  />
                </div>
              </div>
            </TabsContent>
            
            <TabsContent value="exercises" className="mt-0">
              <div className="flex justify-between items-center mb-4">
                <h3 className="font-medium">Exercise List</h3>
                <Dialog open={addExerciseDialogOpen} onOpenChange={setAddExerciseDialogOpen}>
                  <DialogTrigger asChild>
                    <Button size="sm">
                      <Plus className="h-4 w-4 mr-2" />
                      Add Exercise
                    </Button>
                  </DialogTrigger>
                  <DialogContent>
                    <DialogHeader>
                      <DialogTitle>Add Exercise to Workout</DialogTitle>
                      <DialogDescription>
                        Select an exercise and specify sets, reps, and rest time.
                      </DialogDescription>
                    </DialogHeader>
                    
                    <div className="space-y-4 py-2">
                      <div className="space-y-2">
                        <Label htmlFor="exercise">Exercise*</Label>
                        <Select value={selectedExercise?.toString() || ""} onValueChange={(value) => setSelectedExercise(parseInt(value))}>
                          <SelectTrigger id="exercise">
                            <SelectValue placeholder="Select an exercise" />
                          </SelectTrigger>
                          <SelectContent>
                            {exerciseLibrary?.map((exercise: any) => (
                              <SelectItem key={exercise.id} value={exercise.id.toString()}>
                                {exercise.name} ({exercise.muscleGroup})
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </div>
                      
                      <div className="grid grid-cols-2 gap-4">
                        <div className="space-y-2">
                          <Label htmlFor="sets">Sets</Label>
                          <Input 
                            id="sets" 
                            type="number" 
                            min="1" 
                            value={sets} 
                            onChange={(e) => setSets(e.target.value)}
                          />
                        </div>
                        <div className="space-y-2">
                          <Label htmlFor="reps">Reps</Label>
                          <Input 
                            id="reps" 
                            type="number" 
                            min="1" 
                            value={reps} 
                            onChange={(e) => setReps(e.target.value)}
                          />
                        </div>
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="rest">Rest Time (seconds)</Label>
                        <Input 
                          id="rest" 
                          type="number" 
                          min="0" 
                          value={restTime} 
                          onChange={(e) => setRestTime(e.target.value)}
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="notes">Notes</Label>
                        <Textarea 
                          id="notes" 
                          value={notes} 
                          onChange={(e) => setNotes(e.target.value)}
                          placeholder="Additional instructions or tips" 
                          rows={2}
                        />
                      </div>
                    </div>
                    
                    <DialogFooter>
                      <Button variant="outline" onClick={() => setAddExerciseDialogOpen(false)}>
                        Cancel
                      </Button>
                      <Button onClick={handleAddExercise}>
                        Add to Workout
                      </Button>
                    </DialogFooter>
                  </DialogContent>
                </Dialog>
              </div>
              
              {isExercisesLoading ? (
                <div className="animate-pulse space-y-4">
                  {[1, 2, 3].map((i) => (
                    <div key={i} className="h-16 bg-gray-100 rounded-lg"></div>
                  ))}
                </div>
              ) : (
                <>
                  {(!workoutExercises || workoutExercises.length === 0) ? (
                    <div className="text-center py-12 bg-gray-50 rounded-lg">
                      <Dumbbell className="h-12 w-12 text-gray-400 mx-auto mb-3" />
                      <h3 className="text-lg font-medium text-gray-900 mb-1">No Exercises Added</h3>
                      <p className="text-gray-500 mb-4">This workout plan doesn't have any exercises yet.</p>
                      <Button onClick={() => setAddExerciseDialogOpen(true)}>
                        <Plus className="h-4 w-4 mr-2" />
                        Add First Exercise
                      </Button>
                    </div>
                  ) : (
                    <div className="border rounded-lg overflow-hidden">
                      <Table>
                        <TableHeader className="bg-gray-50">
                          <TableRow>
                            <TableHead className="w-12">#</TableHead>
                            <TableHead>Exercise</TableHead>
                            <TableHead>Muscle Group</TableHead>
                            <TableHead>Sets</TableHead>
                            <TableHead>Reps</TableHead>
                            <TableHead>Rest</TableHead>
                            <TableHead className="text-right">Actions</TableHead>
                          </TableRow>
                        </TableHeader>
                        <TableBody>
                          {workoutExercises.map((ex: any, index: number) => {
                            const exerciseDetails = getExerciseDetails(ex.exerciseId);
                            return (
                              <TableRow key={ex.id}>
                                <TableCell className="font-medium">{index + 1}</TableCell>
                                <TableCell>{exerciseDetails?.name || "Unknown Exercise"}</TableCell>
                                <TableCell>{exerciseDetails?.muscleGroup || "-"}</TableCell>
                                <TableCell>{ex.sets || "-"}</TableCell>
                                <TableCell>{ex.reps || "-"}</TableCell>
                                <TableCell>{ex.rest ? `${ex.rest}s` : "-"}</TableCell>
                                <TableCell className="text-right">
                                  <div className="flex justify-end space-x-2">
                                    <Button 
                                      variant="ghost" 
                                      size="icon"
                                      className="h-8 w-8 text-gray-500 hover:text-gray-700"
                                      onClick={() => {}}
                                    >
                                      <ChevronUp className="h-4 w-4" />
                                    </Button>
                                    <Button 
                                      variant="ghost" 
                                      size="icon"
                                      className="h-8 w-8 text-gray-500 hover:text-gray-700"
                                      onClick={() => {}}
                                    >
                                      <ChevronDown className="h-4 w-4" />
                                    </Button>
                                    <Button 
                                      variant="ghost" 
                                      size="icon"
                                      className="h-8 w-8 text-red-500 hover:text-red-700 hover:bg-red-50"
                                      onClick={() => handleRemoveExercise(ex.id)}
                                    >
                                      <Trash2 className="h-4 w-4" />
                                    </Button>
                                  </div>
                                </TableCell>
                              </TableRow>
                            );
                          })}
                        </TableBody>
                      </Table>
                    </div>
                  )}
                </>
              )}
            </TabsContent>
            
            <TabsContent value="students" className="mt-0">
              <div className="flex justify-between items-center mb-4">
                <h3 className="font-medium">Students Using This Plan</h3>
                <Button size="sm" variant="outline">
                  <Plus className="h-4 w-4 mr-2" />
                  Assign to Student
                </Button>
              </div>
              
              <div className="text-center py-12 bg-gray-50 rounded-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400 mx-auto mb-3">
                  <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" />
                  <circle cx="9" cy="7" r="4" />
                  <path d="M22 21v-2a4 4 0 0 0-3-3.87" />
                  <path d="M16 3.13a4 4 0 0 1 0 7.75" />
                </svg>
                <h3 className="text-lg font-medium text-gray-900 mb-1">No Students Assigned</h3>
                <p className="text-gray-500 mb-4">This workout hasn't been assigned to any students yet.</p>
                <Button variant="outline">
                  <Plus className="h-4 w-4 mr-2" />
                  Assign to Student
                </Button>
              </div>
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  );
}

===== ./client/src/pages/workouts/index.tsx =====
// client/src/pages/workouts/index.tsx
import React from 'react';
import { Link } from 'wouter'; 
import { ArrowLeft } from 'lucide-react'; 

export default function WorkoutsIndex() {
  
  // --- CORRIGIR A EXTENSÃO DO ARQUIVO AQUI ---
  const imagePath = '/em-desenvolvimento.jpeg'; // Usar .jpeg
  // --- FIM DA CORREÇÃO ---

  return (
    <div className="flex flex-col items-center justify-center text-center p-8 min-h-[calc(100vh-150px)]"> 
      
      <img 
        src={imagePath}                     
        alt="Ferramenta em desenvolvimento" 
        className="max-w-xs w-full h-auto mb-6" 
      />

           <p className="text-gray-500 mb-8">
        Esta seção de Treinos está sendo preparada. Volte em breve!
      </p>

      <Link 
        href="/" 
        className="inline-flex items-center px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 transition-colors text-sm font-medium"
      >
        <ArrowLeft className="w-4 h-4 mr-2" />
        Voltar para o Painel
      </Link>

    </div>
  );
}
===== ./client/src/pages/workouts/new.tsx =====
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { WorkoutForm } from "@/forms/workout-form";
import { Link } from "wouter";
import { ChevronLeft } from "lucide-react";

export default function NewWorkout() {
  return (
    <div className="p-4 md:p-6 lg:p-8">
      <Link
        href="/workouts"
        className="inline-flex items-center mb-4 text-sm text-primary hover:text-primary-dark"
      >
        <ChevronLeft className="w-4 h-4 mr-1" />
        Back to Workouts
      </Link>
      <Card className="max-w-2xl mx-auto border border-gray-100">
        <CardHeader className="px-6 pt-6 pb-4">
          <CardTitle className="text-xl font-semibold">Create New Workout Plan</CardTitle>
          <CardDescription>
            Design a workout plan for your students with exercises, sets, and reps.
          </CardDescription>
        </CardHeader>
        <CardContent className="px-6 pb-6">
          <WorkoutForm />
        </CardContent>
      </Card>
    </div>
  );
}

===== ./client/src/types/aluno.ts =====
// client/src/types/aluno.ts
export interface Aluno {
  _id: string;
  nome: string;
  email: string;
  phone?: string;
  birthDate: string;
  gender: string;
  goal: string;
  weight: number;
  height: number;
  startDate: string;
  // --- CORREÇÃO AQUI ---
  status: 'active' | 'inactive';
  notes?: string;
  trainerId: string; // ID do PersonalTrainer
  // Novos campos para saber se o aluno utiliza plano ou token avulso
  slotType?: 'plan' | 'token';
  slotId?: string;
  slotStartDate?: string;
  slotEndDate?: string;
}

===== ./client/src/types/exercicio.ts =====
// client/src/types/exercicio.ts

// Define e exporta a interface Exercicio
export interface Exercicio { 
    _id: string; 
    nome: string;
    grupoMuscular: string;
    descricao?: string;
    categoria?: string;
    imageUrl?: string;
    videoUrl?: string; 
    isCustom: boolean;
    creatorId?: string; 
    favoritedBy?: string[]; 
    isFavorited?: boolean; 
    createdAt?: string; 
    updatedAt?: string; 
  }
===== ./client/src/types/treinoOuRotinaTypes.ts =====
// client/src/types/treinoOuRotinaTypes.ts

// Representa um exercício dentro de um dia de treino, como vem da API populado e lean
// e como é usado internamente nos componentes de modal.
export interface ExercicioEmDiaDeTreinoDetalhado {
    _id?: string; // ID do subdocumento ExercicioEmDiaDeTreino no MongoDB (se já salvo)
    exercicioId: { // Objeto do exercício da biblioteca, populado
        _id: string;
        nome: string;
        grupoMuscular?: string;
        urlVideo?: string;
        descricao?: string;
        categoria?: string;
        tipo?: string; 
    } | string; // Pode ser apenas o ID string se não estiver populado
    series?: string;
    repeticoes?: string;
    carga?: string;
    descanso?: string;
    observacoes?: string;
    ordemNoDia: number;
    concluido?: boolean; // Usado pelo aluno ao realizar o treino
    grupoCombinado?: string; // ID do grupo para exercícios combinados
}

// Representa um dia de treino, como vem da API populado e lean
export interface DiaDeTreinoDetalhado {
    _id?: string; // ID do subdocumento DiaDeTreino no MongoDB (se já salvo)
    identificadorDia: string;
    nomeSubFicha?: string | null;
    ordemNaRotina: number;
    exerciciosDoDia?: ExercicioEmDiaDeTreinoDetalhado[];
}

// Interface para a Rotina/Ficha como listada na TreinosPage e usada no cache do React Query.
// Também é a base para o que é passado para os modais de visualização e edição.
export interface RotinaListagemItem {
    _id: string;
    titulo: string;
    descricao?: string | null;
    tipo: "modelo" | "individual";
    // Detalhes do aluno e criador, podem vir populados da API
    alunoId?: { _id: string; nome: string; email?: string; } | string | null; 
    criadorId: { _id: string; nome: string; email?: string; } | string; 
    
    tipoOrganizacaoRotina: 'diasDaSemana' | 'numerico' | 'livre';
    diasDeTreino?: DiaDeTreinoDetalhado[]; // Array de dias de treino detalhados

    // Campos específicos de modelo
    pastaId?: { _id: string; nome: string; } | string | null;
    statusModelo?: "ativo" | "rascunho" | "arquivado" | null;
    ordemNaPasta?: number;

    // Campos específicos de individual
    dataValidade?: string | Date | null; // API pode retornar string, mas Date é útil no form
    totalSessoesRotinaPlanejadas?: number | null;
    sessoesRotinaConcluidas?: number;

    // Timestamps e virtuais (como vêm da API .lean())
    criadoEm: string; 
    atualizadoEm?: string; 
    isExpirada?: boolean;
    progressoRotina?: string;
    __v?: number;
    isCopied?: boolean; // <<< NOVO CAMPO: Indica se a rotina é uma cópia >>>
}

===== ./client/src/utils/dateUtils.ts =====
/**
 * Formats a date string for use in HTML date input fields
 * Handles various date formats and ensures output is always YYYY-MM-DD
 * Fixes timezone issues by treating date-only strings as local dates
 * 
 * @param dateString - The date string to format (can be ISO format, date-only, etc.)
 * @returns Formatted date string in YYYY-MM-DD format, or empty string if invalid
 */
export function formatDateForInput(dateString: string | null | undefined): string {
  // Return empty string for null, undefined, or empty strings
  if (!dateString || dateString.trim() === '') {
    return '';
  }

  try {
    const trimmedDate = dateString.trim();
    
    // Handle the case where dateString is already in YYYY-MM-DD format
    const dateOnlyRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (dateOnlyRegex.test(trimmedDate)) {
      // If it's already in the correct format, just return it
      // This avoids timezone conversion issues for date-only strings
      return trimmedDate;
    }

    // For ISO strings with time (e.g., "2023-12-15T10:30:00Z"), 
    // extract just the date part to avoid timezone issues
    if (trimmedDate.includes('T')) {
      const datePart = trimmedDate.split('T')[0];
      if (dateOnlyRegex.test(datePart)) {
        return datePart;
      }
    }

    // For other formats, try to parse but use UTC methods to avoid timezone issues
    const date = new Date(trimmedDate);
    
    // Check if the date is valid
    if (isNaN(date.getTime())) {
      console.warn('formatDateForInput: Invalid date string:', dateString);
      return '';
    }

    // Use UTC methods to avoid timezone conversion issues for date parsing
    // This ensures that a date like "1988-07-07" doesn't become "1988-07-06" 
    // in timezones behind UTC (like Brazil UTC-3)
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0'); // months are 0-indexed
    const day = String(date.getUTCDate()).padStart(2, '0');

    // Return in YYYY-MM-DD format
    return `${year}-${month}-${day}`;
  } catch (error) {
    console.warn('formatDateForInput: Error formatting date string:', dateString, error);
    return '';
  }
}
===== ./client/src/vite-env.d.ts =====
/// <reference types="vite-plugin-pwa/client" />
===== ./client/tailwind.config.ts =====
import { type Config } from "tailwindcss";

const config: Config = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [
    require('@tailwindcss/typography'), // ✅ Adicionado
  ],
};

export default config;

===== ./client/vite.config.alt.ts =====
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
import { fileURLToPath } from 'url';

const clientDir = path.dirname(fileURLToPath(import.meta.url));
const vitePort = 5174;
const gitpodWorkspaceUrl = process.env.GITPOD_WORKSPACE_URL;

function getGitpodBaseDomain(): string | undefined {
  if (!gitpodWorkspaceUrl) return undefined;
  try {
    return new URL(gitpodWorkspaceUrl).hostname;
  } catch (e) {
    return undefined;
  }
}
const gitpodDomain = getGitpodBaseDomain();

console.log("[vite.config.alt.ts] Rodando com porta:", vitePort);
console.log("[vite.config.alt.ts] gitpodDomain (para HMR):", gitpodDomain);

export default defineConfig({
  root: clientDir, // 👈 ADICIONADO AQUI
  plugins: [react()],
  resolve: {
    alias: { '@': path.resolve(clientDir, 'src') },
  },
  server: {
    host: '0.0.0.0',
    port: vitePort,
    strictPort: true,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false,
        ws: true,
      },
    },
    allowedHosts: ['localhost', '.gitpod.io'],
    hmr: gitpodWorkspaceUrl
      ? {
          host: gitpodDomain || undefined,
          protocol: 'wss',
        }
      : undefined,
  },
  build: {
    outDir: path.resolve(clientDir, 'dist'),
    emptyOutDir: true,
  },
});

===== ./client/vite.config.alt.ts.backup.ts =====
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
import { fileURLToPath } from 'url';

const clientDir = path.dirname(fileURLToPath(import.meta.url));
const vitePort = 5174;
const gitpodWorkspaceUrl = process.env.GITPOD_WORKSPACE_URL;

function getGitpodBaseDomain(): string | undefined {
  if (!gitpodWorkspaceUrl) return undefined;
  try {
    return new URL(gitpodWorkspaceUrl).hostname;
  } catch (e) {
    return undefined;
  }
}
const gitpodDomain = getGitpodBaseDomain();

console.log("[vite.config.alt.ts] Rodando com porta:", vitePort);
console.log("[vite.config.alt.ts] gitpodDomain (para HMR):", gitpodDomain);

export default defineConfig({
  root: clientDir, // 👈 ADICIONADO AQUI
  plugins: [react()],
  resolve: {
    alias: { '@': path.resolve(clientDir, 'src') },
  },
  server: {
    host: '0.0.0.0',
    port: vitePort,
    strictPort: true,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false,
        ws: true,
      },
    },
    allowedHosts: ['localhost', '.gitpod.io'],
    hmr: gitpodWorkspaceUrl
      ? {
          host: gitpodDomain || undefined,
          protocol: 'wss',
        }
      : undefined,
  },
  build: {
    outDir: path.resolve(clientDir, 'dist'),
    emptyOutDir: true,
  },
});

===== ./dev.sh =====
#!/bin/bash

# Mata qualquer processo preso na porta 5000 (Node travado)
PORT=5000
PID=$(lsof -ti tcp:$PORT)
if [ -n "$PID" ]; then
  echo "Matando processo na porta $PORT (PID: $PID)..."
  kill -9 $PID
fi

# Função para encerrar os subprocessos
function cleanup {
  echo "Encerrando processos..."
  kill "$SERVER_PID" "$CLIENT_PID"
  wait "$SERVER_PID" "$CLIENT_PID"
  exit
}

# Captura CTRL+C e outros sinais
trap cleanup SIGINT SIGTERM

# Inicia o backend e salva o PID
npm run dev:server &
SERVER_PID=$!

# Inicia o frontend e salva o PID
npm run dev:client &
CLIENT_PID=$!

# Espera ambos
wait

===== ./drizzle.config.ts =====
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
===== ./export_source_txt.sh =====
set -euo pipefail

OUT_DIR="export_txt_$(date +%Y%m%d_%H%M%S)"
MAX_LINES="${1:-4000}"   # use: ./export_source_txt.sh 5000 (ou o número que quiser)
mkdir -p "$OUT_DIR"

COMBINED="$OUT_DIR/projeto_completo.txt"

# Lista de arquivos (ordenada, e ignorando pastas pesadas)
mapfile -t FILES < <(find . -type f \
  \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.json" \) \
  -not -path "*/node_modules/*" \
  -not -path "*/dist/*" \
  -not -path "*/build/*" \
  -not -path "*/.next/*" \
  -not -path "*/coverage/*" \
  -not -path "*/.vercel/*" \
  -not -path "*/.git/*" \
  -not -path "*/.turbo/*" \
  -not -path "*/.pnpm-store/*" \
| LC_ALL=C sort)

# Gera o .txt combinado com cabeçalho por arquivo
: > "$COMBINED"
for f in "${FILES[@]}"; do
  echo "===== ${f#./} =====" >> "$COMBINED"
  cat "$f" >> "$COMBINED"
  printf "\n\n" >> "$COMBINED"
done

# Divide por número de linhas
split -d -a 3 -l "$MAX_LINES" "$COMBINED" "$OUT_DIR/parte_"

# Renomeia as partes para .txt
for p in "$OUT_DIR"/parte_*; do mv "$p" "${p}.txt"; done

# Manifesto
MANIFEST="$OUT_DIR/manifest.txt"
{
  echo "Export timestamp: $(date -Is)"
  echo "Max lines per part: $MAX_LINES"
  echo "Total source files: ${#FILES[@]}"
  echo
  echo "Included files (in order):"
  for f in "${FILES[@]}"; do echo "${f#./}"; done
  echo
  echo "Parts generated:"
  ls -1 "$OUT_DIR"/parte_*.txt
} > "$MANIFEST"

# ZIP opcional (pronto pra baixar)
ZIP="$OUT_DIR.zip"
zip -q -j "$ZIP" "$OUT_DIR"/parte_*.txt "$MANIFEST"

echo
echo "✅ Pronto!"
echo "Pasta de saída:  $OUT_DIR"
echo "Arquivo ZIP:     $ZIP"

===== ./postcss.config.js =====
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

===== ./server/database.ts =====
// server/database.ts
import mongoose from "mongoose";
import * as dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";

// Reconstruindo __dirname para ambientes ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Carrega o .env da raiz do projeto (assumindo que database.ts está em server/)
dotenv.config({ path: path.resolve(__dirname, "../.env") }); // Ajustado para ../.env

let isConnected = false; // Flag para controlar o estado da conexão

export async function connectToDatabase() {
  if (isConnected && mongoose.connection.readyState >= 1) {
    console.log("ℹ️  Já conectado ao MongoDB.");
    return;
  }

  try {
    const mongoUri = process.env.MONGODB_URI;

    if (!mongoUri) {
      throw new Error("❌ MONGODB_URI não definida no arquivo .env");
    }

    console.log("🟡 Conectando ao MongoDB Atlas...");
    
    // Configuração otimizada para ambiente serverless
    await mongoose.connect(mongoUri, {
      dbName: "dyfit", // Nome do banco de dados especificado
      bufferCommands: false, // Critical for serverless - disable mongoose buffering
      maxPoolSize: 10, // Maintain up to 10 socket connections
      serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
      socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
      family: 4, // Use IPv4, skip trying IPv6
    });

    isConnected = true;
    console.log("✅ Conectado ao MongoDB Atlas com sucesso!");

    mongoose.connection.on('error', (err) => {
      console.error("❌ Erro na conexão com MongoDB após conexão inicial:", err);
      isConnected = false;
    });

    mongoose.connection.on('disconnected', () => {
      console.log("ℹ️  Desconectado do MongoDB.");
      isConnected = false;
    });

    mongoose.connection.on('close', () => {
      console.log("ℹ️  Conexão com MongoDB fechada.");
      isConnected = false;
    });

  } catch (error) {
    console.error("❌ Erro ao conectar ao MongoDB Atlas:", error);
    // In serverless environment, don't exit process - just throw error
    if (process.env.NODE_ENV === 'production' || process.env.VERCEL) {
      throw error;
    }
    process.exit(1);
  }
}

export async function disconnectFromDatabase() {
  if (mongoose.connection.readyState !== 0) {
    await mongoose.disconnect();
    isConnected = false; // Atualiza o flag
    console.log("ℹ️  Conexão com MongoDB fechada.");
  } else {
    console.log("ℹ️  Nenhuma conexão ativa para fechar.");
  }
}

===== ./server/dist/database.js =====
// server/database.ts
import mongoose from "mongoose";
import * as dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";
// Reconstruindo __dirname para ambientes ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// Carrega o .env da raiz do projeto (assumindo que database.ts está em server/)
dotenv.config({ path: path.resolve(__dirname, "../.env") }); // Ajustado para ../.env
let isConnected = false; // Flag para controlar o estado da conexão
export async function connectToDatabase() {
    if (isConnected && mongoose.connection.readyState >= 1) {
        console.log("ℹ️  Já conectado ao MongoDB.");
        return;
    }
    try {
        const mongoUri = process.env.MONGODB_URI;
        if (!mongoUri) {
            throw new Error("❌ MONGODB_URI não definida no arquivo .env");
        }
        console.log("🟡 Conectando ao MongoDB Atlas...");
        // Configuração otimizada para ambiente serverless
        await mongoose.connect(mongoUri, {
            dbName: "dyfit", // Nome do banco de dados especificado
            bufferCommands: false, // Critical for serverless - disable mongoose buffering
            maxPoolSize: 10, // Maintain up to 10 socket connections
            serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
            socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
            family: 4, // Use IPv4, skip trying IPv6
        });
        isConnected = true;
        console.log("✅ Conectado ao MongoDB Atlas com sucesso!");
        mongoose.connection.on('error', (err) => {
            console.error("❌ Erro na conexão com MongoDB após conexão inicial:", err);
            isConnected = false;
        });
        mongoose.connection.on('disconnected', () => {
            console.log("ℹ️  Desconectado do MongoDB.");
            isConnected = false;
        });
        mongoose.connection.on('close', () => {
            console.log("ℹ️  Conexão com MongoDB fechada.");
            isConnected = false;
        });
    }
    catch (error) {
        console.error("❌ Erro ao conectar ao MongoDB Atlas:", error);
        // In serverless environment, don't exit process - just throw error
        if (process.env.NODE_ENV === 'production' || process.env.VERCEL) {
            throw error;
        }
        process.exit(1);
    }
}
export async function disconnectFromDatabase() {
    if (mongoose.connection.readyState !== 0) {
        await mongoose.disconnect();
        isConnected = false; // Atualiza o flag
        console.log("ℹ️  Conexão com MongoDB fechada.");
    }
    else {
        console.log("ℹ️  Nenhuma conexão ativa para fechar.");
    }
}

===== ./server/dist/index.js =====
// server/index.ts
// --- BLOCO DE IMPORTAÇÕES ---
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import express, { Router } from 'express';
import cors from 'cors';
import authRoutes from './src/routes/auth.js';
import convitePublicRoutes from './src/routes/convitePublicRoutes.js';
import conviteAlunoPublicRoutes from './src/routes/conviteAlunoPublicRoutes.js';
import dashboardRoutes from './src/routes/dashboardGeralRoutes.js';
import treinoRoutes from './src/routes/treinos.js';
import exercicioRoutes from './src/routes/exercicios.js';
import sessionsRoutes from './src/routes/sessionsRoutes.js';
import pastaRoutes from './src/routes/pastasTreinos.js';
import alunoApiRoutes from './src/routes/alunoApiRoutes.js';
import adminRoutes from './src/routes/adminRoutes.js';
import activityLogsRoutes from './src/routes/activityLogsRoutes.js'; // <-- 1. IMPORTAÇÃO ADICIONADA
import adminPlanosRoutes from './src/routes/adminPlanosRoutes.js';
import personalPlanosRoutes from './src/routes/personalPlanosRoutes.js';
import adminRenewalRoutes from './src/routes/adminRenewalRoutes.js';
import personalRenewalRoutes from './src/routes/personalRenewalRoutes.js';
import { authenticateToken } from './middlewares/authenticateToken.js';
import { authorizeAdmin } from './middlewares/authorizeAdmin.js';
import { errorHandler } from './middlewares/errorHandler.js';
import dbConnect from './lib/dbConnect.js';
// --- CONFIGURAÇÃO DE AMBIENTE ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
dotenv.config({ path: path.resolve(__dirname, '.env') });
const app = express();
const apiRouter = Router();
// --- CONFIGURAÇÃO DE CORS E MIDDLEWARES GLOBAIS ---
const allowedOrigins = [
    'http://localhost:5173', 'http://localhost:4173', process.env.FRONTEND_URL,
].filter(Boolean);
const corsOptions = {
    origin: (origin, callback) => {
        if (!origin || allowedOrigins.includes(origin) || origin.endsWith('.gitpod.io') || origin.endsWith('.vercel.app')) {
            callback(null, true);
        }
        else {
            console.warn(`CORS: Requisição bloqueada da origem: ${origin}`);
            callback(new Error('Não permitido pela política de CORS'));
        }
    },
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    credentials: true,
    optionsSuccessStatus: 204
};
app.use(cors(corsOptions));
app.use(express.json());
// --- ESTRUTURA DE ROTAS ---
app.use('/api', apiRouter);
// --- 1. Rotas Públicas ---
apiRouter.use('/public/convites', convitePublicRoutes);
apiRouter.use('/public/convite-aluno', conviteAlunoPublicRoutes);
apiRouter.use('/auth', authRoutes);
// --- 2. Rotas Protegidas ---
// A autenticação é aplicada diretamente ou dentro de cada arquivo de rota.
apiRouter.use('/admin', authenticateToken, authorizeAdmin, adminRoutes);
apiRouter.use('/admin', adminPlanosRoutes); // Plan management routes (auth applied inside)
apiRouter.use('/admin/renewal-requests', adminRenewalRoutes); // Admin renewal requests (auth applied inside)
apiRouter.use('/personal', personalPlanosRoutes); // Personal trainer plan routes (auth applied inside)
apiRouter.use('/personal/renewal-requests', personalRenewalRoutes); // Personal renewal requests (auth applied inside)
apiRouter.use('/dashboard/geral', authenticateToken, dashboardRoutes);
apiRouter.use('/treinos', authenticateToken, treinoRoutes);
apiRouter.use('/exercicios', authenticateToken, exercicioRoutes);
apiRouter.use('/pastas/treinos', authenticateToken, pastaRoutes);
apiRouter.use('/activity-logs', authenticateToken, activityLogsRoutes); // <-- 2. REGISTRO DA ROTA ADICIONADO
apiRouter.use('/aluno', alunoApiRoutes);
apiRouter.use('/alunos', alunoApiRoutes); // Add alias for consistency with client expectations
apiRouter.use('/sessions', sessionsRoutes);
// --- 3. Tratamento de Erros ---
app.use(errorHandler);
// --- EXPORTAÇÃO E INICIALIZAÇÃO ---
export default app;
const startServer = async () => {
    try {
        await dbConnect();
        console.log('Banco de dados conectado com sucesso!');
        if (process.env.NODE_ENV === 'development') {
            const PORT = process.env.PORT || 5000;
            app.listen(PORT, () => {
                console.log(`[DEV] Servidor Express de desenvolvimento rodando em http://localhost:${PORT}`);
            });
        }
    }
    catch (error) {
        console.error('Falha ao conectar ao banco de dados:', error);
        process.exit(1); // Encerra o processo se a conexão com o DB falhar
    }
};
startServer();

===== ./server/dist/lib/dbConnect.js =====
import mongoose from 'mongoose';
const MONGODB_URI = process.env.MONGODB_URI;
if (!MONGODB_URI) {
    throw new Error('Por favor, defina a variável de ambiente MONGODB_URI no seu .env ou na Vercel');
}
/**
 * Cache de conexão global. Isso evita criar uma nova conexão a cada
 * invocação da função serverless em um "warm start".
 */
let cached = global.mongoose;
if (!cached) {
    cached = global.mongoose = { conn: null, promise: null };
}
async function dbConnect() {
    if (cached.conn) {
        // Se já temos uma conexão em cache, a reutilizamos.
        console.log('=> Usando conexão de banco de dados em cache');
        return cached.conn;
    }
    if (!cached.promise) {
        // Se não há uma conexão em cache, criamos uma nova.
        const opts = {
            bufferCommands: false, // Desabilitar o buffer é uma boa prática em serverless
            maxPoolSize: 10, // Maintain up to 10 socket connections
            serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
            socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
            family: 4, // Use IPv4, skip trying IPv6
            dbName: "dyfit", // Specify database name
        };
        console.log('=> Criando NOVA conexão com o banco de dados');
        cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
            console.log('✅ Conectado ao MongoDB Atlas com sucesso!');
            // Add event listeners for better error handling
            mongoose.connection.on('error', (err) => {
                console.error("❌ Erro na conexão com MongoDB:", err);
            });
            mongoose.connection.on('disconnected', () => {
                console.log("ℹ️  Desconectado do MongoDB.");
            });
            return mongoose;
        });
    }
    try {
        cached.conn = await cached.promise;
    }
    catch (e) {
        console.error('❌ Erro ao conectar ao MongoDB:', e);
        cached.promise = null;
        throw e;
    }
    return cached.conn;
}
export default dbConnect;

===== ./server/dist/loadEnv.mjs =====
// server/loadEnv.mts (ou server/loadEnv.ts)
// Usamos 'require' para dotenv porque este arquivo será carregado como CommonJS
const dotenv = require('dotenv');
const path = require('path');
// No CommonJS, __dirname e __filename estão disponíveis globalmente
// e apontam para o diretório e nome do arquivo atual, respectivamente.
// Não precisamos de 'fileURLToPath' ou 'import.meta.url' aqui.
dotenv.config({ path: path.resolve(__dirname, '.env') });
export {};

===== ./server/dist/middlewares/authenticateAlunoToken.js =====
import jwt from 'jsonwebtoken';
import Aluno from '../models/Aluno.js';
import dbConnect from '../lib/dbConnect.js';
export const authenticateAlunoToken = async (req, res, next) => {
    // Garante conexão com o banco ANTES de consultar
    try {
        await dbConnect();
    }
    catch (dbError) {
        console.error("[Auth Aluno Middleware] ERRO CRÍTICO: Falha ao conectar ao banco de dados.", dbError);
        return res.status(500).json({
            message: 'Erro interno de conexão com o serviço.',
            code: 'DATABASE_CONNECTION_ERROR'
        });
    }
    const authHeader = req.headers['authorization'];
    const token = authHeader?.startsWith('Bearer ') ? authHeader.split(' ')[1] : null;
    if (!token) {
        console.log("[Auth Aluno Middleware] Falha: Token não fornecido. IP:", req.ip, "User-Agent:", req.get('User-Agent'));
        return res.status(401).json({
            message: 'Acesso não autorizado. Token de aluno não fornecido.',
            code: 'TOKEN_NOT_PROVIDED'
        });
    }
    const JWT_SECRET = process.env.JWT_SECRET;
    if (!JWT_SECRET) {
        console.error("[Auth Aluno Middleware] ERRO CRÍTICO: JWT_SECRET não está definido.");
        return res.status(500).json({
            message: 'Erro interno de configuração do servidor.',
            code: 'SERVER_CONFIGURATION_ERROR'
        });
    }
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        if (!decoded.id) {
            console.warn(`[Auth Aluno Middleware] Token sem 'id'. IP:`, req.ip);
            return res.status(403).json({
                message: 'Acesso proibido. Token de aluno com formato inválido.',
                code: 'INVALID_TOKEN_PAYLOAD'
            });
        }
        // Apenas tokens com role 'aluno' podem passar neste middleware
        if ((decoded.role || '').toString().toLowerCase() === 'aluno') {
            const aluno = await Aluno.findById(decoded.id).select('status').lean();
            if (!aluno || aluno.status !== 'active') {
                console.warn(`[Auth Aluno Middleware] Aluno inativo ou não encontrado - ID: ${decoded.id}, IP:`, req.ip);
                return res.status(403).json({
                    message: 'Sua conta está inativa. Fale com seu personal trainer.',
                    code: 'ACCOUNT_INACTIVE'
                });
            }
            req.aluno = {
                id: decoded.id,
                role: 'aluno',
                nome: decoded.nome,
                email: decoded.email,
                personalId: decoded.personalId,
            };
            return next();
        }
        console.warn(`[Auth Aluno Middleware] Token com role inválida ('${decoded.role}') para rota de aluno. IP:`, req.ip);
        return res.status(403).json({
            message: 'Acesso proibido. Esta rota é exclusiva para alunos.',
            code: 'UNAUTHORIZED_ROLE'
        });
    }
    catch (err) {
        console.warn(`[Auth Aluno Middleware] Falha na verificação do token - ${err.name}: ${err.message}. IP:`, req.ip);
        if (err instanceof jwt.TokenExpiredError) {
            return res.status(401).json({ message: 'Sessão de aluno expirada. Faça login novamente.', code: 'TOKEN_EXPIRED' });
        }
        if (err instanceof jwt.JsonWebTokenError) {
            return res.status(403).json({ message: 'Acesso proibido. Token de aluno inválido.', code: 'INVALID_TOKEN' });
        }
        return res.status(500).json({ message: 'Erro interno ao processar o token de aluno.', code: 'TOKEN_PROCESSING_ERROR' });
    }
};

===== ./server/dist/middlewares/authenticateToken.js =====
import jwt from 'jsonwebtoken';
export const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader?.startsWith('Bearer ') ? authHeader.split(' ')[1] : null;
    if (!token) {
        console.log("[Auth Middleware] Falha: Token não fornecido no cabeçalho. IP:", req.ip, "User-Agent:", req.get('User-Agent'));
        // Adicionado código de erro específico para token não fornecido
        return res.status(401).json({ message: 'Acesso não autorizado. Token não fornecido.', code: 'TOKEN_NOT_PROVIDED' });
    }
    const JWT_SECRET = process.env.JWT_SECRET;
    if (!JWT_SECRET) {
        console.error("[Auth Middleware] ERRO CRÍTICO: JWT_SECRET não está definido no .env");
        return res.status(500).json({
            message: 'Erro interno de configuração do servidor.',
            code: 'SERVER_CONFIGURATION_ERROR'
        });
    }
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        // Converte a role para minúsculo antes de comparar
        const userRole = decoded.role?.toLowerCase();
        if (userRole === 'personal' || userRole === 'admin') {
            req.user = {
                id: decoded.id,
                // Retorna a role original do token para consistência
                role: decoded.role,
                firstName: decoded.firstName,
                lastName: decoded.lastName,
                email: decoded.email
            };
            console.log(`[Auth Middleware] Sucesso: Usuário autenticado - ID: ${decoded.id}, Role: ${decoded.role}`);
            return next();
        }
        // Se o token for válido, mas a role for de Aluno ou outra inesperada, nega o acesso.
        console.warn(`[Auth Middleware] Falha: Token válido, mas com role não autorizada ('${decoded.role}') para esta rota. IP:`, req.ip);
        // Adicionado código de erro específico para role não autorizada
        return res.status(403).json({ message: 'Acesso proibido. Você não tem permissão para acessar este recurso.', code: 'UNAUTHORIZED_ROLE' });
    }
    catch (err) {
        console.warn(`[Auth Middleware] Falha na verificação do token - ${err.name}: ${err.message}. IP:`, req.ip);
        if (err instanceof jwt.TokenExpiredError) {
            // Código de erro para token expirado já existia
            return res.status(401).json({ message: 'Sessão expirada. Faça login novamente.', code: 'TOKEN_EXPIRED' });
        }
        if (err instanceof jwt.JsonWebTokenError) {
            // Adicionado código de erro específico para token inválido (genérico)
            return res.status(403).json({ message: 'Acesso proibido. Token inválido.', code: 'INVALID_TOKEN' });
        }
        // Código de erro genérico para outros erros de processamento do token
        return res.status(500).json({ message: 'Erro interno ao processar o token.', code: 'TOKEN_PROCESSING_ERROR' });
    }
};

===== ./server/dist/middlewares/authorizeAdmin.js =====
// Não precisamos mais da interface 'AuthenticatedRequest' importada,
// pois nosso 'index.d.ts' já estende a interface global do Express.
export function authorizeAdmin(req, res, next) {
    // Padroniza a verificação para 'admin' (minúsculo).
    if (req.user && req.user.role === 'admin') {
        return next(); // Usuário é admin, permite o acesso.
    }
    else {
        // Se não for admin, retorna erro 403.
        return res.status(403).json({ mensagem: "Acesso negado. Esta funcionalidade é restrita a administradores." });
    }
}

===== ./server/dist/middlewares/errorHandler.js =====
// Função para categorizar erros comuns
const categorizeError = (err) => {
    // Erros do MongoDB/Mongoose
    if (err.name === 'ValidationError') {
        return {
            status: 400,
            message: 'Dados fornecidos são inválidos.',
            code: 'VALIDATION_ERROR'
        };
    }
    if (err.name === 'CastError') {
        return {
            status: 400,
            message: 'ID fornecido é inválido.',
            code: 'INVALID_ID'
        };
    }
    if (err.name === 'MongoServerError' && err.code === 11000) {
        return {
            status: 409,
            message: 'Dados duplicados. Este registro já existe.',
            code: 'DUPLICATE_ERROR'
        };
    }
    // Erros de conexão com banco
    if (err.name === 'MongoNetworkError' || err.message?.includes('connection')) {
        return {
            status: 503,
            message: 'Serviço temporariamente indisponível. Tente novamente em alguns instantes.',
            code: 'SERVICE_UNAVAILABLE'
        };
    }
    // Erros de autenticação JWT
    if (err.name === 'JsonWebTokenError') {
        return {
            status: 401,
            message: 'Token de acesso inválido.',
            code: 'INVALID_TOKEN'
        };
    }
    if (err.name === 'TokenExpiredError') {
        return {
            status: 401,
            message: 'Sessão expirada. Faça login novamente.',
            code: 'TOKEN_EXPIRED'
        };
    }
    // Erros operacionais conhecidos
    if (err.isOperational) {
        return {
            status: err.statusCode || 500,
            message: err.message,
            code: err.code || 'OPERATIONAL_ERROR'
        };
    }
    // Erro genérico
    return {
        status: err.statusCode || 500,
        message: err.message || 'Erro interno no servidor.',
        code: err.code || 'INTERNAL_SERVER_ERROR'
    };
};
export function errorHandler(err, req, res, next) {
    console.error("❌ Erro capturado pelo middleware:", {
        name: err.name,
        message: err.message,
        stack: err.stack,
        url: req.url,
        method: req.method,
        ip: req.ip,
        userAgent: req.get('User-Agent')
    });
    const { status, message, code } = categorizeError(err);
    const response = {
        sucesso: false,
        message: message,
        code: code,
        ...(process.env.NODE_ENV === "development" && {
            detalhes: err.stack,
            originalError: err.name
        }),
    };
    res.status(status).json(response);
}

===== ./server/dist/models/Aluno.js =====
// server/models/Aluno.ts
import mongoose, { Schema } from "mongoose";
import bcrypt from 'bcryptjs';
const alunoSchema = new Schema({
    nome: {
        type: String,
        required: [true, 'O nome completo é obrigatório'],
        trim: true
    },
    email: {
        type: String,
        required: [true, 'O email é obrigatório'],
        unique: true,
        lowercase: true,
        trim: true,
    },
    passwordHash: {
        type: String,
        required: [true, 'A senha é obrigatória'],
        select: false,
    },
    phone: { type: String, trim: true },
    // <<< CORREÇÃO: Removida a obrigatoriedade (required: true) dos campos abaixo >>>
    birthDate: { type: String },
    gender: { type: String },
    goal: { type: String },
    weight: { type: Number },
    height: { type: Number },
    startDate: { type: String },
    status: {
        type: String,
        required: true,
        enum: ['active', 'inactive'],
        default: 'active'
    },
    notes: { type: String },
    trainerId: {
        type: Schema.Types.ObjectId,
        ref: 'PersonalTrainer',
        required: [true, 'O ID do treinador é obrigatório']
    },
    // Novos campos para armazenar a vaga (slot) do aluno
    slotType: { type: String, enum: ['plan', 'token'], required: false },
    slotId: { type: Schema.Types.ObjectId, required: false },
    slotStartDate: { type: Date, required: false },
    slotEndDate: { type: Date, required: false },
}, {
    timestamps: true
});
// Hash de senha antes de salvar
alunoSchema.pre('save', async function (next) {
    if (!this.isModified('passwordHash')) {
        return next();
    }
    try {
        const saltRounds = 10;
        if (this.passwordHash) {
            this.passwordHash = await bcrypt.hash(this.passwordHash, saltRounds);
        }
        next();
    }
    catch (error) {
        next(error);
    }
});
// Método para comparar senha
alunoSchema.methods.comparePassword = async function (candidatePassword) {
    if (!this.passwordHash) {
        return false;
    }
    return bcrypt.compare(candidatePassword, this.passwordHash);
};
export default mongoose.model("Aluno", alunoSchema);

===== ./server/dist/models/Contato.js =====
// server/models/Contato.ts
import mongoose, { Schema } from 'mongoose';
const ContatoSchema = new Schema({
    nomeCompleto: {
        type: String,
        required: [true, 'O nome completo é obrigatório.'],
        trim: true,
        minlength: [3, 'O nome completo deve ter pelo menos 3 caracteres.'],
    },
    email: {
        type: String,
        required: [true, 'O e-mail é obrigatório.'],
        trim: true,
        lowercase: true,
        // Validação de formato de e-mail simples (pode ser aprimorada)
        match: [/.+\@.+\..+/, 'Por favor, insira um e-mail válido.'],
        // Considerar adicionar um índice único composto com personalId se um email só puder se registrar uma vez por personal
        // index: { unique: true, partialFilterExpression: { status: 'novo' } } // Exemplo, ajuste conforme necessário
    },
    telefone: {
        type: String,
        trim: true,
        // Validação opcional de formato de telefone
    },
    dataNascimento: {
        type: Date,
    },
    genero: {
        type: String,
        enum: ['masculino', 'feminino', 'outro', 'prefiro_nao_dizer'], // Exemplo de opções
    },
    personalId: {
        type: Schema.Types.ObjectId,
        ref: 'PersonalTrainer', // Certifique-se que 'PersonalTrainer' é o nome do seu modelo de personal
        required: true,
        index: true,
    },
    status: {
        type: String,
        enum: ['novo', 'convertido_aluno', 'arquivado', 'contatado'],
        default: 'novo',
        index: true,
    },
    anotacoesPersonal: {
        type: String,
        trim: true,
    },
    dataCadastro: {
        type: Date,
        default: Date.now,
    },
    origemToken: {
        type: String,
    }
    // Você pode adicionar timestamps automáticos do Mongoose se preferir
    // }, { timestamps: true });
});
// Middleware para evitar que um mesmo email (em status 'novo') seja cadastrado para o mesmo personal.
// Esta é uma abordagem. Outra seria um índice único composto como comentado acima.
ContatoSchema.pre('save', async function (next) {
    if (this.isNew && this.status === 'novo') {
        const existingContact = await mongoose.model('Contato').findOne({
            email: this.email,
            personalId: this.personalId,
            status: 'novo' // Verifica apenas contatos que ainda não foram convertidos ou arquivados
        });
        if (existingContact) {
            const err = new Error(`Este e-mail já foi registrado como um novo contato para este personal.`);
            err.status = 409; // Conflict
            return next(err);
        }
    }
    next();
});
export default mongoose.model('Contato', ContatoSchema);

===== ./server/dist/models/ConviteAluno.js =====
// server/models/ConviteAluno.ts
import mongoose, { Schema } from 'mongoose';
import crypto from 'crypto';
const ConviteAlunoSchema = new Schema({
    token: {
        type: String,
        unique: true,
        required: true,
        default: () => crypto.randomBytes(20).toString('hex'),
    },
    emailConvidado: {
        type: String,
        required: false, // Alterado para opcional
        lowercase: true,
        trim: true,
    },
    status: {
        type: String,
        required: true,
        enum: ['pendente', 'utilizado', 'expirado'],
        default: 'pendente',
    },
    dataExpiracao: {
        type: Date,
        required: true,
        // Expira em 7 dias por padrão
        default: () => new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    },
    criadoPor: {
        type: Schema.Types.ObjectId,
        ref: 'PersonalTrainer',
        required: true,
    },
    usadoPor: {
        type: Schema.Types.ObjectId,
        ref: 'Aluno',
    },
}, {
    timestamps: true,
});
const ConviteAluno = mongoose.model('ConviteAluno', ConviteAlunoSchema);
export default ConviteAluno;

===== ./server/dist/models/ConvitePersonal.js =====
// server/models/ConvitePersonal.ts
import mongoose, { Schema } from 'mongoose';
import crypto from 'crypto';
const ConvitePersonalSchema = new Schema({
    token: {
        type: String,
        unique: true,
        required: true,
    },
    emailConvidado: {
        type: String,
        lowercase: true,
        trim: true,
        // Não é obrigatório, convite pode ser genérico
    },
    roleConvidado: {
        type: String,
        required: true,
        enum: ['Personal Trainer', 'Admin'],
        default: 'Personal Trainer',
    },
    status: {
        type: String,
        required: true,
        enum: ['pendente', 'utilizado', 'expirado'],
        default: 'pendente',
    },
    dataExpiracao: {
        type: Date,
        // Pode ser definido para expirar, por exemplo, em 7 dias
    },
    criadoPor: {
        type: Schema.Types.ObjectId,
        ref: 'PersonalTrainer', // Referencia o modelo de quem pode criar convites (Admin)
        required: true,
    },
    usadoPor: {
        type: Schema.Types.ObjectId,
        ref: 'PersonalTrainer', // Referencia o modelo do usuário que se registrou com este convite
    },
    dataUtilizacao: {
        type: Date,
    },
}, {
    timestamps: true,
});
// Hook pre-save para gerar o token automaticamente se não fornecido
// (embora geralmente o token seja gerado na lógica da rota e passado para o modelo)
ConvitePersonalSchema.pre('validate', function (next) {
    if (!this.token) {
        this.token = crypto.randomBytes(20).toString('hex');
    }
    // Se não houver data de expiração, define para 7 dias a partir de agora, por exemplo
    if (!this.dataExpiracao) {
        const umaSemanaEmMs = 7 * 24 * 60 * 60 * 1000;
        this.dataExpiracao = new Date(Date.now() + umaSemanaEmMs);
    }
    next();
});
const ConvitePersonal = mongoose.model('ConvitePersonal', ConvitePersonalSchema);
export default ConvitePersonal;

===== ./server/dist/models/Exercicio.js =====
// Caminho: ./server/models/Exercicio.ts
import mongoose, { Schema } from "mongoose";
const ExercicioSchema = new Schema({
    nome: { type: String, required: true, trim: true },
    descricao: { type: String, trim: true },
    categoria: { type: String, trim: true },
    grupoMuscular: { type: String, trim: true, index: true }, // Principal grupo muscular trabalhado - MANTÉM ESTE
    tipo: { type: String, trim: true },
    urlVideo: { type: String, trim: true },
    isCustom: { type: Boolean, required: true, default: false },
    creatorId: {
        type: Schema.Types.ObjectId,
        ref: "PersonalTrainer",
        required: function () { return this.isCustom; }
    },
    favoritedBy: [{
            type: Schema.Types.ObjectId,
            ref: "PersonalTrainer"
        }],
}, {
    timestamps: true
});
// Índice para busca por nome (case-insensitive)
ExercicioSchema.index({ nome: 'text' });
// ExercicioSchema.index({ grupoMuscular: 1 }); // <<< REMOVER ESTA LINHA
ExercicioSchema.index({ categoria: 1 });
ExercicioSchema.index({ isCustom: 1, creatorId: 1 });
export default mongoose.model("Exercicio", ExercicioSchema);

===== ./server/dist/models/Pasta.js =====
// server/models/Pasta.ts
import mongoose, { Schema } from 'mongoose';
console.log("--- [server/models/Pasta.ts] Definindo Modelo Pasta (Referência Corrigida) ---");
const pastaSchema = new Schema({
    nome: {
        type: String,
        required: [true, 'O nome da pasta é obrigatório.'],
        trim: true,
        minlength: [1, 'O nome da pasta não pode estar vazio.'],
        maxlength: [100, 'O nome da pasta não pode exceder 100 caracteres.'],
    },
    criadorId: {
        type: Schema.Types.ObjectId,
        ref: 'PersonalTrainer', // <<< CORREÇÃO APLICADA AQUI
        required: true,
    },
    ordem: {
        type: Number,
        default: 0,
    },
}, {
    timestamps: true,
});
// Index para otimizar buscas por criadorId e nome
pastaSchema.index({ criadorId: 1, nome: 1 });
pastaSchema.index({ criadorId: 1, ordem: 1 });
export default mongoose.model('PastaTreino', pastaSchema);

===== ./server/dist/models/PersonalTrainer.js =====
// server/models/PersonalTrainer.ts
import mongoose, { Schema } from 'mongoose';
import bcrypt from 'bcryptjs';
import crypto from 'crypto'; // Importar crypto para gerar o token
const personalTrainerSchema = new Schema({
    nome: {
        type: String,
        required: [true, 'O nome é obrigatório.'],
        trim: true,
    },
    email: {
        type: String,
        required: [true, 'O email é obrigatório.'],
        unique: true,
        lowercase: true,
        trim: true,
        match: [/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/, 'Por favor, forneça um email válido.'],
    },
    passwordHash: {
        type: String,
        required: [true, 'A senha é obrigatória.'],
        select: false, // Não retorna o hash da senha por padrão nas queries
    },
    role: {
        type: String,
        required: true,
        enum: ['Personal Trainer', 'Admin'],
        default: 'Personal Trainer'
    },
    tokenCadastroAluno: {
        type: String,
        unique: true,
        sparse: true, // Permite múltiplos documentos com valor null/undefined, mas único se presente
        // Um índice sparse só contém entradas para documentos que têm o campo indexado.
        // O índice omite todos os documentos que não têm o campo indexado.
    },
    // Campos de Assinatura
    planoId: { type: String },
    statusAssinatura: {
        type: String,
        enum: ['ativa', 'inativa', 'pendente_pagamento', 'cancelada', 'trial', 'sem_assinatura'],
        default: 'sem_assinatura', // Personal começa sem assinatura por padrão
    },
    dataInicioAssinatura: { type: Date },
    dataFimAssinatura: { type: Date },
    idAssinaturaGateway: { type: String },
    limiteAlunos: { type: Number, default: 0 }, // Exemplo: 0 para sem plano, ou o limite do plano
}, {
    timestamps: true, // Adiciona createdAt e updatedAt automaticamente
});
// Middleware para fazer o hash da senha ANTES de salvar, se ela foi modificada
personalTrainerSchema.pre('save', async function (next) {
    // Só faz o hash da senha se ela foi modificada (ou é nova)
    if (!this.isModified('passwordHash')) {
        return next();
    }
    try {
        const saltRounds = 10; // Custo do salt
        this.passwordHash = await bcrypt.hash(this.passwordHash, saltRounds);
        next();
    }
    catch (error) {
        next(error); // Passa o erro para o próximo middleware/error handler
    }
});
// Middleware para gerar o tokenCadastroAluno ANTES de salvar um novo personal
personalTrainerSchema.pre('save', function (next) {
    // Gera o token apenas se for um novo documento e o token ainda não existir
    if (this.isNew && !this.tokenCadastroAluno) {
        this.tokenCadastroAluno = crypto.randomBytes(20).toString('hex');
    }
    next();
});
// Método para comparar a senha candidata com o hash armazenado
personalTrainerSchema.methods.comparePassword = async function (candidatePassword) {
    // 'this.passwordHash' refere-se ao passwordHash do documento específico
    // É importante que o campo 'passwordHash' não esteja com select: false aqui,
    // ou que você o selecione explicitamente na query antes de chamar comparePassword.
    // No entanto, como o método é chamado em uma instância do documento onde passwordHash pode
    // ter sido selecionado ou já estar presente (ex: após um findOne().select('+passwordHash')),
    // geralmente funciona. Se der problema, garanta que o hash está carregado.
    if (!this.passwordHash)
        return false; // Caso o hash não esteja presente por algum motivo
    return bcrypt.compare(candidatePassword, this.passwordHash);
};
const PersonalTrainer = mongoose.model('PersonalTrainer', personalTrainerSchema);
export default PersonalTrainer;

===== ./server/dist/models/Sessao.js =====
// server/models/Sessao.ts
import mongoose, { Schema } from 'mongoose';
export const TIPOS_COMPROMISSO = ['avaliacao', 'checkin', 'treino_acompanhado', 'outro', 'treino_rotina', 'treino'];
export const OPCOES_PSE = [
    'Muito Leve', 'Leve', 'Moderado', 'Intenso', 'Muito Intenso', 'Máximo Esforço'
];
const SessaoSchema = new Schema({
    personalId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer', required: true, index: true },
    alunoId: { type: Schema.Types.ObjectId, ref: 'Aluno', required: true, index: true },
    rotinaId: { type: Schema.Types.ObjectId, ref: 'Treino', required: false, default: null, index: true },
    diaDeTreinoId: { type: Schema.Types.ObjectId, required: false, default: null },
    diaDeTreinoIdentificador: { type: String, trim: true, default: null },
    nomeSubFichaDia: { type: String, trim: true, default: null },
    sessionDate: { type: Date, required: true },
    tipoCompromisso: {
        type: String,
        enum: { values: TIPOS_COMPROMISSO, message: 'Tipo de compromisso inválido: {VALUE}' },
        required: true,
    },
    notes: { type: String, trim: true },
    status: {
        type: String,
        enum: { values: ['pending', 'confirmed', 'completed', 'cancelled', 'skipped'], message: 'Status inválido: {VALUE}' },
        default: 'pending',
        required: true,
    },
    concluidaEm: { type: Date, required: false, default: null },
    pseAluno: {
        type: String,
        enum: { values: [...OPCOES_PSE, null], message: 'PSE inválido: {VALUE}' },
        required: false,
        default: null,
    },
    comentarioAluno: {
        type: String,
        trim: true,
        required: false,
        default: null,
    },
    duracaoSegundos: {
        type: Number,
        required: false,
        default: 0
    },
    cargasExecutadas: {
        type: Map,
        of: String,
        required: false,
        default: {}
    },
    aumentouCarga: {
        type: Boolean,
        required: false,
        default: false
    },
    detalhesAumentoCarga: {
        type: [{
                exercicioId: { type: String, required: true },
                nomeExercicio: { type: String, required: false },
                cargaAnterior: { type: String, required: true },
                cargaAtual: { type: String, required: true }
            }],
        required: false,
        default: []
    }
}, {
    timestamps: true,
    toJSON: { virtuals: true, getters: true },
    toObject: { virtuals: true, getters: true },
});
SessaoSchema.index({ personalId: 1, sessionDate: 1 });
SessaoSchema.index({ alunoId: 1, status: 1, sessionDate: 1 });
SessaoSchema.index({ rotinaId: 1, diaDeTreinoId: 1 });
export default mongoose.model('Sessao', SessaoSchema);

===== ./server/dist/models/Treino.js =====
// server/models/Treino.ts
import mongoose, { Schema } from "mongoose";
export const TIPOS_ORGANIZACAO_ROTINA = ['diasDaSemana', 'numerico', 'livre'];
// --- Schemas ---
const ExercicioEmDiaDeTreinoSchema = new Schema({
    exercicioId: { type: Schema.Types.ObjectId, ref: 'Exercicio', required: true },
    series: { type: String, trim: true },
    repeticoes: { type: String, trim: true },
    carga: { type: String, trim: true },
    descanso: { type: String, trim: true },
    observacoes: { type: String, trim: true },
    ordemNoDia: { type: Number, required: true },
    concluido: { type: Boolean, default: false },
    grupoCombinado: { type: String, trim: true },
}, { _id: true });
const DiaDeTreinoSchema = new Schema({
    identificadorDia: { type: String, required: true, trim: true },
    nomeSubFicha: { type: String, trim: true, default: null },
    ordemNaRotina: { type: Number, required: true },
    exerciciosDoDia: [ExercicioEmDiaDeTreinoSchema],
}, { _id: true });
const TreinoSchema = new Schema({
    titulo: { type: String, required: true, trim: true },
    descricao: { type: String, trim: true },
    tipo: { type: String, required: true, enum: ['modelo', 'individual'] },
    criadorId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer', required: true },
    alunoId: { type: Schema.Types.ObjectId, ref: 'Aluno', default: null, sparse: true, index: true },
    tipoOrganizacaoRotina: { type: String, required: true, enum: TIPOS_ORGANIZACAO_ROTINA },
    diasDeTreino: [DiaDeTreinoSchema],
    pastaId: { type: Schema.Types.ObjectId, ref: 'PastaTreino', default: null, sparse: true },
    statusModelo: { type: String, enum: ['ativo', 'rascunho', 'arquivado'], default: 'ativo' },
    ordemNaPasta: { type: Number },
    dataValidade: { type: Date, default: null },
    totalSessoesRotinaPlanejadas: { type: Number, default: 0 },
    sessoesRotinaConcluidas: { type: Number, default: 0 },
    criadoEm: { type: Date, default: Date.now },
    atualizadoEm: { type: Date, default: Date.now },
    isCopied: { type: Boolean, default: false }, // <<< NOVO CAMPO NO SCHEMA >>>
});
TreinoSchema.pre('save', function (next) {
    this.atualizadoEm = new Date();
    next();
});
TreinoSchema.pre('findOneAndUpdate', function (next) {
    this.set({ atualizadoEm: new Date() });
    next();
});
// ... Virtuais e Índices permanecem os mesmos ...
TreinoSchema.virtual('isConcluida').get(function () {
    if (this.tipo !== 'individual')
        return false;
    const totalPlanejado = this.totalSessoesRotinaPlanejadas ?? 0;
    const sessoesConcluidas = this.sessoesRotinaConcluidas ?? 0;
    if (totalPlanejado === 0 && sessoesConcluidas > 0)
        return true;
    if (totalPlanejado > 0 && sessoesConcluidas >= totalPlanejado)
        return true;
    return false;
});
TreinoSchema.virtual('progressoRotina').get(function () {
    if (this.tipo !== 'individual')
        return null;
    const totalPlanejado = this.totalSessoesRotinaPlanejadas ?? 0;
    const sessoesConcluidas = this.sessoesRotinaConcluidas ?? 0;
    if (totalPlanejado > 0)
        return `${sessoesConcluidas}/${totalPlanejado}`;
    if (totalPlanejado === 0)
        return `0/0`;
    return null;
});
TreinoSchema.index({ criadorId: 1, tipo: 1 });
TreinoSchema.index({ criadorId: 1, tipo: 1, pastaId: 1 }, { sparse: true });
TreinoSchema.index({ criadorId: 1, tipo: 1, statusModelo: 1 }, { partialFilterExpression: { tipo: 'modelo' } });
export default mongoose.model("Treino", TreinoSchema);

===== ./server/dist/models/WorkoutLog.js =====
// server/models/WorkoutLog.ts
import mongoose, { Schema } from 'mongoose';
const WorkoutLogSchema = new Schema({
    treinoId: { type: Schema.Types.ObjectId, ref: 'Treino', required: true },
    treinoTitulo: { type: String, required: true },
    alunoId: { type: Schema.Types.ObjectId, ref: 'Aluno', required: true },
    personalId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer', required: true },
    dataInicio: { type: Date, required: true },
    dataFim: { type: Date, required: true },
    duracaoTotalMinutos: { type: Number, required: true },
    nivelTreino: {
        type: String,
        enum: ['muito_facil', 'facil', 'moderado', 'dificil', 'muito_dificil'],
        required: true
    },
    comentarioAluno: { type: String },
    aumentoCarga: { type: Boolean },
    cargaAnterior: { type: Number },
    cargaAtual: { type: Number },
    criadoEm: { type: Date, default: Date.now },
    atualizadoEm: { type: Date, default: Date.now }
});
export default mongoose.models.WorkoutLog || mongoose.model('WorkoutLog', WorkoutLogSchema);

===== ./server/dist/scripts/createPersonal.js =====
import dotenv from 'dotenv';
import PersonalTrainer from '../models/PersonalTrainer.js'; // Ajuste o caminho se necessário
import { connectToDatabase, disconnectFromDatabase } from '../database.js'; // Ajuste o caminho se necessário
dotenv.config({ path: '../../.env' }); // Carrega variáveis de ambiente do .env na raiz do projeto
async function createPersonal() {
    // Pega os argumentos da linha de comando: nome, email, senha
    // Exemplo de como rodar: ts-node server/scripts/createPersonal.ts "Nome do Personal" "email@example.com" "senha123"
    const args = process.argv.slice(2); // Os dois primeiros args são 'node' e o nome do script
    if (args.length < 3) {
        console.error('Uso: ts-node server/scripts/createPersonal.ts "<Nome Completo>" "<email>" "<senha>" [role]');
        console.error('Exemplo: ts-node server/scripts/createPersonal.ts "João Silva" "joao@example.com" "senhaSegura"');
        process.exit(1);
    }
    const [nome, email, passwordInput] = args;
    const roleInput = args[3] || 'Personal Trainer'; // Pega o quarto argumento como role, ou usa o default
    if (!['Personal Trainer', 'Admin'].includes(roleInput)) {
        console.error(`Role inválido: "${roleInput}". Use "Personal Trainer" ou "Admin".`);
        process.exit(1);
    }
    try {
        await connectToDatabase();
        console.log('Conectado ao banco de dados...');
        const existingPersonal = await PersonalTrainer.findOne({ email: email.toLowerCase() });
        if (existingPersonal) {
            console.warn(`Já existe um personal trainer com o email: ${email}`);
            await disconnectFromDatabase();
            process.exit(1);
        }
        console.log(`Criando personal: ${nome}, Email: ${email}, Role: ${roleInput}`);
        // Criamos a instância com a senha em texto plano.
        // O middleware pre('save') no modelo PersonalTrainer cuidará do hashing.
        const newPersonal = new PersonalTrainer({
            nome,
            email: email.toLowerCase(),
            passwordHash: passwordInput, // O middleware pre-save irá hashear este campo
            role: roleInput,
            // tokenCadastroAluno será gerado automaticamente pelo middleware pre-save
            // statusAssinatura e limiteAlunos usarão os defaults do schema
        });
        await newPersonal.save();
        // O token é gerado no pre-save, então podemos logá-lo aqui se quisermos
        console.log('Personal Trainer criado com sucesso!');
        console.log('Detalhes:');
        console.log(`  ID: ${newPersonal._id}`);
        console.log(`  Nome: ${newPersonal.nome}`);
        console.log(`  Email: ${newPersonal.email}`);
        console.log(`  Role: ${newPersonal.role}`);
        console.log(`  Token de Cadastro de Aluno: ${newPersonal.tokenCadastroAluno}`);
        console.log(`  Status da Assinatura: ${newPersonal.statusAssinatura}`);
    }
    catch (error) {
        console.error('Erro ao criar Personal Trainer:', error);
    }
    finally {
        await disconnectFromDatabase();
        console.log('Desconectado do banco de dados.');
        process.exit(0);
    }
}
createPersonal();

===== ./server/dist/src/routes/activityLogsRoutes.js =====
// server/src/routes/activityLogsRoutes.ts
import express from 'express';
import mongoose from 'mongoose';
import dbConnect from '../../lib/dbConnect.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import Sessao from '../../models/Sessao.js'; // <-- 1. MUDANÇA: Importa Sessao ao invés de WorkoutLog
const router = express.Router();
console.log("--- [server/src/routes/activityLogsRoutes.ts] Ficheiro carregado ---");
// ROTA AJUSTADA PARA BUSCAR DA COLEÇÃO CORRETA ('sessoes')
router.get('/aluno/:alunoId', authenticateToken, async (req, res, next) => {
    await dbConnect();
    const { alunoId } = req.params;
    const personalId = req.user?.id;
    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ mensagem: "ID do aluno inválido." });
    }
    if (!personalId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    try {
        // --- 2. MUDANÇA: A consulta agora usa o modelo 'Sessao' ---
        // Adicionamos status: 'completed' para pegar apenas os treinos finalizados.
        const historico = await Sessao.find({
            alunoId: new mongoose.Types.ObjectId(alunoId),
            personalId: new mongoose.Types.ObjectId(personalId),
            status: 'completed'
        })
            .sort({ concluidaEm: -1 }) // Ordena pelos mais recentes
            .populate('rotinaId', 'titulo') // Popula o título da rotina para exibição
            .lean(); // Usa .lean() para um desempenho melhor
        // Mapeia os dados para a estrutura que o frontend espera (IWorkoutHistoryLog)
        const historicoMapeado = historico.map(sessao => ({
            _id: sessao._id,
            treinoId: sessao.rotinaId?._id || null,
            treinoTitulo: sessao.rotinaId?.titulo || sessao.diaDeTreinoIdentificador || 'Treino Concluído',
            dataInicio: sessao.sessionDate,
            dataFim: sessao.concluidaEm,
            duracaoTotalMinutos: sessao.duracaoSegundos ? Math.round(sessao.duracaoSegundos / 60) : 0,
            nivelTreino: sessao.pseAluno,
            comentarioAluno: sessao.comentarioAluno,
            aumentoCarga: sessao.aumentouCarga || false,
        }));
        res.json(historicoMapeado);
    }
    catch (error) {
        console.error(`[GET /api/activity-logs/aluno/${alunoId}] Erro:`, error);
        next(error);
    }
});
// Rota placeholder mantida como original
router.get('/', authenticateToken, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const limitParam = req.query.limit;
    const limit = typeof limitParam === 'string' && parseInt(limitParam) > 0 ? parseInt(limitParam) : 5;
    if (!trainerId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    console.log(`[GET /api/activity-logs] (Placeholder) Buscando logs para trainerId: ${trainerId} com limite: ${limit}`);
    try {
        const mockActivities = [];
        res.json(mockActivities);
    }
    catch (error) {
        console.error("[GET /api/activity-logs] (Placeholder) Erro:", error);
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/adminRoutes.js =====
// server/src/routes/adminRoutes.ts
import express from 'express';
import mongoose from 'mongoose';
import crypto from 'crypto';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import ConvitePersonal from '../../models/ConvitePersonal.js';
import Exercicio from '../../models/Exercicio.js';
import dbConnect from '../../lib/dbConnect.js';
// <<< INÍCIO DA ALTERAÇÃO: Importar o modelo Aluno >>>
import Aluno from '../../models/Aluno.js';
// <<< FIM DA ALTERAÇÃO >>>
const router = express.Router();
// --- ROTAS DE GESTÃO DE PERSONAL TRAINERS ---
// POST /api/admin/personal-trainers
router.post('/personal-trainers', async (req, res, next) => {
    await dbConnect();
    try {
        const { nome, email, password, role } = req.body;
        if (!nome || !email || !password) {
            return res.status(400).json({ mensagem: "Nome, email e senha são obrigatórios." });
        }
        const roleFinal = (role && role.toLowerCase() === 'admin') ? 'Admin' : 'Personal Trainer';
        const existingPersonal = await PersonalTrainer.findOne({ email: email.toLowerCase() });
        if (existingPersonal) {
            return res.status(409).json({ mensagem: `Já existe um usuário com o email: ${email}` });
        }
        const newPersonal = new PersonalTrainer({ nome, email: email.toLowerCase(), passwordHash: password, role: roleFinal });
        await newPersonal.save();
        const personalToReturn = { _id: newPersonal._id, nome: newPersonal.nome, email: newPersonal.email, role: newPersonal.role, createdAt: newPersonal.createdAt, updatedAt: newPersonal.updatedAt };
        res.status(201).json(personalToReturn);
    }
    catch (error) {
        console.error('[ADMIN ROUTES] Erro em POST /personal-trainers:', error);
        next(error);
    }
});
// GET /api/admin/dashboard/stats
router.get('/dashboard/stats', async (req, res, next) => {
    await dbConnect();
    try {
        const totalPersonaisPromise = PersonalTrainer.countDocuments();
        const personaisAtivosPromise = PersonalTrainer.countDocuments({ statusAssinatura: 'ativa' });
        const convitesPendentesPromise = ConvitePersonal.countDocuments({ status: 'pendente' });
        const totalExerciciosPromise = Exercicio.countDocuments();
        const [totalPersonais, personaisAtivos, convitesPendentes, totalExercicios] = await Promise.all([
            totalPersonaisPromise,
            personaisAtivosPromise,
            convitesPendentesPromise,
            totalExerciciosPromise
        ]);
        const finalPersonaisAtivos = personaisAtivos > 0 ? personaisAtivos : totalPersonais;
        res.status(200).json({
            totalPersonais,
            personaisAtivos: finalPersonaisAtivos,
            convitesPendentes,
            totalExercicios
        });
    }
    catch (error) {
        console.error('[ADMIN ROUTES] Erro em GET /dashboard/stats:', error);
        next(error);
    }
});
// <<< INÍCIO DA ALTERAÇÃO: Rota agora busca e retorna a lista de alunos do personal >>>
// GET /api/admin/personal-trainers/:id
router.get('/personal-trainers/:id', async (req, res, next) => {
    await dbConnect();
    try {
        const { id } = req.params;
        if (!mongoose.isValidObjectId(id)) {
            return res.status(400).json({ mensagem: "ID do personal inválido." });
        }
        // Busca o personal e seus alunos em paralelo para melhor performance
        const [personal, alunosDoPersonal] = await Promise.all([
            PersonalTrainer.findById(id).select('-passwordHash').lean(),
            Aluno.find({ trainerId: id })
                .select('nome email status slotType slotId slotStartDate slotEndDate')
                .sort({ nome: 1 })
                .lean()
        ]);
        if (!personal) {
            return res.status(404).json({ mensagem: "Personal trainer não encontrado." });
        }
        // Combina os dados em uma única resposta
        const responsePayload = {
            ...personal,
            alunos: alunosDoPersonal // Adiciona a lista de alunos à resposta
        };
        res.status(200).json(responsePayload);
    }
    catch (error) {
        console.error(`[ADMIN ROUTES] Erro em GET /personal-trainers/${req.params.id}:`, error);
        next(error);
    }
});
// <<< FIM DA ALTERAÇÃO >>>
// PUT /api/admin/personal-trainers/:id
router.put('/personal-trainers/:id', async (req, res, next) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const { nome, email, role } = req.body;
        if (!mongoose.isValidObjectId(id)) {
            return res.status(400).json({ mensagem: 'ID do personal inválido.' });
        }
        if (!nome || !email || !role) {
            return res.status(400).json({ mensagem: 'Nome, email e função são obrigatórios.' });
        }
        const personal = await PersonalTrainer.findById(id);
        if (!personal) {
            return res.status(404).json({ mensagem: 'Personal trainer não encontrado.' });
        }
        personal.nome = nome;
        personal.email = email.toLowerCase();
        personal.role = (role.toLowerCase() === 'admin') ? 'Admin' : 'Personal Trainer';
        const updatedPersonal = await personal.save();
        const personalToReturn = { _id: updatedPersonal._id, nome: updatedPersonal.nome, email: updatedPersonal.email, role: updatedPersonal.role, createdAt: updatedPersonal.createdAt, updatedAt: updatedPersonal.updatedAt };
        res.status(200).json(personalToReturn);
    }
    catch (error) {
        console.error(`[ADMIN ROUTES] Erro em PUT /personal-trainers/${req.params.id}:`, error);
        next(error);
    }
});
// DELETE /api/admin/personal-trainers/:id
router.delete('/personal-trainers/:id', async (req, res, next) => {
    await dbConnect();
    try {
        const { id: personalIdToDelete } = req.params;
        if (!mongoose.isValidObjectId(personalIdToDelete)) {
            return res.status(400).json({ mensagem: "ID do personal inválido." });
        }
        const personal = await PersonalTrainer.findByIdAndDelete(personalIdToDelete);
        if (!personal) {
            return res.status(404).json({ mensagem: "Personal trainer não encontrado." });
        }
        res.status(200).json({ mensagem: `Personal trainer ${personal.nome} excluído com sucesso.` });
    }
    catch (error) {
        console.error(`[ADMIN ROUTES] Erro em DELETE /personal-trainers/${req.params.id}:`, error);
        next(error);
    }
});
// --- ROTAS DE GESTÃO DE CONVITES ---
const conviteRouter = express.Router();
conviteRouter.post('/personal', async (req, res, next) => {
    await dbConnect();
    try {
        const { emailConvidado, roleConvidado, diasParaExpirar } = req.body;
        const adminId = req.user?.id;
        if (!adminId) {
            return res.status(401).json({ mensagem: "Administrador não autenticado." });
        }
        if (emailConvidado) {
            const convitePendente = await ConvitePersonal.findOne({
                emailConvidado: emailConvidado.toLowerCase().trim(),
                status: 'pendente',
                criadoPor: new mongoose.Types.ObjectId(adminId),
            });
            if (convitePendente) {
                const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
                const linkConvite = `${frontendUrl}/cadastrar-personal/convite/${convitePendente.token}`;
                return res.status(200).json({ mensagem: "Já existe um convite pendente para este email.", linkConvite });
            }
        }
        const token = crypto.randomBytes(20).toString('hex');
        const dataExpiracao = new Date();
        dataExpiracao.setDate(dataExpiracao.getDate() + (diasParaExpirar || 7));
        const novoConvite = new ConvitePersonal({
            token,
            emailConvidado: emailConvidado ? emailConvidado.toLowerCase().trim() : undefined,
            roleConvidado: roleConvidado || 'Personal Trainer',
            status: 'pendente',
            dataExpiracao,
            criadoPor: new mongoose.Types.ObjectId(adminId),
        });
        await novoConvite.save();
        const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
        const linkConvite = `${frontendUrl}/cadastrar-personal/convite/${token}`;
        res.status(201).json({ mensagem: "Convite criado com sucesso!", convite: novoConvite, linkConvite });
    }
    catch (error) {
        next(error);
    }
});
conviteRouter.get('/personal', async (req, res, next) => {
    await dbConnect();
    try {
        const adminId = req.user?.id;
        if (!adminId) {
            return res.status(401).json({ mensagem: "Administrador não autenticado." });
        }
        const convites = await ConvitePersonal.find({ criadoPor: new mongoose.Types.ObjectId(adminId) })
            .populate('usadoPor', 'nome email')
            .sort({ createdAt: -1 });
        res.status(200).json(convites);
    }
    catch (error) {
        next(error);
    }
});
conviteRouter.delete('/personal/:conviteId', async (req, res, next) => {
    await dbConnect();
    try {
        const adminId = req.user?.id;
        const { conviteId } = req.params;
        if (!adminId) {
            return res.status(401).json({ mensagem: "Administrador não autenticado." });
        }
        if (!mongoose.isValidObjectId(conviteId)) {
            return res.status(400).json({ mensagem: "ID do convite inválido." });
        }
        const convite = await ConvitePersonal.findOneAndDelete({
            _id: new mongoose.Types.ObjectId(conviteId),
            criadoPor: new mongoose.Types.ObjectId(adminId),
            status: 'pendente',
        });
        if (!convite) {
            return res.status(404).json({ mensagem: "Convite não encontrado ou já utilizado." });
        }
        res.status(200).json({ mensagem: "Convite revogado com sucesso." });
    }
    catch (error) {
        next(error);
    }
});
router.use('/convites', conviteRouter);
export default router;

===== ./server/dist/src/routes/alunoApiRoutes.js =====
// server/src/routes/alunoApiRoutes.ts
import express from 'express';
import mongoose from 'mongoose';
import Treino from '../../models/Treino.js';
import Sessao, { OPCOES_PSE } from '../../models/Sessao.js';
import { startOfWeek, endOfWeek, differenceInCalendarDays, parseISO, startOfDay } from 'date-fns';
import Aluno from '../../models/Aluno.js';
import ConviteAluno from '../../models/ConviteAluno.js';
import TokenAvulso from '../../models/TokenAvulso.js';
import dbConnect from '../../lib/dbConnect.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import { authenticateAlunoToken } from '../../middlewares/authenticateAlunoToken.js';
import { checkLimiteAlunos } from '../../middlewares/checkLimiteAlunos.js';
import PlanoService from '../../services/PlanoService.js';
const router = express.Router();
// =======================================================
// ROTAS DO PERSONAL (PARA GERENCIAR ALUNOS)
// =======================================================
router.post("/convite", authenticateToken, checkLimiteAlunos, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    if (!trainerId) {
        return res.status(401).json({ erro: "Personal não autenticado." });
    }
    try {
        const { emailConvidado } = req.body;
        if (emailConvidado) {
            const alunoExistente = await Aluno.findOne({
                email: emailConvidado,
                trainerId: new mongoose.Types.ObjectId(trainerId)
            });
            if (alunoExistente) {
                return res.status(409).json({ message: "Este aluno já está cadastrado com você." });
            }
            const convitePendente = await ConviteAluno.findOne({
                emailConvidado,
                status: 'pendente',
                criadoPor: trainerId
            });
            if (convitePendente) {
                const linkConvite = `${process.env.FRONTEND_URL}/convite/aluno/${convitePendente.token}`;
                return res.status(200).json({ mensagem: "Já existe um convite pendente para este email.", linkConvite });
            }
        }
        const novoConvite = new ConviteAluno({
            emailConvidado: emailConvidado || undefined,
            criadoPor: new mongoose.Types.ObjectId(trainerId)
        });
        await novoConvite.save();
        const linkConvite = `${process.env.FRONTEND_URL}/convite/aluno/${novoConvite.token}`;
        res.status(201).json({ mensagem: "Link de convite gerado com sucesso!", linkConvite });
    }
    catch (error) {
        next(error);
    }
});
router.get("/gerenciar", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }
    try {
        const { status } = req.query;
        const query = { trainerId };
        if (status && typeof status === 'string' && status.toLowerCase() !== 'all') {
            query.status = status;
        }
        const alunos = await Aluno.find(query).sort({ nome: 1 }).select('-passwordHash');
        res.status(200).json(alunos);
    }
    catch (error) {
        next(error);
    }
});
router.post("/gerenciar", authenticateToken, checkLimiteAlunos, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const session = await mongoose.startSession();
    session.startTransaction();
    try {
        const { nome, email, password, ...outrosDados } = req.body;
        if (!nome || !email || !password) {
            await session.abortTransaction();
            return res.status(400).json({ message: "Nome, email e senha são obrigatórios." });
        }
        const alunoExistente = await Aluno.findOne({ email: email.toLowerCase() }).session(session);
        if (alunoExistente) {
            await session.abortTransaction();
            return res.status(409).json({ message: "Já existe um aluno com este email." });
        }
        const planStatus = await PlanoService.getPersonalCurrentPlan(trainerId);
        const limiteBasePlano = planStatus.isExpired ? 0 : (planStatus.plano?.limiteAlunos || 0);
        const alunosAtivosNoPlano = await Aluno.countDocuments({
            trainerId, status: 'active', slotType: 'plan'
        }).session(session);
        let slotType;
        let slotId;
        let slotStartDate;
        let slotEndDate;
        if (alunosAtivosNoPlano < limiteBasePlano) {
            slotType = 'plan';
            slotId = new mongoose.Types.ObjectId(planStatus.personalPlano._id);
            slotStartDate = planStatus.personalPlano.dataInicio;
            slotEndDate = planStatus.personalPlano.dataVencimento;
        }
        else {
            slotType = 'token';
            const token = await TokenAvulso.findOne({
                personalTrainerId: trainerId,
                ativo: true,
                dataVencimento: { $gt: new Date() }
            }).sort({ dataVencimento: 1 }).session(session);
            if (!token) {
                await session.abortTransaction();
                return res.status(403).json({ message: "Não há vagas de plano ou tokens avulsos disponíveis." });
            }
            slotId = new mongoose.Types.ObjectId(token._id);
            slotStartDate = new Date();
            slotEndDate = token.dataVencimento;
            if (token.quantidade > 1) {
                token.quantidade -= 1;
                await token.save({ session });
            }
            else {
                await TokenAvulso.deleteOne({ _id: token._id }).session(session);
            }
        }
        const novoAluno = new Aluno({
            nome,
            email: email.toLowerCase(),
            passwordHash: password,
            trainerId: new mongoose.Types.ObjectId(trainerId),
            ...outrosDados,
            status: 'active',
            slotType,
            slotId,
            slotStartDate,
            slotEndDate,
        });
        await novoAluno.save({ session });
        await session.commitTransaction();
        const alunoResponse = novoAluno.toObject();
        delete alunoResponse.passwordHash;
        res.status(201).json({
            message: "Aluno criado e vaga associada com sucesso!",
            aluno: alunoResponse
        });
    }
    catch (error) {
        if (session.inTransaction())
            await session.abortTransaction();
        next(error);
    }
    finally {
        session.endSession();
    }
});
router.get("/gerenciar/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const alunoId = req.params.id;
    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }
    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ erro: "ID do aluno inválido." });
    }
    try {
        const aluno = await Aluno.findOne({
            _id: new mongoose.Types.ObjectId(alunoId),
            trainerId: new mongoose.Types.ObjectId(trainerId)
        }).select('-passwordHash');
        if (!aluno) {
            return res.status(404).json({ erro: "Aluno não encontrado ou não pertence a você." });
        }
        res.status(200).json(aluno);
    }
    catch (error) {
        next(error);
    }
});
router.put("/gerenciar/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const alunoId = req.params.id;
    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }
    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ erro: "ID do aluno inválido." });
    }
    try {
        const { slotType, slotId, slotStartDate, slotEndDate, ...updateData } = req.body;
        if (!updateData.nome || !updateData.email) {
            return res.status(400).json({ erro: "Nome e email são obrigatórios." });
        }
        const alunoAtualizado = await Aluno.findOneAndUpdate({ _id: new mongoose.Types.ObjectId(alunoId), trainerId: new mongoose.Types.ObjectId(trainerId) }, { $set: updateData }, { new: true, runValidators: true }).select('-passwordHash');
        if (!alunoAtualizado) {
            return res.status(404).json({ erro: "Aluno não encontrado ou não pertence a você." });
        }
        res.status(200).json({
            mensagem: "Aluno atualizado com sucesso!",
            aluno: alunoAtualizado
        });
    }
    catch (error) {
        next(error);
    }
});
router.delete("/gerenciar/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const alunoId = req.params.id;
    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }
    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ erro: "ID do aluno inválido." });
    }
    try {
        const alunoInativado = await Aluno.findOneAndUpdate({ _id: new mongoose.Types.ObjectId(alunoId), trainerId: new mongoose.Types.ObjectId(trainerId) }, {
            $set: { status: 'inactive' },
            $unset: { slotType: "", slotId: "", slotStartDate: "", slotEndDate: "" }
        }, { new: true }).select('-passwordHash');
        if (!alunoInativado) {
            return res.status(404).json({ message: "Aluno não encontrado ou não pertence a você." });
        }
        res.status(200).json({
            message: "Aluno marcado como inativo e vaga liberada com sucesso!",
            aluno: alunoInativado
        });
    }
    catch (error) {
        next(error);
    }
});
// =======================================================
// ROTAS DO ALUNO (DASHBOARD, FICHAS, HISTÓRICO)
// =======================================================
router.get('/meus-treinos', authenticateAlunoToken, async (req, res, next) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId)
        return res.status(401).json({ erro: "Aluno não autenticado." });
    try {
        const rotinas = await Treino.find({ alunoId: new mongoose.Types.ObjectId(alunoId), tipo: 'individual' })
            .populate('criadorId', 'nome email')
            .populate({
            path: 'diasDeTreino.exerciciosDoDia.exercicioId',
            model: 'Exercicio',
            select: 'nome grupoMuscular urlVideo descricao categoria tipo'
        })
            .sort({ atualizadoEm: -1 })
            .lean();
        res.status(200).json(rotinas);
    }
    catch (error) {
        console.error("Erro ao buscar treinos do aluno:", error);
        next(error);
    }
});
router.get('/meus-treinos/:id', authenticateAlunoToken, async (req, res, next) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    const rotinaId = req.params.id;
    if (!alunoId)
        return res.status(401).json({ erro: "Aluno não autenticado." });
    if (!mongoose.Types.ObjectId.isValid(rotinaId)) {
        return res.status(400).json({ erro: 'ID da rotina inválido.' });
    }
    try {
        const rotina = await Treino.findOne({
            _id: new mongoose.Types.ObjectId(rotinaId),
            alunoId: new mongoose.Types.ObjectId(alunoId)
        })
            .populate({
            path: 'diasDeTreino.exerciciosDoDia.exercicioId',
            model: 'Exercicio',
            select: 'nome urlVideo'
        })
            .lean();
        if (!rotina) {
            return res.status(404).json({ erro: 'Rotina de treino não encontrada ou não pertence a este aluno.' });
        }
        res.status(200).json(rotina);
    }
    catch (error) {
        console.error(`Erro ao buscar detalhes da rotina ${rotinaId} para o aluno ${alunoId}:`, error);
        next(error);
    }
});
router.get('/minhas-sessoes-concluidas-na-semana', authenticateAlunoToken, async (req, res, next) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId)
        return res.status(401).json({ erro: "Aluno não autenticado." });
    try {
        const hoje = new Date();
        const inicioSemana = startOfWeek(hoje, { weekStartsOn: 0 });
        const fimSemana = endOfWeek(hoje, { weekStartsOn: 0 });
        const sessoes = await Sessao.find({
            alunoId: new mongoose.Types.ObjectId(alunoId),
            status: 'completed',
            concluidaEm: {
                $gte: inicioSemana,
                $lte: fimSemana,
            },
        }).select('_id sessionDate tipoCompromisso concluidaEm').lean();
        res.status(200).json(sessoes);
    }
    catch (error) {
        console.error("Erro ao buscar sessões da semana do aluno:", error);
        next(error);
    }
});
router.get('/stats-progresso', authenticateAlunoToken, async (req, res, next) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId)
        return res.status(401).json({ erro: "Aluno não autenticado." });
    try {
        const sessoesConcluidas = await Sessao.find({
            alunoId: new mongoose.Types.ObjectId(alunoId),
            status: 'completed'
        }).select('concluidaEm pseAluno').lean();
        const totalTreinosConcluidos = sessoesConcluidas.length;
        const pseMap = OPCOES_PSE.reduce((acc, val, i) => ({ ...acc, [val]: i + 1 }), {});
        const sessoesComPSE = sessoesConcluidas.filter(s => s.pseAluno && pseMap[s.pseAluno]);
        let mediaPSE = 'N/D';
        if (sessoesComPSE.length > 0) {
            const somaPSE = sessoesComPSE.reduce((acc, s) => acc + pseMap[s.pseAluno], 0);
            const mediaNumerica = Math.round(somaPSE / sessoesComPSE.length);
            mediaPSE = OPCOES_PSE[mediaNumerica - 1] || 'N/D';
        }
        let diasConsecutivos = 0;
        if (sessoesConcluidas.length > 0) {
            const datasDeTreinoUnicas = [...new Set(sessoesConcluidas.map(s => startOfDay(s.concluidaEm).toISOString()))]
                .map(d => parseISO(d))
                .sort((a, b) => a.getTime() - b.getTime());
            if (datasDeTreinoUnicas.length > 0) {
                let streakAtual = 0;
                const hoje = startOfDay(new Date());
                const ontem = startOfDay(new Date(hoje.setDate(hoje.getDate() - 1)));
                hoje.setDate(hoje.getDate() + 1);
                let ultimaData = startOfDay(new Date(2000, 0, 1));
                for (const data of datasDeTreinoUnicas) {
                    if (differenceInCalendarDays(data, ultimaData) === 1) {
                        streakAtual++;
                    }
                    else {
                        streakAtual = 1;
                    }
                    diasConsecutivos = Math.max(diasConsecutivos, streakAtual);
                    ultimaData = data;
                }
            }
        }
        res.status(200).json({
            totalTreinosConcluidos,
            mediaPSE,
            diasConsecutivos
        });
    }
    catch (error) {
        console.error("Erro ao calcular stats de progresso do aluno:", error);
        next(error);
    }
});
router.patch('/meus-treinos/:id/cargas', authenticateAlunoToken, async (req, res, next) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    const rotinaId = req.params.id;
    const { diaDeTreinoId, cargas } = req.body;
    if (!alunoId)
        return res.status(401).json({ erro: "Aluno não autenticado." });
    if (!mongoose.Types.ObjectId.isValid(rotinaId)) {
        return res.status(400).json({ erro: 'ID da rotina inválido.' });
    }
    if (!diaDeTreinoId || !cargas || typeof cargas !== 'object') {
        return res.status(400).json({ erro: 'diaDeTreinoId e cargas são obrigatórios.' });
    }
    try {
        const rotina = await Treino.findOne({
            _id: new mongoose.Types.ObjectId(rotinaId),
            alunoId: new mongoose.Types.ObjectId(alunoId),
            tipo: 'individual'
        });
        if (!rotina) {
            return res.status(404).json({ erro: 'Rotina não encontrada ou não pertence a este aluno.' });
        }
        const diaDeTreino = rotina.diasDeTreino.find(dia => dia._id.toString() === diaDeTreinoId);
        if (!diaDeTreino) {
            return res.status(404).json({ erro: 'Dia de treino não encontrado na rotina.' });
        }
        let exerciciosAtualizados = 0;
        for (const [exercicioId, novaCarga] of Object.entries(cargas)) {
            const exercicio = diaDeTreino.exerciciosDoDia?.find(ex => ex._id.toString() === exercicioId);
            if (exercicio) {
                if (novaCarga && typeof novaCarga === 'string' && novaCarga.trim()) {
                    exercicio.carga = novaCarga.trim();
                    exerciciosAtualizados++;
                }
            }
        }
        if (exerciciosAtualizados === 0) {
            return res.status(400).json({ erro: 'Nenhum exercício foi encontrado para atualizar.' });
        }
        await rotina.save();
        res.status(200).json({
            mensagem: `${exerciciosAtualizados} carga(s) atualizada(s) com sucesso.`,
            exerciciosAtualizados
        });
    }
    catch (error) {
        console.error(`Erro ao atualizar cargas da rotina ${rotinaId}:`, error);
        next(error);
    }
});
router.get('/meu-historico-sessoes', authenticateAlunoToken, async (req, res, next) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId)
        return res.status(401).json({ erro: "Aluno não autenticado." });
    try {
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 5;
        const skip = (page - 1) * limit;
        const query = {
            alunoId: new mongoose.Types.ObjectId(alunoId),
            status: 'completed'
        };
        const totalSessoes = await Sessao.countDocuments(query);
        const totalPages = Math.ceil(totalSessoes / limit);
        const sessoes = await Sessao.find(query)
            .sort({ concluidaEm: -1 })
            .skip(skip)
            .limit(limit)
            .populate('rotinaId', 'titulo')
            .populate('personalId', 'nome')
            .lean();
        res.status(200).json({
            sessoes,
            currentPage: page,
            totalPages,
            totalSessoes
        });
    }
    catch (error) {
        console.error("Erro ao buscar histórico de sessões do aluno:", error);
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/auth.js =====
// server/src/routes/auth.ts
import { Router } from 'express';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import Aluno from '../../models/Aluno.js';
import jwt from 'jsonwebtoken';
import ms from 'ms';
import dbConnect from '../../lib/dbConnect.js';
const router = Router();
const getJwtSecret = () => {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
        console.error("FATAL_ERROR: A variável de ambiente JWT_SECRET não foi encontrada.");
        throw new Error("Configuração de segurança do servidor incompleta.");
    }
    return secret;
};
const getExpiresInSeconds = (durationString, defaultDuration) => {
    try {
        const durationMs = ms(durationString || defaultDuration);
        return Math.floor(durationMs / 1000);
    }
    catch (e) {
        return Math.floor(ms(defaultDuration) / 1000);
    }
};
// Função para validar e sanitizar entrada de login
const validateLoginInput = (email, password) => {
    if (!email || !password) {
        return { isValid: false, message: 'Email e senha são obrigatórios.' };
    }
    if (typeof email !== 'string' || typeof password !== 'string') {
        return { isValid: false, message: 'Email e senha devem ser strings válidas.' };
    }
    // Sanitização básica do email
    const sanitizedEmail = email.trim().toLowerCase();
    // Validação do formato do email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(sanitizedEmail)) {
        return { isValid: false, message: 'Formato de email inválido.' };
    }
    // Validação da senha
    if (password.length < 1) {
        return { isValid: false, message: 'Senha não pode estar vazia.' };
    }
    if (password.length > 128) {
        return { isValid: false, message: 'Senha muito longa.' };
    }
    return { isValid: true };
};
router.post('/login', async (req, res, next) => {
    await dbConnect();
    const { email, password } = req.body;
    // Validação e sanitização de entrada
    const validation = validateLoginInput(email, password);
    if (!validation.isValid) {
        console.warn(`[POST /login] Entrada inválida. IP: ${req.ip}, Error: ${validation.message}`);
        return res.status(400).json({ message: validation.message, code: 'INVALID_INPUT' });
    }
    const sanitizedEmail = email.trim().toLowerCase();
    try {
        const user = await PersonalTrainer.findOne({ email: sanitizedEmail }).select('+passwordHash +role');
        if (!user || !user._id) {
            console.warn(`[POST /login] Tentativa de login falhada para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }
        const isPasswordValid = await user.comparePassword(password);
        if (!isPasswordValid) {
            console.warn(`[POST /login] Senha incorreta para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }
        const firstName = user.nome.split(' ')[0] || '';
        const lastName = user.nome.split(' ').slice(1).join(' ') || '';
        let role = user.role?.toLowerCase() === 'admin' ? 'admin' : 'personal';
        const tokenPayload = {
            id: user._id.toString(),
            email: user.email,
            firstName,
            lastName,
            role: role
        };
        const secret = getJwtSecret();
        const expiresIn = getExpiresInSeconds(process.env.JWT_EXPIRES_IN, '1h');
        const refreshExpiresIn = getExpiresInSeconds(process.env.JWT_REFRESH_EXPIRES_IN, '7d');
        const token = jwt.sign(tokenPayload, secret, { expiresIn });
        const refreshToken = jwt.sign({ id: tokenPayload.id, type: 'refresh' }, secret, { expiresIn: refreshExpiresIn });
        console.log(`[POST /login] SUCESSO: Token gerado para ${sanitizedEmail}. IP: ${req.ip}`);
        res.json({
            message: 'Login bem-sucedido!',
            token,
            refreshToken,
            user: { ...tokenPayload }
        });
    }
    catch (error) {
        console.error(`[POST /login] Erro catastrófico durante o processo de login para ${sanitizedEmail}. IP: ${req.ip}:`, error);
        next(error);
    }
});
router.post('/aluno/login', async (req, res, next) => {
    await dbConnect();
    const { email, password } = req.body;
    // Validação e sanitização de entrada
    const validation = validateLoginInput(email, password);
    if (!validation.isValid) {
        console.warn(`[POST /aluno/login] Entrada inválida. IP: ${req.ip}, Error: ${validation.message}`);
        return res.status(400).json({ message: validation.message, code: 'INVALID_INPUT' });
    }
    const sanitizedEmail = email.trim().toLowerCase();
    try {
        // <<< ALTERAÇÃO: Agora buscamos o status junto com o hash da senha >>>
        const aluno = await Aluno.findOne({ email: sanitizedEmail }).select('+passwordHash +status');
        if (!aluno || !aluno._id) {
            console.warn(`[POST /aluno/login] Tentativa de login falhada para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }
        const isPasswordValid = await aluno.comparePassword(password);
        if (!isPasswordValid) {
            console.warn(`[POST /aluno/login] Senha incorreta para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }
        // <<< ADIÇÃO: Verificação de status ANTES de gerar o token >>>
        if (aluno.status !== 'active') {
            console.warn(`[POST /aluno/login] Falha: Tentativa de login de aluno inativo - Email: ${aluno.email}. IP: ${req.ip}`);
            // Retorna o erro 403 com a mensagem e o código que o frontend espera
            return res.status(403).json({
                message: 'Sua conta está inativa. Fale com seu personal trainer.',
                code: 'ACCOUNT_INACTIVE'
            });
        }
        const tokenPayload = {
            id: aluno._id.toString(),
            nome: aluno.nome,
            email: aluno.email,
            personalId: aluno.trainerId?.toString(),
            role: 'aluno',
        };
        const secret = getJwtSecret();
        const expiresIn = getExpiresInSeconds(process.env.JWT_ALUNO_EXPIRES_IN, '7d');
        const refreshExpiresIn = getExpiresInSeconds(process.env.JWT_ALUNO_REFRESH_EXPIRES_IN, '30d');
        const token = jwt.sign(tokenPayload, secret, { expiresIn });
        const refreshToken = jwt.sign({ id: tokenPayload.id, type: 'refresh' }, secret, { expiresIn: refreshExpiresIn });
        console.log(`✅ Login de Aluno bem-sucedido para: ${aluno.email}. IP: ${req.ip}`);
        res.json({
            message: 'Login de aluno bem-sucedido!',
            token,
            refreshToken,
            aluno: tokenPayload
        });
    }
    catch (error) {
        console.error(`[POST /aluno/login] Erro catastrófico durante o processo de login para ${sanitizedEmail}. IP: ${req.ip}:`, error);
        next(error);
    }
});
// Endpoint para renovar token de Personal/Admin
router.post('/refresh', async (req, res, next) => {
    const { refreshToken } = req.body;
    if (!refreshToken) {
        return res.status(400).json({ message: 'Refresh token é obrigatório.' });
    }
    try {
        const secret = getJwtSecret();
        const decoded = jwt.verify(refreshToken, secret);
        if (decoded.type !== 'refresh') {
            return res.status(401).json({ message: 'Token inválido.', code: 'INVALID_REFRESH_TOKEN' });
        }
        // Buscar o usuário no banco
        const user = await PersonalTrainer.findById(decoded.id).select('+role');
        if (!user) {
            return res.status(401).json({ message: 'Usuário não encontrado.', code: 'USER_NOT_FOUND' });
        }
        const firstName = user.nome.split(' ')[0] || '';
        const lastName = user.nome.split(' ').slice(1).join(' ') || '';
        let role = user.role?.toLowerCase() === 'admin' ? 'admin' : 'personal';
        const tokenPayload = {
            id: user._id.toString(),
            email: user.email,
            firstName,
            lastName,
            role: role
        };
        const expiresIn = getExpiresInSeconds(process.env.JWT_EXPIRES_IN, '1h');
        const newToken = jwt.sign(tokenPayload, secret, { expiresIn });
        res.json({
            message: 'Token renovado com sucesso!',
            token: newToken,
            user: { ...tokenPayload }
        });
    }
    catch (error) {
        console.error('[POST /refresh] Erro ao renovar token:', error);
        if (error instanceof jwt.JsonWebTokenError) {
            return res.status(401).json({ message: 'Refresh token inválido ou expirado.', code: 'INVALID_REFRESH_TOKEN' });
        }
        next(error);
    }
});
// Endpoint para renovar token de Aluno
router.post('/aluno/refresh', async (req, res, next) => {
    await dbConnect();
    const { refreshToken } = req.body;
    if (!refreshToken) {
        return res.status(400).json({ message: 'Refresh token é obrigatório.' });
    }
    try {
        const secret = getJwtSecret();
        const decoded = jwt.verify(refreshToken, secret);
        if (decoded.type !== 'refresh') {
            return res.status(401).json({ message: 'Token inválido.', code: 'INVALID_REFRESH_TOKEN' });
        }
        // Buscar o aluno no banco
        const aluno = await Aluno.findById(decoded.id).select('+status');
        if (!aluno) {
            return res.status(401).json({ message: 'Aluno não encontrado.', code: 'USER_NOT_FOUND' });
        }
        if (aluno.status !== 'active') {
            return res.status(403).json({
                message: 'Sua conta está inativa. Fale com seu personal trainer.',
                code: 'ACCOUNT_INACTIVE'
            });
        }
        const tokenPayload = {
            id: aluno._id.toString(),
            nome: aluno.nome,
            email: aluno.email,
            personalId: aluno.trainerId?.toString(),
            role: 'aluno',
        };
        const expiresIn = getExpiresInSeconds(process.env.JWT_ALUNO_EXPIRES_IN, '7d');
        const newToken = jwt.sign(tokenPayload, secret, { expiresIn });
        res.json({
            message: 'Token de aluno renovado com sucesso!',
            token: newToken,
            aluno: tokenPayload
        });
    }
    catch (error) {
        console.error('[POST /aluno/refresh] Erro ao renovar token:', error);
        if (error instanceof jwt.JsonWebTokenError) {
            return res.status(401).json({ message: 'Refresh token inválido ou expirado.', code: 'INVALID_REFRESH_TOKEN' });
        }
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/authRoutes.js =====
// server/src/routes/authRoutes.ts
import { Router } from 'express';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import jwt from 'jsonwebtoken';
import ms from 'ms';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA
const router = Router();
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';
const calculateExpiresInSeconds = (durationStr) => {
    const msValue = ms(durationStr);
    return typeof msValue === 'number' ? Math.floor(msValue / 1000) : 3600;
};
const expiresInSeconds = calculateExpiresInSeconds(JWT_EXPIRES_IN);
// --- Login Personal/Admin ---
router.post('/login', async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const { email, password } = req.body;
    if (!email || !password)
        return res.status(400).json({ message: 'Email e senha são obrigatórios.' });
    try {
        const user = await PersonalTrainer
            .findOne({ email: email.toLowerCase() })
            .select('+passwordHash +role');
        if (!user || !user._id) {
            return res.status(401).json({ message: 'Credenciais inválidas.' });
        }
        const isPasswordValid = await user.comparePassword(password);
        if (!isPasswordValid) {
            return res.status(401).json({ message: 'Credenciais inválidas.' });
        }
        const firstName = user.nome.split(' ')[0] || '';
        const lastName = user.nome.split(' ').slice(1).join(' ') || '';
        const role = user.role;
        const tokenPayload = {
            id: user._id.toString(),
            email: user.email,
            firstName,
            lastName,
            role,
        };
        if (!process.env.JWT_SECRET) {
            throw new Error("JWT_SECRET não está definido nas variáveis de ambiente.");
        }
        const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, {
            expiresIn: expiresInSeconds,
        });
        res.json({
            message: 'Login bem-sucedido!',
            token,
            user: {
                id: user._id.toString(),
                trainerId: user._id.toString(),
                username: user.email,
                firstName,
                lastName,
                email: user.email,
                role,
            },
        });
    }
    catch (error) {
        console.error("Erro no login:", error);
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/conviteAlunoPublicRoutes.js =====
// server/src/routes/conviteAlunoPublicRoutes.ts
import express from 'express';
import ConviteAluno from '../../models/ConviteAluno.js';
import Aluno from '../../models/Aluno.js';
import PersonalTrainer from '../../models/PersonalTrainer.js'; // Importa o modelo PersonalTrainer
import dbConnect from '../../lib/dbConnect.js';
const router = express.Router();
// GET /api/public/convite-aluno/:token - Valida o token do convite
router.get('/:token', async (req, res, next) => {
    await dbConnect();
    try {
        const { token } = req.params;
        const convite = await ConviteAluno.findOne({ token, status: 'pendente' });
        if (!convite || convite.dataExpiracao < new Date()) {
            if (convite) {
                convite.status = 'expirado';
                await convite.save();
            }
            return res.status(404).json({ erro: 'Convite inválido ou expirado.' });
        }
        const personal = await PersonalTrainer.findById(convite.criadoPor).select('nome');
        if (!personal) {
            return res.status(404).json({ erro: 'Personal trainer associado ao convite não encontrado.' });
        }
        // Retorna o e-mail (que pode ser undefined) e o nome do personal
        res.status(200).json({ email: convite.emailConvidado, personalName: personal.nome });
    }
    catch (error) {
        next(error);
    }
});
// POST /api/public/convite-aluno/registrar - Finaliza o cadastro do aluno
router.post('/registrar', async (req, res, next) => {
    await dbConnect();
    try {
        const { token, nome, password, email, ...outrosDados } = req.body;
        if (!token || !nome || !password) {
            return res.status(400).json({ erro: 'Dados insuficientes para o registro.' });
        }
        const convite = await ConviteAluno.findOne({ token, status: 'pendente' });
        if (!convite || convite.dataExpiracao < new Date()) {
            if (convite) {
                convite.status = 'expirado';
                await convite.save();
            }
            return res.status(404).json({ erro: 'Convite inválido ou expirado.' });
        }
        const emailFinal = convite.emailConvidado || email;
        if (!emailFinal) {
            return res.status(400).json({ erro: 'O e-mail é obrigatório para o cadastro.' });
        }
        const novoAluno = new Aluno({
            nome,
            email: emailFinal, // Usa o e-mail determinado
            passwordHash: password,
            trainerId: convite.criadoPor,
            status: 'active',
            ...outrosDados,
        });
        await novoAluno.save();
        convite.status = 'utilizado';
        convite.usadoPor = novoAluno._id;
        await convite.save();
        res.status(201).json({ mensagem: 'Aluno registrado com sucesso!' });
    }
    catch (error) {
        if (error.code === 11000) {
            return res.status(409).json({ erro: 'Este endereço de e-mail já está em uso.' });
        }
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/convitePublicRoutes.js =====
// server/src/routes/convitePublicRoutes.ts
import express from 'express';
import mongoose from 'mongoose';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import ConvitePersonal from '../../models/ConvitePersonal.js';
import dbConnect from '../../lib/dbConnect.js';
import PlanoService from '../../services/PlanoService.js'; // <- NOVA importação
const router = express.Router();
// Rota: GET /api/convites/validar/:tokenDeConvite
router.get('/validar/:tokenDeConvite', async (req, res, next) => {
    await dbConnect();
    const { tokenDeConvite } = req.params;
    if (!tokenDeConvite) {
        return res.status(400).json({ mensagem: "Token de convite não fornecido." });
    }
    try {
        const convite = await ConvitePersonal.findOne({ token: tokenDeConvite });
        if (!convite) {
            return res.status(404).json({ mensagem: "Convite inválido ou não encontrado." });
        }
        if (convite.status === 'utilizado') {
            return res.status(400).json({ mensagem: "Este convite já foi utilizado." });
        }
        if (convite.status === 'expirado' || (convite.dataExpiracao && convite.dataExpiracao < new Date())) {
            if (convite.status === 'pendente') {
                convite.status = 'expirado';
                await convite.save();
            }
            return res.status(400).json({ mensagem: "Este convite expirou." });
        }
        res.status(200).json({
            mensagem: "Convite válido.",
            emailConvidado: convite.emailConvidado,
            roleConvidado: convite.roleConvidado,
        });
    }
    catch (error) {
        next(error);
    }
});
// Rota: POST /api/convites/registrar/:tokenDeConvite
router.post('/registrar/:tokenDeConvite', async (req, res, next) => {
    await dbConnect();
    const { tokenDeConvite } = req.params;
    const { nome, email, password } = req.body;
    if (!tokenDeConvite) {
        return res.status(400).json({ mensagem: "Token de convite não fornecido." });
    }
    if (!nome || !password) {
        return res.status(400).json({ mensagem: "Nome e senha são obrigatórios." });
    }
    const session = await mongoose.startSession();
    try {
        session.startTransaction();
        const convite = await ConvitePersonal.findOne({ token: tokenDeConvite }).session(session);
        if (!convite) {
            await session.abortTransaction();
            return res.status(404).json({ mensagem: "Convite inválido ou não encontrado." });
        }
        if (convite.status === 'utilizado') {
            await session.abortTransaction();
            return res.status(400).json({ mensagem: "Este convite já foi utilizado." });
        }
        if (convite.status === 'expirado' || (convite.dataExpiracao && convite.dataExpiracao < new Date())) {
            if (convite.status === 'pendente') {
                convite.status = 'expirado';
                await convite.save({ session });
            }
            await session.abortTransaction();
            return res.status(400).json({ mensagem: "Este convite expirou." });
        }
        const emailFinal = convite.emailConvidado || email;
        if (!emailFinal) {
            await session.abortTransaction();
            return res.status(400).json({ mensagem: "O e-mail é obrigatório para o cadastro." });
        }
        const existingPersonal = await PersonalTrainer.findOne({ email: emailFinal.toLowerCase() }).session(session);
        if (existingPersonal) {
            await session.abortTransaction();
            return res.status(409).json({ mensagem: `Já existe um usuário com o email: ${emailFinal}` });
        }
        const novoPersonal = new PersonalTrainer({
            nome,
            email: emailFinal.toLowerCase(),
            passwordHash: password,
            role: convite.roleConvidado,
        });
        await novoPersonal.save({ session });
        convite.status = 'utilizado';
        convite.usadoPor = novoPersonal._id;
        convite.dataUtilizacao = new Date();
        await convite.save({ session });
        await session.commitTransaction();
        // === ATRIBUIR PLANO FREE AUTOMATICAMENTE ===
        try {
            await PlanoService.ensureInitialPlansExist();
            const planos = await PlanoService.getAllPlans();
            const freePlan = planos.find(p => p.tipo === 'free');
            if (freePlan) {
                await PlanoService.assignPlanToPersonal(String(novoPersonal._id), // converte _id para string
                String(freePlan._id), null, freePlan.duracao, 'Plano Free automático na criação de conta');
            }
        }
        catch (err) {
            console.error('Erro ao atribuir plano Free:', err);
            // Não impede o cadastro; apenas registra o erro
        }
        res.status(201).json({ mensagem: "Personal registrado com sucesso! Você já pode fazer login." });
    }
    catch (error) {
        if (session.inTransaction()) {
            await session.abortTransaction();
        }
        if (error.name === 'ValidationError') {
            const mensagens = Object.values(error.errors).map((el) => el.message);
            return res.status(400).json({ mensagem: mensagens.join(', ') });
        }
        next(error);
    }
    finally {
        session.endSession();
    }
});
export default router;

===== ./server/dist/src/routes/dashboardGeralRoutes.js =====
// server/src/routes/dashboardGeralRoutes.ts
import express from 'express';
import mongoose from 'mongoose';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import Aluno from '../../models/Aluno.js';
import Treino from '../../models/Treino.js';
import Sessao from '../../models/Sessao.js';
import dbConnect from '../../lib/dbConnect.js';
const router = express.Router();
router.get('/', authenticateToken, async (req, res, next) => {
    await dbConnect();
    const trainerId = req.user?.id;
    if (!trainerId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    try {
        const trainerObjectId = new mongoose.Types.ObjectId(trainerId);
        // --- MÉTRICAS COM A NOVA REGRA DE NEGÓCIO ---
        // 1. Total de Alunos (sem alteração)
        const totalAlunos = await Aluno.countDocuments({ trainerId: trainerObjectId });
        // <<< ALTERAÇÃO: "Alunos Ativos" agora conta pelo status do cadastro do aluno >>>
        const treinosAtivos = await Aluno.countDocuments({
            trainerId: trainerObjectId,
            status: 'active' // A nova regra de negócio
        });
        // 3. Total de Fichas Modelo (sem alteração)
        const totalTreinosModelo = await Treino.countDocuments({
            criadorId: trainerObjectId,
            tipo: 'modelo'
        });
        // 4. Feedbacks Recebidos Hoje (sem alteração)
        const hojeInicio = new Date();
        hojeInicio.setHours(0, 0, 0, 0);
        const hojeFim = new Date();
        hojeFim.setHours(23, 59, 59, 999);
        const feedbacksHojeCount = await Sessao.countDocuments({
            personalId: trainerObjectId,
            concluidaEm: { $gte: hojeInicio, $lte: hojeFim },
            status: 'completed',
            $or: [
                { pseAluno: { $exists: true, $nin: [null, ''] } },
                { comentarioAluno: { $exists: true, $nin: [null, ""] } }
            ]
        });
        res.json({
            totalAlunos,
            treinosAtivos, // Este nome de campo é mantido, mas agora representa "Alunos Ativos"
            totalTreinosModelo,
            feedbacksHojeCount,
        });
    }
    catch (error) {
        console.error("[GET /api/dashboard/geral] Erro ao buscar estatísticas:", error);
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/exercicios.js =====
// server/src/routes/exercicios.ts
import express from "express";
import mongoose from "mongoose";
import Exercicio from "../../models/Exercicio.js";
import Treino from "../../models/Treino.js";
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js';
const router = express.Router();
// Função auxiliar de filtro
const buildFilterQuery = (baseFilter, req) => {
    const query = { ...baseFilter };
    const { grupo, categoria } = req.query;
    if (grupo && typeof grupo === 'string' && grupo !== 'all')
        query.grupoMuscular = grupo;
    if (categoria && typeof categoria === 'string' && categoria !== 'all')
        query.categoria = categoria;
    return query;
};
// <<< CONSOLIDAÇÃO: Nova rota GET /biblioteca para todos os tipos de filtro >>>
router.get("/biblioteca", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const userId = req.user?.id;
    try {
        if (!userId)
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        const { tipo } = req.query; // 'todos', 'app', 'meus', 'favoritos'
        let baseFilter = {};
        switch (tipo) {
            case 'app':
                baseFilter.isCustom = { $ne: true }; // Exercícios do App (não personalizados)
                break;
            case 'meus':
                baseFilter.isCustom = true; // Exercícios personalizados
                baseFilter.creatorId = new mongoose.Types.ObjectId(userId); // Apenas os do usuário logado
                break;
            case 'favoritos':
                baseFilter.favoritedBy = new mongoose.Types.ObjectId(userId); // Exercícios favoritados pelo usuário
                break;
            case 'todos':
            default:
                // Retorna todos os exercícios do App + os personalizados do usuário logado
                baseFilter.$or = [
                    { isCustom: { $ne: true } },
                    { isCustom: true, creatorId: new mongoose.Types.ObjectId(userId) }
                ];
                break;
        }
        const finalFilterQuery = buildFilterQuery(baseFilter, req);
        // Busca os exercícios com os filtros aplicados
        const exercicios = await Exercicio.find(finalFilterQuery).lean();
        // Adiciona a flag isFavoritedByCurrentUser para cada exercício
        const exerciciosComFavorito = exercicios.map(ex => ({
            ...ex,
            isFavoritedByCurrentUser: ex.favoritedBy?.some(favId => favId.equals(new mongoose.Types.ObjectId(userId))) ?? false
        }));
        res.status(200).json(exerciciosComFavorito);
    }
    catch (error) {
        console.error("Erro ao buscar exercícios da biblioteca:", error);
        next(error);
    }
});
// As rotas GET /app, /meus, /favoritos foram consolidadas na rota /biblioteca e podem ser removidas se não houver outro uso.
// Se ainda houver outros usos específicos, elas podem ser mantidas, mas a rota /biblioteca é a principal para o modal.
// POST / - Criar um novo exercício
router.post("/", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const { nome, descricao, categoria, grupoMuscular, urlVideo, isCustom } = req.body;
    const requesterId = req.user?.id;
    const requesterRole = req.user?.role;
    if (!requesterId)
        return res.status(401).json({ erro: "Usuário não autenticado." });
    if (!nome)
        return res.status(400).json({ erro: "O nome do exercício é obrigatório." });
    try {
        const exercicioData = {
            nome: nome.trim(), descricao, categoria, grupoMuscular, urlVideo, isCustom
        };
        if (isCustom === false) {
            if (requesterRole?.toLowerCase() !== 'admin') {
                return res.status(403).json({ erro: "Apenas administradores podem criar exercícios do App." });
            }
            exercicioData.creatorId = undefined;
        }
        else {
            exercicioData.isCustom = true;
            exercicioData.creatorId = new mongoose.Types.ObjectId(requesterId);
            const jaExiste = await Exercicio.findOne({ nome: nome.trim(), creatorId: exercicioData.creatorId });
            if (jaExiste)
                return res.status(409).json({ erro: "Você já possui um exercício personalizado com esse nome." });
        }
        const novoExercicio = await Exercicio.create(exercicioData);
        res.status(201).json(novoExercicio);
    }
    catch (error) {
        next(error);
    }
});
// PUT /:id - Atualizar um exercício
router.put("/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const requesterId = req.user?.id;
    const requesterRole = req.user?.role;
    const { id } = req.params;
    const updates = req.body;
    if (!mongoose.Types.ObjectId.isValid(id))
        return res.status(400).json({ erro: "ID inválido." });
    if (!requesterId)
        return res.status(401).json({ erro: "Não autorizado." });
    try {
        const exercicio = await Exercicio.findById(id);
        if (!exercicio)
            return res.status(404).json({ erro: "Exercício não encontrado." });
        const isOwner = exercicio.creatorId?.equals(new mongoose.Types.ObjectId(requesterId));
        const isAdmin = requesterRole?.toLowerCase() === 'admin';
        if ((exercicio.isCustom && isOwner) || (!exercicio.isCustom && isAdmin)) {
            Object.assign(exercicio, updates);
            await exercicio.save();
            res.status(200).json(exercicio);
        }
        else {
            return res.status(403).json({ erro: "Permissão negada para editar este exercício." });
        }
    }
    catch (error) {
        next(error);
    }
});
// DELETE /:id - Deletar um exercício
router.delete("/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const requesterId = req.user?.id;
    const requesterRole = req.user?.role;
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id))
        return res.status(400).json({ erro: "ID inválido." });
    if (!requesterId)
        return res.status(401).json({ erro: "Não autorizado." });
    try {
        const exercicio = await Exercicio.findById(id);
        if (!exercicio)
            return res.status(404).json({ erro: "Exercício não encontrado." });
        const isOwner = exercicio.creatorId?.equals(new mongoose.Types.ObjectId(requesterId));
        const isAdmin = requesterRole?.toLowerCase() === 'admin';
        if ((exercicio.isCustom && isOwner) || (!exercicio.isCustom && isAdmin)) {
            // <<< CORREÇÃO: Lógica de remoção em cascata >>>
            const exercicioId = new mongoose.Types.ObjectId(id);
            // 1. Remove o exercício de todas as rotinas
            await Treino.updateMany({ "diasDeTreino.exerciciosDoDia.exercicioId": exercicioId }, { $pull: { "diasDeTreino.$[].exerciciosDoDia": { exercicioId: exercicioId } } });
            // 2. Deleta o exercício principal
            await exercicio.deleteOne();
            res.status(200).json({ message: "Exercício deletado com sucesso e removido de todas as rotinas." });
        }
        else {
            return res.status(403).json({ erro: "Permissão negada para deletar este exercício." });
        }
    }
    catch (error) {
        next(error);
    }
});
// ... (rotas de favorite/unfavorite permanecem inalteradas)
// POST /:id/favorite - Favoritar
router.post("/:id/favorite", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const userId = req.user?.id;
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id) || !userId)
        return res.status(400).json({ erro: "Requisição inválida." });
    try {
        await Exercicio.updateOne({ _id: id }, { $addToSet: { favoritedBy: new mongoose.Types.ObjectId(userId) } });
        res.status(200).json({ message: "Exercício favoritado." });
    }
    catch (error) {
        next(error);
    }
});
// DELETE /:id/favorite - Desfavoritar
router.delete("/:id/favorite", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const userId = req.user?.id;
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id) || !userId)
        return res.status(400).json({ erro: "Requisição inválida." });
    try {
        await Exercicio.updateOne({ _id: id }, { $pull: { favoritedBy: new mongoose.Types.ObjectId(userId) } });
        res.status(200).json({ message: "Exercício desfavoritado." });
    }
    catch (error) {
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/pastasTreinos.js =====
// server/src/routes/pastasTreinos.ts
import express from 'express';
import mongoose from 'mongoose';
import PastaTreino from '../../models/Pasta.js';
import Treino from '../../models/Treino.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA
const router = express.Router();
console.log("--- [server/src/routes/pastasTreinos.ts] Ficheiro carregado (DEBUG transação para reordenar - Correção TS) ---");
router.put('/reordenar', authenticateToken, async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const criadorId = req.user?.id;
    const { novaOrdemIds } = req.body;
    console.log(`[DEBUG PUT /api/pastas/treinos/reordenar] Tentativa de reordenar pastas. CriadorID: ${criadorId}`);
    console.log(`[DEBUG PUT /api/pastas/treinos/reordenar] Nova ordem de IDs recebida:`, novaOrdemIds);
    if (!criadorId) {
        console.warn("[DEBUG PUT /api/pastas/treinos/reordenar] Usuário não autenticado.");
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    if (!Array.isArray(novaOrdemIds) || novaOrdemIds.some(id => typeof id !== 'string' || !mongoose.Types.ObjectId.isValid(id))) {
        console.warn("[DEBUG PUT /api/pastas/treinos/reordenar] 'novaOrdemIds' deve ser um array de IDs de pasta válidos.");
        return res.status(400).json({ mensagem: "'novaOrdemIds' deve ser um array de IDs de pasta válidos." });
    }
    const session = await mongoose.startSession();
    let sessionIdForLogging = "N/A_SESSAO_INIT";
    try {
        if (session.id && session.id.id && typeof session.id.id.toString === 'function') {
            sessionIdForLogging = session.id.id.toString('hex');
        }
        else {
            sessionIdForLogging = "ID_SESSAO_NAO_RECUPERAVEL";
            console.warn("[DEBUG TRANSACTION] Não foi possível obter o ID da sessão para logging.");
        }
        console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Iniciando transação para reordenar pastas.`);
        session.startTransaction();
        const criadorObjectId = new mongoose.Types.ObjectId(criadorId);
        for (let i = 0; i < novaOrdemIds.length; i++) {
            const pastaId = novaOrdemIds[i];
            const index = i;
            console.log(`  [DEBUG TRANSACTION ${sessionIdForLogging}] Atualizando Pasta ID: ${pastaId} para Ordem: ${index}`);
            const result = await PastaTreino.updateOne({ _id: new mongoose.Types.ObjectId(pastaId), criadorId: criadorObjectId }, { $set: { ordem: index } }, { session });
            console.log(`    [DEBUG TRANSACTION ${sessionIdForLogging}] Resultado para Pasta ID ${pastaId}: matchedCount=${result.matchedCount}, modifiedCount=${result.modifiedCount}`);
            if (result.matchedCount === 0) {
                console.warn(`  [DEBUG TRANSACTION ${sessionIdForLogging}] ERRO: Pasta com ID ${pastaId} não encontrada para o usuário ${criadorId}. Abortando.`);
                await session.abortTransaction();
                return res.status(404).json({ mensagem: `Erro ao reordenar: Pasta com ID ${pastaId} não encontrada.` });
            }
        }
        console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Commitando transação.`);
        await session.commitTransaction();
        console.log("[DEBUG PUT /api/pastas/treinos/reordenar] Pastas reordenadas com sucesso (com transação).");
        res.status(200).json({ mensagem: "Pastas reordenadas com sucesso." });
    }
    catch (error) {
        console.error(`[DEBUG TRANSACTION ${sessionIdForLogging}] Erro durante a transação de reordenar pastas:`, error);
        if (session.inTransaction()) {
            console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Abortando transação devido a erro.`);
            await session.abortTransaction();
        }
        else {
            console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Transação não estava ativa no momento do erro ou já foi abortada/commitada.`);
        }
        next(error);
    }
    finally {
        console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Finalizando sessão.`);
        await session.endSession();
    }
});
router.post('/', authenticateToken, async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const criadorId = req.user?.id;
    const { nome } = req.body;
    console.log(`[POST /api/pastas/treinos] Tentativa de criar pasta. Nome: "${nome}", CriadorID: ${criadorId}`);
    if (!criadorId) {
        console.warn("[POST /api/pastas/treinos] Usuário não autenticado.");
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    if (!nome || typeof nome !== 'string' || nome.trim().length === 0) {
        console.warn("[POST /api/pastas/treinos] Nome da pasta ausente ou inválido.");
        return res.status(400).json({ mensagem: "O nome da pasta é obrigatório e não pode ser vazio." });
    }
    try {
        const criadorObjectId = new mongoose.Types.ObjectId(criadorId);
        const pastaExistente = await PastaTreino.findOne({ nome: nome.trim(), criadorId: criadorObjectId });
        if (pastaExistente) {
            console.warn(`[POST /api/pastas/treinos] Pasta com nome "${nome.trim()}" já existe para o usuário ${criadorId}.`);
            return res.status(409).json({ mensagem: `Uma pasta com o nome "${nome.trim()}" já existe.` });
        }
        const contagemPastas = await PastaTreino.countDocuments({ criadorId: criadorObjectId });
        const novaPasta = new PastaTreino({
            nome: nome.trim(),
            criadorId: criadorObjectId,
            ordem: contagemPastas,
        });
        await novaPasta.save();
        console.log(`[POST /api/pastas/treinos] Pasta "${novaPasta.nome}" criada com sucesso. ID: ${novaPasta._id}, Ordem: ${novaPasta.ordem}`);
        res.status(201).json(novaPasta);
    }
    catch (error) {
        console.error("[POST /api/pastas/treinos] Erro ao criar pasta:", error);
        if (error.name === 'ValidationError') {
            const mensagens = Object.values(error.errors).map((el) => el.message);
            return res.status(400).json({ mensagem: mensagens.join(', ') });
        }
        next(error);
    }
});
router.get('/', authenticateToken, async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const criadorId = req.user?.id;
    console.log(`[GET /api/pastas/treinos] Buscando pastas para o criador ID: ${criadorId}`);
    if (!criadorId) {
        console.warn("[GET /api/pastas/treinos] Usuário não autenticado.");
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    try {
        const pastas = await PastaTreino.find({ criadorId: new mongoose.Types.ObjectId(criadorId) })
            .sort({ ordem: 1, nome: 1 });
        console.log(`[GET /api/pastas/treinos] ${pastas.length} pastas encontradas para o usuário ${criadorId}.`);
        res.status(200).json(pastas);
    }
    catch (error) {
        console.error("[GET /api/pastas/treinos] Erro ao buscar pastas:", error);
        next(error);
    }
});
router.put('/:pastaId', authenticateToken, async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const { pastaId } = req.params;
    const criadorId = req.user?.id;
    const { nome } = req.body;
    console.log(`[PUT /api/pastas/treinos/${pastaId}] Tentativa de editar pasta. Novo nome: "${nome}", CriadorID: ${criadorId}`);
    if (!criadorId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    if (!mongoose.Types.ObjectId.isValid(pastaId)) {
        return res.status(400).json({ mensagem: "ID da pasta inválido." });
    }
    if (!nome || typeof nome !== 'string' || nome.trim().length === 0) {
        return res.status(400).json({ mensagem: "O nome da pasta é obrigatório." });
    }
    try {
        const criadorObjectId = new mongoose.Types.ObjectId(criadorId);
        const pastaObjectId = new mongoose.Types.ObjectId(pastaId);
        const pastaParaAtualizar = await PastaTreino.findOne({ _id: pastaObjectId, criadorId: criadorObjectId });
        if (!pastaParaAtualizar) {
            return res.status(404).json({ mensagem: "Pasta não encontrada ou você não tem permissão para editá-la." });
        }
        const pastaComMesmoNome = await PastaTreino.findOne({
            nome: nome.trim(),
            criadorId: criadorObjectId,
            _id: { $ne: pastaObjectId }
        });
        if (pastaComMesmoNome) {
            return res.status(409).json({ mensagem: `Outra pasta com o nome "${nome.trim()}" já existe.` });
        }
        pastaParaAtualizar.nome = nome.trim();
        await pastaParaAtualizar.save();
        console.log(`[PUT /api/pastas/treinos/${pastaId}] Pasta atualizada com sucesso para "${pastaParaAtualizar.nome}".`);
        res.status(200).json(pastaParaAtualizar);
    }
    catch (error) {
        console.error(`[PUT /api/pastas/treinos/${pastaId}] Erro ao editar pasta:`, error);
        if (error.name === 'ValidationError') {
            const mensagens = Object.values(error.errors).map((el) => el.message);
            return res.status(400).json({ mensagem: mensagens.join(', ') });
        }
        next(error);
    }
});
router.delete('/:pastaId', authenticateToken, async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const { pastaId } = req.params;
    const criadorId = req.user?.id;
    console.log(`[DELETE /api/pastas/treinos/${pastaId}] Tentativa de excluir pasta. CriadorID: ${criadorId}`);
    if (!criadorId) {
        console.warn(`[DELETE /api/pastas/treinos/${pastaId}] Usuário não autenticado.`);
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    if (!mongoose.Types.ObjectId.isValid(pastaId)) {
        console.warn(`[DELETE /api/pastas/treinos/${pastaId}] ID da pasta inválido: ${pastaId}`);
        return res.status(400).json({ mensagem: "ID da pasta inválido." });
    }
    const session = await mongoose.startSession();
    let sessionIdForLogging = "N/A_SESSAO_INIT_DELETE";
    try {
        if (session.id && session.id.id && typeof session.id.id.toString === 'function') {
            sessionIdForLogging = session.id.id.toString('hex');
        }
        else {
            sessionIdForLogging = "ID_SESSAO_NAO_RECUPERAVEL_DELETE";
            console.warn("[TRANSACTION DELETE] Não foi possível obter o ID da sessão para logging.");
        }
        console.log(`[TRANSACTION ${sessionIdForLogging}] Iniciando transação para excluir pasta ${pastaId}.`);
        session.startTransaction();
        const pastaObjectId = new mongoose.Types.ObjectId(pastaId);
        const criadorObjectId = new mongoose.Types.ObjectId(criadorId);
        const pastaParaExcluir = await PastaTreino.findOne({ _id: pastaObjectId, criadorId: criadorObjectId }).session(session);
        if (!pastaParaExcluir) {
            console.warn(`[TRANSACTION ${sessionIdForLogging}] Pasta não encontrada ou usuário não autorizado. Abortando.`);
            await session.abortTransaction();
            return res.status(404).json({ mensagem: "Pasta não encontrada ou você não tem permissão para excluí-la." });
        }
        console.log(`  [TRANSACTION ${sessionIdForLogging}] Desassociando fichas da pasta ${pastaId}.`);
        const updateResult = await Treino.updateMany({ criadorId: criadorObjectId, tipo: 'modelo', pastaId: pastaObjectId }, { $set: { pastaId: null } }, { session });
        console.log(`  [TRANSACTION ${sessionIdForLogging}] ${updateResult.modifiedCount} fichas foram desassociadas.`);
        console.log(`  [TRANSACTION ${sessionIdForLogging}] Excluindo pasta ${pastaId}.`);
        const deleteResult = await PastaTreino.deleteOne({ _id: pastaObjectId, criadorId: criadorObjectId }, { session });
        if (deleteResult.deletedCount === 0) {
            console.warn(`  [TRANSACTION ${sessionIdForLogging}] ERRO: Falha ao deletar a pasta ${pastaId} (não encontrada ou já deletada). Abortando.`);
            await session.abortTransaction();
            return res.status(404).json({ mensagem: "Erro ao excluir: Pasta não encontrada no momento da exclusão." });
        }
        console.log(`[TRANSACTION ${sessionIdForLogging}] Commitando transação.`);
        await session.commitTransaction();
        console.log(`[DELETE /api/pastas/treinos/${pastaId}] Pasta "${pastaParaExcluir.nome}" excluída com sucesso (com transação).`);
        res.status(200).json({ mensagem: `Pasta "${pastaParaExcluir.nome}" excluída com sucesso.` });
    }
    catch (error) {
        console.error(`[TRANSACTION ${sessionIdForLogging}] Erro durante a transação de excluir pasta ${pastaId}:`, error);
        if (session.inTransaction()) {
            console.log(`[TRANSACTION ${sessionIdForLogging}] Abortando transação devido a erro.`);
            await session.abortTransaction();
        }
        else {
            console.log(`[TRANSACTION ${sessionIdForLogging}] Transação não estava ativa no momento do erro ou já foi abortada/commitada.`);
        }
        next(error);
    }
    finally {
        console.log(`[TRANSACTION ${sessionIdForLogging}] Finalizando sessão.`);
        await session.endSession();
    }
});
export default router;

===== ./server/dist/src/routes/profile.js =====
// server/src/routes/profile.ts
import { Router } from 'express';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA
const router = Router();
router.patch('/me', authenticateToken, async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const userId = req.user?.id;
    const { firstName, lastName } = req.body;
    if (!userId) {
        return res.status(401).json({ message: 'Não autorizado: ID do usuário não encontrado no token.' });
    }
    if (!firstName || !lastName) {
        return res.status(400).json({ message: 'Nome e Sobrenome são obrigatórios.' });
    }
    if (typeof firstName !== 'string' || typeof lastName !== 'string') {
        return res.status(400).json({ message: 'Nome e Sobrenome devem ser strings.' });
    }
    try {
        const nomeCompleto = `${firstName.trim()} ${lastName.trim()}`.trim();
        const updatedUser = await PersonalTrainer.findByIdAndUpdate(userId, { nome: nomeCompleto }, { new: true, runValidators: true, select: '-passwordHash' }).exec();
        if (!updatedUser || !updatedUser._id) {
            console.warn(`[SERVER] Usuário ${userId} não encontrado para atualização de perfil.`);
            return res.status(404).json({ message: 'Personal Trainer não encontrado.' });
        }
        const responseUser = {
            id: updatedUser._id.toString(),
            username: updatedUser.email,
            firstName: updatedUser.nome.split(' ')[0] || '',
            lastName: updatedUser.nome.split(' ').slice(1).join(' ') || '',
            email: updatedUser.email,
            role: updatedUser.role
        };
        console.log(`[SERVER] Perfil atualizado para usuário ${userId}: ${nomeCompleto}`);
        res.status(200).json({ message: 'Perfil atualizado com sucesso!', user: responseUser });
    }
    catch (error) {
        console.error(`[SERVER] Erro ao atualizar perfil para usuário ${userId}:`, error);
        if (error.name === 'ValidationError') {
            const messages = Object.values(error.errors).map((e) => e.message);
            return res.status(400).json({ message: messages.join(', ') });
        }
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/publicContatosRoutes.js =====
// server/src/routes/publicContatosRoutes.ts
import express from 'express';
import Contato from '../../models/Contato.js';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA
const router = express.Router();
console.log("--- [server/src/routes/publicContatosRoutes.ts] Ficheiro carregado ---");
// Rota: POST /api/public/contatos/registrar/:tokenPersonal
router.post('/registrar/:tokenPersonal', async (req, res, next) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const { tokenPersonal } = req.params;
    const { nomeCompleto, email, telefone, dataNascimento, genero } = req.body;
    console.log(`[POST /registrar/${tokenPersonal}] Tentativa de registrar novo contato. Email: ${email}`);
    if (!tokenPersonal) {
        return res.status(400).json({ mensagem: "Token do personal não fornecido." });
    }
    if (!nomeCompleto || typeof nomeCompleto !== 'string' || nomeCompleto.trim().length < 3) {
        return res.status(400).json({ mensagem: "Nome completo é obrigatório e deve ter pelo menos 3 caracteres." });
    }
    if (!email || typeof email !== 'string' || !/.+\@.+\..+/.test(email)) {
        return res.status(400).json({ mensagem: "E-mail inválido." });
    }
    try {
        const personal = await PersonalTrainer.findOne({ tokenCadastroAluno: tokenPersonal }).select('nome _id');
        if (!personal) {
            console.warn(`[POST /registrar/${tokenPersonal}] Personal não encontrado com este token.`);
            return res.status(404).json({ mensagem: "Link de cadastro inválido ou personal não encontrado." });
        }
        const contatoExistente = await Contato.findOne({
            email: email.toLowerCase().trim(),
            personalId: personal._id,
            status: 'novo'
        });
        if (contatoExistente) {
            console.log(`[POST /registrar/${tokenPersonal}] Contato com email ${email} já existe para o personal ${personal._id} com status 'novo'.`);
            return res.status(200).json({ mensagem: `Você já demonstrou interesse. O personal ${personal.nome} entrará em contato.` });
        }
        const novoContato = new Contato({
            nomeCompleto: nomeCompleto.trim(),
            email: email.toLowerCase().trim(),
            telefone: telefone?.trim(),
            dataNascimento: dataNascimento ? new Date(dataNascimento) : undefined,
            genero,
            personalId: personal._id,
            status: 'novo',
            origemToken: tokenPersonal,
        });
        await novoContato.save();
        console.log(`[POST /registrar/${tokenPersonal}] Novo contato ID: ${novoContato._id} registrado para Personal ID: ${personal._id}.`);
        res.status(201).json({ mensagem: "Interesse registrado com sucesso! Em breve, seu personal entrará em contato." });
    }
    catch (error) {
        console.error(`[POST /registrar/${tokenPersonal}] Erro ao registrar contato:`, error);
        if (error.status === 409) {
            return res.status(409).json({ mensagem: error.message });
        }
        if (error.name === 'ValidationError') {
            const mensagens = Object.values(error.errors).map((el) => el.message);
            return res.status(400).json({ mensagem: mensagens.join(', ') });
        }
        next(error);
    }
});
export default router;

===== ./server/dist/src/routes/sessionsRoutes.js =====
// server/src/routes/sessionsRoutes.ts
import express from 'express';
import mongoose, { Types } from 'mongoose';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import { authenticateAlunoToken } from '../../middlewares/authenticateAlunoToken.js';
import Sessao from '../../models/Sessao.js';
import Treino from '../../models/Treino.js';
import dbConnect from '../../lib/dbConnect.js';
const router = express.Router();
// =======================================================
// ROTAS DO PERSONAL
// =======================================================
// (Rotas do personal omitidas por brevidade, permanecem inalteradas)
router.get('/', authenticateToken, async (req, res, next) => {
    // ... código original inalterado ...
});
router.post('/', authenticateToken, async (req, res, next) => {
    // ... código original inalterado ...
});
router.put('/:sessionId', authenticateToken, async (req, res, next) => {
    // ... código original inalterado ...
});
router.delete('/:sessionId', authenticateToken, async (req, res, next) => {
    // ... código original inalterado ...
});
// =======================================================
// ROTAS DO ALUNO
// =======================================================
router.post('/aluno/concluir-dia', authenticateAlunoToken, async (req, res, next) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    // <-- 1. MUDANÇA: Recebe 'dataInicio' do corpo da requisição -->
    const { rotinaId, diaDeTreinoId, pseAluno, comentarioAluno, duracaoSegundos, cargas, dataInicio } = req.body;
    if (!alunoId)
        return res.status(401).json({ message: "Aluno não autenticado." });
    if (!rotinaId || !diaDeTreinoId)
        return res.status(400).json({ message: "ID da rotina e do dia de treino são obrigatórios." });
    // <-- 2. MUDANÇA: Validação para o novo campo 'dataInicio' -->
    if (!dataInicio) {
        return res.status(400).json({ message: "A data de início do treino é obrigatória." });
    }
    const dataInicioValida = new Date(dataInicio);
    if (isNaN(dataInicioValida.getTime())) {
        return res.status(400).json({ message: "Formato de data de início inválido." });
    }
    const mongoTransactionSession = await mongoose.startSession();
    try {
        mongoTransactionSession.startTransaction();
        const rotina = await Treino.findOne({ _id: rotinaId, alunoId }).session(mongoTransactionSession);
        if (!rotina) {
            await mongoTransactionSession.abortTransaction();
            return res.status(404).json({ message: "Rotina não encontrada ou não pertence a este aluno." });
        }
        const diaDeTreino = rotina.diasDeTreino.id(diaDeTreinoId);
        if (!diaDeTreino) {
            await mongoTransactionSession.abortTransaction();
            return res.status(404).json({ message: "Dia de treino não encontrado nesta rotina." });
        }
        const diaConcluidoIndex = rotina.diasDeTreino.findIndex(d => d._id.toString() === diaDeTreinoId);
        if (diaConcluidoIndex > -1) {
            const [diaMovido] = rotina.diasDeTreino.splice(diaConcluidoIndex, 1);
            rotina.diasDeTreino.push(diaMovido);
            rotina.diasDeTreino.forEach((dia, index) => {
                dia.ordemNaRotina = index;
            });
        }
        // Buscar sessão anterior do mesmo aluno/rotina/dia para comparar cargas
        let aumentouCarga = false;
        let detalhesAumentoCarga = [];
        if (cargas && Object.keys(cargas).length > 0) {
            try {
                const sessaoAnterior = await Sessao.findOne({
                    alunoId: new Types.ObjectId(alunoId),
                    rotinaId: rotina._id,
                    diaDeTreinoId: diaDeTreino._id,
                    status: 'completed'
                })
                    .sort({ concluidaEm: -1 })
                    .session(mongoTransactionSession);
                if (sessaoAnterior && sessaoAnterior.cargasExecutadas) {
                    const cargasAnteriores = sessaoAnterior.cargasExecutadas;
                    // Comparar cargas exercício por exercício
                    for (const [exercicioId, cargaAtual] of Object.entries(cargas)) {
                        // Lidar com Map ou objeto plano
                        let cargaAnterior;
                        if (cargasAnteriores instanceof Map) {
                            cargaAnterior = cargasAnteriores.get(exercicioId);
                        }
                        else {
                            cargaAnterior = cargasAnteriores[exercicioId];
                        }
                        // Considerar aumento apenas se havia carga anterior e a atual é maior
                        if (cargaAnterior && typeof cargaAnterior === 'string' && cargaAnterior.trim() &&
                            cargaAtual && typeof cargaAtual === 'string' && cargaAtual.trim()) {
                            const cargaAnteriorNum = parseFloat(cargaAnterior.replace(/[^\d.,]/g, '').replace(',', '.'));
                            const cargaAtualNum = parseFloat(cargaAtual.replace(/[^\d.,]/g, '').replace(',', '.'));
                            if (!isNaN(cargaAnteriorNum) && !isNaN(cargaAtualNum) && cargaAtualNum > cargaAnteriorNum) {
                                aumentouCarga = true;
                                detalhesAumentoCarga.push({
                                    exercicioId,
                                    cargaAnterior: cargaAnterior,
                                    cargaAtual: cargaAtual
                                });
                            }
                        }
                    }
                }
            }
            catch (comparisonError) {
                console.warn('Erro ao comparar cargas:', comparisonError);
                // Continua sem interromper o fluxo principal
            }
        }
        const novaSessao = new Sessao({
            personalId: rotina.criadorId,
            alunoId: new Types.ObjectId(alunoId),
            sessionDate: dataInicioValida,
            concluidaEm: new Date(),
            status: 'completed',
            tipoCompromisso: 'treino',
            rotinaId: rotina._id,
            diaDeTreinoId: diaDeTreino._id,
            diaDeTreinoIdentificador: diaDeTreino.identificadorDia,
            pseAluno: pseAluno || null,
            comentarioAluno: comentarioAluno || null,
            duracaoSegundos: duracaoSegundos || 0,
            cargasExecutadas: cargas || {},
            aumentouCarga,
            detalhesAumentoCarga
        });
        await novaSessao.save({ session: mongoTransactionSession });
        rotina.sessoesRotinaConcluidas = (rotina.sessoesRotinaConcluidas || 0) + 1;
        await rotina.save({ session: mongoTransactionSession });
        await mongoTransactionSession.commitTransaction();
        res.status(201).json({ message: "Dia de treino concluído com sucesso!", _id: novaSessao._id, status: novaSessao.status, concluidaEm: novaSessao.concluidaEm });
    }
    catch (error) {
        if (mongoTransactionSession.inTransaction())
            await mongoTransactionSession.abortTransaction();
        next(error);
    }
    finally {
        await mongoTransactionSession.endSession();
    }
});
router.patch('/:sessionId/feedback', authenticateAlunoToken, async (req, res, next) => {
    // ... código original inalterado ...
});
export default router;

===== ./server/dist/src/routes/treinos.js =====
// server/src/routes/treinos.ts
import express from "express";
import mongoose, { Types } from "mongoose";
import Treino from "../../models/Treino.js";
import PastaTreino from '../../models/Pasta.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js';
const router = express.Router();
router.get("/", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const criadorId = req.user?.id;
        if (!criadorId)
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        const query = { criadorId: new Types.ObjectId(criadorId) };
        if (req.query.tipo) {
            query.tipo = req.query.tipo;
        }
        const rotinas = await Treino.find(query)
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        })
            .sort({ tipo: 1, atualizadoEm: -1 });
        res.status(200).json(rotinas);
    }
    catch (error) {
        next(error);
    }
});
router.get("/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const criadorId = req.user?.id;
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return res.status(400).json({ mensagem: "ID da rotina inválido." });
        }
        if (!criadorId) {
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        }
        const rotina = await Treino.findOne({ _id: id, criadorId: new Types.ObjectId(criadorId) })
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });
        if (!rotina) {
            return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão." });
        }
        res.status(200).json(rotina);
    }
    catch (error) {
        next(error);
    }
});
router.post("/", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const criadorId = req.user?.id;
        if (!criadorId)
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        const dadosRotina = { ...req.body, criadorId: new Types.ObjectId(criadorId), isCopied: false };
        const novaRotina = new Treino(dadosRotina);
        await novaRotina.save();
        const rotinaPopulada = await Treino.findById(novaRotina._id)
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });
        res.status(201).json(rotinaPopulada);
    }
    catch (error) {
        next(error);
    }
});
router.post("/associar-modelo", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const { fichaModeloId, alunoId } = req.body;
        const criadorId = req.user?.id;
        if (!criadorId)
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        if (!mongoose.Types.ObjectId.isValid(fichaModeloId) || !mongoose.Types.ObjectId.isValid(alunoId)) {
            return res.status(400).json({ mensagem: "IDs inválidos fornecidos." });
        }
        const fichaModelo = await Treino.findOne({ _id: fichaModeloId, criadorId: new Types.ObjectId(criadorId), tipo: 'modelo' });
        if (!fichaModelo)
            return res.status(404).json({ mensagem: "Ficha modelo não encontrada ou você não tem permissão para usá-la." });
        const { _id, criadoEm, atualizadoEm, diasDeTreino, ...modeloRestante } = fichaModelo.toObject();
        const newFichaData = {
            ...modeloRestante,
            tipo: 'individual',
            criadorId: new Types.ObjectId(criadorId),
            alunoId: new Types.ObjectId(alunoId),
            pastaId: null,
            titulo: modeloRestante.titulo,
            isCopied: true,
            diasDeTreino: diasDeTreino?.map((dia) => ({
                identificadorDia: dia.identificadorDia,
                nomeSubFicha: dia.nomeSubFicha,
                ordemNaRotina: dia.ordemNaRotina,
                exerciciosDoDia: dia.exerciciosDoDia?.map((ex) => {
                    const exercicioIdValue = typeof ex.exercicioId === 'object' && ex.exercicioId?._id
                        ? ex.exercicioId._id.toString() : ex.exercicioId.toString();
                    return {
                        exercicioId: new Types.ObjectId(exercicioIdValue),
                        series: ex.series,
                        repeticoes: ex.repeticoes,
                        carga: ex.carga,
                        descanso: ex.descanso,
                        observacoes: ex.observacoes,
                        ordemNoDia: ex.ordemNoDia,
                        concluido: false
                    };
                }) ?? []
            })) ?? []
        };
        const novaFichaIndividual = new Treino(newFichaData);
        await novaFichaIndividual.save();
        const fichaPopulada = await Treino.findById(novaFichaIndividual._id)
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });
        res.status(201).json(fichaPopulada);
    }
    catch (error) {
        console.error("Erro ao associar modelo de treino ao aluno:", error);
        next(error);
    }
});
// <<< INÍCIO DA ROTA CORRIGIDA >>>
// Esta rota agora CRIA um novo modelo a partir de uma rotina existente, em vez de modificá-la.
router.post("/:id/tornar-modelo", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const criadorId = req.user?.id;
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return res.status(400).json({ mensagem: "ID da rotina inválido." });
        }
        if (!criadorId) {
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        }
        // 1. Encontra a rotina original para copiar. Pode ser 'individual' ou 'modelo'.
        const rotinaOriginal = await Treino.findOne({ _id: id, criadorId: new Types.ObjectId(criadorId) });
        if (!rotinaOriginal) {
            return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão para copiá-la." });
        }
        // 2. Cria uma cópia profunda da rotina, removendo campos específicos.
        const { _id, criadoEm, atualizadoEm, alunoId, pastaId, ...restanteDaRotina } = rotinaOriginal.toObject();
        const novaRotinaModeloData = {
            ...restanteDaRotina,
            tipo: 'modelo', // Define o tipo como 'modelo'
            alunoId: null, // Remove a associação com o aluno
            pastaId: null, // Remove a associação com pasta
            titulo: restanteDaRotina.titulo, // Mantém o título original
            isCopied: true, // Marca como uma cópia
            diasDeTreino: restanteDaRotina.diasDeTreino?.map((dia) => ({
                identificadorDia: dia.identificadorDia,
                nomeSubFicha: dia.nomeSubFicha,
                ordemNaRotina: dia.ordemNaRotina,
                exerciciosDoDia: dia.exerciciosDoDia?.map((ex) => {
                    const exercicioIdValue = typeof ex.exercicioId === 'object' && ex.exercicioId?._id
                        ? ex.exercicioId._id.toString() : ex.exercicioId.toString();
                    return {
                        exercicioId: new Types.ObjectId(exercicioIdValue),
                        series: ex.series,
                        repeticoes: ex.repeticoes,
                        carga: ex.carga,
                        descanso: ex.descanso,
                        observacoes: ex.observacoes,
                        ordemNoDia: ex.ordemNoDia,
                        concluido: false
                    };
                }) ?? []
            })) ?? []
        };
        // 3. Salva a nova rotina como um novo documento.
        const novaRotinaModelo = new Treino(novaRotinaModeloData);
        await novaRotinaModelo.save();
        // 4. Popula e retorna o NOVO modelo criado.
        const rotinaPopulada = await Treino.findById(novaRotinaModelo._id)
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });
        res.status(201).json(rotinaPopulada); // Usa 201 Created para indicar criação de novo recurso
    }
    catch (error) {
        console.error("Erro ao copiar rotina para modelo:", error);
        next(error);
    }
});
// <<< FIM DA ROTA CORRIGIDA >>>
router.put("/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const criadorId = req.user?.id;
        if (!mongoose.Types.ObjectId.isValid(id) || !criadorId)
            return res.status(400).json({ mensagem: "Requisição inválida." });
        const rotina = await Treino.findOneAndUpdate({ _id: id, criadorId: new Types.ObjectId(criadorId) }, { $set: req.body }, { new: true, runValidators: true }).populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });
        if (!rotina)
            return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão." });
        res.status(200).json(rotina);
    }
    catch (error) {
        next(error);
    }
});
router.put("/:id/pasta", authenticateToken, async (req, res, next) => {
    await dbConnect();
    const { id: rotinaId } = req.params;
    const { pastaId } = req.body;
    const criadorId = req.user?.id;
    if (!criadorId || !mongoose.Types.ObjectId.isValid(rotinaId))
        return res.status(400).json({ mensagem: "ID da rotina inválido ou usuário não autenticado." });
    if (pastaId && !mongoose.Types.ObjectId.isValid(pastaId))
        return res.status(400).json({ mensagem: "ID da pasta inválido." });
    try {
        if (pastaId) {
            const pastaDestino = await PastaTreino.findOne({ _id: pastaId, criadorId: criadorId });
            if (!pastaDestino)
                return res.status(404).json({ mensagem: "Pasta de destino não encontrada ou você não tem permissão para usá-la." });
        }
        const rotinaAtualizada = await Treino.findOneAndUpdate({ _id: rotinaId, criadorId: criadorId }, { $set: { pastaId: pastaId ? new Types.ObjectId(pastaId) : null } }, { new: true }).populate('pastaId', 'nome')
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });
        if (!rotinaAtualizada)
            return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão para movê-la." });
        res.status(200).json(rotinaAtualizada);
    }
    catch (error) {
        next(error);
    }
});
router.delete("/:id", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const criadorId = req.user?.id;
        if (!mongoose.Types.ObjectId.isValid(id) || !criadorId)
            return res.status(400).json({ mensagem: "Requisição inválida." });
        const resultado = await Treino.findOneAndDelete({ _id: id, criadorId: new Types.ObjectId(criadorId) });
        if (!resultado)
            return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão." });
        res.status(200).json({ mensagem: "Rotina excluída com sucesso." });
    }
    catch (error) {
        next(error);
    }
});
// GET /api/treinos/aluno/:alunoId - Lista as rotinas de um aluno específico (para o personal)
router.get("/aluno/:alunoId", authenticateToken, async (req, res, next) => {
    await dbConnect();
    try {
        const { alunoId } = req.params;
        const criadorId = req.user?.id;
        if (!mongoose.Types.ObjectId.isValid(alunoId)) {
            return res.status(400).json({ mensagem: "ID do aluno inválido." });
        }
        if (!criadorId) {
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        }
        // Buscar rotinas do aluno específico criadas pelo personal logado
        const rotinas = await Treino.find({
            alunoId: new Types.ObjectId(alunoId),
            criadorId: new Types.ObjectId(criadorId),
            tipo: 'individual'
        })
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        })
            .sort({ atualizadoEm: -1 });
        // Transformar para o formato esperado pelo frontend
        const rotinasFormatadas = rotinas.map(rotina => ({
            _id: rotina._id,
            titulo: rotina.titulo,
            descricao: rotina.descricao,
            atualizadoEm: rotina.atualizadoEm
        }));
        res.status(200).json(rotinasFormatadas);
    }
    catch (error) {
        next(error);
    }
});
export default router;

===== ./server/index.ts =====
// server/index.ts

// --- BLOCO DE IMPORTAÇÕES ---
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import express, { Router } from 'express';
import cors, { CorsOptions } from 'cors';
import authRoutes from './src/routes/auth.js';
import convitePublicRoutes from './src/routes/convitePublicRoutes.js';
import conviteAlunoPublicRoutes from './src/routes/conviteAlunoPublicRoutes.js';
import dashboardRoutes from './src/routes/dashboardGeralRoutes.js';
import treinoRoutes from './src/routes/treinos.js';
import exercicioRoutes from './src/routes/exercicios.js';
import sessionsRoutes from './src/routes/sessionsRoutes.js';
import pastaRoutes from './src/routes/pastasTreinos.js';
import alunoApiRoutes from './src/routes/alunoApiRoutes.js';
import adminRoutes from './src/routes/adminRoutes.js';
import activityLogsRoutes from './src/routes/activityLogsRoutes.js'; // <-- 1. IMPORTAÇÃO ADICIONADA
import adminPlanosRoutes from './src/routes/adminPlanosRoutes.js';
import personalPlanosRoutes from './src/routes/personalPlanosRoutes.js';
import adminRenewalRoutes from './src/routes/adminRenewalRoutes.js';
import personalRenewalRoutes from './src/routes/personalRenewalRoutes.js';
import { authenticateToken } from './middlewares/authenticateToken.js';
import { authorizeAdmin } from './middlewares/authorizeAdmin.js';
import { errorHandler } from './middlewares/errorHandler.js';
import dbConnect from './lib/dbConnect.js';


// --- CONFIGURAÇÃO DE AMBIENTE ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
dotenv.config({ path: path.resolve(__dirname, '.env') });

const app = express();
const apiRouter = Router();

// --- CONFIGURAÇÃO DE CORS E MIDDLEWARES GLOBAIS ---
const allowedOrigins = [
  'http://localhost:5173', 'http://localhost:4173', process.env.FRONTEND_URL, 
].filter(Boolean) as string[];

const corsOptions: CorsOptions = {
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin) || origin.endsWith('.gitpod.io') || origin.endsWith('.vercel.app')) {
      callback(null, true);
    } else {
      console.warn(`CORS: Requisição bloqueada da origem: ${origin}`);
      callback(new Error('Não permitido pela política de CORS'));
    }
  },
  methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
  credentials: true,
  optionsSuccessStatus: 204
};

app.use(cors(corsOptions));
app.use(express.json());

// --- ESTRUTURA DE ROTAS ---
app.use('/api', apiRouter);

// --- 1. Rotas Públicas ---
apiRouter.use('/public/convites', convitePublicRoutes);
apiRouter.use('/public/convite-aluno', conviteAlunoPublicRoutes);
apiRouter.use('/auth', authRoutes);

// --- 2. Rotas Protegidas ---
// A autenticação é aplicada diretamente ou dentro de cada arquivo de rota.
apiRouter.use('/admin', authenticateToken, authorizeAdmin, adminRoutes);
apiRouter.use('/admin', adminPlanosRoutes); // Plan management routes (auth applied inside)
apiRouter.use('/admin/renewal-requests', adminRenewalRoutes); // Admin renewal requests (auth applied inside)
apiRouter.use('/personal', personalPlanosRoutes); // Personal trainer plan routes (auth applied inside)
apiRouter.use('/personal/renewal-requests', personalRenewalRoutes); // Personal renewal requests (auth applied inside)
apiRouter.use('/dashboard/geral', authenticateToken, dashboardRoutes);
apiRouter.use('/treinos', authenticateToken, treinoRoutes);
apiRouter.use('/exercicios', authenticateToken, exercicioRoutes);
apiRouter.use('/pastas/treinos', authenticateToken, pastaRoutes);
apiRouter.use('/activity-logs', authenticateToken, activityLogsRoutes); // <-- 2. REGISTRO DA ROTA ADICIONADO

apiRouter.use('/aluno', alunoApiRoutes);
apiRouter.use('/alunos', alunoApiRoutes); // Add alias for consistency with client expectations
apiRouter.use('/sessions', sessionsRoutes);

// --- 3. Tratamento de Erros ---
app.use(errorHandler);

// --- EXPORTAÇÃO E INICIALIZAÇÃO ---
export default app;

const startServer = async () => {
  try {
    await dbConnect();
    console.log('Banco de dados conectado com sucesso!');
    
    if (process.env.NODE_ENV === 'development') {
      const PORT = process.env.PORT || 5000;
      app.listen(PORT, () => {
        console.log(`[DEV] Servidor Express de desenvolvimento rodando em http://localhost:${PORT}`);
      });
    }
  } catch (error) {
    console.error('Falha ao conectar ao banco de dados:', error);
    process.exit(1); // Encerra o processo se a conexão com o DB falhar
  }
};

startServer();

===== ./server/jobs/planExpiryNotifier.ts =====
// server/jobs/planExpiryNotifier.ts
import PersonalPlano from '../models/PersonalPlano.js';
import { sendNotification } from '../services/NotificationService.js';

/**
 * Agenda uma verificação diária para notificar os personais
 * quando seus planos estiverem a X dias de vencer.
 * Sem necessidade de node-cron.
 */
export function startPlanExpiryNotifier() {
  const ONE_DAY_MS = 24 * 60 * 60 * 1000;

  async function checkExpiringPlans() {
    const now = new Date();
    const inThreeDays = new Date(now.getTime() + 3 * ONE_DAY_MS);

    // Planos que vencem entre agora e os próximos 3 dias
    const expiringPlans = await PersonalPlano.find({
      dataVencimento: { $lte: inThreeDays, $gt: now },
      ativo: true,
    });

    for (const plan of expiringPlans) {
      const userId = plan.personalTrainerId.toString();
      await sendNotification(
        userId,
        'Seu plano vence em breve. Solicite a renovação ou fale com o administrador.'
      );
    }
  }

  // Executa imediatamente e agenda para rodar a cada 24h
  checkExpiringPlans();
  setInterval(checkExpiringPlans, ONE_DAY_MS);
}

===== ./server/lib/dbConnect.ts =====
import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('Por favor, defina a variável de ambiente MONGODB_URI no seu .env ou na Vercel');
}

/**
 * Cache de conexão global. Isso evita criar uma nova conexão a cada
 * invocação da função serverless em um "warm start".
 */
let cached = (global as any).mongoose;

if (!cached) {
  cached = (global as any).mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    // Se já temos uma conexão em cache, a reutilizamos.
    console.log('=> Usando conexão de banco de dados em cache');
    return cached.conn;
  }

  if (!cached.promise) {
    // Se não há uma conexão em cache, criamos uma nova.
    const opts = {
      bufferCommands: false, // Desabilitar o buffer é uma boa prática em serverless
      maxPoolSize: 10, // Maintain up to 10 socket connections
      serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
      socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
      family: 4, // Use IPv4, skip trying IPv6
      dbName: "dyfit", // Specify database name
    };

    console.log('=> Criando NOVA conexão com o banco de dados');
    cached.promise = mongoose.connect(MONGODB_URI!, opts).then((mongoose) => {
      console.log('✅ Conectado ao MongoDB Atlas com sucesso!');
      
      // Add event listeners for better error handling
      mongoose.connection.on('error', (err) => {
        console.error("❌ Erro na conexão com MongoDB:", err);
      });

      mongoose.connection.on('disconnected', () => {
        console.log("ℹ️  Desconectado do MongoDB.");
      });

      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    console.error('❌ Erro ao conectar ao MongoDB:', e);
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

===== ./server/middlewares/authenticateAdmin.ts =====
// server/middlewares/authenticateAdmin.ts
import { Request, Response, NextFunction } from "express";
import { authenticateToken } from "./authenticateToken.js";

/**
 * Este middleware garante que o usuário esteja autenticado e possua o papel de administrador.
 * Assuma que `req.user.role` é preenchido pelo authenticateToken.
 */
export function authenticateAdmin(req: Request, res: Response, next: NextFunction) {
  authenticateToken(req, res, (err?: any) => {
    if (err) {
      return; // authenticateToken já tratou a resposta
    }
    const user = (req as any).user;
    if (!user || (user.role !== "admin" && user.role !== "administrator")) {
      return res.status(403).json({ message: "Acesso negado. Somente administradores podem realizar esta ação." });
    }
    next();
  });
}

===== ./server/middlewares/authenticateAlunoToken.ts =====
// server/middlewares/authenticateAlunoToken.ts
import { Request, Response, NextFunction } from 'express';
import jwt, { Secret, JwtPayload } from 'jsonwebtoken';
import Aluno from '../models/Aluno.js';
import dbConnect from '../lib/dbConnect.js';

export const authenticateAlunoToken = async (req: Request, res: Response, next: NextFunction) => {
  // Garante conexão com o banco ANTES de consultar
  try {
    await dbConnect();
  } catch (dbError) {
    console.error("[Auth Aluno Middleware] ERRO CRÍTICO: Falha ao conectar ao banco de dados.", dbError);
    return res.status(500).json({
      message: 'Erro interno de conexão com o serviço.',
      code: 'DATABASE_CONNECTION_ERROR'
    });
  }

  const authHeader = req.headers['authorization'];
  const token = authHeader?.startsWith('Bearer ') ? authHeader.split(' ')[1] : null;

  if (!token) {
    console.log("[Auth Aluno Middleware] Falha: Token não fornecido. IP:", req.ip, "User-Agent:", req.get('User-Agent'));
    return res.status(401).json({
      message: 'Acesso não autorizado. Token de aluno não fornecido.',
      code: 'TOKEN_NOT_PROVIDED'
    });
  }

  const JWT_SECRET = process.env.JWT_SECRET as Secret;
  if (!JWT_SECRET) {
    console.error("[Auth Aluno Middleware] ERRO CRÍTICO: JWT_SECRET não está definido.");
    return res.status(500).json({
      message: 'Erro interno de configuração do servidor.',
      code: 'SERVER_CONFIGURATION_ERROR'
    });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;

    if (!decoded.id) {
      console.warn(`[Auth Aluno Middleware] Token sem 'id'. IP:`, req.ip);
      return res.status(403).json({
        message: 'Acesso proibido. Token de aluno com formato inválido.',
        code: 'INVALID_TOKEN_PAYLOAD'
      });
    }

    // Apenas tokens com role 'aluno' podem passar neste middleware
    if ((decoded.role || '').toString().toLowerCase() === 'aluno') {
      const aluno = await Aluno.findById(decoded.id).select('status').lean();
      if (!aluno || aluno.status !== 'active') {
        console.warn(`[Auth Aluno Middleware] Aluno inativo ou não encontrado - ID: ${decoded.id}, IP:`, req.ip);
        return res.status(403).json({
          message: 'Sua conta está inativa. Fale com seu personal trainer.',
          code: 'ACCOUNT_INACTIVE'
        });
      }

      (req as any).aluno = {
        id: decoded.id,
        role: 'aluno',
        nome: decoded.nome,
        email: decoded.email,
        personalId: decoded.personalId,
      };
      return next();
    }

    console.warn(`[Auth Aluno Middleware] Token com role inválida ('${decoded.role}') para rota de aluno. IP:`, req.ip);
    return res.status(403).json({
      message: 'Acesso proibido. Esta rota é exclusiva para alunos.',
      code: 'UNAUTHORIZED_ROLE'
    });

  } catch (err: any) {
    console.warn(`[Auth Aluno Middleware] Falha na verificação do token - ${err.name}: ${err.message}. IP:`, req.ip);
    if (err instanceof jwt.TokenExpiredError) {
      return res.status(401).json({ message: 'Sessão de aluno expirada. Faça login novamente.', code: 'TOKEN_EXPIRED' });
    }
    if (err instanceof jwt.JsonWebTokenError) {
      return res.status(403).json({ message: 'Acesso proibido. Token de aluno inválido.', code: 'INVALID_TOKEN' });
    }
    return res.status(500).json({ message: 'Erro interno ao processar o token de aluno.', code: 'TOKEN_PROCESSING_ERROR' });
  }
};

===== ./server/middlewares/authenticateToken.ts =====
// server/middlewares/authenticateToken.ts
import { Request, Response, NextFunction } from 'express';
import jwt, { Secret, JwtPayload } from 'jsonwebtoken';

export const authenticateToken = (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader?.startsWith('Bearer ') ? authHeader.split(' ')[1] : null;

    if (!token) {
        console.log("[Auth Middleware] Falha: Token não fornecido no cabeçalho. IP:", req.ip, "User-Agent:", req.get('User-Agent'));
        // Adicionado código de erro específico para token não fornecido
        return res.status(401).json({ message: 'Acesso não autorizado. Token não fornecido.', code: 'TOKEN_NOT_PROVIDED' });
    }

    const JWT_SECRET = process.env.JWT_SECRET as Secret;
    if (!JWT_SECRET) {
        console.error("[Auth Middleware] ERRO CRÍTICO: JWT_SECRET não está definido no .env");
        return res.status(500).json({ 
            message: 'Erro interno de configuração do servidor.', 
            code: 'SERVER_CONFIGURATION_ERROR' 
        });
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET) as JwtPayload;

        // Converte a role para minúsculo antes de comparar
        const userRole = decoded.role?.toLowerCase();

        if (userRole === 'personal' || userRole === 'admin') {
            req.user = {
                id: decoded.id,
                // Retorna a role original do token para consistência
                role: decoded.role, 
                firstName: decoded.firstName, 
                lastName: decoded.lastName,
                email: decoded.email
            };
            console.log(`[Auth Middleware] Sucesso: Usuário autenticado - ID: ${decoded.id}, Role: ${decoded.role}`);
            return next();
        }
        
        // Se o token for válido, mas a role for de Aluno ou outra inesperada, nega o acesso.
        console.warn(`[Auth Middleware] Falha: Token válido, mas com role não autorizada ('${decoded.role}') para esta rota. IP:`, req.ip);
        // Adicionado código de erro específico para role não autorizada
        return res.status(403).json({ message: 'Acesso proibido. Você não tem permissão para acessar este recurso.', code: 'UNAUTHORIZED_ROLE' });

    } catch (err: any) {
        console.warn(`[Auth Middleware] Falha na verificação do token - ${err.name}: ${err.message}. IP:`, req.ip);
        if (err instanceof jwt.TokenExpiredError) {
            // Código de erro para token expirado já existia
            return res.status(401).json({ message: 'Sessão expirada. Faça login novamente.', code: 'TOKEN_EXPIRED' });
        }
        if (err instanceof jwt.JsonWebTokenError) {
            // Adicionado código de erro específico para token inválido (genérico)
            return res.status(403).json({ message: 'Acesso proibido. Token inválido.', code: 'INVALID_TOKEN' });
        }
        // Código de erro genérico para outros erros de processamento do token
        return res.status(500).json({ message: 'Erro interno ao processar o token.', code: 'TOKEN_PROCESSING_ERROR' });
    }
};

===== ./server/middlewares/authorizeAdmin.ts =====
// server/middlewares/authorizeAdmin.ts
import { Request, Response, NextFunction } from 'express';

// Não precisamos mais da interface 'AuthenticatedRequest' importada,
// pois nosso 'index.d.ts' já estende a interface global do Express.

export function authorizeAdmin(req: Request, res: Response, next: NextFunction) {
  // Padroniza a verificação para 'admin' (minúsculo).
  if (req.user && req.user.role === 'admin') {
    return next(); // Usuário é admin, permite o acesso.
  } else {
    // Se não for admin, retorna erro 403.
    return res.status(403).json({ mensagem: "Acesso negado. Esta funcionalidade é restrita a administradores." });
  }
}
===== ./server/middlewares/checkLimiteAlunos.ts =====
// server/middlewares/checkLimiteAlunos.ts
import { Request, Response, NextFunction } from 'express';
import PlanoService from '../services/PlanoService.js';

/**
 * Middleware to check if personal trainer can activate more students
 */
export const checkLimiteAlunos = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const personalTrainerId = req.user?.id;
        
        if (!personalTrainerId) {
            return res.status(401).json({ 
                message: 'Usuário não autenticado',
                code: 'UNAUTHORIZED'
            });
        }

        // Skip check for admins
        if (req.user?.role === 'admin') {
            return next();
        }

        // Get requested quantity from body or default to 1
        const quantidadeDesejada = req.body.quantidade || 1;

        const status = await PlanoService.canActivateMoreStudents(personalTrainerId, quantidadeDesejada);

        if (!status.canActivate) {
            return res.status(403).json({
                message: 'Limite de alunos ativos excedido',
                code: 'STUDENT_LIMIT_EXCEEDED',
                data: {
                    currentLimit: status.currentLimit,
                    activeStudents: status.activeStudents,
                    availableSlots: status.availableSlots,
                    requestedQuantity: quantidadeDesejada
                }
            });
        }

        // Add status to request for potential use in controller
        (req as any).studentLimitStatus = status;
        next();
    } catch (error) {
        console.error('Error in checkLimiteAlunos middleware:', error);
        res.status(500).json({ 
            message: 'Erro interno do servidor',
            code: 'INTERNAL_ERROR'
        });
    }
};

/**
 * Middleware to check if personal trainer can activate a specific student
 * Used when activating an existing inactive student
 */
export const checkCanActivateStudent = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const personalTrainerId = req.user?.id;
        
        if (!personalTrainerId) {
            return res.status(401).json({ 
                message: 'Usuário não autenticado',
                code: 'UNAUTHORIZED'
            });
        }

        // Skip check for admins
        if (req.user?.role === 'admin') {
            return next();
        }

        const status = await PlanoService.canActivateMoreStudents(personalTrainerId, 1);

        if (!status.canActivate) {
            return res.status(403).json({
                message: 'Não é possível ativar mais alunos. Limite excedido.',
                code: 'STUDENT_LIMIT_EXCEEDED',
                data: {
                    currentLimit: status.currentLimit,
                    activeStudents: status.activeStudents,
                    availableSlots: status.availableSlots
                }
            });
        }

        next();
    } catch (error) {
        console.error('Error in checkCanActivateStudent middleware:', error);
        res.status(500).json({ 
            message: 'Erro interno do servidor',
            code: 'INTERNAL_ERROR'
        });
    }
};
===== ./server/middlewares/ensureDatabase.ts =====
// server/middlewares/ensureDatabase.ts
import dbConnect from '../lib/dbConnect.js';
import { Request, Response, NextFunction } from 'express';

/**
 * Middleware to ensure database connection is established before processing requests
 */
export async function ensureDatabase(req: Request, res: Response, next: NextFunction) {
    try {
        console.log(`🔌 Ensuring database connection for ${req.method} ${req.path}`);
        await dbConnect();
        next();
    } catch (error) {
        console.error('❌ Database connection failed:', error);
        
        res.status(503).json({
            message: 'Serviço temporariamente indisponível. Tente novamente em alguns instantes.',
            error: 'DATABASE_CONNECTION_FAILED',
            timestamp: new Date().toISOString()
        });
    }
}
===== ./server/middlewares/errorHandler.ts =====
// server/middlewares/errorHandler.ts
import { Request, Response, NextFunction } from "express";

export interface AppError extends Error {
  statusCode?: number;
  isOperational?: boolean;
  code?: string; // Adicionado código de erro específico
}

// Função para categorizar erros comuns
const categorizeError = (err: AppError): { status: number; message: string; code: string } => {
  // Erros do MongoDB/Mongoose
  if (err.name === 'ValidationError') {
    return {
      status: 400,
      message: 'Dados fornecidos são inválidos.',
      code: 'VALIDATION_ERROR'
    };
  }
  
  if (err.name === 'CastError') {
    return {
      status: 400,
      message: 'ID fornecido é inválido.',
      code: 'INVALID_ID'
    };
  }
  
  if (err.name === 'MongoServerError' && (err as any).code === 11000) {
    return {
      status: 409,
      message: 'Dados duplicados. Este registro já existe.',
      code: 'DUPLICATE_ERROR'
    };
  }
  
  // Erros de conexão com banco
  if (err.name === 'MongoNetworkError' || err.message?.includes('connection')) {
    return {
      status: 503,
      message: 'Serviço temporariamente indisponível. Tente novamente em alguns instantes.',
      code: 'SERVICE_UNAVAILABLE'
    };
  }
  
  // Erros de autenticação JWT
  if (err.name === 'JsonWebTokenError') {
    return {
      status: 401,
      message: 'Token de acesso inválido.',
      code: 'INVALID_TOKEN'
    };
  }
  
  if (err.name === 'TokenExpiredError') {
    return {
      status: 401,
      message: 'Sessão expirada. Faça login novamente.',
      code: 'TOKEN_EXPIRED'
    };
  }
  
  // Erros operacionais conhecidos
  if (err.isOperational) {
    return {
      status: err.statusCode || 500,
      message: err.message,
      code: err.code || 'OPERATIONAL_ERROR'
    };
  }
  
  // Erro genérico
  return {
    status: err.statusCode || 500,
    message: err.message || 'Erro interno no servidor.',
    code: err.code || 'INTERNAL_SERVER_ERROR'
  };
};

export function errorHandler(
  err: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) {
  console.error("❌ Erro capturado pelo middleware:", {
    name: err.name,
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  const { status, message, code } = categorizeError(err);
  
  const response = {
    sucesso: false,
    message: message,
    code: code,
    ...(process.env.NODE_ENV === "development" && { 
      detalhes: err.stack,
      originalError: err.name 
    }),
  };

  res.status(status).json(response);
}

===== ./server/models/Aluno.ts =====
// server/models/Aluno.ts
import mongoose, { Schema, Document } from "mongoose";
import bcrypt from 'bcryptjs';

export interface IAluno extends Document {
  nome: string;
  email: string;
  passwordHash?: string;
  phone?: string;
  // <<< CORREÇÃO: Campos agora são opcionais >>>
  birthDate?: string;
  gender?: string;
  goal?: string;
  weight?: number;
  height?: number;
  startDate?: string;
  status: 'active' | 'inactive';
  notes?: string;
  trainerId: mongoose.Types.ObjectId;
  /**
   * Informações de slot (plano ou token) que este aluno utiliza.
   * slotType: 'plan' indica que o aluno conta dentro do limite do plano,
   * 'token' indica que utiliza um token avulso. slotId referencia o registro
   * de PersonalPlano ou TokenAvulso correspondente. slotStartDate e
   * slotEndDate definem o período de validade desse slot.
   */
  slotType?: 'plan' | 'token';
  slotId?: mongoose.Types.ObjectId;
  slotStartDate?: Date;
  slotEndDate?: Date;
  createdAt: Date;
  updatedAt: Date;
  comparePassword(candidatePassword: string): Promise<boolean>;
}

const alunoSchema = new Schema<IAluno>(
  {
    nome: {
      type: String,
      required: [true, 'O nome completo é obrigatório'],
      trim: true
    },
    email: {
      type: String,
      required: [true, 'O email é obrigatório'],
      unique: true,
      lowercase: true,
      trim: true,
    },
    passwordHash: {
      type: String,
      required: [true, 'A senha é obrigatória'],
      select: false,
    },
    phone: { type: String, trim: true },
    // <<< CORREÇÃO: Removida a obrigatoriedade (required: true) dos campos abaixo >>>
    birthDate: { type: String },
    gender: { type: String },
    goal: { type: String },
    weight: { type: Number },
    height: { type: Number },
    startDate: { type: String },
    status: {
      type: String,
      required: true,
      enum: ['active', 'inactive'],
      default: 'active'
    },
    notes: { type: String },
    trainerId: {
      type: Schema.Types.ObjectId,
      ref: 'PersonalTrainer',
      required: [true, 'O ID do treinador é obrigatório']
    },
    // Novos campos para armazenar a vaga (slot) do aluno
    slotType: { type: String, enum: ['plan', 'token'], required: false },
    slotId: { type: Schema.Types.ObjectId, required: false },
    slotStartDate: { type: Date, required: false },
    slotEndDate: { type: Date, required: false },
  },
  {
    timestamps: true
  }
);

// Hash de senha antes de salvar
alunoSchema.pre<IAluno>('save', async function (next) {
  if (!this.isModified('passwordHash')) {
    return next();
  }
  try {
    const saltRounds = 10;
    if (this.passwordHash) {
      this.passwordHash = await bcrypt.hash(this.passwordHash, saltRounds);
    }
    next();
  } catch (error: any) {
    next(error);
  }
});

// Método para comparar senha
alunoSchema.methods.comparePassword = async function (candidatePassword: string): Promise<boolean> {
  if (!this.passwordHash) {
    return false;
  }
  return bcrypt.compare(candidatePassword, this.passwordHash);
};

export default mongoose.model<IAluno>("Aluno", alunoSchema);
===== ./server/models/Contato.ts =====
// server/models/Contato.ts
import mongoose, { Document, Schema, Types } from 'mongoose';

// Interface para tipar os documentos de Contato
export interface IContato extends Document {
  nomeCompleto: string;
  email: string;
  telefone?: string;
  dataNascimento?: Date;
  genero?: string;
  personalId: Types.ObjectId; // Referência ao PersonalTrainer
  status: 'novo' | 'convertido_aluno' | 'arquivado' | 'contatado'; // Status do lead/contato
  anotacoesPersonal?: string; // Anotações que o personal pode fazer
  dataCadastro: Date;
  origemToken?: string; // Token do personal que originou este contato
  // Adicione quaisquer outros campos que você achar relevantes
}

const ContatoSchema: Schema<IContato> = new Schema({
  nomeCompleto: {
    type: String,
    required: [true, 'O nome completo é obrigatório.'],
    trim: true,
    minlength: [3, 'O nome completo deve ter pelo menos 3 caracteres.'],
  },
  email: {
    type: String,
    required: [true, 'O e-mail é obrigatório.'],
    trim: true,
    lowercase: true,
    // Validação de formato de e-mail simples (pode ser aprimorada)
    match: [/.+\@.+\..+/, 'Por favor, insira um e-mail válido.'],
    // Considerar adicionar um índice único composto com personalId se um email só puder se registrar uma vez por personal
    // index: { unique: true, partialFilterExpression: { status: 'novo' } } // Exemplo, ajuste conforme necessário
  },
  telefone: {
    type: String,
    trim: true,
    // Validação opcional de formato de telefone
  },
  dataNascimento: {
    type: Date,
  },
  genero: {
    type: String,
    enum: ['masculino', 'feminino', 'outro', 'prefiro_nao_dizer'], // Exemplo de opções
  },
  personalId: {
    type: Schema.Types.ObjectId,
    ref: 'PersonalTrainer', // Certifique-se que 'PersonalTrainer' é o nome do seu modelo de personal
    required: true,
    index: true,
  },
  status: {
    type: String,
    enum: ['novo', 'convertido_aluno', 'arquivado', 'contatado'],
    default: 'novo',
    index: true,
  },
  anotacoesPersonal: {
    type: String,
    trim: true,
  },
  dataCadastro: {
    type: Date,
    default: Date.now,
  },
  origemToken: { // Para rastrear qual link de personal gerou este contato
    type: String,
  }
  // Você pode adicionar timestamps automáticos do Mongoose se preferir
  // }, { timestamps: true });
});

// Middleware para evitar que um mesmo email (em status 'novo') seja cadastrado para o mesmo personal.
// Esta é uma abordagem. Outra seria um índice único composto como comentado acima.
ContatoSchema.pre<IContato>('save', async function (next) {
  if (this.isNew && this.status === 'novo') {
    const existingContact = await mongoose.model('Contato').findOne({
      email: this.email,
      personalId: this.personalId,
      status: 'novo' // Verifica apenas contatos que ainda não foram convertidos ou arquivados
    });
    if (existingContact) {
      const err = new Error(`Este e-mail já foi registrado como um novo contato para este personal.`) as any;
      err.status = 409; // Conflict
      return next(err);
    }
  }
  next();
});


export default mongoose.model<IContato>('Contato', ContatoSchema);

===== ./server/models/ConviteAluno.ts =====
// server/models/ConviteAluno.ts
import mongoose, { Schema, Document } from 'mongoose';
import crypto from 'crypto';

export interface IConviteAluno extends Document {
  token: string;
  emailConvidado?: string; // Alterado para opcional
  status: 'pendente' | 'utilizado' | 'expirado';
  dataExpiracao: Date;
  criadoPor: mongoose.Types.ObjectId; // ID do PersonalTrainer que criou o convite
  usadoPor?: mongoose.Types.ObjectId; // ID do Aluno que utilizou o convite
}

const ConviteAlunoSchema: Schema<IConviteAluno> = new Schema(
  {
    token: {
      type: String,
      unique: true,
      required: true,
      default: () => crypto.randomBytes(20).toString('hex'),
    },
    emailConvidado: {
      type: String,
      required: false, // Alterado para opcional
      lowercase: true,
      trim: true,
    },
    status: {
      type: String,
      required: true,
      enum: ['pendente', 'utilizado', 'expirado'],
      default: 'pendente',
    },
    dataExpiracao: {
      type: Date,
      required: true,
      // Expira em 7 dias por padrão
      default: () => new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    },
    criadoPor: {
      type: Schema.Types.ObjectId,
      ref: 'PersonalTrainer',
      required: true,
    },
    usadoPor: {
      type: Schema.Types.ObjectId,
      ref: 'Aluno',
    },
  },
  {
    timestamps: true,
  }
);

const ConviteAluno = mongoose.model<IConviteAluno>('ConviteAluno', ConviteAlunoSchema);

export default ConviteAluno;

===== ./server/models/ConvitePersonal.ts =====
// server/models/ConvitePersonal.ts
import mongoose, { Schema, Document } from 'mongoose';
import crypto from 'crypto';

export interface IConvitePersonal extends Document {
  token: string;
  emailConvidado?: string; // Email para o qual o convite foi especificamente enviado (opcional)
  roleConvidado: 'Personal Trainer' | 'Admin'; // Role a ser atribuída ao se registrar
  status: 'pendente' | 'utilizado' | 'expirado';
  dataExpiracao?: Date;
  criadoPor: mongoose.Types.ObjectId; // ID do Admin que criou o convite
  usadoPor?: mongoose.Types.ObjectId; // ID do PersonalTrainer que utilizou o convite
  dataUtilizacao?: Date;
  createdAt: Date;
  updatedAt: Date;
}

const ConvitePersonalSchema: Schema<IConvitePersonal> = new Schema(
  {
    token: {
      type: String,
      unique: true,
      required: true,
    },
    emailConvidado: {
      type: String,
      lowercase: true,
      trim: true,
      // Não é obrigatório, convite pode ser genérico
    },
    roleConvidado: {
      type: String,
      required: true,
      enum: ['Personal Trainer', 'Admin'],
      default: 'Personal Trainer',
    },
    status: {
      type: String,
      required: true,
      enum: ['pendente', 'utilizado', 'expirado'],
      default: 'pendente',
    },
    dataExpiracao: {
      type: Date,
      // Pode ser definido para expirar, por exemplo, em 7 dias
    },
    criadoPor: {
      type: Schema.Types.ObjectId,
      ref: 'PersonalTrainer', // Referencia o modelo de quem pode criar convites (Admin)
      required: true,
    },
    usadoPor: {
      type: Schema.Types.ObjectId,
      ref: 'PersonalTrainer', // Referencia o modelo do usuário que se registrou com este convite
    },
    dataUtilizacao: {
      type: Date,
    },
  },
  {
    timestamps: true,
  }
);

// Hook pre-save para gerar o token automaticamente se não fornecido
// (embora geralmente o token seja gerado na lógica da rota e passado para o modelo)
ConvitePersonalSchema.pre<IConvitePersonal>('validate', function (next) {
  if (!this.token) {
    this.token = crypto.randomBytes(20).toString('hex');
  }
  // Se não houver data de expiração, define para 7 dias a partir de agora, por exemplo
  if (!this.dataExpiracao) {
    const umaSemanaEmMs = 7 * 24 * 60 * 60 * 1000;
    this.dataExpiracao = new Date(Date.now() + umaSemanaEmMs);
  }
  next();
});

const ConvitePersonal = mongoose.model<IConvitePersonal>('ConvitePersonal', ConvitePersonalSchema);

export default ConvitePersonal;

===== ./server/models/Exercicio.ts =====
// Caminho: ./server/models/Exercicio.ts
import mongoose, { Document, Schema, Types } from "mongoose";

export interface IExercicio extends Document {
  nome: string;
  descricao?: string;
  categoria?: string; // Ex: Superior, Inferior, Core
  grupoMuscular?: string; // Ex: Peito, Costas, Pernas
  tipo?: string; // Ex: Musculação, Calistenia, Funcional (pode ser o mesmo que categoria ou um campo adicional)
  urlVideo?: string;
  isCustom: boolean; // true se criado pelo personal, false se for do sistema/app
  creatorId?: Types.ObjectId; // ID do PersonalTrainer que criou (se isCustom for true)
  favoritedBy: Types.ObjectId[]; // Array de IDs de PersonalTrainers que favoritaram
  createdAt?: Date;
  updatedAt?: Date;
}

const ExercicioSchema = new Schema<IExercicio>({
  nome: { type: String, required: true, trim: true },
  descricao: { type: String, trim: true },
  categoria: { type: String, trim: true },
  grupoMuscular: { type: String, trim: true, index: true }, // Principal grupo muscular trabalhado - MANTÉM ESTE
  tipo: { type: String, trim: true },
  urlVideo: { type: String, trim: true },
  isCustom: { type: Boolean, required: true, default: false },
  creatorId: {
    type: Schema.Types.ObjectId,
    ref: "PersonalTrainer",
    required: function(this: IExercicio) { return this.isCustom; }
  },
  favoritedBy: [{
    type: Schema.Types.ObjectId,
    ref: "PersonalTrainer"
  }],
}, {
  timestamps: true
});

// Índice para busca por nome (case-insensitive)
ExercicioSchema.index({ nome: 'text' });
// ExercicioSchema.index({ grupoMuscular: 1 }); // <<< REMOVER ESTA LINHA
ExercicioSchema.index({ categoria: 1 });
ExercicioSchema.index({ isCustom: 1, creatorId: 1 });


export default mongoose.model<IExercicio>("Exercicio", ExercicioSchema);
===== ./server/models/Notification.ts =====
// server/models/Notification.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface INotification extends Document {
  userId: mongoose.Types.ObjectId;
  message: string;
  read: boolean;
  createdAt: Date;
}

const NotificationSchema = new Schema<INotification>({
  userId: { type: Schema.Types.ObjectId, required: true, ref: 'User' }, // pode ser Personal ou Admin
  message: { type: String, required: true },
  read: { type: Boolean, default: false },
  createdAt: { type: Date, default: Date.now },
});

export default mongoose.model<INotification>('Notification', NotificationSchema);

===== ./server/models/Pasta.ts =====
// server/models/Pasta.ts
import mongoose, { Schema, Document } from 'mongoose';

console.log("--- [server/models/Pasta.ts] Definindo Modelo Pasta (Referência Corrigida) ---");

// Interface para tipar o documento Pasta
export interface IPasta extends Document {
  nome: string;
  criadorId: mongoose.Types.ObjectId; // Referência ao PersonalTrainer (_id do usuário)
  ordem?: number; 
  createdAt: Date;
  updatedAt: Date;
}

const pastaSchema = new Schema<IPasta>(
  {
    nome: {
      type: String,
      required: [true, 'O nome da pasta é obrigatório.'],
      trim: true,
      minlength: [1, 'O nome da pasta não pode estar vazio.'],
      maxlength: [100, 'O nome da pasta não pode exceder 100 caracteres.'],
    },
    criadorId: {
      type: Schema.Types.ObjectId,
      ref: 'PersonalTrainer', // <<< CORREÇÃO APLICADA AQUI
      required: true,
    },
    ordem: { 
      type: Number,
      default: 0, 
    },
  },
  {
    timestamps: true,
  }
);

// Index para otimizar buscas por criadorId e nome
pastaSchema.index({ criadorId: 1, nome: 1 });
pastaSchema.index({ criadorId: 1, ordem: 1 });

export default mongoose.model<IPasta>('PastaTreino', pastaSchema);

===== ./server/models/PersonalPlano.ts =====
// server/models/PersonalPlano.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IPersonalPlano extends Document {
    personalTrainerId: mongoose.Types.ObjectId;
    planoId: mongoose.Types.ObjectId;
    dataInicio: Date;
    dataVencimento: Date;
    ativo: boolean;
    atribuidoPorAdmin: mongoose.Types.ObjectId; // ID do admin que atribuiu
    motivoAtribuicao?: string;
    createdAt: Date;
    updatedAt: Date;
}

const personalPlanoSchema: Schema<IPersonalPlano> = new Schema(
    {
        personalTrainerId: {
            type: Schema.Types.ObjectId,
            ref: 'PersonalTrainer',
            required: [true, 'O ID do Personal Trainer é obrigatório.'],
        },
        planoId: {
            type: Schema.Types.ObjectId,
            ref: 'Plano',
            required: [true, 'O ID do plano é obrigatório.'],
        },
        dataInicio: {
            type: Date,
            required: [true, 'A data de início é obrigatória.'],
            default: Date.now,
        },
        dataVencimento: {
            type: Date,
            required: [true, 'A data de vencimento é obrigatória.'],
        },
        ativo: {
            type: Boolean,
            default: true,
        },
        atribuidoPorAdmin: {
            type: Schema.Types.ObjectId,
            ref: 'PersonalTrainer', // Assuming admin is also a PersonalTrainer with role 'Admin'
            required: [true, 'O ID do admin é obrigatório.'],
        },
        motivoAtribuicao: {
            type: String,
            trim: true,
        },
    },
    {
        timestamps: true,
    }
);

// Index for efficient queries
personalPlanoSchema.index({ personalTrainerId: 1, ativo: 1 });
personalPlanoSchema.index({ dataVencimento: 1 });
personalPlanoSchema.index({ personalTrainerId: 1, dataVencimento: 1 });

const PersonalPlano = mongoose.model<IPersonalPlano>('PersonalPlano', personalPlanoSchema);

export default PersonalPlano;
===== ./server/models/PersonalTrainer.ts =====
// server/models/PersonalTrainer.ts
import mongoose, { Schema, Document } from 'mongoose';
import bcrypt from 'bcryptjs';
import crypto from 'crypto'; // Importar crypto para gerar o token

// Interface atualizada para incluir todos os campos planejados
export interface IPersonalTrainer extends Document {
    nome: string;
    email: string;
    passwordHash: string; // Mantido como passwordHash conforme seu arquivo
    role: 'Personal Trainer' | 'Admin';
    tokenCadastroAluno?: string; // Token para o link de cadastro de alunos
    
    // Campos de Assinatura
    planoId?: string; // Ex: 'mensal_5_alunos', 'anual_ilimitado'
    statusAssinatura?: 'ativa' | 'inativa' | 'pendente_pagamento' | 'cancelada' | 'trial' | 'sem_assinatura';
    dataInicioAssinatura?: Date;
    dataFimAssinatura?: Date;
    idAssinaturaGateway?: string; // ID da assinatura no provedor de pagamento
    limiteAlunos?: number; // Limite de alunos ativos com base no plano

    createdAt: Date;
    updatedAt: Date;
    comparePassword(password: string): Promise<boolean>;
}

const personalTrainerSchema: Schema<IPersonalTrainer> = new Schema(
    {
        nome: {
            type: String,
            required: [true, 'O nome é obrigatório.'],
            trim: true,
        },
        email: {
            type: String,
            required: [true, 'O email é obrigatório.'],
            unique: true,
            lowercase: true,
            trim: true,
            match: [/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/, 'Por favor, forneça um email válido.'],
        },
        passwordHash: { // Nome do campo da senha hasheada
            type: String,
            required: [true, 'A senha é obrigatória.'],
            select: false, // Não retorna o hash da senha por padrão nas queries
        },
        role: {
            type: String,
            required: true,
            enum: ['Personal Trainer', 'Admin'],
            default: 'Personal Trainer'
        },
        tokenCadastroAluno: { // Novo campo adicionado
            type: String,
            unique: true,
            sparse: true, // Permite múltiplos documentos com valor null/undefined, mas único se presente
                        // Um índice sparse só contém entradas para documentos que têm o campo indexado.
                        // O índice omite todos os documentos que não têm o campo indexado.
        },
        // Campos de Assinatura
        planoId: { type: String },
        statusAssinatura: {
            type: String,
            enum: ['ativa', 'inativa', 'pendente_pagamento', 'cancelada', 'trial', 'sem_assinatura'],
            default: 'sem_assinatura', // Personal começa sem assinatura por padrão
        },
        dataInicioAssinatura: { type: Date },
        dataFimAssinatura: { type: Date },
        idAssinaturaGateway: { type: String },
        limiteAlunos: { type: Number, default: 0 }, // Exemplo: 0 para sem plano, ou o limite do plano
    },
    {
        timestamps: true, // Adiciona createdAt e updatedAt automaticamente
    }
);

// Middleware para fazer o hash da senha ANTES de salvar, se ela foi modificada
personalTrainerSchema.pre<IPersonalTrainer>('save', async function (next) {
    // Só faz o hash da senha se ela foi modificada (ou é nova)
    if (!this.isModified('passwordHash')) {
        return next();
    }
    try {
        const saltRounds = 10; // Custo do salt
        this.passwordHash = await bcrypt.hash(this.passwordHash, saltRounds);
        next();
    } catch (error: any) {
        next(error); // Passa o erro para o próximo middleware/error handler
    }
});

// Middleware para gerar o tokenCadastroAluno ANTES de salvar um novo personal
personalTrainerSchema.pre<IPersonalTrainer>('save', function (next) {
  // Gera o token apenas se for um novo documento e o token ainda não existir
  if (this.isNew && !this.tokenCadastroAluno) {
    this.tokenCadastroAluno = crypto.randomBytes(20).toString('hex');
  }
  next();
});


// Método para comparar a senha candidata com o hash armazenado
personalTrainerSchema.methods.comparePassword = async function (candidatePassword: string): Promise<boolean> {
    // 'this.passwordHash' refere-se ao passwordHash do documento específico
    // É importante que o campo 'passwordHash' não esteja com select: false aqui,
    // ou que você o selecione explicitamente na query antes de chamar comparePassword.
    // No entanto, como o método é chamado em uma instância do documento onde passwordHash pode
    // ter sido selecionado ou já estar presente (ex: após um findOne().select('+passwordHash')),
    // geralmente funciona. Se der problema, garanta que o hash está carregado.
    if (!this.passwordHash) return false; // Caso o hash não esteja presente por algum motivo
    return bcrypt.compare(candidatePassword, this.passwordHash);
};


const PersonalTrainer = mongoose.model<IPersonalTrainer>('PersonalTrainer', personalTrainerSchema);

export default PersonalTrainer;

===== ./server/models/Plano.ts =====
// server/models/Plano.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IPlano extends Document {
    nome: string;
    descricao?: string;
    limiteAlunos: number;
    preco: number;
    duracao: number; // Duration in days
    tipo: 'free' | 'paid';
    ativo: boolean;
    createdAt: Date;
    updatedAt: Date;
}

const planoSchema: Schema<IPlano> = new Schema(
    {
        nome: {
            type: String,
            required: [true, 'O nome do plano é obrigatório.'],
            trim: true,
            unique: true,
        },
        descricao: {
            type: String,
            trim: true,
        },
        limiteAlunos: {
            type: Number,
            required: [true, 'O limite de alunos é obrigatório.'],
            min: [0, 'O limite de alunos não pode ser negativo.'],
        },
        preco: {
            type: Number,
            required: [true, 'O preço é obrigatório.'],
            min: [0, 'O preço não pode ser negativo.'],
        },
        duracao: {
            type: Number,
            required: [true, 'A duração é obrigatória.'],
            min: [1, 'A duração deve ser de pelo menos 1 dia.'],
        },
        tipo: {
            type: String,
            required: true,
            enum: ['free', 'paid'],
            default: 'paid',
        },
        ativo: {
            type: Boolean,
            default: true,
        },
    },
    {
        timestamps: true,
    }
);

const Plano = mongoose.model<IPlano>('Plano', planoSchema);

export default Plano;
===== ./server/models/RenewalRequest.ts =====
// server/models/RenewalRequest.ts
import mongoose, { Schema, Document, Types } from 'mongoose';

// Objeto de status para evitar strings mágicas e garantir consistência
export const RStatus = {
  REQUESTED: 'requested',
  LINK_SENT: 'link_sent',
  PROOF_SUBMITTED: 'proof_submitted',
  APPROVED: 'approved',
  REJECTED: 'rejected',
  FULFILLED: 'fulfilled',
  CYCLE_ASSIGNMENT_PENDING: 'cycle_assignment_pending',
  // Status legados para compatibilidade, se necessário
  PENDING: 'pending',
  PAYMENT_LINK_SENT: 'payment_link_sent',
  PAYMENT_PROOF_UPLOADED: 'payment_proof_uploaded',
} as const;

export type RenewalStatus = typeof RStatus[keyof typeof RStatus];

export interface IRenewalProof {
  kind: 'link' | 'file';
  url?: string;
  fileId?: Types.ObjectId;
  filename?: string;
  contentType?: string;
  size?: number;
  uploadedAt?: Date;
}

export interface IRenewalRequest extends Document {
  personalTrainerId: Types.ObjectId;
  planIdRequested?: Types.ObjectId;
  status: RenewalStatus;
  notes?: string;
  proof?: IRenewalProof;
  
  // Timestamps do fluxo
  requestedAt: Date;
  linkSentAt?: Date;
  proofUploadedAt?: Date;
  paymentDecisionAt?: Date;
  cycleFinalizedAt?: Date;
  
  // Campos de controle do Admin e legados
  paymentLink?: string;
  paymentProofUrl?: string; // Mantido para compatibilidade com a rota existente
  paymentDecisionNote?: string;
  adminId?: Types.ObjectId;
  
  // Timestamps automáticos do Mongoose
  createdAt: Date;
  updatedAt: Date;
}

const ProofSchema = new Schema<IRenewalProof>({
  kind: { type: String, enum: ['link', 'file'], required: true },
  url: { type: String },
  fileId: { type: Schema.Types.ObjectId },
  filename: { type: String },
  contentType: { type: String },
  size: { type: Number },
  uploadedAt: { type: Date, default: Date.now }
}, { _id: false });

const RenewalRequestSchema = new Schema<IRenewalRequest>({
  personalTrainerId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer', required: true, index: true },
  planIdRequested: { type: Schema.Types.ObjectId, ref: 'Plano' },
  status: { 
    type: String, 
    enum: Object.values(RStatus), 
    default: RStatus.REQUESTED 
  },
  notes: { type: String, trim: true },
  proof: { type: ProofSchema },
  
  // Timestamps
  requestedAt: { type: Date, default: Date.now },
  linkSentAt: { type: Date },
  proofUploadedAt: { type: Date },
  paymentDecisionAt: { type: Date },
  cycleFinalizedAt: { type: Date },
  
  // Campos do admin e legados
  paymentLink: { type: String, trim: true },
  paymentProofUrl: { type: String, trim: true },
  paymentDecisionNote: { type: String, trim: true },
  adminId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer' },
}, { timestamps: true }); // Habilita createdAt e updatedAt

export default mongoose.model<IRenewalRequest>('RenewalRequest', RenewalRequestSchema);
===== ./server/models/Sessao.ts =====
// server/models/Sessao.ts
import mongoose, { Schema, Document, Types } from 'mongoose';

export const TIPOS_COMPROMISSO = ['avaliacao', 'checkin', 'treino_acompanhado', 'outro', 'treino_rotina', 'treino'] as const;
export type TipoCompromisso = typeof TIPOS_COMPROMISSO[number];

export const OPCOES_PSE = [
    'Muito Leve', 'Leve', 'Moderado', 'Intenso', 'Muito Intenso', 'Máximo Esforço'
] as const;
export type OpcaoPSE = typeof OPCOES_PSE[number];

interface IPopulatedAlunoLean { _id: string; nome: string; }
interface IPopulatedRotinaLean { _id: string; titulo: string; }

// Interface para o mapa de cargas executadas
interface CargasExecutadasMap {
  [exercicioDoDiaId: string]: string;
}

// Interface para detalhes de aumento de carga
interface DetalheAumentoCarga {
  exercicioId: string;
  nomeExercicio?: string;
  cargaAnterior: string;
  cargaAtual: string;
}


export interface ISessaoLean {
  _id: string; 
  personalId: string; 
  alunoId: IPopulatedAlunoLean | string; 
  rotinaId: IPopulatedRotinaLean | string | null; 
  diaDeTreinoId: string | null; 
  diaDeTreinoIdentificador?: string | null;
  nomeSubFichaDia?: string | null;
  sessionDate: string; 
  tipoCompromisso: TipoCompromisso;
  notes?: string; 
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled' | 'skipped';
  concluidaEm?: string | null; 
  pseAluno?: OpcaoPSE | null;
  comentarioAluno?: string | null;
  duracaoSegundos?: number;
  cargasExecutadas?: CargasExecutadasMap;
  aumentouCarga?: boolean;
  detalhesAumentoCarga?: DetalheAumentoCarga[];
  createdAt?: string;
  updatedAt?: string;
}

export interface ISessaoDocument extends Document {
  personalId: Types.ObjectId; 
  alunoId: Types.ObjectId; 
  rotinaId?: Types.ObjectId | null; 
  diaDeTreinoId?: Types.ObjectId | null; 
  diaDeTreinoIdentificador?: string | null;
  nomeSubFichaDia?: string | null;
  sessionDate: Date; 
  tipoCompromisso: TipoCompromisso;
  notes?: string; 
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled' | 'skipped';
  concluidaEm?: Date | null;
  pseAluno?: OpcaoPSE | null;
  comentarioAluno?: string | null;
  duracaoSegundos?: number;
  cargasExecutadas?: CargasExecutadasMap;
  aumentouCarga?: boolean;
  detalhesAumentoCarga?: DetalheAumentoCarga[];
}

const SessaoSchema = new Schema<ISessaoDocument>(
  {
    personalId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer', required: true, index: true },
    alunoId: { type: Schema.Types.ObjectId, ref: 'Aluno', required: true, index: true },
    rotinaId: { type: Schema.Types.ObjectId, ref: 'Treino', required: false, default: null, index: true },
    diaDeTreinoId: { type: Schema.Types.ObjectId, required: false, default: null }, 
    diaDeTreinoIdentificador: { type: String, trim: true, default: null },
    nomeSubFichaDia: { type: String, trim: true, default: null },
    sessionDate: { type: Date, required: true },
    tipoCompromisso: {
      type: String,
      enum: { values: TIPOS_COMPROMISSO, message: 'Tipo de compromisso inválido: {VALUE}' },
      required: true,
    },
    notes: { type: String, trim: true },
    status: {
      type: String,
      enum: { values: ['pending', 'confirmed', 'completed', 'cancelled', 'skipped'], message: 'Status inválido: {VALUE}'},
      default: 'pending',
      required: true,
    },
    concluidaEm: { type: Date, required: false, default: null },
    pseAluno: { 
        type: String,
        enum: { values: [...OPCOES_PSE, null], message: 'PSE inválido: {VALUE}' }, 
        required: false,
        default: null,
    },
    comentarioAluno: { 
        type: String,
        trim: true,
        required: false,
        default: null,
    },
    duracaoSegundos: {
        type: Number,
        required: false,
        default: 0
    },
    cargasExecutadas: {
        type: Map,
        of: String,
        required: false,
        default: {}
    },
    aumentouCarga: {
        type: Boolean,
        required: false,
        default: false
    },
    detalhesAumentoCarga: {
        type: [{
            exercicioId: { type: String, required: true },
            nomeExercicio: { type: String, required: false },
            cargaAnterior: { type: String, required: true },
            cargaAtual: { type: String, required: true }
        }],
        required: false,
        default: []
    }
  },
  {
    timestamps: true, 
    toJSON: { virtuals: true, getters: true }, 
    toObject: { virtuals: true, getters: true },
  }
);

SessaoSchema.index({ personalId: 1, sessionDate: 1 });
SessaoSchema.index({ alunoId: 1, status: 1, sessionDate: 1 });
SessaoSchema.index({ rotinaId: 1, diaDeTreinoId: 1 });

export { DetalheAumentoCarga, CargasExecutadasMap };
export default mongoose.model<ISessaoDocument>('Sessao', SessaoSchema);
===== ./server/models/TokenAvulso.ts =====
// server/models/TokenAvulso.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface ITokenAvulso extends Document {
    personalTrainerId: mongoose.Types.ObjectId;
    quantidade: number;
    dataVencimento: Date;
    ativo: boolean;
    motivoAdicao?: string;
    adicionadoPorAdmin: mongoose.Types.ObjectId; // ID do admin que adicionou
    createdAt: Date;
    updatedAt: Date;
}

const tokenAvulsoSchema: Schema<ITokenAvulso> = new Schema(
    {
        personalTrainerId: {
            type: Schema.Types.ObjectId,
            ref: 'PersonalTrainer',
            required: [true, 'O ID do Personal Trainer é obrigatório.'],
        },
        quantidade: {
            type: Number,
            required: [true, 'A quantidade de tokens é obrigatória.'],
            min: [1, 'A quantidade deve ser pelo menos 1.'],
        },
        dataVencimento: {
            type: Date,
            required: [true, 'A data de vencimento é obrigatória.'],
        },
        ativo: {
            type: Boolean,
            default: true,
        },
        motivoAdicao: {
            type: String,
            trim: true,
        },
        adicionadoPorAdmin: {
            type: Schema.Types.ObjectId,
            ref: 'PersonalTrainer', // Assuming admin is also a PersonalTrainer with role 'Admin'
            required: [true, 'O ID do admin é obrigatório.'],
        },
    },
    {
        timestamps: true,
    }
);

// Index for efficient queries
tokenAvulsoSchema.index({ personalTrainerId: 1, ativo: 1 });
tokenAvulsoSchema.index({ dataVencimento: 1 });

const TokenAvulso = mongoose.model<ITokenAvulso>('TokenAvulso', tokenAvulsoSchema);

export default TokenAvulso;
===== ./server/models/Treino.ts =====
// server/models/Treino.ts
import mongoose, { Schema, Document, Types } from "mongoose";
import { IExercicio } from './Exercicio.js';

export const TIPOS_ORGANIZACAO_ROTINA = ['diasDaSemana', 'numerico', 'livre'] as const;
export type TipoOrganizacaoRotina = typeof TIPOS_ORGANIZACAO_ROTINA[number];

// --- Subdocumento: Exercício em Dia de Treino ---
export interface IExercicioEmDiaDeTreino extends Types.Subdocument {
  _id: Types.ObjectId;
  exercicioId: Types.ObjectId | IExercicio;
  series?: string;
  repeticoes?: string;
  carga?: string;
  descanso?: string;
  observacoes?: string;
  ordemNoDia: number;
  concluido?: boolean;
  grupoCombinado?: string;
}

// <<< ADICIONADO EXPORT >>>
export interface IExercicioEmDiaDeTreinoPopuladoLean {
  _id: string;
  exercicioId: { _id: string; nome: string; grupoMuscular?: string; urlVideo?: string; descricao?: string; categoria?: string; tipo?: string; } | string;
  series?: string;
  repeticoes?: string;
  carga?: string;
  descanso?: string;
  observacoes?: string;
  ordemNoDia: number;
  concluido?: boolean;
  grupoCombinado?: string;
}

export interface IExercicioEmDiaDeTreinoPlain {
  _id?: Types.ObjectId;
  exercicioId: Types.ObjectId;
  series?: string;
  repeticoes?: string;
  carga?: string;
  descanso?: string;
  observacoes?: string;
  ordemNoDia: number;
  concluido?: boolean;
  grupoCombinado?: string;
}

// --- Subdocumento: Dia de Treino ---
export interface IDiaDeTreino extends Types.Subdocument {
    _id: Types.ObjectId;
    identificadorDia: string;
    nomeSubFicha?: string | null;
    ordemNaRotina: number;
    exerciciosDoDia?: Types.DocumentArray<IExercicioEmDiaDeTreino>;
}

// <<< ADICIONADO EXPORT >>>
export interface IDiaDeTreinoPopuladoLean {
    _id: string;
    identificadorDia: string;
    nomeSubFicha?: string | null;
    ordemNaRotina: number;
    exerciciosDoDia?: IExercicioEmDiaDeTreinoPopuladoLean[];
}

export interface IDiaDeTreinoPlain {
    _id?: Types.ObjectId;
    identificadorDia: string;
    nomeSubFicha?: string | null;
    ordemNaRotina: number;
    exerciciosDoDia?: IExercicioEmDiaDeTreinoPlain[];
}

// --- Documento Principal: Treino/Rotina ---
export interface ITreino extends Document {
  titulo: string;
  descricao?: string;
  tipo: 'modelo' | 'individual';
  criadorId: Types.ObjectId;
  alunoId?: Types.ObjectId | null;
  tipoOrganizacaoRotina: TipoOrganizacaoRotina;
  diasDeTreino: Types.DocumentArray<IDiaDeTreino>;
  pastaId?: Types.ObjectId | null;
  statusModelo?: 'ativo' | 'rascunho' | 'arquivado' | null;
  ordemNaPasta?: number;
  dataValidade?: Date | null;
  totalSessoesRotinaPlanejadas?: number;
  sessoesRotinaConcluidas?: number;
  criadoEm: Date;
  atualizadoEm: Date;
  isConcluida?: boolean;
  progressoRotina?: string;
  isCopied?: boolean; // <<< NOVO CAMPO: Indica se a rotina é uma cópia >>>
}

// <<< CORREÇÃO PRINCIPAL: Adicionado EXPORT aqui >>>
// Renomeado para ITreinoPopuladoLean para corresponder ao uso
export interface ITreinoPopuladoLean {
    _id: string;
    titulo: string;
    descricao?: string | null;
    tipo: "modelo" | "individual";
    alunoId?: { _id: string; nome: string; email?: string; } | string | null; 
    criadorId: { _id: string; nome: string; email?: string; } | string; 
    tipoOrganizacaoRotina: 'diasDaSemana' | 'numerico' | 'livre';
    diasDeTreino?: IDiaDeTreinoPopuladoLean[];
    pastaId?: { _id: string; nome: string; } | string | null;
    statusModelo?: "ativo" | "rascunho" | "arquivado" | null;
    ordemNaPasta?: number;
    dataValidade?: string | Date | null;
    totalSessoesRotinaPlanejadas?: number;
    sessoesRotinaConcluidas?: number;
    criadoEm?: string | Date;
    atualizadoEm?: string | Date;
    isConcluida?: boolean;
    progressoRotina?: string;
    isCopied?: boolean; // <<< NOVO CAMPO: Indica se a rotina é uma cópia >>>
}

// <<< MANTIDO EXPORTADO: O frontend também usa este tipo com o nome RotinaListagemItem >>>
export type RotinaListagemItem = ITreinoPopuladoLean;


// --- Schemas ---
const ExercicioEmDiaDeTreinoSchema = new Schema<IExercicioEmDiaDeTreino>({
  exercicioId: { type: Schema.Types.ObjectId, ref: 'Exercicio', required: true },
  series: { type: String, trim: true },
  repeticoes: { type: String, trim: true },
  carga: { type: String, trim: true },
  descanso: { type: String, trim: true },
  observacoes: { type: String, trim: true },
  ordemNoDia: { type: Number, required: true },
  concluido: { type: Boolean, default: false },
  grupoCombinado: { type: String, trim: true },
}, { _id: true });

const DiaDeTreinoSchema = new Schema<IDiaDeTreino>({
  identificadorDia: { type: String, required: true, trim: true },
  nomeSubFicha: { type: String, trim: true, default: null },
  ordemNaRotina: { type: Number, required: true },
  exerciciosDoDia: [ExercicioEmDiaDeTreinoSchema],
}, { _id: true });

const TreinoSchema = new Schema<ITreino>({
  titulo: { type: String, required: true, trim: true },
  descricao: { type: String, trim: true },
  tipo: { type: String, required: true, enum: ['modelo', 'individual'] },
  criadorId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer', required: true },
  alunoId: { type: Schema.Types.ObjectId, ref: 'Aluno', default: null, sparse: true, index: true },
  tipoOrganizacaoRotina: { type: String, required: true, enum: TIPOS_ORGANIZACAO_ROTINA },
  diasDeTreino: [DiaDeTreinoSchema],
  pastaId: { type: Schema.Types.ObjectId, ref: 'PastaTreino', default: null, sparse: true },
  statusModelo: { type: String, enum: ['ativo', 'rascunho', 'arquivado'], default: 'ativo' },
  ordemNaPasta: { type: Number },
  dataValidade: { type: Date, default: null },
  totalSessoesRotinaPlanejadas: { type: Number, default: 0 },
  sessoesRotinaConcluidas: { type: Number, default: 0 },
  criadoEm: { type: Date, default: Date.now },
  atualizadoEm: { type: Date, default: Date.now },
  isCopied: { type: Boolean, default: false }, // <<< NOVO CAMPO NO SCHEMA >>>
});

TreinoSchema.pre('save', function (next) {
    this.atualizadoEm = new Date();
    next();
});

TreinoSchema.pre('findOneAndUpdate', function (next) {
    this.set({ atualizadoEm: new Date() });
    next();
});

// ... Virtuais e Índices permanecem os mesmos ...
TreinoSchema.virtual('isConcluida').get(function(this: ITreino) {
    if (this.tipo !== 'individual') return false;
    const totalPlanejado = this.totalSessoesRotinaPlanejadas ?? 0;
    const sessoesConcluidas = this.sessoesRotinaConcluidas ?? 0;
    if (totalPlanejado === 0 && sessoesConcluidas > 0) return true;
    if (totalPlanejado > 0 && sessoesConcluidas >= totalPlanejado) return true;
    return false;
});
TreinoSchema.virtual('progressoRotina').get(function(this: ITreino) {
    if (this.tipo !== 'individual') return null;
    const totalPlanejado = this.totalSessoesRotinaPlanejadas ?? 0;
    const sessoesConcluidas = this.sessoesRotinaConcluidas ?? 0;
    if (totalPlanejado > 0) return `${sessoesConcluidas}/${totalPlanejado}`;
    if (totalPlanejado === 0) return `0/0`;
    return null;
});
TreinoSchema.index({ criadorId: 1, tipo: 1 });
TreinoSchema.index({ criadorId: 1, tipo: 1, pastaId: 1 }, { sparse: true }); 
TreinoSchema.index({ criadorId: 1, tipo: 1, statusModelo: 1 }, { partialFilterExpression: { tipo: 'modelo' } });

export default mongoose.model<ITreino>("Treino", TreinoSchema);

===== ./server/models/WorkoutLog.ts =====
// server/models/WorkoutLog.ts
import mongoose, { Schema, Document, Types } from 'mongoose';

// Interface para o documento do log de treino
export interface IWorkoutLog extends Document {
  treinoId: Types.ObjectId;
  treinoTitulo: string;
  alunoId: Types.ObjectId;
  personalId: Types.ObjectId;
  dataInicio: Date;
  dataFim: Date;
  duracaoTotalMinutos: number;
  nivelTreino: 'muito_facil' | 'facil' | 'moderado' | 'dificil' | 'muito_dificil';
  comentarioAluno?: string;
  aumentoCarga?: boolean;
  cargaAnterior?: number;
  cargaAtual?: number;
  criadoEm: Date;
  atualizadoEm: Date;
}

const WorkoutLogSchema: Schema = new Schema<IWorkoutLog>({
  treinoId: { type: Schema.Types.ObjectId, ref: 'Treino', required: true },
  treinoTitulo: { type: String, required: true },
  alunoId: { type: Schema.Types.ObjectId, ref: 'Aluno', required: true },
  personalId: { type: Schema.Types.ObjectId, ref: 'PersonalTrainer', required: true },
  dataInicio: { type: Date, required: true },
  dataFim: { type: Date, required: true },
  duracaoTotalMinutos: { type: Number, required: true },
  nivelTreino: {
    type: String,
    enum: ['muito_facil', 'facil', 'moderado', 'dificil', 'muito_dificil'],
    required: true
  },
  comentarioAluno: { type: String },
  aumentoCarga: { type: Boolean },
  cargaAnterior: { type: Number },
  cargaAtual: { type: Number },
  criadoEm: { type: Date, default: Date.now },
  atualizadoEm: { type: Date, default: Date.now }
});

export default mongoose.models.WorkoutLog || mongoose.model<IWorkoutLog>('WorkoutLog', WorkoutLogSchema);

===== ./server/scripts/createInitialPlans.ts =====
// server/scripts/createInitialPlans.ts
import mongoose from 'mongoose';
import Plano from '../models/Plano.js';
import '../loadEnv.mts'; // Load environment variables

const INITIAL_PLANS = [
    {
        nome: 'Free',
        descricao: 'Plano gratuito por 7 dias com 1 aluno ativo',
        limiteAlunos: 1,
        preco: 0,
        duracao: 7, // 7 days
        tipo: 'free' as const,
        ativo: true
    },
    {
        nome: 'Start',
        descricao: 'Plano inicial para até 5 alunos ativos',
        limiteAlunos: 5,
        preco: 29.90,
        duracao: 30, // 30 days
        tipo: 'paid' as const,
        ativo: true
    },
    {
        nome: 'Pro',
        descricao: 'Plano profissional para até 10 alunos ativos',
        limiteAlunos: 10,
        preco: 49.90,
        duracao: 30, // 30 days
        tipo: 'paid' as const,
        ativo: true
    },
    {
        nome: 'Elite',
        descricao: 'Plano elite para até 20 alunos ativos',
        limiteAlunos: 20,
        preco: 79.90,
        duracao: 30, // 30 days
        tipo: 'paid' as const,
        ativo: true
    },
    {
        nome: 'Master',
        descricao: 'Plano master para até 50 alunos ativos',
        limiteAlunos: 50,
        preco: 129.90,
        duracao: 30, // 30 days
        tipo: 'paid' as const,
        ativo: true
    }
];

async function createInitialPlans() {
    try {
        console.log('Conectando ao MongoDB...');
        
        const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/dyfit';
        await mongoose.connect(mongoUri);
        
        console.log('Conectado ao MongoDB');

        console.log('Verificando planos existentes...');
        const existingPlans = await Plano.find({});
        
        if (existingPlans.length > 0) {
            console.log(`Encontrados ${existingPlans.length} planos existentes:`);
            existingPlans.forEach(plan => {
                console.log(`  - ${plan.nome} (${plan.limiteAlunos} alunos, R$${plan.preco})`);
            });
            
            console.log('\nAtualizar planos existentes? [y/N]');
            // For script execution, we'll skip the interactive part and just log
            console.log('Script executado em modo não-interativo. Pulando atualização.');
        } else {
            console.log('Nenhum plano encontrado. Criando planos iniciais...');
            
            for (const planData of INITIAL_PLANS) {
                try {
                    const existingPlan = await Plano.findOne({ nome: planData.nome });
                    
                    if (existingPlan) {
                        console.log(`Plano '${planData.nome}' já existe. Atualizando...`);
                        await Plano.findByIdAndUpdate(existingPlan._id, planData);
                        console.log(`  ✓ Plano '${planData.nome}' atualizado`);
                    } else {
                        const newPlan = new Plano(planData);
                        await newPlan.save();
                        console.log(`  ✓ Plano '${planData.nome}' criado`);
                    }
                } catch (error) {
                    console.error(`  ✗ Erro ao criar/atualizar plano '${planData.nome}':`, error);
                }
            }
        }

        console.log('\n=== Planos atuais no sistema ===');
        const allPlans = await Plano.find({}).sort({ preco: 1 });
        allPlans.forEach(plan => {
            console.log(`${plan.nome}:`);
            console.log(`  - Limite: ${plan.limiteAlunos} alunos`);
            console.log(`  - Preço: R$${plan.preco.toFixed(2)}`);
            console.log(`  - Duração: ${plan.duracao} dias`);
            console.log(`  - Tipo: ${plan.tipo}`);
            console.log(`  - Ativo: ${plan.ativo ? 'Sim' : 'Não'}`);
            console.log('');
        });

        console.log('Script concluído com sucesso!');
        
    } catch (error) {
        console.error('Erro ao executar script:', error);
        process.exit(1);
    } finally {
        await mongoose.connection.close();
        console.log('Conexão com MongoDB fechada');
        process.exit(0);
    }
}

// Execute if run directly
if (import.meta.url === `file://${process.argv[1]}`) {
    createInitialPlans();
}

export { createInitialPlans, INITIAL_PLANS };
===== ./server/scripts/createPersonal.ts =====
// server/scripts/createPersonal.ts
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import PersonalTrainer, { IPersonalTrainer } from '../models/PersonalTrainer.js'; // Ajuste o caminho se necessário
import { connectToDatabase, disconnectFromDatabase } from '../database.js'; // Ajuste o caminho se necessário

dotenv.config({ path: '../../.env' }); // Carrega variáveis de ambiente do .env na raiz do projeto

async function createPersonal() {
  // Pega os argumentos da linha de comando: nome, email, senha
  // Exemplo de como rodar: ts-node server/scripts/createPersonal.ts "Nome do Personal" "email@example.com" "senha123"
  const args = process.argv.slice(2); // Os dois primeiros args são 'node' e o nome do script

  if (args.length < 3) {
    console.error('Uso: ts-node server/scripts/createPersonal.ts "<Nome Completo>" "<email>" "<senha>" [role]');
    console.error('Exemplo: ts-node server/scripts/createPersonal.ts "João Silva" "joao@example.com" "senhaSegura"');
    process.exit(1);
  }

  const [nome, email, passwordInput] = args;
  const roleInput = args[3] || 'Personal Trainer'; // Pega o quarto argumento como role, ou usa o default

  if (!['Personal Trainer', 'Admin'].includes(roleInput)) {
    console.error(`Role inválido: "${roleInput}". Use "Personal Trainer" ou "Admin".`);
    process.exit(1);
  }

  try {
    await connectToDatabase();
    console.log('Conectado ao banco de dados...');

    const existingPersonal = await PersonalTrainer.findOne({ email: email.toLowerCase() });
    if (existingPersonal) {
      console.warn(`Já existe um personal trainer com o email: ${email}`);
      await disconnectFromDatabase();
      process.exit(1);
    }

    console.log(`Criando personal: ${nome}, Email: ${email}, Role: ${roleInput}`);

    // Criamos a instância com a senha em texto plano.
    // O middleware pre('save') no modelo PersonalTrainer cuidará do hashing.
    const newPersonal = new PersonalTrainer({
      nome,
      email: email.toLowerCase(),
      passwordHash: passwordInput, // O middleware pre-save irá hashear este campo
      role: roleInput as IPersonalTrainer['role'],
      // tokenCadastroAluno será gerado automaticamente pelo middleware pre-save
      // statusAssinatura e limiteAlunos usarão os defaults do schema
    });

    await newPersonal.save();

    // O token é gerado no pre-save, então podemos logá-lo aqui se quisermos
    console.log('Personal Trainer criado com sucesso!');
    console.log('Detalhes:');
    console.log(`  ID: ${newPersonal._id}`);
    console.log(`  Nome: ${newPersonal.nome}`);
    console.log(`  Email: ${newPersonal.email}`);
    console.log(`  Role: ${newPersonal.role}`);
    console.log(`  Token de Cadastro de Aluno: ${newPersonal.tokenCadastroAluno}`);
    console.log(`  Status da Assinatura: ${newPersonal.statusAssinatura}`);

  } catch (error) {
    console.error('Erro ao criar Personal Trainer:', error);
  } finally {
    await disconnectFromDatabase();
    console.log('Desconectado do banco de dados.');
    process.exit(0);
  }
}

createPersonal();

===== ./server/scripts/testPlansCreation.ts =====
// server/scripts/testPlansCreation.ts
import { connectToDatabase } from '../database.js';
import PlanoService from '../services/PlanoService.js';
import '../loadEnv.mts'; // Load environment variables

async function testPlansCreation() {
    try {
        console.log('🔄 Iniciando teste de criação de planos...');
        
        // Test database connection
        console.log('🔌 Testando conexão com banco de dados...');
        await connectToDatabase();
        console.log('✅ Conectado ao banco de dados com sucesso!');
        
        // Test plans creation/verification
        console.log('📝 Testando criação de planos...');
        const planosIniciaisStatus = await PlanoService.ensureInitialPlansExist();
        console.log(`🎯 Status da criação de planos iniciais: ${planosIniciaisStatus ? 'Sucesso' : 'Falha'}`);
        
        // Test getting all plans
        console.log('📊 Testando busca de todos os planos...');
        const planos = await PlanoService.getAllPlans();
        console.log(`✅ Encontrados ${planos.length} planos:`);
        
        planos.forEach((plano, index) => {
            console.log(`  ${index + 1}. ${plano.nome}:`);
            console.log(`     - Limite: ${plano.limiteAlunos} alunos`);
            console.log(`     - Preço: R$${plano.preco.toFixed(2)}`);
            console.log(`     - Duração: ${plano.duracao} dias`);
            console.log(`     - Tipo: ${plano.tipo}`);
            console.log(`     - Ativo: ${plano.ativo ? 'Sim' : 'Não'}`);
        });
        
        console.log('\n🎉 Teste concluído com sucesso!');
        
    } catch (error) {
        console.error('❌ Erro durante o teste:', error);
        throw error;
    } finally {
        // Close database connection
        const mongoose = await import('mongoose');
        await mongoose.disconnect();
        console.log('🔌 Conexão com banco de dados fechada');
    }
}

// Execute if run directly
if (import.meta.url === `file://${process.argv[1]}`) {
    testPlansCreation()
        .then(() => {
            console.log('✅ Script executado com sucesso');
            process.exit(0);
        })
        .catch((error) => {
            console.error('❌ Script falhou:', error);
            process.exit(1);
        });
}

export { testPlansCreation };
===== ./server/services/NotificationService.ts =====
// server/services/NotificationService.ts
import Notification from '../models/Notification.js';

export async function sendNotification(userId: string, message: string) {
  try {
    const notification = new Notification({ userId, message });
    await notification.save();
  } catch (error) {
    console.error('Erro ao enviar notificação:', error);
  }
}

===== ./server/services/PlanoService.ts =====
// server/services/PlanoService.ts
import mongoose from 'mongoose';
import Plano, { IPlano } from '../models/Plano.js';
import PersonalPlano, { IPersonalPlano } from '../models/PersonalPlano.js';
import TokenAvulso, { ITokenAvulso } from '../models/TokenAvulso.js';
import Aluno from '../models/Aluno.js';

// Configuração de planos iniciais
const INITIAL_PLANS = [
    {
        nome: 'Free',
        descricao: 'Plano gratuito por 7 dias com 1 aluno ativo',
        limiteAlunos: 1,
        preco: 0,
        duracao: 7,
        tipo: 'free' as const,
        ativo: true
    },
    {
        nome: 'Start',
        descricao: 'Plano inicial para até 5 alunos ativos',
        limiteAlunos: 5,
        preco: 29.90,
        duracao: 30,
        tipo: 'paid' as const,
        ativo: true
    },
    {
        nome: 'Pro',
        descricao: 'Plano profissional para até 10 alunos ativos',
        limiteAlunos: 10,
        preco: 49.90,
        duracao: 30,
        tipo: 'paid' as const,
        ativo: true
    },
    {
        nome: 'Elite',
        descricao: 'Plano elite para até 20 alunos ativos',
        limiteAlunos: 20,
        preco: 79.90,
        duracao: 30,
        tipo: 'paid' as const,
        ativo: true
    },
    {
        nome: 'Master',
        descricao: 'Plano master para até 50 alunos ativos',
        limiteAlunos: 50,
        preco: 129.90,
        duracao: 30,
        tipo: 'paid' as const,
        ativo: true
    }
];

export class PlanoService {
    /**
     * Retorna a quantidade de tokens avulsos ativos
     */
    async getTokensAvulsosAtivos(personalTrainerId: string): Promise<number> {
        try {
            if (!personalTrainerId) {
                console.warn('⚠️  Personal trainer ID não fornecido para busca de tokens');
                return 0;
            }

            const tokens = await TokenAvulso.find({
                personalTrainerId,
                ativo: true,
                dataVencimento: { $gt: new Date() }
            });

            const total = tokens.reduce((total, token) => total + (token.quantidade || 0), 0);
            return total;
        } catch (error) {
            console.error('❌ Erro ao buscar tokens avulsos ativos:', error);
            return 0;
        }
    }

    /**
     * Busca o plano atual do personal trainer
     */
    async getPersonalCurrentPlan(personalTrainerId: string): Promise<{
        plano: IPlano | null;
        personalPlano: IPersonalPlano | null;
        limiteAtual: number;
        alunosAtivos: number;
        tokensAvulsos: number;
        isExpired: boolean;
        expiredPlan?: {
            plano: IPlano | null;
            personalPlano: IPersonalPlano | null;
        };
    }> {
        try {
            if (!personalTrainerId) {
                throw new Error('Personal trainer ID é obrigatório');
            }
            
            const trainerObjectId = new mongoose.Types.ObjectId(personalTrainerId);

            const [personalPlanoAtivo, alunosAtivos, tokensAtivos] = await Promise.all([
                PersonalPlano.findOne({
                    personalTrainerId: trainerObjectId,
                    ativo: true,
                    dataVencimento: { $gt: new Date() }
                }).populate('planoId').sort({ dataInicio: -1 }).lean(),
                Aluno.countDocuments({ trainerId: trainerObjectId, status: 'active' }),
                this.getTokensAvulsosAtivos(personalTrainerId)
            ]);
            
            let personalPlanoExpirado = null;
            if (!personalPlanoAtivo) {
                personalPlanoExpirado = await PersonalPlano.findOne({
                    personalTrainerId: trainerObjectId,
                    ativo: true,
                }).populate('planoId').sort({ dataVencimento: -1 }).lean();
            }

            const currentPersonalPlano = personalPlanoAtivo || personalPlanoExpirado;
            
            const plano: IPlano | null =
                currentPersonalPlano &&
                currentPersonalPlano.planoId &&
                typeof currentPersonalPlano.planoId === 'object' &&
                'nome' in (currentPersonalPlano.planoId as any)
                    ? (currentPersonalPlano.planoId as unknown as IPlano)
                    : null;

            const isExpired = !personalPlanoAtivo && !!personalPlanoExpirado;

            const limiteBaseDoPlano = !isExpired && plano ? plano.limiteAlunos : 0;
            const limiteAtual = limiteBaseDoPlano + tokensAtivos;

            const result = {
                plano: plano,
                personalPlano: currentPersonalPlano,
                limiteAtual,
                alunosAtivos,
                tokensAvulsos: tokensAtivos,
                isExpired,
                ...(isExpired && { expiredPlan: { plano, personalPlano: personalPlanoExpirado } })
            };

            return result;
        } catch (error) {
            console.error('❌ Erro ao buscar plano atual do personal:', error);
            throw error;
        }
    }

    /**
     * Verifica se é possível ativar mais alunos
     */
    async canActivateMoreStudents(personalTrainerId: string, quantidadeDesejada: number = 1): Promise<{
        canActivate: boolean;
        currentLimit: number;
        activeStudents: number;
        availableSlots: number;
    }> {
        const status = await this.getPersonalCurrentPlan(personalTrainerId);
        const availableSlots = status.limiteAtual - status.alunosAtivos;
        
        return {
            canActivate: availableSlots >= quantidadeDesejada,
            currentLimit: status.limiteAtual,
            activeStudents: status.alunosAtivos,
            availableSlots
        };
    }

    /**
     * Atribui um plano ao personal trainer
     */
    async assignPlanToPersonal(
        personalTrainerId: string,
        planoId: string,
        adminId?: string | null,
        customDuration?: number,
        motivo?: string
    ): Promise<IPersonalPlano> {
        const PersonalTrainer = (await import('../models/PersonalTrainer.js')).default;
        
        await PersonalPlano.updateMany(
            { personalTrainerId, ativo: true },
            { ativo: false }
        );

        const plano = await Plano.findById(planoId);
        if (!plano) {
            throw new Error('Plano não encontrado');
        }

        const dataInicio = new Date();
        const dataVencimento = new Date();
        dataVencimento.setDate(dataVencimento.getDate() + (customDuration || plano.duracao));

        const personalPlano = new PersonalPlano({
            personalTrainerId,
            planoId,
            dataInicio,
            dataVencimento,
            atribuidoPorAdmin: adminId ?? undefined,
            motivoAtribuicao: motivo,
            ativo: true
        });

        const savedPersonalPlano = await personalPlano.save();

        await PersonalTrainer.findByIdAndUpdate(personalTrainerId, {
            planoId: planoId,
            statusAssinatura: 'ativa',
            dataInicioAssinatura: dataInicio,
            dataFimAssinatura: dataVencimento,
            limiteAlunos: plano.limiteAlunos
        });

        return savedPersonalPlano;
    }

    /**
     * Adiciona tokens ao personal trainer
     */
    async addTokensToPersonal(
        personalTrainerId: string,
        quantidade: number,
        adminId: string,
        customDays?: number,
        motivo?: string
    ): Promise<ITokenAvulso> {
        const dataVencimento = new Date();
        dataVencimento.setDate(dataVencimento.getDate() + (customDays || 30));

        const token = new TokenAvulso({
            personalTrainerId,
            quantidade,
            dataVencimento,
            adicionadoPorAdmin: adminId,
            motivoAdicao: motivo,
            ativo: true
        });

        return await token.save();
    }

    /**
     * Garante que os planos iniciais existam no banco
     */
    async ensureInitialPlansExist(): Promise<boolean> {
        try {
            const existingPlansCount = await Plano.countDocuments({ ativo: true });
            if (existingPlansCount > 0 && existingPlansCount === INITIAL_PLANS.length) {
                return true;
            }

            for (const planData of INITIAL_PLANS) {
                await Plano.findOneAndUpdate({ nome: planData.nome }, planData, { upsert: true, new: true });
            }
            return true;
        } catch (error) {
            console.error('❌ Erro ao verificar/criar planos iniciais:', error);
            return false;
        }
    }

    /**
     * Busca todos os planos
     */
    async getAllPlans(): Promise<IPlano[]> {
        try {
            await this.ensureInitialPlansExist();
            const plans = await Plano.find({ ativo: true }).sort({ preco: 1 });
            return plans;
        } catch (error) {
            console.error('❌ Erro ao buscar planos:', error);
            throw error;
        }
    }

    /**
     * Cria ou atualiza um plano
     */
    async createOrUpdatePlan(planData: Partial<IPlano>): Promise<IPlano> {
        if (planData._id) {
            const plan = await Plano.findByIdAndUpdate(planData._id, planData, { new: true });
            if (!plan) throw new Error('Plano não encontrado');
            return plan;
        } else {
            return await Plano.create(planData);
        }
    }

    /**
     * Retorna os tokens detalhados para admin
     */
    async getDetailedTokensForAdmin(personalTrainerId: string): Promise<{
        activeTokens: ITokenAvulso[];
        expiredTokens: ITokenAvulso[];
        totalActiveQuantity: number;
    }> {
        try {
            const now = new Date();
            const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

            const [activeTokens, expiredTokens] = await Promise.all([
                TokenAvulso.find({
                    personalTrainerId,
                    ativo: true,
                    dataVencimento: { $gt: now }
                }).populate('adicionadoPorAdmin', 'nome').sort({ dataVencimento: 1 }),
                TokenAvulso.find({
                    personalTrainerId,
                    ativo: true,
                    dataVencimento: { $lte: now, $gte: thirtyDaysAgo }
                }).populate('adicionadoPorAdmin', 'nome').sort({ dataVencimento: -1 })
            ]);

            const totalActiveQuantity = activeTokens.reduce((sum, token) => sum + token.quantidade, 0);

            return {
                activeTokens,
                expiredTokens,
                totalActiveQuantity
            };
        } catch (error) {
            console.error('❌ Erro ao buscar tokens detalhados:', error);
            return {
                activeTokens: [],
                expiredTokens: [],
                totalActiveQuantity: 0
            };
        }
    }

    /**
     * Busca o status do personal para admin
     */
    async getPersonalStatusForAdmin(personalTrainerId: string): Promise<{
        personalInfo: any;
        currentPlan: any;
        activeTokens: ITokenAvulso[];
        expiredTokens: ITokenAvulso[];
        totalActiveTokens: number;
        activeStudents: number;
        totalLimit: number;
        planHistory: IPersonalPlano[];
    }> {
        const [currentStatus, tokenDetails, planHistory] = await Promise.all([
            this.getPersonalCurrentPlan(personalTrainerId),
            this.getDetailedTokensForAdmin(personalTrainerId),
            PersonalPlano.find({ personalTrainerId })
                .populate('planoId')
                .populate('atribuidoPorAdmin', 'nome')
                .sort({ createdAt: -1 })
                .limit(10)
        ]);

        return {
            personalInfo: null,
            currentPlan: currentStatus,
            activeTokens: tokenDetails.activeTokens,
            expiredTokens: tokenDetails.expiredTokens,
            totalActiveTokens: tokenDetails.totalActiveQuantity,
            activeStudents: currentStatus.alunosAtivos,
            totalLimit: currentStatus.limiteAtual,
            planHistory
        };
    }

    /**
     * Desativa planos e tokens expirados
     */
    async cleanupExpired(): Promise<{ plansDeactivated: number; tokensDeactivated: number }> {
        const now = new Date();

        const [plansResult, tokensResult] = await Promise.all([
            PersonalPlano.updateMany(
                { dataVencimento: { $lt: now }, ativo: true },
                { $set: { ativo: false } }
            ),
            TokenAvulso.updateMany(
                { dataVencimento: { $lt: now }, ativo: true },
                { $set: { ativo: false } }
            )
        ]);

        return {
            plansDeactivated: plansResult.modifiedCount,
            tokensDeactivated: tokensResult.modifiedCount
        };
    }
}

export default new PlanoService();
===== ./server/src/routes/activityLogsRoutes.ts =====
// server/src/routes/activityLogsRoutes.ts
import express, { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import dbConnect from '../../lib/dbConnect.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import Sessao from '../../models/Sessao.js'; // <-- 1. MUDANÇA: Importa Sessao ao invés de WorkoutLog

const router = express.Router();

console.log("--- [server/src/routes/activityLogsRoutes.ts] Ficheiro carregado ---");

// ROTA AJUSTADA PARA BUSCAR DA COLEÇÃO CORRETA ('sessoes')
router.get('/aluno/:alunoId', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();

    const { alunoId } = req.params;
    const personalId = req.user?.id;

    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ mensagem: "ID do aluno inválido." });
    }
    if (!personalId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }

    try {
        // --- 2. MUDANÇA: A consulta agora usa o modelo 'Sessao' ---
        // Adicionamos status: 'completed' para pegar apenas os treinos finalizados.
        const historico = await Sessao.find({ 
            alunoId: new mongoose.Types.ObjectId(alunoId),
            personalId: new mongoose.Types.ObjectId(personalId),
            status: 'completed' 
        })
        .sort({ concluidaEm: -1 }) // Ordena pelos mais recentes
        .populate('rotinaId', 'titulo') // Popula o título da rotina para exibição
        .lean(); // Usa .lean() para um desempenho melhor

        // Mapeia os dados para a estrutura que o frontend espera (IWorkoutHistoryLog)
        const historicoMapeado = historico.map(sessao => ({
            _id: sessao._id,
            treinoId: sessao.rotinaId?._id || null,
            treinoTitulo: (sessao.rotinaId as any)?.titulo || sessao.diaDeTreinoIdentificador || 'Treino Concluído',
            dataInicio: sessao.sessionDate,
            dataFim: sessao.concluidaEm,
            duracaoTotalMinutos: sessao.duracaoSegundos ? Math.round(sessao.duracaoSegundos / 60) : 0,
            nivelTreino: sessao.pseAluno,
            comentarioAluno: sessao.comentarioAluno,
            aumentoCarga: sessao.aumentouCarga || false,
        }));

        res.json(historicoMapeado);

    } catch (error) {
        console.error(`[GET /api/activity-logs/aluno/${alunoId}] Erro:`, error);
        next(error);
    }
});


// Rota placeholder mantida como original
router.get('/', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const limitParam = req.query.limit;
    const limit = typeof limitParam === 'string' && parseInt(limitParam) > 0 ? parseInt(limitParam) : 5;
    if (!trainerId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    console.log(`[GET /api/activity-logs] (Placeholder) Buscando logs para trainerId: ${trainerId} com limite: ${limit}`);
    try {
        const mockActivities: any[] = [];
        res.json(mockActivities);
    } catch (error) {
        console.error("[GET /api/activity-logs] (Placeholder) Erro:", error);
        next(error);
    }
});

export default router;
===== ./server/src/routes/adminPlanosRoutes.ts =====
// server/src/routes/adminPlanosRoutes.ts
import express from 'express';
import PlanoService from '../../services/PlanoService.js';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import { authorizeAdmin } from '../../middlewares/authorizeAdmin.js';
import dbConnect from '../../lib/dbConnect.js';

const router = express.Router();

// Apply authentication and admin authorization to all routes
router.use(authenticateToken);
router.use(authorizeAdmin);

/**
 * GET /api/admin/planos/status - Check plans status
 */
router.get('/planos/status', async (req, res) => {
    try {
        await dbConnect();
        
        console.log('🔍 Verificando status dos planos...');
        
        const status = await PlanoService.ensureInitialPlansExist();
        const planos = await PlanoService.getAllPlans();
        
        res.json({
            status: status ? 'ok' : 'error',
            planosCount: planos.length,
            planos: planos.map(p => ({ 
                nome: p.nome, 
                limiteAlunos: p.limiteAlunos, 
                preco: p.preco, 
                ativo: p.ativo 
            })),
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('❌ Erro ao verificar status dos planos:', error);
        res.status(500).json({ 
            message: 'Erro ao verificar status dos planos',
            error: error instanceof Error ? error.message : 'Erro desconhecido'
        });
    }
});

/**
 * GET /api/admin/planos - Get all plans
 */
router.get('/planos', async (req, res) => {
    try {
        await dbConnect();
        
        console.log('📊 Recebida requisição para listar planos...');
        
        const planos = await PlanoService.getAllPlans();
        
        console.log(`✅ Retornando ${planos.length} planos encontrados.`);
        
        res.json(planos);
    } catch (error) {
        console.error('❌ Erro ao buscar planos:', error);
        
        res.status(500).json({ 
            message: 'Erro ao buscar planos',
            error: error instanceof Error ? error.message : 'Erro desconhecido',
            timestamp: new Date().toISOString()
        });
    }
});

/**
 * POST /api/admin/planos - Create or update a plan
 */
router.post('/planos', async (req, res) => {
    try {
        await dbConnect();
        
        const planData = req.body;
        const plano = await PlanoService.createOrUpdatePlan(planData);
        res.status(201).json(plano);
    } catch (error) {
        console.error('Error creating/updating plan:', error);
        res.status(500).json({ message: 'Erro ao criar/atualizar plano' });
    }
});

/**
 * GET /api/admin/personal/:personalId/status - Get personal trainer plan status
 */
router.get('/personal/:personalId/status', async (req, res) => {
    try {
        await dbConnect();
        
        const { personalId } = req.params;
        
        const personal = await PersonalTrainer.findById(personalId);
        if (!personal) {
            return res.status(404).json({ message: 'Personal trainer não encontrado' });
        }

        const status = await PlanoService.getPersonalStatusForAdmin(personalId);
        status.personalInfo = {
            _id: personal._id,
            nome: personal.nome,
            email: personal.email
        };

        res.json(status);
    } catch (error) {
        console.error('Error fetching personal status:', error);
        res.status(500).json({ message: 'Erro ao buscar status do personal' });
    }
});

/**
 * POST /api/admin/personal/:personalId/assign-plan - Assign plan to personal trainer
 */
router.post('/personal/:personalId/assign-plan', async (req, res) => {
    try {
        await dbConnect();
        
        const { personalId } = req.params;
        const { planoId, customDuration, motivo } = req.body;
        const adminId = (req as any).user.id;

        console.log('🔄 Atribuindo plano:', { personalId, planoId, customDuration, motivo });

        const personal = await PersonalTrainer.findById(personalId);
        if (!personal) {
            return res.status(404).json({ message: 'Personal trainer não encontrado' });
        }

        const personalPlano = await PlanoService.assignPlanToPersonal(
            personalId,
            planoId,
            adminId,
            customDuration,
            motivo
        );

        console.log('✅ Plano atribuído com sucesso:', personalPlano._id);

        res.status(201).json({
            message: 'Plano atribuído com sucesso',
            personalPlano,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('❌ Error assigning plan:', error);
        res.status(500).json({ 
            message: error instanceof Error ? error.message : 'Erro ao atribuir plano',
            timestamp: new Date().toISOString()
        });
    }
});

/**
 * POST /api/admin/personal/:personalId/add-tokens - Add tokens to personal trainer
 */
router.post('/personal/:personalId/add-tokens', async (req, res) => {
    try {
        await dbConnect();
        
        const { personalId } = req.params;
        const { quantidade, customDays, motivo } = req.body;
        const adminId = (req as any).user.id;

        console.log('🔄 Adicionando tokens:', { personalId, quantidade, customDays, motivo });

        if (!quantidade || quantidade < 1) {
            return res.status(400).json({ message: 'Quantidade deve ser pelo menos 1' });
        }

        const personal = await PersonalTrainer.findById(personalId);
        if (!personal) {
            return res.status(404).json({ message: 'Personal trainer não encontrado' });
        }

        const token = await PlanoService.addTokensToPersonal(
            personalId,
            quantidade,
            adminId,
            customDays,
            motivo
        );

        console.log('✅ Tokens adicionados com sucesso:', token._id);

        res.status(201).json({
            message: 'Tokens adicionados com sucesso',
            token,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('❌ Error adding tokens:', error);
        res.status(500).json({ 
            message: 'Erro ao adicionar tokens',
            timestamp: new Date().toISOString()
        });
    }
});

/**
 * GET /api/admin/personal-trainers - Get all personal trainers with their current plan status
 */
router.get('/personal-trainers', async (req, res) => {
    try {
        await dbConnect();
        
        console.log('📊 Buscando personal trainers com status de planos...');
        
        const personalTrainers = await PersonalTrainer.find({ 
            role: 'Personal Trainer' 
        }).select('nome email createdAt statusAssinatura limiteAlunos dataInicioAssinatura dataFimAssinatura planoId');

        console.log(`✅ Encontrados ${personalTrainers.length} personal trainers.`);

        const personalTrainersWithStatus = await Promise.all(
            personalTrainers.map(async (personal) => {
                const personalId = personal._id?.toString();
                if (!personalId) return null;
                
                try {
                    const status = await PlanoService.getPersonalCurrentPlan(personalId);
                    
                    const planoNome = (status.plano && status.plano.nome) ? status.plano.nome : 'Sem plano';
                    const planoId = (status.plano && status.plano._id) ? status.plano._id : null;
                    const planoDisplay = (status.plano && status.plano.nome) ? 
                        status.plano.nome : 
                        'Sem plano';
                    
                    // Extract plan dates - prefer active plan, fallback to expired plan
                    let dataInicio = null;
                    let dataVencimento = null;
                    
                    if (status.personalPlano) {
                        dataInicio = status.personalPlano.dataInicio;
                        dataVencimento = status.personalPlano.dataVencimento;
                    }
                    
                    const personalData = {
                        _id: personal._id,
                        nome: personal.nome,
                        email: personal.email,
                        createdAt: personal.createdAt,
                        statusAssinatura: personal.statusAssinatura,
                        dataInicioAssinatura: personal.dataInicioAssinatura,
                        dataFimAssinatura: personal.dataFimAssinatura,
                        planoId: personal.planoId, 

                        planoAtual: planoNome, 
                        planoDisplay: planoDisplay, 
                        alunosAtivos: status.alunosAtivos,
                        limiteAlunos: status.limiteAtual, // Total limit: base plan + active tokens
                        percentualUso: status.limiteAtual > 0 ? Math.round((status.alunosAtivos / status.limiteAtual) * 100) : 0,
                        hasActivePlan: !!(status.plano && status.plano.nome && !status.isExpired),
                        isExpired: status.isExpired, // New field for expiration status
                        dataInicio: dataInicio, // Plan start date (preserved when expired)
                        dataVencimento: dataVencimento, // Plan expiration date (preserved when expired)
                        planDetails: (status.plano && status.plano.nome) ? {
                            id: status.plano._id,
                            nome: status.plano.nome,
                            limiteAlunos: status.plano.limiteAlunos,
                            preco: status.plano.preco
                        } : null
                    };

                    // --- NOVO LOG DE DIAGNÓSTICO NO BACKEND ---
                    console.log(`[adminPlanosRoutes] Dados finais para ${personal.nome} ANTES de enviar:`, JSON.stringify(personalData, null, 2));
                    // --- FIM NOVO LOG DE DIAGNÓSTICO NO BACKEND ---

                    return personalData;
                } catch (error) {
                    console.error(`❌ Erro ao buscar status do personal ${personalId}:`, error);
                    return {
                        _id: personal._id,
                        nome: personal.nome,
                        email: personal.email,
                        createdAt: personal.createdAt,
                        planoAtual: 'Erro ao carregar',
                        planoId: null,
                        planoDisplay: 'Erro ao carregar',
                        alunosAtivos: 0,
                        limiteAlunos: 0,
                        percentualUso: 0,
                        hasActivePlan: false,
                        isExpired: false,
                        dataInicio: null,
                        dataVencimento: null,
                        planDetails: null
                    };
                }
            })
        );

        const filteredResults = personalTrainersWithStatus.filter(Boolean);
        
        console.log(`✅ Retornando dados de ${filteredResults.length} personal trainers com status.`);

        res.json(filteredResults); 
    } catch (error) {
        console.error('❌ Erro ao buscar personal trainers:', error);
        res.status(500).json({ 
            message: 'Erro ao buscar personal trainers',
            error: error instanceof Error ? error.message : 'Erro desconhecido'
        });
    }
});

/**
 * POST /api/admin/cleanup-expired - Cleanup expired plans and tokens
 */
router.post('/cleanup-expired', async (req, res) => {
    try {
        const result = await PlanoService.cleanupExpired();
        res.json({
            message: 'Limpeza realizada com sucesso',
            ...result
        });
    } catch (error) {
        console.error('Error cleaning up expired items:', error);
        res.status(500).json({ message: 'Erro ao realizar limpeza' });
    }
});

export default router;

===== ./server/src/routes/adminRenewalRoutes.ts =====
// server/src/routes/adminRenewalRoutes.ts
import express from 'express';
import mongoose from 'mongoose';

import dbConnect from '../../lib/dbConnect.js';
import RenewalRequest, { RStatus } from '../../models/RenewalRequest.js';
import PlanoService from '../../services/PlanoService.js';
import Plano from '../../models/Plano.js';
import { authenticateAdmin } from '../../middlewares/authenticateAdmin.js';
import { getPaymentProofBucket } from '../../utils/gridfs.js';

const router = express.Router();

// Todas as rotas abaixo exigem que o usuário seja um administrador autenticado.
router.use(authenticateAdmin);

/**
 * GET /api/admin/renewal-requests
 * Lista solicitações que requerem ação do administrador.
 * Popula os dados do personal e do plano para exibição na interface.
 */
router.get('/', async (req, res, next) => {
  await dbConnect();
  try {
    const { status, limit } = req.query as { status?: string; limit?: string };
    const lim = Math.max(1, Math.min(parseInt(limit || '50', 10) || 50, 200));

    // Por padrão, busca solicitações que precisam de alguma ação do admin.
    const defaultStatuses = [
      RStatus.REQUESTED, 
      RStatus.PROOF_SUBMITTED,
      // Status legados para garantir compatibilidade
      'pending', 
      'payment_proof_uploaded'
    ];
    
    const listStatuses = status ? status.split(',').map(s => s.trim()) : defaultStatuses;

    const requests = await RenewalRequest.find({ status: { $in: listStatuses } })
      .populate('personalTrainerId', 'nome email')
      .populate('planIdRequested', 'nome limiteAlunos tipo duracao')
      .sort({ createdAt: -1 })
      .limit(lim)
      .lean();

    res.json(requests);
  } catch (error) {
    console.error('[AdminRenewal] Erro ao listar solicitações:', error);
    next(error);
  }
});

/**
 * GET /api/admin/renewal-requests/:id/proof/download
 * Permite que o administrador baixe um comprovante que foi enviado como arquivo.
 */
router.get('/:id/proof/download', async (req, res, next) => {
  await dbConnect();
  try {
    const request = await RenewalRequest.findById(req.params.id);
    if (!request) {
      return res.status(404).json({ mensagem: 'Solicitação não encontrada.' });
    }

    if (!request.proof || request.proof.kind !== 'file' || !request.proof.fileId) {
      return res.status(404).json({ mensagem: 'Comprovante não encontrado ou é um link externo.' });
    }

    const bucket = await getPaymentProofBucket();
    const downloadStream = bucket.openDownloadStream(request.proof.fileId);

    res.set({
      'Content-Type': request.proof.contentType || 'application/octet-stream',
      'Content-Disposition': `attachment; filename="${request.proof.filename || 'comprovante'}"`,
    });

    downloadStream.pipe(res);
    downloadStream.on('error', (err) => {
      console.error('Erro no download do comprovante:', err);
      if (!res.headersSent) {
        res.status(404).json({ mensagem: 'Arquivo de comprovante não encontrado no armazenamento.' });
      }
    });
  } catch (error) {
    console.error('Erro ao baixar comprovante:', error);
    next(error);
  }
});

/**
 * PUT /api/admin/renewal-requests/:id/payment-link
 * Admin envia o link de pagamento para o personal.
 * Body: { paymentLink: string }
 */
router.put('/:id/payment-link', async (req, res, next) => {
  await dbConnect();
  const { paymentLink } = req.body as { paymentLink?: string };
  try {
    if (!paymentLink || typeof paymentLink !== 'string') {
      return res.status(400).json({ mensagem: 'Link de pagamento é obrigatório.', code: 'INVALID_PAYMENT_LINK' });
    }

    const request = await RenewalRequest.findById(req.params.id);
    if (!request) {
      return res.status(404).json({ mensagem: 'Solicitação não encontrada.', code: 'REQUEST_NOT_FOUND' });
    }

    if (request.status !== RStatus.REQUESTED) {
      return res.status(400).json({ mensagem: `A solicitação não está mais aguardando um link (status atual: ${request.status}).`, code: 'INVALID_STATUS' });
    }

    request.paymentLink = paymentLink;
    request.status = RStatus.LINK_SENT;
    request.linkSentAt = new Date();
    request.adminId = new mongoose.Types.ObjectId((req as any).user.id);
    await request.save();

    res.json({
      _id: request._id,
      status: request.status,
      paymentLink: request.paymentLink,
      linkSentAt: request.linkSentAt,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * PUT /api/admin/renewal-requests/:id/approve
 * Aprova uma solicitação e ATIVA o novo plano do personal.
 * O personal então precisará finalizar o ciclo de alunos.
 * Body (opcional): { customDuration?: number, motivo?: string }
 */
router.put('/:id/approve', async (req, res, next) => {
  await dbConnect();
  const requestId = req.params.id;
  const { customDuration, motivo } = req.body as { customDuration?: number; motivo?: string };

  try {
    const request = await RenewalRequest.findById(requestId);
    if (!request) {
      return res.status(404).json({ mensagem: 'Solicitação não encontrada.', code: 'REQUEST_NOT_FOUND' });
    }

    if (request.status !== RStatus.PROOF_SUBMITTED) {
      return res.status(400).json({
        mensagem: `Apenas solicitações com comprovante enviado podem ser aprovadas (status atual: ${request.status}).`,
        code: 'INVALID_STATUS',
      });
    }

    const planId = request.planIdRequested?.toString();
    if (!planId) {
      return res.status(400).json({ mensagem: 'Plano solicitado não foi encontrado na solicitação.', code: 'MISSING_PLAN_ID' });
    }

    const plano = await Plano.findById(planId);
    if (!plano) {
      return res.status(400).json({ mensagem: 'O plano solicitado não existe mais no sistema.', code: 'PLAN_NOT_FOUND' });
    }

    // Atribui o novo plano (isso desativa o antigo)
    const newPersonalPlano = await PlanoService.assignPlanToPersonal(
      request.personalTrainerId.toString(),
      planId,
      (req as any).user.id,
      customDuration,
      motivo || 'Renovação de plano aprovada'
    );

    // Atualiza o status da solicitação para indicar que foi aprovada
    request.status = RStatus.APPROVED;
    request.paymentDecisionAt = new Date();
    request.adminId = new mongoose.Types.ObjectId((req as any).user.id);
    await request.save();

    res.json({
      message: "Plano renovado e ativado com sucesso. Aguardando o personal definir o ciclo de alunos.",
      request,
      newPersonalPlano,
    });
  } catch (error) {
    next(error);
  }
});

/**
 * PATCH /api/admin/renewal-requests/:id/decision
 * Rota para REJEITAR uma solicitação.
 * Body: { approved: false, note?: string }
 */
router.patch('/:id/decision', async (req, res, next) => {
  await dbConnect();
  const { approved, note } = req.body as { approved?: boolean; note?: string };
  try {
    if (approved === true) {
      return res.status(400).json({ mensagem: 'Para aprovar, use a rota PUT /:id/approve.' });
    }

    const request = await RenewalRequest.findById(req.params.id);
    if (!request) {
      return res.status(404).json({ mensagem: 'Solicitação não encontrada.' });
    }

    if (request.status !== RStatus.PROOF_SUBMITTED) {
      return res.status(400).json({ mensagem: `Não é possível rejeitar uma solicitação com status "${request.status}".`, code: 'INVALID_STATUS' });
    }

    request.status = RStatus.REJECTED;
    request.paymentDecisionAt = new Date();
    request.paymentDecisionNote = note;
    request.adminId = new mongoose.Types.ObjectId((req as any).user.id);

    await request.save();
    res.json(request);
  } catch (error) {
    next(error);
  }
});

export default router;
===== ./server/src/routes/adminRoutes.ts =====
// server/src/routes/adminRoutes.ts
import express, { Response, NextFunction, Request } from 'express';
import mongoose from 'mongoose';
import crypto from 'crypto';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import ConvitePersonal from '../../models/ConvitePersonal.js';
import Exercicio from '../../models/Exercicio.js';
import dbConnect from '../../lib/dbConnect.js';
// <<< INÍCIO DA ALTERAÇÃO: Importar o modelo Aluno >>>
import Aluno from '../../models/Aluno.js';
// <<< FIM DA ALTERAÇÃO >>>

const router = express.Router();

// --- ROTAS DE GESTÃO DE PERSONAL TRAINERS ---

// POST /api/admin/personal-trainers
router.post('/personal-trainers', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const { nome, email, password, role } = req.body;
    if (!nome || !email || !password) {
      return res.status(400).json({ mensagem: "Nome, email e senha são obrigatórios." });
    }
    const roleFinal = (role && role.toLowerCase() === 'admin') ? 'Admin' : 'Personal Trainer';
    const existingPersonal = await PersonalTrainer.findOne({ email: email.toLowerCase() });
    if (existingPersonal) {
      return res.status(409).json({ mensagem: `Já existe um usuário com o email: ${email}` });
    }
    const newPersonal = new PersonalTrainer({ nome, email: email.toLowerCase(), passwordHash: password, role: roleFinal });
    await newPersonal.save();
    const personalToReturn = { _id: newPersonal._id, nome: newPersonal.nome, email: newPersonal.email, role: newPersonal.role, createdAt: newPersonal.createdAt, updatedAt: newPersonal.updatedAt };
    res.status(201).json(personalToReturn);
  } catch (error) {
    console.error('[ADMIN ROUTES] Erro em POST /personal-trainers:', error);
    next(error);
  }
});

// GET /api/admin/dashboard/stats
router.get('/dashboard/stats', async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const totalPersonaisPromise = PersonalTrainer.countDocuments();
        const personaisAtivosPromise = PersonalTrainer.countDocuments({ statusAssinatura: 'ativa' });
        const convitesPendentesPromise = ConvitePersonal.countDocuments({ status: 'pendente' });
        const totalExerciciosPromise = Exercicio.countDocuments();

        const [totalPersonais, personaisAtivos, convitesPendentes, totalExercicios] = await Promise.all([
            totalPersonaisPromise,
            personaisAtivosPromise,
            convitesPendentesPromise,
            totalExerciciosPromise
        ]);
        
        const finalPersonaisAtivos = personaisAtivos > 0 ? personaisAtivos : totalPersonais;

        res.status(200).json({
            totalPersonais,
            personaisAtivos: finalPersonaisAtivos,
            convitesPendentes,
            totalExercicios
        });

    } catch (error) {
        console.error('[ADMIN ROUTES] Erro em GET /dashboard/stats:', error);
        next(error);
    }
});


// <<< INÍCIO DA ALTERAÇÃO: Rota agora busca e retorna a lista de alunos do personal >>>
// GET /api/admin/personal-trainers/:id
router.get('/personal-trainers/:id', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const { id } = req.params;
    if (!mongoose.isValidObjectId(id)) {
      return res.status(400).json({ mensagem: "ID do personal inválido." });
    }
    
    // Busca o personal e seus alunos em paralelo para melhor performance
    const [personal, alunosDoPersonal] = await Promise.all([
      PersonalTrainer.findById(id).select('-passwordHash').lean(),
      Aluno.find({ trainerId: id })
           .select('nome email status slotType slotId slotStartDate slotEndDate')
           .sort({ nome: 1 })
           .lean()
    ]);
    
    if (!personal) {
      return res.status(404).json({ mensagem: "Personal trainer não encontrado." });
    }
    
    // Combina os dados em uma única resposta
    const responsePayload = {
      ...personal,
      alunos: alunosDoPersonal // Adiciona a lista de alunos à resposta
    };
    
    res.status(200).json(responsePayload);

  } catch (error) {
    console.error(`[ADMIN ROUTES] Erro em GET /personal-trainers/${req.params.id}:`, error);
    next(error);
  }
});
// <<< FIM DA ALTERAÇÃO >>>

// PUT /api/admin/personal-trainers/:id
router.put('/personal-trainers/:id', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const { id } = req.params;
    const { nome, email, role } = req.body;
    if (!mongoose.isValidObjectId(id)) {
      return res.status(400).json({ mensagem: 'ID do personal inválido.' });
    }
    if (!nome || !email || !role) {
      return res.status(400).json({ mensagem: 'Nome, email e função são obrigatórios.' });
    }
    const personal = await PersonalTrainer.findById(id);
    if (!personal) {
      return res.status(404).json({ mensagem: 'Personal trainer não encontrado.' });
    }
    personal.nome = nome;
    personal.email = email.toLowerCase();
    personal.role = (role.toLowerCase() === 'admin') ? 'Admin' : 'Personal Trainer';
    const updatedPersonal = await personal.save();
    const personalToReturn = { _id: updatedPersonal._id, nome: updatedPersonal.nome, email: updatedPersonal.email, role: updatedPersonal.role, createdAt: updatedPersonal.createdAt, updatedAt: updatedPersonal.updatedAt };
    res.status(200).json(personalToReturn);
  } catch (error) {
    console.error(`[ADMIN ROUTES] Erro em PUT /personal-trainers/${req.params.id}:`, error);
    next(error);
  }
});

// DELETE /api/admin/personal-trainers/:id
router.delete('/personal-trainers/:id', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const { id: personalIdToDelete } = req.params;
    if (!mongoose.isValidObjectId(personalIdToDelete)) {
      return res.status(400).json({ mensagem: "ID do personal inválido." });
    }
    const personal = await PersonalTrainer.findByIdAndDelete(personalIdToDelete);
    if (!personal) {
      return res.status(404).json({ mensagem: "Personal trainer não encontrado." });
    }
    res.status(200).json({ mensagem: `Personal trainer ${personal.nome} excluído com sucesso.` });
  } catch (error) {
    console.error(`[ADMIN ROUTES] Erro em DELETE /personal-trainers/${req.params.id}:`, error);
    next(error);
  }
});

// --- ROTAS DE GESTÃO DE CONVITES ---
const conviteRouter = express.Router();

conviteRouter.post('/personal', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const { emailConvidado, roleConvidado, diasParaExpirar } = req.body;
    const adminId = req.user?.id;
    if (!adminId) {
      return res.status(401).json({ mensagem: "Administrador não autenticado." });
    }

    if (emailConvidado) {
        const convitePendente = await ConvitePersonal.findOne({ 
            emailConvidado: emailConvidado.toLowerCase().trim(), 
            status: 'pendente',
            criadoPor: new mongoose.Types.ObjectId(adminId),
        });
        if (convitePendente) {
            const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
            const linkConvite = `${frontendUrl}/cadastrar-personal/convite/${convitePendente.token}`;
            return res.status(200).json({ mensagem: "Já existe um convite pendente para este email.", linkConvite });
        }
    }

    const token = crypto.randomBytes(20).toString('hex');
    const dataExpiracao = new Date();
    dataExpiracao.setDate(dataExpiracao.getDate() + (diasParaExpirar || 7));
    
    const novoConvite = new ConvitePersonal({
      token,
      emailConvidado: emailConvidado ? emailConvidado.toLowerCase().trim() : undefined,
      roleConvidado: roleConvidado || 'Personal Trainer',
      status: 'pendente',
      dataExpiracao,
      criadoPor: new mongoose.Types.ObjectId(adminId),
    });
    
    await novoConvite.save();
    
    const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:5173';
    const linkConvite = `${frontendUrl}/cadastrar-personal/convite/${token}`;
    res.status(201).json({ mensagem: "Convite criado com sucesso!", convite: novoConvite, linkConvite });

  } catch (error) {
    next(error);
  }
});

conviteRouter.get('/personal', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const adminId = req.user?.id;
    if (!adminId) {
      return res.status(401).json({ mensagem: "Administrador não autenticado." });
    }
    const convites = await ConvitePersonal.find({ criadoPor: new mongoose.Types.ObjectId(adminId) })
      .populate('usadoPor', 'nome email')
      .sort({ createdAt: -1 });
    res.status(200).json(convites);
  } catch (error) {
    next(error);
  }
});

conviteRouter.delete('/personal/:conviteId', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const adminId = req.user?.id;
    const { conviteId } = req.params;
    if (!adminId) {
      return res.status(401).json({ mensagem: "Administrador não autenticado." });
    }
    if (!mongoose.isValidObjectId(conviteId)) {
      return res.status(400).json({ mensagem: "ID do convite inválido." });
    }
    const convite = await ConvitePersonal.findOneAndDelete({
      _id: new mongoose.Types.ObjectId(conviteId),
      criadoPor: new mongoose.Types.ObjectId(adminId),
      status: 'pendente',
    });
    if (!convite) {
      return res.status(404).json({ mensagem: "Convite não encontrado ou já utilizado." });
    }
    res.status(200).json({ mensagem: "Convite revogado com sucesso." });
  } catch (error) {
    next(error);
  }
});

router.use('/convites', conviteRouter);

export default router;
===== ./server/src/routes/alunoApiRoutes.ts =====
// server/src/routes/alunoApiRoutes.ts
import express, { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import Treino from '../../models/Treino.js';
import Sessao, { OPCOES_PSE } from '../../models/Sessao.js';
import { startOfWeek, endOfWeek, differenceInCalendarDays, parseISO, startOfDay } from 'date-fns';
import Aluno from '../../models/Aluno.js';
import ConviteAluno from '../../models/ConviteAluno.js';
import PersonalPlano from '../../models/PersonalPlano.js';
import TokenAvulso from '../../models/TokenAvulso.js';
import dbConnect from '../../lib/dbConnect.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import { authenticateAlunoToken } from '../../middlewares/authenticateAlunoToken.js';
import { checkLimiteAlunos } from '../../middlewares/checkLimiteAlunos.js';
import PlanoService from '../../services/PlanoService.js';

const router = express.Router();

// =======================================================
// ROTAS DO PERSONAL (PARA GERENCIAR ALUNOS)
// =======================================================

router.post("/convite", authenticateToken, checkLimiteAlunos, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id;
    if (!trainerId) {
        return res.status(401).json({ erro: "Personal não autenticado." });
    }

    try {
        const { emailConvidado } = req.body;

        if (emailConvidado) {
            const alunoExistente = await Aluno.findOne({ 
                email: emailConvidado, 
                trainerId: new mongoose.Types.ObjectId(trainerId) 
            });
            if (alunoExistente) {
                return res.status(409).json({ message: "Este aluno já está cadastrado com você." });
            }

            const convitePendente = await ConviteAluno.findOne({
                emailConvidado,
                status: 'pendente',
                criadoPor: trainerId
            });
            if (convitePendente) {
                const linkConvite = `${process.env.FRONTEND_URL}/convite/aluno/${convitePendente.token}`;
                return res.status(200).json({ mensagem: "Já existe um convite pendente para este email.", linkConvite });
            }
        }

        const novoConvite = new ConviteAluno({
            emailConvidado: emailConvidado || undefined,
            criadoPor: new mongoose.Types.ObjectId(trainerId)
        });

        await novoConvite.save();
        const linkConvite = `${process.env.FRONTEND_URL}/convite/aluno/${novoConvite.token}`;
        res.status(201).json({ mensagem: "Link de convite gerado com sucesso!", linkConvite });

    } catch (error) {
        next(error);
    }
});

router.get("/gerenciar", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id;
    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }

    try {
        const { status } = req.query;
        const query: { trainerId: string; status?: string } = { trainerId };

        if (status && typeof status === 'string' && status.toLowerCase() !== 'all') {
            query.status = status;
        }

        const alunos = await Aluno.find(query).sort({ nome: 1 }).select('-passwordHash');
        res.status(200).json(alunos);
    } catch (error) {
        next(error);
    }
});

router.post("/gerenciar", authenticateToken, checkLimiteAlunos, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id!;
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
        const { nome, email, password, ...outrosDados } = req.body;

        if (!nome || !email || !password) {
            await session.abortTransaction();
            return res.status(400).json({ message: "Nome, email e senha são obrigatórios." });
        }

        const alunoExistente = await Aluno.findOne({ email: email.toLowerCase() }).session(session);
        if (alunoExistente) {
            await session.abortTransaction();
            return res.status(409).json({ message: "Já existe um aluno com este email." });
        }

        const planStatus = await PlanoService.getPersonalCurrentPlan(trainerId);
        const limiteBasePlano = planStatus.isExpired ? 0 : (planStatus.plano?.limiteAlunos || 0);
        const alunosAtivosNoPlano = await Aluno.countDocuments({
            trainerId, status: 'active', slotType: 'plan'
        }).session(session);

        let slotType: 'plan' | 'token';
        let slotId: mongoose.Types.ObjectId;
        let slotStartDate: Date;
        let slotEndDate: Date;

        if (alunosAtivosNoPlano < limiteBasePlano) {
            slotType = 'plan';
            slotId = new mongoose.Types.ObjectId(planStatus.personalPlano!._id as any);
            slotStartDate = planStatus.personalPlano!.dataInicio;
            slotEndDate = planStatus.personalPlano!.dataVencimento;
        } else {
            slotType = 'token';
            const token = await TokenAvulso.findOne({
                personalTrainerId: trainerId,
                ativo: true,
                dataVencimento: { $gt: new Date() }
            }).sort({ dataVencimento: 1 }).session(session);

            if (!token) {
                await session.abortTransaction();
                return res.status(403).json({ message: "Não há vagas de plano ou tokens avulsos disponíveis." });
            }
            
            slotId = new mongoose.Types.ObjectId(token._id as any);
            slotStartDate = new Date();
            slotEndDate = token.dataVencimento;

            if (token.quantidade > 1) {
                token.quantidade -= 1;
                await token.save({ session });
            } else {
                await TokenAvulso.deleteOne({ _id: token._id }).session(session);
            }
        }
        
        const novoAluno = new Aluno({
            nome,
            email: email.toLowerCase(),
            passwordHash: password,
            trainerId: new mongoose.Types.ObjectId(trainerId),
            ...outrosDados,
            status: 'active',
            slotType,
            slotId,
            slotStartDate,
            slotEndDate,
        });

        await novoAluno.save({ session });
        await session.commitTransaction();

        const alunoResponse = novoAluno.toObject();
        delete (alunoResponse as any).passwordHash;

        res.status(201).json({
            message: "Aluno criado e vaga associada com sucesso!",
            aluno: alunoResponse
        });

    } catch (error) {
        if (session.inTransaction()) await session.abortTransaction();
        next(error);
    } finally {
        session.endSession();
    }
});

router.get("/gerenciar/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const alunoId = req.params.id;

    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }

    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ erro: "ID do aluno inválido." });
    }

    try {
        const aluno = await Aluno.findOne({
            _id: new mongoose.Types.ObjectId(alunoId),
            trainerId: new mongoose.Types.ObjectId(trainerId)
        }).select('-passwordHash');

        if (!aluno) {
            return res.status(404).json({ erro: "Aluno não encontrado ou não pertence a você." });
        }

        res.status(200).json(aluno);

    } catch (error) {
        next(error);
    }
});

router.put("/gerenciar/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const alunoId = req.params.id;

    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }

    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ erro: "ID do aluno inválido." });
    }

    try {
        const { slotType, slotId, slotStartDate, slotEndDate, ...updateData } = req.body;

        if (!updateData.nome || !updateData.email) {
            return res.status(400).json({ erro: "Nome e email são obrigatórios." });
        }

        const alunoAtualizado = await Aluno.findOneAndUpdate(
            { _id: new mongoose.Types.ObjectId(alunoId), trainerId: new mongoose.Types.ObjectId(trainerId) },
            { $set: updateData },
            { new: true, runValidators: true }
        ).select('-passwordHash');
        
        if (!alunoAtualizado) {
            return res.status(404).json({ erro: "Aluno não encontrado ou não pertence a você." });
        }

        res.status(200).json({
            mensagem: "Aluno atualizado com sucesso!",
            aluno: alunoAtualizado
        });

    } catch (error) {
        next(error);
    }
});

router.delete("/gerenciar/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id;
    const alunoId = req.params.id;

    if (!trainerId) {
        return res.status(401).json({ erro: "Usuário não autenticado." });
    }

    if (!mongoose.Types.ObjectId.isValid(alunoId)) {
        return res.status(400).json({ erro: "ID do aluno inválido." });
    }

    try {
        const alunoInativado = await Aluno.findOneAndUpdate(
            { _id: new mongoose.Types.ObjectId(alunoId), trainerId: new mongoose.Types.ObjectId(trainerId) },
            { 
              $set: { status: 'inactive' }, 
              $unset: { slotType: "", slotId: "", slotStartDate: "", slotEndDate: "" }
            },
            { new: true }
        ).select('-passwordHash');

        if (!alunoInativado) {
            return res.status(404).json({ message: "Aluno não encontrado ou não pertence a você." });
        }
        
        res.status(200).json({
            message: "Aluno marcado como inativo e vaga liberada com sucesso!",
            aluno: alunoInativado
        });
    } catch (error) {
        next(error);
    }
});


// =======================================================
// ROTAS DO ALUNO (DASHBOARD, FICHAS, HISTÓRICO)
// =======================================================
router.get('/meus-treinos', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId) return res.status(401).json({ erro: "Aluno não autenticado." });

    try {
        const rotinas = await Treino.find({ alunoId: new mongoose.Types.ObjectId(alunoId), tipo: 'individual' })
            .populate('criadorId', 'nome email')
            .populate({
                path: 'diasDeTreino.exerciciosDoDia.exercicioId',
                model: 'Exercicio',
                select: 'nome grupoMuscular urlVideo descricao categoria tipo'
            })
            .sort({ atualizadoEm: -1 })
            .lean();

        res.status(200).json(rotinas);
    } catch (error) {
        console.error("Erro ao buscar treinos do aluno:", error);
        next(error);
    }
});
router.get('/meus-treinos/:id', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    const rotinaId = req.params.id;

    if (!alunoId) return res.status(401).json({ erro: "Aluno não autenticado." });
    if (!mongoose.Types.ObjectId.isValid(rotinaId)) {
        return res.status(400).json({ erro: 'ID da rotina inválido.' });
    }

    try {
        const rotina = await Treino.findOne({
                _id: new mongoose.Types.ObjectId(rotinaId),
                alunoId: new mongoose.Types.ObjectId(alunoId)
            })
            .populate({
                path: 'diasDeTreino.exerciciosDoDia.exercicioId',
                model: 'Exercicio',
                select: 'nome urlVideo'
            })
            .lean();

        if (!rotina) {
            return res.status(404).json({ erro: 'Rotina de treino não encontrada ou não pertence a este aluno.' });
        }

        res.status(200).json(rotina);
    } catch (error) {
        console.error(`Erro ao buscar detalhes da rotina ${rotinaId} para o aluno ${alunoId}:`, error);
        next(error);
    }
});
router.get('/minhas-sessoes-concluidas-na-semana', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId) return res.status(401).json({ erro: "Aluno não autenticado." });

    try {
        const hoje = new Date();
        const inicioSemana = startOfWeek(hoje, { weekStartsOn: 0 });
        const fimSemana = endOfWeek(hoje, { weekStartsOn: 0 });

        const sessoes = await Sessao.find({
            alunoId: new mongoose.Types.ObjectId(alunoId),
            status: 'completed',
            concluidaEm: {
                $gte: inicioSemana,
                $lte: fimSemana,
            },
        }).select('_id sessionDate tipoCompromisso concluidaEm').lean();

        res.status(200).json(sessoes);
    } catch (error) {
        console.error("Erro ao buscar sessões da semana do aluno:", error);
        next(error);
    }
});
router.get('/stats-progresso', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId) return res.status(401).json({ erro: "Aluno não autenticado." });

    try {
        const sessoesConcluidas = await Sessao.find({
            alunoId: new mongoose.Types.ObjectId(alunoId),
            status: 'completed'
        }).select('concluidaEm pseAluno').lean();

        const totalTreinosConcluidos = sessoesConcluidas.length;

        const pseMap: { [key: string]: number } = OPCOES_PSE.reduce((acc, val, i) => ({ ...acc, [val]: i + 1 }), {});
        const sessoesComPSE = sessoesConcluidas.filter(s => s.pseAluno && pseMap[s.pseAluno]);
        let mediaPSE = 'N/D';
        if (sessoesComPSE.length > 0) {
            const somaPSE = sessoesComPSE.reduce((acc, s) => acc + pseMap[s.pseAluno!], 0);
            const mediaNumerica = Math.round(somaPSE / sessoesComPSE.length);
            mediaPSE = OPCOES_PSE[mediaNumerica - 1] || 'N/D';
        }

        let diasConsecutivos = 0;
        if (sessoesConcluidas.length > 0) {
            const datasDeTreinoUnicas = [...new Set(sessoesConcluidas.map(s => startOfDay(s.concluidaEm!).toISOString()))]
                                          .map(d => parseISO(d))
                                          .sort((a, b) => a.getTime() - b.getTime());
            
            if (datasDeTreinoUnicas.length > 0) {
                let streakAtual = 0;
                const hoje = startOfDay(new Date());
                const ontem = startOfDay(new Date(hoje.setDate(hoje.getDate() - 1)));
                hoje.setDate(hoje.getDate() + 1);
                
                let ultimaData = startOfDay(new Date(2000, 0, 1));
                for(const data of datasDeTreinoUnicas) {
                    if (differenceInCalendarDays(data, ultimaData) === 1) {
                        streakAtual++;
                    } else {
                        streakAtual = 1;
                    }
                    diasConsecutivos = Math.max(diasConsecutivos, streakAtual);
                    ultimaData = data;
                }
            }
        }

        res.status(200).json({
            totalTreinosConcluidos,
            mediaPSE,
            diasConsecutivos
        });

    } catch (error) {
        console.error("Erro ao calcular stats de progresso do aluno:", error);
        next(error);
    }
});
router.patch('/meus-treinos/:id/cargas', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    const rotinaId = req.params.id;
    const { diaDeTreinoId, cargas } = req.body;

    if (!alunoId) return res.status(401).json({ erro: "Aluno não autenticado." });
    
    if (!mongoose.Types.ObjectId.isValid(rotinaId)) {
        return res.status(400).json({ erro: 'ID da rotina inválido.' });
    }

    if (!diaDeTreinoId || !cargas || typeof cargas !== 'object') {
        return res.status(400).json({ erro: 'diaDeTreinoId e cargas são obrigatórios.' });
    }

    try {
        const rotina = await Treino.findOne({
            _id: new mongoose.Types.ObjectId(rotinaId),
            alunoId: new mongoose.Types.ObjectId(alunoId),
            tipo: 'individual'
        });

        if (!rotina) {
            return res.status(404).json({ erro: 'Rotina não encontrada ou não pertence a este aluno.' });
        }

        const diaDeTreino = rotina.diasDeTreino.find(dia => dia._id.toString() === diaDeTreinoId);
        if (!diaDeTreino) {
            return res.status(404).json({ erro: 'Dia de treino não encontrado na rotina.' });
        }

        let exerciciosAtualizados = 0;
        
        for (const [exercicioId, novaCarga] of Object.entries(cargas)) {
            const exercicio = diaDeTreino.exerciciosDoDia?.find(ex => ex._id.toString() === exercicioId);
            if (exercicio) {
                if (novaCarga && typeof novaCarga === 'string' && novaCarga.trim()) {
                    exercicio.carga = novaCarga.trim();
                    exerciciosAtualizados++;
                }
            }
        }

        if (exerciciosAtualizados === 0) {
            return res.status(400).json({ erro: 'Nenhum exercício foi encontrado para atualizar.' });
        }

        await rotina.save();

        res.status(200).json({
            mensagem: `${exerciciosAtualizados} carga(s) atualizada(s) com sucesso.`,
            exerciciosAtualizados
        });

    } catch (error) {
        console.error(`Erro ao atualizar cargas da rotina ${rotinaId}:`, error);
        next(error);
    }
});
router.get('/meu-historico-sessoes', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    if (!alunoId) return res.status(401).json({ erro: "Aluno não autenticado." });
    
    try {
        const page = parseInt(req.query.page as string) || 1;
        const limit = parseInt(req.query.limit as string) || 5;
        const skip = (page - 1) * limit;

        const query = {
            alunoId: new mongoose.Types.ObjectId(alunoId),
            status: 'completed'
        };

        const totalSessoes = await Sessao.countDocuments(query);
        const totalPages = Math.ceil(totalSessoes / limit);

        const sessoes = await Sessao.find(query)
            .sort({ concluidaEm: -1 })
            .skip(skip)
            .limit(limit)
            .populate('rotinaId', 'titulo')
            .populate('personalId', 'nome')
            .lean();

        res.status(200).json({
            sessoes,
            currentPage: page,
            totalPages,
            totalSessoes
        });

    } catch (error) {
        console.error("Erro ao buscar histórico de sessões do aluno:", error);
        next(error);
    }
});

export default router;
===== ./server/src/routes/auth.ts =====
// server/src/routes/auth.ts
import { Router, Request, Response, NextFunction } from 'express';
import PersonalTrainer, { IPersonalTrainer } from '../../models/PersonalTrainer.js';
import Aluno, { IAluno } from '../../models/Aluno.js';
import jwt, { Secret } from 'jsonwebtoken';
import ms from 'ms';
import mongoose from 'mongoose';
import dbConnect from '../../lib/dbConnect.js';

const router = Router();

const getJwtSecret = (): Secret => {
    const secret = process.env.JWT_SECRET;
    if (!secret) {
        console.error("FATAL_ERROR: A variável de ambiente JWT_SECRET não foi encontrada.");
        throw new Error("Configuração de segurança do servidor incompleta.");
    }
    return secret;
};

const getExpiresInSeconds = (durationString: string | undefined, defaultDuration: string): number => {
    try {
        const durationMs = ms(durationString || defaultDuration);
        return Math.floor(durationMs / 1000);
    } catch (e) {
        return Math.floor(ms(defaultDuration) / 1000);
    }
};

// Função para validar e sanitizar entrada de login
const validateLoginInput = (email: string, password: string): { isValid: boolean; message?: string } => {
    if (!email || !password) {
        return { isValid: false, message: 'Email e senha são obrigatórios.' };
    }
    
    if (typeof email !== 'string' || typeof password !== 'string') {
        return { isValid: false, message: 'Email e senha devem ser strings válidas.' };
    }
    
    // Sanitização básica do email
    const sanitizedEmail = email.trim().toLowerCase();
    
    // Validação do formato do email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(sanitizedEmail)) {
        return { isValid: false, message: 'Formato de email inválido.' };
    }
    
    // Validação da senha
    if (password.length < 1) {
        return { isValid: false, message: 'Senha não pode estar vazia.' };
    }
    
    if (password.length > 128) {
        return { isValid: false, message: 'Senha muito longa.' };
    }
    
    return { isValid: true };
};

router.post('/login', async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    
    const { email, password } = req.body;
    
    // Validação e sanitização de entrada
    const validation = validateLoginInput(email, password);
    if (!validation.isValid) {
        console.warn(`[POST /login] Entrada inválida. IP: ${req.ip}, Error: ${validation.message}`);
        return res.status(400).json({ message: validation.message, code: 'INVALID_INPUT' });
    }

    const sanitizedEmail = email.trim().toLowerCase();

    try {
        const user: IPersonalTrainer | null = await PersonalTrainer.findOne({ email: sanitizedEmail }).select('+passwordHash +role');
        
        if (!user || !user._id) {
            console.warn(`[POST /login] Tentativa de login falhada para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }
        
        const isPasswordValid = await user.comparePassword(password);
        if (!isPasswordValid) {
            console.warn(`[POST /login] Senha incorreta para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }
        
        const firstName = user.nome.split(' ')[0] || '';
        const lastName = user.nome.split(' ').slice(1).join(' ') || '';
        let role = user.role?.toLowerCase() === 'admin' ? 'admin' : 'personal';

        const tokenPayload = {
            id: user._id.toString(),
            email: user.email,
            firstName,
            lastName,
            role: role
        };

        const secret = getJwtSecret();
        const expiresIn = getExpiresInSeconds(process.env.JWT_EXPIRES_IN, '1h');
        const refreshExpiresIn = getExpiresInSeconds(process.env.JWT_REFRESH_EXPIRES_IN, '7d');
        
        const token = jwt.sign(tokenPayload, secret, { expiresIn });
        const refreshToken = jwt.sign({ id: tokenPayload.id, type: 'refresh' }, secret, { expiresIn: refreshExpiresIn });

        console.log(`[POST /login] SUCESSO: Token gerado para ${sanitizedEmail}. IP: ${req.ip}`);
        res.json({ 
            message: 'Login bem-sucedido!', 
            token, 
            refreshToken, 
            user: { ...tokenPayload } 
        });

    } catch (error) {
        console.error(`[POST /login] Erro catastrófico durante o processo de login para ${sanitizedEmail}. IP: ${req.ip}:`, error);
        next(error);
    }
});

router.post('/aluno/login', async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    
    const { email, password } = req.body;
    
    // Validação e sanitização de entrada
    const validation = validateLoginInput(email, password);
    if (!validation.isValid) {
        console.warn(`[POST /aluno/login] Entrada inválida. IP: ${req.ip}, Error: ${validation.message}`);
        return res.status(400).json({ message: validation.message, code: 'INVALID_INPUT' });
    }

    const sanitizedEmail = email.trim().toLowerCase();

    try {
        // <<< ALTERAÇÃO: Agora buscamos o status junto com o hash da senha >>>
        const aluno: IAluno | null = await Aluno.findOne({ email: sanitizedEmail }).select('+passwordHash +status');
        if (!aluno || !aluno._id) {
            console.warn(`[POST /aluno/login] Tentativa de login falhada para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }
        
        const isPasswordValid = await aluno.comparePassword(password);
        if (!isPasswordValid) {
            console.warn(`[POST /aluno/login] Senha incorreta para email: ${sanitizedEmail}. IP: ${req.ip}`);
            // Adicionado código de erro para credenciais inválidas
            return res.status(401).json({ message: 'Credenciais inválidas.', code: 'INVALID_CREDENTIALS' });
        }

        // <<< ADIÇÃO: Verificação de status ANTES de gerar o token >>>
        if (aluno.status !== 'active') {
            console.warn(`[POST /aluno/login] Falha: Tentativa de login de aluno inativo - Email: ${aluno.email}. IP: ${req.ip}`);
            // Retorna o erro 403 com a mensagem e o código que o frontend espera
            return res.status(403).json({ 
                message: 'Sua conta está inativa. Fale com seu personal trainer.', 
                code: 'ACCOUNT_INACTIVE' 
            });
        }
        
        const tokenPayload = {
            id: aluno._id.toString(),
            nome: aluno.nome,
            email: aluno.email,
            personalId: aluno.trainerId?.toString(),
            role: 'aluno',
        };

        const secret = getJwtSecret();
        const expiresIn = getExpiresInSeconds(process.env.JWT_ALUNO_EXPIRES_IN, '7d');
        const refreshExpiresIn = getExpiresInSeconds(process.env.JWT_ALUNO_REFRESH_EXPIRES_IN, '30d');
        
        const token = jwt.sign(tokenPayload, secret, { expiresIn });
        const refreshToken = jwt.sign({ id: tokenPayload.id, type: 'refresh' }, secret, { expiresIn: refreshExpiresIn });
        
        console.log(`✅ Login de Aluno bem-sucedido para: ${aluno.email}. IP: ${req.ip}`);
        res.json({
            message: 'Login de aluno bem-sucedido!',
            token,
            refreshToken,
            aluno: tokenPayload
        });
    } catch (error) {
        console.error(`[POST /aluno/login] Erro catastrófico durante o processo de login para ${sanitizedEmail}. IP: ${req.ip}:`, error);
        next(error);
    }
});

// Endpoint para renovar token de Personal/Admin
router.post('/refresh', async (req: Request, res: Response, next: NextFunction) => {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
        return res.status(400).json({ message: 'Refresh token é obrigatório.' });
    }

    try {
        const secret = getJwtSecret();
        const decoded = jwt.verify(refreshToken, secret) as any;
        
        if (decoded.type !== 'refresh') {
            return res.status(401).json({ message: 'Token inválido.', code: 'INVALID_REFRESH_TOKEN' });
        }

        // Buscar o usuário no banco
        const user: IPersonalTrainer | null = await PersonalTrainer.findById(decoded.id).select('+role');
        if (!user) {
            return res.status(401).json({ message: 'Usuário não encontrado.', code: 'USER_NOT_FOUND' });
        }

        const firstName = user.nome.split(' ')[0] || '';
        const lastName = user.nome.split(' ').slice(1).join(' ') || '';
        let role = user.role?.toLowerCase() === 'admin' ? 'admin' : 'personal';

        const tokenPayload = {
            id: (user._id as mongoose.Types.ObjectId).toString(),
            email: user.email,
            firstName,
            lastName,
            role: role
        };

        const expiresIn = getExpiresInSeconds(process.env.JWT_EXPIRES_IN, '1h');
        const newToken = jwt.sign(tokenPayload, secret, { expiresIn });

        res.json({
            message: 'Token renovado com sucesso!',
            token: newToken,
            user: { ...tokenPayload }
        });

    } catch (error) {
        console.error('[POST /refresh] Erro ao renovar token:', error);
        if (error instanceof jwt.JsonWebTokenError) {
            return res.status(401).json({ message: 'Refresh token inválido ou expirado.', code: 'INVALID_REFRESH_TOKEN' });
        }
        next(error);
    }
});

// Endpoint para renovar token de Aluno
router.post('/aluno/refresh', async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
        return res.status(400).json({ message: 'Refresh token é obrigatório.' });
    }

    try {
        const secret = getJwtSecret();
        const decoded = jwt.verify(refreshToken, secret) as any;
        
        if (decoded.type !== 'refresh') {
            return res.status(401).json({ message: 'Token inválido.', code: 'INVALID_REFRESH_TOKEN' });
        }

        // Buscar o aluno no banco
        const aluno: IAluno | null = await Aluno.findById(decoded.id).select('+status');
        if (!aluno) {
            return res.status(401).json({ message: 'Aluno não encontrado.', code: 'USER_NOT_FOUND' });
        }

        if (aluno.status !== 'active') {
            return res.status(403).json({ 
                message: 'Sua conta está inativa. Fale com seu personal trainer.', 
                code: 'ACCOUNT_INACTIVE' 
            });
        }
        
        const tokenPayload = {
            id: (aluno._id as mongoose.Types.ObjectId).toString(),
            nome: aluno.nome,
            email: aluno.email,
            personalId: aluno.trainerId?.toString(),
            role: 'aluno',
        };

        const expiresIn = getExpiresInSeconds(process.env.JWT_ALUNO_EXPIRES_IN, '7d');
        const newToken = jwt.sign(tokenPayload, secret, { expiresIn });
        
        res.json({
            message: 'Token de aluno renovado com sucesso!',
            token: newToken,
            aluno: tokenPayload
        });

    } catch (error) {
        console.error('[POST /aluno/refresh] Erro ao renovar token:', error);
        if (error instanceof jwt.JsonWebTokenError) {
            return res.status(401).json({ message: 'Refresh token inválido ou expirado.', code: 'INVALID_REFRESH_TOKEN' });
        }
        next(error);
    }
});

export default router;

===== ./server/src/routes/authRoutes.ts =====
// server/src/routes/authRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import PersonalTrainer, { IPersonalTrainer } from '../../models/PersonalTrainer.js';
import jwt from 'jsonwebtoken';
import ms from 'ms';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA

const router = Router();

const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '1h';

const calculateExpiresInSeconds = (durationStr: string): number => {
  const msValue = ms(durationStr);
  return typeof msValue === 'number' ? Math.floor(msValue / 1000) : 3600;
};
const expiresInSeconds = calculateExpiresInSeconds(JWT_EXPIRES_IN);

// --- Login Personal/Admin ---
router.post('/login', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect(); // <<< CHAMADA ADICIONADA
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ message: 'Email e senha são obrigatórios.' });

  try {
    const user: IPersonalTrainer | null = await PersonalTrainer
      .findOne({ email: email.toLowerCase() })
      .select('+passwordHash +role');

    if (!user || !user._id) {
      return res.status(401).json({ message: 'Credenciais inválidas.' });
    }

    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Credenciais inválidas.' });
    }

    const firstName = user.nome.split(' ')[0] || '';
    const lastName = user.nome.split(' ').slice(1).join(' ') || '';
    const role = user.role;

    const tokenPayload = {
      id: user._id.toString(),
      email: user.email,
      firstName,
      lastName,
      role,
    };

    if(!process.env.JWT_SECRET) {
        throw new Error("JWT_SECRET não está definido nas variáveis de ambiente.");
    }

    const token = jwt.sign(tokenPayload, process.env.JWT_SECRET, {
      expiresIn: expiresInSeconds,
    });

    res.json({
      message: 'Login bem-sucedido!',
      token,
      user: {
        id: user._id.toString(),
        trainerId: user._id.toString(),
        username: user.email,
        firstName,
        lastName,
        email: user.email,
        role,
      },
    });

  } catch (error) {
    console.error("Erro no login:", error);
    next(error);
  }
});

export default router;
===== ./server/src/routes/conviteAlunoPublicRoutes.ts =====
// server/src/routes/conviteAlunoPublicRoutes.ts
import express, { Request, Response, NextFunction } from 'express';
import ConviteAluno from '../../models/ConviteAluno.js';
import Aluno from '../../models/Aluno.js';
import PersonalTrainer from '../../models/PersonalTrainer.js'; // Importa o modelo PersonalTrainer
import mongoose from 'mongoose';
import dbConnect from '../../lib/dbConnect.js';

const router = express.Router();

// GET /api/public/convite-aluno/:token - Valida o token do convite
router.get('/:token', async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const { token } = req.params;
        const convite = await ConviteAluno.findOne({ token, status: 'pendente' });

        if (!convite || convite.dataExpiracao < new Date()) {
            if (convite) {
                convite.status = 'expirado';
                await convite.save();
            }
            return res.status(404).json({ erro: 'Convite inválido ou expirado.' });
        }

        const personal = await PersonalTrainer.findById(convite.criadoPor).select('nome');

        if (!personal) {
            return res.status(404).json({ erro: 'Personal trainer associado ao convite não encontrado.' });
        }
        
        // Retorna o e-mail (que pode ser undefined) e o nome do personal
        res.status(200).json({ email: convite.emailConvidado, personalName: personal.nome });

    } catch (error) {
        next(error);
    }
});

// POST /api/public/convite-aluno/registrar - Finaliza o cadastro do aluno
router.post('/registrar', async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const { token, nome, password, email, ...outrosDados } = req.body;

        if (!token || !nome || !password) {
            return res.status(400).json({ erro: 'Dados insuficientes para o registro.' });
        }

        const convite = await ConviteAluno.findOne({ token, status: 'pendente' });

        if (!convite || convite.dataExpiracao < new Date()) {
            if (convite) {
                convite.status = 'expirado';
                await convite.save();
            }
            return res.status(404).json({ erro: 'Convite inválido ou expirado.' });
        }
        
        const emailFinal = convite.emailConvidado || email;
        if (!emailFinal) {
            return res.status(400).json({ erro: 'O e-mail é obrigatório para o cadastro.' });
        }

        const novoAluno = new Aluno({
            nome,
            email: emailFinal, // Usa o e-mail determinado
            passwordHash: password,
            trainerId: convite.criadoPor,
            status: 'active',
            ...outrosDados,
        });

        await novoAluno.save();

        convite.status = 'utilizado';
        convite.usadoPor = novoAluno._id as mongoose.Types.ObjectId;
        await convite.save();

        res.status(201).json({ mensagem: 'Aluno registrado com sucesso!' });

    } catch (error: any) {
        if (error.code === 11000) {
            return res.status(409).json({ erro: 'Este endereço de e-mail já está em uso.' });
        }
        next(error);
    }
});

export default router;
===== ./server/src/routes/convitePublicRoutes.ts =====
// server/src/routes/convitePublicRoutes.ts
import express, { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import ConvitePersonal from '../../models/ConvitePersonal.js';
import dbConnect from '../../lib/dbConnect.js';
import PlanoService from '../../services/PlanoService.js'; // <- NOVA importação

const router = express.Router();

// Rota: GET /api/convites/validar/:tokenDeConvite
router.get('/validar/:tokenDeConvite', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  const { tokenDeConvite } = req.params;

  if (!tokenDeConvite) {
    return res.status(400).json({ mensagem: "Token de convite não fornecido." });
  }

  try {
    const convite = await ConvitePersonal.findOne({ token: tokenDeConvite });

    if (!convite) {
      return res.status(404).json({ mensagem: "Convite inválido ou não encontrado." });
    }

    if (convite.status === 'utilizado') {
      return res.status(400).json({ mensagem: "Este convite já foi utilizado." });
    }

    if (convite.status === 'expirado' || (convite.dataExpiracao && convite.dataExpiracao < new Date())) {
      if (convite.status === 'pendente') {
        convite.status = 'expirado';
        await convite.save();
      }
      return res.status(400).json({ mensagem: "Este convite expirou." });
    }
    
    res.status(200).json({
      mensagem: "Convite válido.",
      emailConvidado: convite.emailConvidado,
      roleConvidado: convite.roleConvidado,
    });

  } catch (error: any) {
    next(error);
  }
});

// Rota: POST /api/convites/registrar/:tokenDeConvite
router.post('/registrar/:tokenDeConvite', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  const { tokenDeConvite } = req.params;
  const { nome, email, password } = req.body;

  if (!tokenDeConvite) {
    return res.status(400).json({ mensagem: "Token de convite não fornecido." });
  }
  if (!nome || !password) {
    return res.status(400).json({ mensagem: "Nome e senha são obrigatórios." });
  }

  const session = await mongoose.startSession();
  try {
    session.startTransaction();

    const convite = await ConvitePersonal.findOne({ token: tokenDeConvite }).session(session);

    if (!convite) {
      await session.abortTransaction();
      return res.status(404).json({ mensagem: "Convite inválido ou não encontrado." });
    }

    if (convite.status === 'utilizado') {
      await session.abortTransaction();
      return res.status(400).json({ mensagem: "Este convite já foi utilizado." });
    }

    if (convite.status === 'expirado' || (convite.dataExpiracao && convite.dataExpiracao < new Date())) {
      if (convite.status === 'pendente') {
        convite.status = 'expirado';
        await convite.save({ session });
      }
      await session.abortTransaction();
      return res.status(400).json({ mensagem: "Este convite expirou." });
    }

    const emailFinal = convite.emailConvidado || email;
    if (!emailFinal) {
        await session.abortTransaction();
        return res.status(400).json({ mensagem: "O e-mail é obrigatório para o cadastro." });
    }

    const existingPersonal = await PersonalTrainer.findOne({ email: emailFinal.toLowerCase() }).session(session);
    if (existingPersonal) {
      await session.abortTransaction();
      return res.status(409).json({ mensagem: `Já existe um usuário com o email: ${emailFinal}` });
    }

    const novoPersonal = new PersonalTrainer({
      nome,
      email: emailFinal.toLowerCase(),
      passwordHash: password, 
      role: convite.roleConvidado,
    });
    await novoPersonal.save({ session });

    convite.status = 'utilizado';
    convite.usadoPor = novoPersonal._id as mongoose.Types.ObjectId;
    convite.dataUtilizacao = new Date();
    await convite.save({ session });

    await session.commitTransaction();

    // === ATRIBUIR PLANO FREE AUTOMATICAMENTE ===
    try {
      await PlanoService.ensureInitialPlansExist();
      const planos = await PlanoService.getAllPlans();
      const freePlan = planos.find(p => (p as any).tipo === 'free');
      if (freePlan) {
        await PlanoService.assignPlanToPersonal(
          String(novoPersonal._id),                     // converte _id para string
          String((freePlan as any)._id),
          null,
          (freePlan as any).duracao,
          'Plano Free automático na criação de conta'
        );
      }
    } catch (err) {
      console.error('Erro ao atribuir plano Free:', err);
      // Não impede o cadastro; apenas registra o erro
    }

    res.status(201).json({ mensagem: "Personal registrado com sucesso! Você já pode fazer login." });

  } catch (error: any) {
    if (session.inTransaction()) {
      await session.abortTransaction();
    }
    if (error.name === 'ValidationError') {
      const mensagens = Object.values(error.errors).map((el: any) => el.message);
      return res.status(400).json({ mensagem: mensagens.join(', ') });
    }
    next(error);
  } finally {
    session.endSession();
  }
});

export default router;

===== ./server/src/routes/dashboardGeralRoutes.ts =====
// server/src/routes/dashboardGeralRoutes.ts
import express, { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import Aluno from '../../models/Aluno.js';
import Treino from '../../models/Treino.js';
import Sessao from '../../models/Sessao.js';
import dbConnect from '../../lib/dbConnect.js';

const router = express.Router();

router.get('/', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const trainerId = req.user?.id;

    if (!trainerId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }

    try {
        const trainerObjectId = new mongoose.Types.ObjectId(trainerId);

        // --- MÉTRICAS COM A NOVA REGRA DE NEGÓCIO ---

        // 1. Total de Alunos (sem alteração)
        const totalAlunos = await Aluno.countDocuments({ trainerId: trainerObjectId });

        // <<< ALTERAÇÃO: "Alunos Ativos" agora conta pelo status do cadastro do aluno >>>
        const treinosAtivos = await Aluno.countDocuments({
            trainerId: trainerObjectId,
            status: 'active' // A nova regra de negócio
        });
        
        // 3. Total de Fichas Modelo (sem alteração)
        const totalTreinosModelo = await Treino.countDocuments({
            criadorId: trainerObjectId,
            tipo: 'modelo'
        });
        
        // 4. Feedbacks Recebidos Hoje (sem alteração)
        const hojeInicio = new Date();
        hojeInicio.setHours(0, 0, 0, 0);
        const hojeFim = new Date();
        hojeFim.setHours(23, 59, 59, 999);

        const feedbacksHojeCount = await Sessao.countDocuments({
            personalId: trainerObjectId,
            concluidaEm: { $gte: hojeInicio, $lte: hojeFim },
            status: 'completed',
            $or: [
                { pseAluno: { $exists: true, $nin: [null, ''] } },
                { comentarioAluno: { $exists: true, $nin: [null, ""] } }
            ]
        });

        res.json({
            totalAlunos,
            treinosAtivos, // Este nome de campo é mantido, mas agora representa "Alunos Ativos"
            totalTreinosModelo,
            feedbacksHojeCount,
        });

    } catch (error) {
        console.error("[GET /api/dashboard/geral] Erro ao buscar estatísticas:", error);
        next(error);
    }
});

export default router;
===== ./server/src/routes/exercicios.ts =====
// server/src/routes/exercicios.ts
import express, { Request, Response, Router, NextFunction } from "express";
import mongoose from "mongoose";
import Exercicio, { IExercicio } from "../../models/Exercicio.js";
import Treino from "../../models/Treino.js";
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js';

const router: Router = express.Router();

// Função auxiliar de filtro
const buildFilterQuery = (baseFilter: mongoose.FilterQuery<IExercicio>, req: Request): mongoose.FilterQuery<IExercicio> => {
    const query: mongoose.FilterQuery<IExercicio> = { ...baseFilter };
    const { grupo, categoria } = req.query;
    if (grupo && typeof grupo === 'string' && grupo !== 'all') query.grupoMuscular = grupo;
    if (categoria && typeof categoria === 'string' && categoria !== 'all') query.categoria = categoria;
    return query;
};

// <<< CONSOLIDAÇÃO: Nova rota GET /biblioteca para todos os tipos de filtro >>>
router.get("/biblioteca", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  const userId = req.user?.id; 

  try {
    if (!userId) return res.status(401).json({ mensagem: "Usuário não autenticado." });

    const { tipo } = req.query; // 'todos', 'app', 'meus', 'favoritos'
    let baseFilter: mongoose.FilterQuery<IExercicio> = {};

    switch (tipo) {
      case 'app':
        baseFilter.isCustom = { $ne: true }; // Exercícios do App (não personalizados)
        break;
      case 'meus':
        baseFilter.isCustom = true; // Exercícios personalizados
        baseFilter.creatorId = new mongoose.Types.ObjectId(userId); // Apenas os do usuário logado
        break;
      case 'favoritos':
        baseFilter.favoritedBy = new mongoose.Types.ObjectId(userId); // Exercícios favoritados pelo usuário
        break;
      case 'todos':
      default:
        // Retorna todos os exercícios do App + os personalizados do usuário logado
        baseFilter.$or = [
          { isCustom: { $ne: true } },
          { isCustom: true, creatorId: new mongoose.Types.ObjectId(userId) }
        ];
        break;
    }

    const finalFilterQuery = buildFilterQuery(baseFilter, req);
    
    // Busca os exercícios com os filtros aplicados
    const exercicios = await Exercicio.find(finalFilterQuery).lean();

    // Adiciona a flag isFavoritedByCurrentUser para cada exercício
    const exerciciosComFavorito = exercicios.map(ex => ({
      ...ex,
      isFavoritedByCurrentUser: ex.favoritedBy?.some(favId => favId.equals(new mongoose.Types.ObjectId(userId))) ?? false
    }));

    res.status(200).json(exerciciosComFavorito);
  } catch (error) {
    console.error("Erro ao buscar exercícios da biblioteca:", error);
    next(error);
  }
});

// As rotas GET /app, /meus, /favoritos foram consolidadas na rota /biblioteca e podem ser removidas se não houver outro uso.
// Se ainda houver outros usos específicos, elas podem ser mantidas, mas a rota /biblioteca é a principal para o modal.

// POST / - Criar um novo exercício
router.post("/", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const { nome, descricao, categoria, grupoMuscular, urlVideo, isCustom } = req.body;
    const requesterId = req.user?.id;
    const requesterRole = req.user?.role;

    if (!requesterId) return res.status(401).json({ erro: "Usuário não autenticado." });
    if (!nome) return res.status(400).json({ erro: "O nome do exercício é obrigatório." });

    try {
        const exercicioData: Partial<IExercicio> = {
            nome: nome.trim(), descricao, categoria, grupoMuscular, urlVideo, isCustom
        };
        if (isCustom === false) {
            if (requesterRole?.toLowerCase() !== 'admin') {
                return res.status(403).json({ erro: "Apenas administradores podem criar exercícios do App." });
            }
            exercicioData.creatorId = undefined;
        } else {
            exercicioData.isCustom = true;
            exercicioData.creatorId = new mongoose.Types.ObjectId(requesterId);
            const jaExiste = await Exercicio.findOne({ nome: nome.trim(), creatorId: exercicioData.creatorId });
            if (jaExiste) return res.status(409).json({ erro: "Você já possui um exercício personalizado com esse nome." });
        }
        const novoExercicio = await Exercicio.create(exercicioData);
        res.status(201).json(novoExercicio);
    } catch (error) {
        next(error);
    }
});
// PUT /:id - Atualizar um exercício
router.put("/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const requesterId = req.user?.id;
    const requesterRole = req.user?.role;
    const { id } = req.params;
    const updates = req.body;

    if (!mongoose.Types.ObjectId.isValid(id)) return res.status(400).json({ erro: "ID inválido." });
    if (!requesterId) return res.status(401).json({ erro: "Não autorizado." });

    try {
        const exercicio = await Exercicio.findById(id);
        if (!exercicio) return res.status(404).json({ erro: "Exercício não encontrado." });
        const isOwner = exercicio.creatorId?.equals(new mongoose.Types.ObjectId(requesterId));
        const isAdmin = requesterRole?.toLowerCase() === 'admin';
        if ((exercicio.isCustom && isOwner) || (!exercicio.isCustom && isAdmin)) {
            Object.assign(exercicio, updates);
            await exercicio.save();
            res.status(200).json(exercicio);
        } else {
            return res.status(403).json({ erro: "Permissão negada para editar este exercício." });
        }
    } catch (error) {
        next(error);
    }
});


// DELETE /:id - Deletar um exercício
router.delete("/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const requesterId = req.user?.id;
    const requesterRole = req.user?.role;
    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) return res.status(400).json({ erro: "ID inválido." });
    if (!requesterId) return res.status(401).json({ erro: "Não autorizado." });

    try {
        const exercicio = await Exercicio.findById(id);
        if (!exercicio) return res.status(404).json({ erro: "Exercício não encontrado." });
        
        const isOwner = exercicio.creatorId?.equals(new mongoose.Types.ObjectId(requesterId));
        const isAdmin = requesterRole?.toLowerCase() === 'admin';

        if ((exercicio.isCustom && isOwner) || (!exercicio.isCustom && isAdmin)) {
            
            // <<< CORREÇÃO: Lógica de remoção em cascata >>>
            const exercicioId = new mongoose.Types.ObjectId(id);

            // 1. Remove o exercício de todas as rotinas
            await Treino.updateMany(
                { "diasDeTreino.exerciciosDoDia.exercicioId": exercicioId },
                { $pull: { "diasDeTreino.$[].exerciciosDoDia": { exercicioId: exercicioId } } }
            );

            // 2. Deleta o exercício principal
            await exercicio.deleteOne();
            
            res.status(200).json({ message: "Exercício deletado com sucesso e removido de todas as rotinas." });
        } else {
            return res.status(403).json({ erro: "Permissão negada para deletar este exercício." });
        }
    } catch (error) {
        next(error);
    }
});

// ... (rotas de favorite/unfavorite permanecem inalteradas)
// POST /:id/favorite - Favoritar
router.post("/:id/favorite", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const userId = req.user?.id;
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id) || !userId) return res.status(400).json({ erro: "Requisição inválida." });
    try {
        await Exercicio.updateOne({ _id: id }, { $addToSet: { favoritedBy: new mongoose.Types.ObjectId(userId) } });
        res.status(200).json({ message: "Exercício favoritado." });
    } catch (error) { next(error); }
});
// DELETE /:id/favorite - Desfavoritar
router.delete("/:id/favorite", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const userId = req.user?.id;
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id) || !userId) return res.status(400).json({ erro: "Requisição inválida." });
    try {
        await Exercicio.updateOne({ _id: id }, { $pull: { favoritedBy: new mongoose.Types.ObjectId(userId) } });
        res.status(200).json({ message: "Exercício desfavoritado." });
    } catch (error) { next(error); }
});

export default router;

===== ./server/src/routes/healthRoutes.ts =====
// server/src/routes/healthRoutes.ts
import express from 'express';
import dbConnect from '../../lib/dbConnect.js';
import PlanoService from '../../services/PlanoService.js';
import mongoose from 'mongoose';

const router = express.Router();

/**
 * GET /api/health - Health check endpoint
 */
router.get('/health', async (req, res) => {
    const healthStatus = {
        status: 'ok',
        timestamp: new Date().toISOString(),
        version: '1.0.0',
        database: 'disconnected',
        plans: 'unknown',
        checks: {
            database: false,
            plans: false,
            connection: false
        }
    };

    try {
        // Check database connection
        await dbConnect();
        healthStatus.database = 'connected';
        healthStatus.checks.database = true;
        healthStatus.checks.connection = mongoose.connection.readyState === 1;

        // Check plans availability
        try {
            const planos = await PlanoService.getAllPlans();
            healthStatus.plans = `${planos.length} plans available`;
            healthStatus.checks.plans = planos.length > 0;
        } catch (planError) {
            console.error('Health check - Plans error:', planError);
            healthStatus.plans = 'error checking plans';
        }

        // Overall status
        const allChecksPass = Object.values(healthStatus.checks).every(check => check === true);
        healthStatus.status = allChecksPass ? 'healthy' : 'degraded';

        res.status(allChecksPass ? 200 : 503).json(healthStatus);

    } catch (error) {
        console.error('Health check failed:', error);
        
        healthStatus.status = 'unhealthy';
        healthStatus.database = 'error';
        
        res.status(503).json({
            ...healthStatus,
            error: error instanceof Error ? error.message : 'Unknown error'
        });
    }
});

/**
 * GET /api/health/detailed - Detailed system status
 */
router.get('/health/detailed', async (req, res) => {
    try {
        await dbConnect();
        
        const detailedStatus = {
            timestamp: new Date().toISOString(),
            database: {
                connected: mongoose.connection.readyState === 1,
                readyState: mongoose.connection.readyState,
                host: mongoose.connection.host,
                name: mongoose.connection.name
            },
            plans: {
                available: 0,
                initialized: false,
                status: 'unknown'
            },
            memory: {
                used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
                total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024)
            },
            uptime: Math.round(process.uptime())
        };

        // Check plans in detail
        try {
            const planos = await PlanoService.getAllPlans();
            detailedStatus.plans.available = planos.length;
            detailedStatus.plans.initialized = planos.length > 0;
            detailedStatus.plans.status = planos.length > 0 ? 'ready' : 'needs_initialization';
        } catch (error) {
            detailedStatus.plans.status = 'error';
        }

        res.json(detailedStatus);
        
    } catch (error) {
        console.error('Detailed health check failed:', error);
        res.status(503).json({
            error: 'Health check failed',
            message: error instanceof Error ? error.message : 'Unknown error',
            timestamp: new Date().toISOString()
        });
    }
});

export default router;
===== ./server/src/routes/pastasTreinos.ts =====
// server/src/routes/pastasTreinos.ts
import express, { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import PastaTreino from '../../models/Pasta.js';
import Treino from '../../models/Treino.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA

const router = express.Router();

console.log("--- [server/src/routes/pastasTreinos.ts] Ficheiro carregado (DEBUG transação para reordenar - Correção TS) ---");

router.put('/reordenar', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const criadorId = req.user?.id;
    const { novaOrdemIds } = req.body;

    console.log(`[DEBUG PUT /api/pastas/treinos/reordenar] Tentativa de reordenar pastas. CriadorID: ${criadorId}`);
    console.log(`[DEBUG PUT /api/pastas/treinos/reordenar] Nova ordem de IDs recebida:`, novaOrdemIds);

    if (!criadorId) {
        console.warn("[DEBUG PUT /api/pastas/treinos/reordenar] Usuário não autenticado.");
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }

    if (!Array.isArray(novaOrdemIds) || novaOrdemIds.some(id => typeof id !== 'string' || !mongoose.Types.ObjectId.isValid(id))) {
        console.warn("[DEBUG PUT /api/pastas/treinos/reordenar] 'novaOrdemIds' deve ser um array de IDs de pasta válidos.");
        return res.status(400).json({ mensagem: "'novaOrdemIds' deve ser um array de IDs de pasta válidos." });
    }

    const session = await mongoose.startSession();
    let sessionIdForLogging = "N/A_SESSAO_INIT";
    try {
        if (session.id && session.id.id && typeof session.id.id.toString === 'function') {
            sessionIdForLogging = session.id.id.toString('hex');
        } else {
            sessionIdForLogging = "ID_SESSAO_NAO_RECUPERAVEL";
            console.warn("[DEBUG TRANSACTION] Não foi possível obter o ID da sessão para logging.");
        }

        console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Iniciando transação para reordenar pastas.`);
        session.startTransaction();

        const criadorObjectId = new mongoose.Types.ObjectId(criadorId);

        for (let i = 0; i < novaOrdemIds.length; i++) {
            const pastaId = novaOrdemIds[i];
            const index = i;
            console.log(`  [DEBUG TRANSACTION ${sessionIdForLogging}] Atualizando Pasta ID: ${pastaId} para Ordem: ${index}`);
            const result = await PastaTreino.updateOne(
                { _id: new mongoose.Types.ObjectId(pastaId), criadorId: criadorObjectId },
                { $set: { ordem: index } },
                { session }
            );
            console.log(`    [DEBUG TRANSACTION ${sessionIdForLogging}] Resultado para Pasta ID ${pastaId}: matchedCount=${result.matchedCount}, modifiedCount=${result.modifiedCount}`);
            if (result.matchedCount === 0) {
                console.warn(`  [DEBUG TRANSACTION ${sessionIdForLogging}] ERRO: Pasta com ID ${pastaId} não encontrada para o usuário ${criadorId}. Abortando.`);
                await session.abortTransaction();
                return res.status(404).json({ mensagem: `Erro ao reordenar: Pasta com ID ${pastaId} não encontrada.` });
            }
        }

        console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Commitando transação.`);
        await session.commitTransaction();
        console.log("[DEBUG PUT /api/pastas/treinos/reordenar] Pastas reordenadas com sucesso (com transação).");
        res.status(200).json({ mensagem: "Pastas reordenadas com sucesso." });

    } catch (error: any) {
        console.error(`[DEBUG TRANSACTION ${sessionIdForLogging}] Erro durante a transação de reordenar pastas:`, error);
        if (session.inTransaction()) {
            console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Abortando transação devido a erro.`);
            await session.abortTransaction();
        } else {
            console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Transação não estava ativa no momento do erro ou já foi abortada/commitada.`);
        }
        next(error);
    } finally {
        console.log(`[DEBUG TRANSACTION ${sessionIdForLogging}] Finalizando sessão.`);
        await session.endSession();
    }
});

router.post('/', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect(); // <<< CHAMADA ADICIONADA
  const criadorId = req.user?.id;
  const { nome } = req.body;

  console.log(`[POST /api/pastas/treinos] Tentativa de criar pasta. Nome: "${nome}", CriadorID: ${criadorId}`);

  if (!criadorId) {
    console.warn("[POST /api/pastas/treinos] Usuário não autenticado.");
    return res.status(401).json({ mensagem: "Usuário não autenticado." });
  }

  if (!nome || typeof nome !== 'string' || nome.trim().length === 0) {
    console.warn("[POST /api/pastas/treinos] Nome da pasta ausente ou inválido.");
    return res.status(400).json({ mensagem: "O nome da pasta é obrigatório e não pode ser vazio." });
  }

  try {
    const criadorObjectId = new mongoose.Types.ObjectId(criadorId);
    const pastaExistente = await PastaTreino.findOne({ nome: nome.trim(), criadorId: criadorObjectId });
    if (pastaExistente) {
      console.warn(`[POST /api/pastas/treinos] Pasta com nome "${nome.trim()}" já existe para o usuário ${criadorId}.`);
      return res.status(409).json({ mensagem: `Uma pasta com o nome "${nome.trim()}" já existe.` });
    }

    const contagemPastas = await PastaTreino.countDocuments({ criadorId: criadorObjectId });

    const novaPasta = new PastaTreino({
      nome: nome.trim(),
      criadorId: criadorObjectId,
      ordem: contagemPastas,
    });

    await novaPasta.save();
    console.log(`[POST /api/pastas/treinos] Pasta "${novaPasta.nome}" criada com sucesso. ID: ${novaPasta._id}, Ordem: ${novaPasta.ordem}`);
    res.status(201).json(novaPasta);

  } catch (error: any) {
    console.error("[POST /api/pastas/treinos] Erro ao criar pasta:", error);
    if (error.name === 'ValidationError') {
      const mensagens = Object.values(error.errors).map((el: any) => el.message);
      return res.status(400).json({ mensagem: mensagens.join(', ') });
    }
    next(error);
  }
});

router.get('/', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect(); // <<< CHAMADA ADICIONADA
  const criadorId = req.user?.id;
  console.log(`[GET /api/pastas/treinos] Buscando pastas para o criador ID: ${criadorId}`);

  if (!criadorId) {
    console.warn("[GET /api/pastas/treinos] Usuário não autenticado.");
    return res.status(401).json({ mensagem: "Usuário não autenticado." });
  }

  try {
    const pastas = await PastaTreino.find({ criadorId: new mongoose.Types.ObjectId(criadorId) })
      .sort({ ordem: 1, nome: 1 });

    console.log(`[GET /api/pastas/treinos] ${pastas.length} pastas encontradas para o usuário ${criadorId}.`);
    res.status(200).json(pastas);

  } catch (error: any) {
    console.error("[GET /api/pastas/treinos] Erro ao buscar pastas:", error);
    next(error);
  }
});

router.put('/:pastaId', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const { pastaId } = req.params;
    const criadorId = req.user?.id;
    const { nome } = req.body;

    console.log(`[PUT /api/pastas/treinos/${pastaId}] Tentativa de editar pasta. Novo nome: "${nome}", CriadorID: ${criadorId}`);

    if (!criadorId) {
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }
    if (!mongoose.Types.ObjectId.isValid(pastaId)) {
        return res.status(400).json({ mensagem: "ID da pasta inválido." });
    }
    if (!nome || typeof nome !== 'string' || nome.trim().length === 0) {
        return res.status(400).json({ mensagem: "O nome da pasta é obrigatório." });
    }

    try {
        const criadorObjectId = new mongoose.Types.ObjectId(criadorId);
        const pastaObjectId = new mongoose.Types.ObjectId(pastaId);

        const pastaParaAtualizar = await PastaTreino.findOne({ _id: pastaObjectId, criadorId: criadorObjectId });

        if (!pastaParaAtualizar) {
            return res.status(404).json({ mensagem: "Pasta não encontrada ou você não tem permissão para editá-la." });
        }

        const pastaComMesmoNome = await PastaTreino.findOne({
            nome: nome.trim(),
            criadorId: criadorObjectId,
            _id: { $ne: pastaObjectId }
        });

        if (pastaComMesmoNome) {
            return res.status(409).json({ mensagem: `Outra pasta com o nome "${nome.trim()}" já existe.` });
        }

        pastaParaAtualizar.nome = nome.trim();
        await pastaParaAtualizar.save();

        console.log(`[PUT /api/pastas/treinos/${pastaId}] Pasta atualizada com sucesso para "${pastaParaAtualizar.nome}".`);
        res.status(200).json(pastaParaAtualizar);

    } catch (error: any) {
        console.error(`[PUT /api/pastas/treinos/${pastaId}] Erro ao editar pasta:`, error);
        if (error.name === 'ValidationError') {
            const mensagens = Object.values(error.errors).map((el: any) => el.message);
            return res.status(400).json({ mensagem: mensagens.join(', ') });
        }
        next(error);
    }
});

router.delete('/:pastaId', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const { pastaId } = req.params;
    const criadorId = req.user?.id;

    console.log(`[DELETE /api/pastas/treinos/${pastaId}] Tentativa de excluir pasta. CriadorID: ${criadorId}`);

    if (!criadorId) {
        console.warn(`[DELETE /api/pastas/treinos/${pastaId}] Usuário não autenticado.`);
        return res.status(401).json({ mensagem: "Usuário não autenticado." });
    }

    if (!mongoose.Types.ObjectId.isValid(pastaId)) {
        console.warn(`[DELETE /api/pastas/treinos/${pastaId}] ID da pasta inválido: ${pastaId}`);
        return res.status(400).json({ mensagem: "ID da pasta inválido." });
    }

    const session = await mongoose.startSession();
    let sessionIdForLogging = "N/A_SESSAO_INIT_DELETE";
    try {
        if (session.id && session.id.id && typeof session.id.id.toString === 'function') {
            sessionIdForLogging = session.id.id.toString('hex');
        } else {
            sessionIdForLogging = "ID_SESSAO_NAO_RECUPERAVEL_DELETE";
             console.warn("[TRANSACTION DELETE] Não foi possível obter o ID da sessão para logging.");
        }

        console.log(`[TRANSACTION ${sessionIdForLogging}] Iniciando transação para excluir pasta ${pastaId}.`);
        session.startTransaction();

        const pastaObjectId = new mongoose.Types.ObjectId(pastaId);
        const criadorObjectId = new mongoose.Types.ObjectId(criadorId);

        const pastaParaExcluir = await PastaTreino.findOne({ _id: pastaObjectId, criadorId: criadorObjectId }).session(session);

        if (!pastaParaExcluir) {
            console.warn(`[TRANSACTION ${sessionIdForLogging}] Pasta não encontrada ou usuário não autorizado. Abortando.`);
            await session.abortTransaction();
            return res.status(404).json({ mensagem: "Pasta não encontrada ou você não tem permissão para excluí-la." });
        }

        console.log(`  [TRANSACTION ${sessionIdForLogging}] Desassociando fichas da pasta ${pastaId}.`);
        const updateResult = await Treino.updateMany(
            { criadorId: criadorObjectId, tipo: 'modelo', pastaId: pastaObjectId },
            { $set: { pastaId: null } },
            { session }
        );
        console.log(`  [TRANSACTION ${sessionIdForLogging}] ${updateResult.modifiedCount} fichas foram desassociadas.`);

        console.log(`  [TRANSACTION ${sessionIdForLogging}] Excluindo pasta ${pastaId}.`);
        const deleteResult = await PastaTreino.deleteOne({ _id: pastaObjectId, criadorId: criadorObjectId }, { session });

        if (deleteResult.deletedCount === 0) {
            console.warn(`  [TRANSACTION ${sessionIdForLogging}] ERRO: Falha ao deletar a pasta ${pastaId} (não encontrada ou já deletada). Abortando.`);
            await session.abortTransaction();
            return res.status(404).json({ mensagem: "Erro ao excluir: Pasta não encontrada no momento da exclusão." });
        }

        console.log(`[TRANSACTION ${sessionIdForLogging}] Commitando transação.`);
        await session.commitTransaction();
        console.log(`[DELETE /api/pastas/treinos/${pastaId}] Pasta "${pastaParaExcluir.nome}" excluída com sucesso (com transação).`);
        res.status(200).json({ mensagem: `Pasta "${pastaParaExcluir.nome}" excluída com sucesso.` });

    } catch (error: any) {
        console.error(`[TRANSACTION ${sessionIdForLogging}] Erro durante a transação de excluir pasta ${pastaId}:`, error);
        if (session.inTransaction()) {
            console.log(`[TRANSACTION ${sessionIdForLogging}] Abortando transação devido a erro.`);
            await session.abortTransaction();
        } else {
            console.log(`[TRANSACTION ${sessionIdForLogging}] Transação não estava ativa no momento do erro ou já foi abortada/commitada.`);
        }
        next(error);
    } finally {
        console.log(`[TRANSACTION ${sessionIdForLogging}] Finalizando sessão.`);
        await session.endSession();
    }
});

export default router;
===== ./server/src/routes/personalPlanosRoutes.ts =====
// server/src/routes/personalPlanosRoutes.ts

import express, { Request, Response, NextFunction } from 'express';
import PlanoService from '../../services/PlanoService.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js';
import Aluno from '../../models/Aluno.js';
import Plano from '../../models/Plano.js';
import mongoose from 'mongoose';

const router = express.Router();

// Aplica autenticação a todas as rotas
router.use(authenticateToken);

/**
 * GET /api/personal/meu-plano - Consulta o plano atual do personal
 */
router.get('/meu-plano', async (req: Request, res: Response, next: NextFunction) => {
  try {
    await dbConnect();
    const personalTrainerId = (req as any).user.id;
    const status = await PlanoService.getPersonalCurrentPlan(personalTrainerId);

    res.json({
      plano: status.plano,
      personalPlano: status.personalPlano,
      limiteAtual: status.limiteAtual,
      alunosAtivos: status.alunosAtivos,
      tokensAvulsos: status.tokensAvulsos,
      percentualUso: status.limiteAtual > 0 ? Math.round((status.alunosAtivos / status.limiteAtual) * 100) : 0,
      podeAtivarMais: status.limiteAtual > status.alunosAtivos,
      vagasDisponiveis: status.limiteAtual - status.alunosAtivos
    });
  } catch (error) {
    console.error('Erro ao consultar plano do personal:', error);
    next(error);
  }
});

/**
 * GET /api/personal/can-activate/:quantidade? - Verifica se há vagas para cadastrar mais alunos
 */
router.get('/can-activate/:quantidade?', async (req: Request, res: Response, next: NextFunction) => {
  try {
    await dbConnect();
    const personalTrainerId = (req as any).user.id;
    const quantidade = parseInt(req.params.quantidade || '1');
    if (isNaN(quantidade) || quantidade < 1) {
      return res.status(400).json({ mensagem: 'Quantidade deve ser pelo menos 1' });
    }
    const status = await PlanoService.canActivateMoreStudents(personalTrainerId, quantidade);
    res.json(status);
  } catch (error) {
    console.error('Erro ao verificar vagas disponíveis:', error);
    next(error);
  }
});

/**
 * GET /api/personal/tokens-ativos - Retorna a quantidade de tokens avulsos ativos
 */
router.get('/tokens-ativos', async (req: Request, res: Response, next: NextFunction) => {
  try {
    await dbConnect();
    const personalTrainerId = (req as any).user.id;
    const tokensQuantity = await PlanoService.getTokensAvulsosAtivos(personalTrainerId);
    res.json({ quantidadeTotal: tokensQuantity });
  } catch (error) {
    console.error('Erro ao buscar tokens ativos:', error);
    next(error);
  }
});

/**
 * GET /api/personal/meus-tokens - Lista detalhes dos tokens avulsos ativos do personal
 */
router.get('/meus-tokens', async (req, res, next: NextFunction) => {
  try {
    await dbConnect();
    const personalTrainerId = (req as any).user.id;
    const detalhes = await PlanoService.getDetailedTokensForAdmin(personalTrainerId);
    const tokens = detalhes.activeTokens.map(token => ({
      id: token._id,
      quantidade: token.quantidade,
      dataAdicao: token.createdAt,
      dataVencimento: token.dataVencimento
    }));
    res.json({ tokens });
  } catch (error) {
    console.error('Erro ao buscar tokens do personal:', error);
    next(error);
  }
});

/**
 * GET /api/personal/planos-disponiveis - Lista todos os planos disponíveis para upgrade/downgrade
 */
router.get('/planos-disponiveis', async (req: Request, res: Response, next: NextFunction) => {
  try {
    await dbConnect();
    const planos = await PlanoService.getAllPlans();
    const planosPublicos = planos.map(plano => ({
      _id: plano._id,
      nome: plano.nome,
      descricao: plano.descricao,
      limiteAlunos: plano.limiteAlunos,
      preco: plano.preco,
      duracao: plano.duracao,
      tipo: plano.tipo
    }));
    res.json(planosPublicos);
  } catch (error) {
    console.error('Erro ao buscar planos disponíveis:', error);
    next(error);
  }
});

// <<< INÍCIO DA ALTERAÇÃO >>>
/**
 * POST /api/personal/renovar-plano - Finaliza o ciclo de renovação, definindo quais alunos continuam.
 * Esta rota NÃO atribui um novo plano, ela assume que o plano já foi ativado pelo admin.
 */
router.post('/renovar-plano', async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const session = await mongoose.startSession();
    
    try {
        await session.withTransaction(async () => {
            const personalTrainerId = req.user?.id;
            const { alunosSelecionados } = req.body;

            if (!personalTrainerId) {
                throw new Error('Usuário não autenticado.');
            }
            if (!Array.isArray(alunosSelecionados)) {
                throw new Error('A lista de alunos selecionados é inválida.');
            }

            // 1. Encontra o plano ATUAL e ATIVO do personal (que foi recém atribuído pelo admin).
            const planStatus = await PlanoService.getPersonalCurrentPlan(personalTrainerId);
            
            if (!planStatus || !planStatus.personalPlano || planStatus.isExpired) {
                throw new Error('Nenhum plano ativo foi encontrado. A renovação pode não ter sido concluída pelo administrador.');
            }
            const { personalPlano, plano, tokensAvulsos } = planStatus;

            if (!plano) {
               throw new Error('Detalhes do plano ativo não foram encontrados.');
            }

            const limiteTotal = (plano.limiteAlunos || 0) + (tokensAvulsos || 0);

            // 2. Valida o limite de alunos.
            if (alunosSelecionados.length > limiteTotal) {
                throw new Error(`Limite de vagas excedido. Seu limite total é de ${limiteTotal} vagas (plano + tokens), mas ${alunosSelecionados.length} alunos foram selecionados.`);
            }

            const personalObjectId = new mongoose.Types.ObjectId(personalTrainerId);
            const alunosSelecionadosIds = alunosSelecionados.map(id => new mongoose.Types.ObjectId(id));

            // 3. Inativa TODOS os alunos do personal que estavam ativos, limpando seus slots.
            // Isso garante que alunos de ciclos antigos não mantenham vagas indevidamente.
            await Aluno.updateMany(
                { trainerId: personalObjectId, status: 'active' },
                { 
                    $set: { status: 'inactive' },
                    $unset: { slotType: "", slotId: "", slotStartDate: "", slotEndDate: "" }
                },
                { session }
            );

            // 4. Reativa os alunos SELECIONADOS, atribuindo o novo slot do plano.
            if (alunosSelecionados.length > 0) {
                await Aluno.updateMany(
                    { _id: { $in: alunosSelecionadosIds }, trainerId: personalObjectId },
                    {
                        $set: {
                            status: 'active',
                            slotType: 'plan',
                            slotId: personalPlano._id,
                            slotStartDate: personalPlano.dataInicio,
                            slotEndDate: personalPlano.dataVencimento,
                        }
                    },
                    { session }
                );
            }
        });

        res.json({
            mensagem: 'Ciclo de renovação finalizado e alunos atualizados com sucesso!',
            dados: {
                alunosMantidos: req.body.alunosSelecionados.length
            }
        });

    } catch (error) {
        next(error);
    } finally {
        await session.endSession();
    }
});
// <<< FIM DA ALTERAÇÃO >>>


export default router;
===== ./server/src/routes/personalRenewalRoutes.ts =====
// server/src/routes/personalRenewalRoutes.ts
import express from 'express';
import multer from 'multer';
import mongoose from 'mongoose';

import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js';
import RenewalRequest, { IRenewalRequest, RStatus, RenewalStatus } from '../../models/RenewalRequest.js';
import { getPaymentProofBucket } from '../../utils/gridfs.js';
import PlanoService from '../../services/PlanoService.js';
import Aluno from '../../models/Aluno.js';
import PersonalPlano from '../../models/PersonalPlano.js';

const router = express.Router();
router.use(authenticateToken);

// Configuração do Multer (upload de arquivos)
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
  fileFilter: (req, file, cb) => {
    if (file.mimetype.match(/^(image\/(jpeg|png)|application\/pdf)$/)) {
      cb(null, true);
    } else {
      cb(new Error('Apenas arquivos JPEG, PNG e PDF são permitidos'));
    }
  }
});

/**
 * Lista as solicitações do personal logado.
 */
async function listMyRenewals(req: any, res: any, next: any) {
  try {
    await dbConnect();
    const personalTrainerId = req.user.id;
    const { status, limit } = req.query as { status?: string; limit?: string };

    const query: any = { personalTrainerId };
    if (status) {
      const statuses = status.split(',').map(s => s.trim());
      query.status = { $in: statuses };
    }

    const lim = Math.max(1, Math.min(parseInt(limit || '25', 10) || 25, 100));

    const items = await RenewalRequest
      .find(query)
      .populate('planIdRequested', 'nome') // Popula o nome do plano
      .sort({ createdAt: -1 })
      .limit(lim)
      .lean<IRenewalRequest[]>();

    res.json(items);
  } catch (error) {
    console.error('[PersonalRenewalRoutes] Erro ao listar solicitações:', error);
    next(error);
  }
}

router.get('/renewal-requests', listMyRenewals);
router.get('/', listMyRenewals);

/**
 * Cria uma nova solicitação de renovação (sem comprovante ainda).
 */
router.post('/', async (req, res, next) => {
  await dbConnect();
  try {
    const personalTrainerId = (req as any).user.id;
    const { planIdRequested, notes } = req.body as { planIdRequested: string; notes?: string };

    if (!planIdRequested) {
      return res.status(400).json({ mensagem: 'O ID do plano solicitado é obrigatório.', code: 'MISSING_PLAN_ID' });
    }

    const openRequest = await RenewalRequest.findOne({
      personalTrainerId,
      status: { $in: [RStatus.REQUESTED, RStatus.LINK_SENT, RStatus.PROOF_SUBMITTED, RStatus.APPROVED, RStatus.CYCLE_ASSIGNMENT_PENDING, RStatus.PENDING, RStatus.PAYMENT_LINK_SENT, RStatus.PAYMENT_PROOF_UPLOADED] }
    });

    if (openRequest) {
      return res.status(409).json({
        mensagem: 'Você já possui uma solicitação de renovação em andamento. Aguarde a conclusão do processo atual.',
        code: 'OPEN_REQUEST_EXISTS'
      });
    }

    const newRequest = new RenewalRequest({
      personalTrainerId,
      planIdRequested,
      status: RStatus.REQUESTED,
      notes,
    });

    await newRequest.save();
    res.status(201).json(newRequest);
  } catch (error) {
    next(error);
  }
});

/**
 * Download do comprovante (se for arquivo).
 */
router.get('/:id/proof/download', async (req, res, next) => {
    await dbConnect();
    try {
      const requestId = req.params.id;
      const personalTrainerId = (req as any).user.id;
  
      const request = await RenewalRequest.findOne({ _id: requestId, personalTrainerId });
      if (!request) return res.status(404).json({ mensagem: 'Solicitação não encontrada.' });
  
      if (!request.proof || request.proof.kind !== 'file' || !request.proof.fileId) {
        return res.status(404).json({ mensagem: 'Comprovante não encontrado ou é um link externo.' });
      }
  
      const bucket = await getPaymentProofBucket();
      const downloadStream = bucket.openDownloadStream(request.proof.fileId);
  
      res.set({
        'Content-Type': request.proof.contentType || 'application/octet-stream',
        'Content-Disposition': `attachment; filename="${request.proof.filename || 'comprovante'}"`,
      });
  
      downloadStream.pipe(res);
      downloadStream.on('error', (err) => {
        console.error('Erro no download do comprovante:', err);
        if (!res.headersSent) {
          res.status(404).json({ mensagem: 'Arquivo de comprovante não encontrado no armazenamento.' });
        }
      });
    } catch (error) {
      next(error);
    }
});
  
/**
 * Rota para o personal enviar o comprovante (link ou arquivo).
 */
router.post('/:id/proof', upload.single('paymentProof'), async (req, res, next) => {
    await dbConnect();
    try {
      const requestId = req.params.id;
      const personalTrainerId = (req as any).user.id;
      const { paymentProofUrl } = req.body as { paymentProofUrl?: string };
      const file = (req as any).file as Express.Multer.File | undefined;
  
      if (!paymentProofUrl && !file) {
        return res.status(400).json({ mensagem: 'Forneça um link ou um arquivo de comprovante.', code: 'MISSING_PAYMENT_PROOF' });
      }
      if (paymentProofUrl && file) {
        return res.status(400).json({ mensagem: 'Envie apenas um link OU um arquivo, não ambos.', code: 'CONFLICTING_PAYMENT_PROOF' });
      }
  
      const request = await RenewalRequest.findOne({ _id: requestId, personalTrainerId });
      if (!request) {
        return res.status(404).json({ mensagem: 'Solicitação não encontrada.' });
      }
      
      const validStatuses: RenewalStatus[] = [RStatus.LINK_SENT, RStatus.PAYMENT_LINK_SENT];
      if (!validStatuses.includes(request.status)) {
        return res.status(400).json({ mensagem: `Não é possível enviar comprovante para uma solicitação com status "${request.status}". Aguarde o envio do link de pagamento.`, code: 'INVALID_STATUS' });
      }
  
      if (file) {
        const bucket = await getPaymentProofBucket();
        const uploadStream = bucket.openUploadStream(file.originalname, {
          metadata: { contentType: file.mimetype, personalId: personalTrainerId, uploadedAt: new Date() }
        });
        uploadStream.end(file.buffer);
  
        request.proof = {
          kind: 'file',
          fileId: uploadStream.id,
          filename: file.originalname,
          contentType: file.mimetype,
          size: file.size,
          uploadedAt: new Date()
        };
        request.paymentProofUrl = undefined; // Limpa o campo legado
      } else if (paymentProofUrl) {
        request.proof = { kind: 'link', url: paymentProofUrl, uploadedAt: new Date() };
        request.paymentProofUrl = paymentProofUrl; // Mantém compatibilidade
      }
  
      request.status = RStatus.PROOF_SUBMITTED;
      request.proofUploadedAt = new Date();
      await request.save();
  
      res.json(request);
    } catch (error) {
      next(error);
    }
});

/**
 * Rota para finalizar o ciclo de renovação sem ID específico.
 * Encontra automaticamente a solicitação aprovada do personal e a finaliza.
 * IMPORTANTE: Esta rota deve vir ANTES da rota com parâmetro :id para evitar conflitos
 */
router.post('/finalize-cycle', async (req, res, next) => {
    await dbConnect();
    const userId = (req as any).user.id;
    const { keepStudentIds = [], removeStudentIds = [], note } = req.body || {};
    const session = await mongoose.startSession();
  
    try {
      await session.withTransaction(async () => {
        // Encontra a solicitação aprovada ou pendente de atribuição de ciclo
        const validStatuses: RenewalStatus[] = [RStatus.APPROVED, RStatus.CYCLE_ASSIGNMENT_PENDING];
        const request = await RenewalRequest.findOne({ 
          personalTrainerId: userId, 
          status: { $in: validStatuses }
        }).session(session);
        
        if (!request) {
          throw { status: 404, message: 'Nenhuma solicitação aprovada encontrada para finalizar.' };
        }
        
        const finalizedStatuses: RenewalStatus[] = [RStatus.FULFILLED, RStatus.REJECTED];
        if (finalizedStatuses.includes(request.status)) {
          res.status(200).json({ renewalId: request._id, status: request.status, message: 'Pedido já encerrado.' });
          return;
        }
  
        const activePlan = await PersonalPlano.findOne({ personalTrainerId: userId, ativo: true }).populate('planoId').session(session);
        if (!activePlan) throw { status: 409, message: 'Plano ativo não encontrado para aplicar o ciclo.' };
  
        const limite = (activePlan as any).planoId?.limiteAlunos ?? 0;
        if (Array.isArray(keepStudentIds) && keepStudentIds.length > limite) {
          throw { status: 400, message: `Quantidade de alunos selecionados (${keepStudentIds.length}) excede o limite do plano (${limite}).` };
        }
  
        const personalObjectId = new mongoose.Types.ObjectId(userId);
  
        // Inativa todos os alunos ativos do personal
        await Aluno.updateMany(
          { trainerId: personalObjectId, status: 'active' },
          { $set: { status: 'inactive' }, $unset: { slotType: "", slotId: "", slotStartDate: "", slotEndDate: "" } },
          { session }
        );
        
        // Reativa apenas os alunos selecionados
        if (keepStudentIds.length > 0) {
          await Aluno.updateMany(
            { _id: { $in: keepStudentIds.map((id: string) => new mongoose.Types.ObjectId(id)) }, trainerId: personalObjectId },
            { $set: { 
                status: 'active', 
                slotType: 'plan', 
                slotId: activePlan._id, 
                slotStartDate: activePlan.dataInicio, 
                slotEndDate: activePlan.dataVencimento 
              } 
            },
            { session }
          );
        }
        
        // Finaliza a solicitação
        request.status = RStatus.FULFILLED;
        request.cycleFinalizedAt = new Date();
        if (note) request.notes = `${request.notes || ''}\nNota de finalização: ${note}`.trim();
        await request.save({ session });
  
        res.json({
          renewalId: request._id,
          status: request.status,
          cycleFinalizedAt: request.cycleFinalizedAt,
          kept: keepStudentIds,
          removed: removeStudentIds,
        });
      });
    } catch (error) {
      next(error);
    } finally {
      await session.endSession();
    }
});

/**
 * Rota para o personal finalizar o ciclo de renovação, ativando os alunos selecionados.
 * Esta rota aceita um ID específico da solicitação.
 */
router.post('/:id/finalize-cycle', async (req, res, next) => {
    await dbConnect();
    const renewalId = req.params.id;
    const userId = (req as any).user.id;
    const { keepStudentIds = [], removeStudentIds = [], note } = req.body || {};
    const session = await mongoose.startSession();
  
    try {
      await session.withTransaction(async () => {
        if (!mongoose.isValidObjectId(renewalId)) {
          throw { status: 400, message: 'ID da solicitação inválido.' };
        }
  
        const request = await RenewalRequest.findById(renewalId).session(session);
        if (!request) throw { status: 404, message: 'Solicitação não encontrada.' };
        if (request.personalTrainerId.toString() !== userId) {
          throw { status: 403, message: 'Sem permissão para finalizar esta solicitação.' };
        }
        
        const finalizedStatuses: RenewalStatus[] = [RStatus.FULFILLED, RStatus.REJECTED];
        if (finalizedStatuses.includes(request.status)) {
          res.status(200).json({ renewalId: request._id, status: request.status, message: 'Pedido já encerrado.' });
          return;
        }
        
        const validStatuses: RenewalStatus[] = [RStatus.APPROVED, RStatus.CYCLE_ASSIGNMENT_PENDING];
        if (!validStatuses.includes(request.status)) {
          throw { status: 409, message: `Estado inválido: ${request.status}. A solicitação precisa estar aprovada.` };
        }
  
        const activePlan = await PersonalPlano.findOne({ personalTrainerId: userId, ativo: true }).populate('planoId').session(session);
        if (!activePlan) throw { status: 409, message: 'Plano ativo não encontrado para aplicar o ciclo.' };
  
        const limite = (activePlan as any).planoId?.limiteAlunos ?? 0;
        if (Array.isArray(keepStudentIds) && keepStudentIds.length > limite) {
          throw { status: 400, message: `Quantidade de alunos selecionados (${keepStudentIds.length}) excede o limite do plano (${limite}).` };
        }
  
        const personalObjectId = new mongoose.Types.ObjectId(userId);
  
        // Inativa todos os alunos ativos do personal
        await Aluno.updateMany(
          { trainerId: personalObjectId, status: 'active' },
          { $set: { status: 'inactive' }, $unset: { slotType: "", slotId: "", slotStartDate: "", slotEndDate: "" } },
          { session }
        );
        
        // Reativa apenas os alunos selecionados
        if (keepStudentIds.length > 0) {
          await Aluno.updateMany(
            { _id: { $in: keepStudentIds.map((id: string) => new mongoose.Types.ObjectId(id)) }, trainerId: personalObjectId },
            { $set: { 
                status: 'active', 
                slotType: 'plan', 
                slotId: activePlan._id, 
                slotStartDate: activePlan.dataInicio, 
                slotEndDate: activePlan.dataVencimento 
              } 
            },
            { session }
          );
        }
        
        // Finaliza a solicitação
        request.status = RStatus.FULFILLED;
        request.cycleFinalizedAt = new Date();
        if (note) request.notes = `${request.notes || ''}\nNota de finalização: ${note}`.trim();
        await request.save({ session });
  
        res.json({
          renewalId: request._id,
          status: request.status,
          cycleFinalizedAt: request.cycleFinalizedAt,
          kept: keepStudentIds,
          removed: removeStudentIds,
        });
      });
    } catch (error) {
      next(error);
    } finally {
      await session.endSession();
    }
});

/**
 * POST /api/personal/renovar-plano (Rota LEGADA para compatibilidade)
 */
router.post('/renovar-plano', async (req, res, next) => {
    await dbConnect();
    const session = await mongoose.startSession();
  
    try {
      let closedRequests: string[] = [];
  
      await session.withTransaction(async () => {
        const personalTrainerId = (req as any).user?.id as string;
        const { alunosSelecionados } = req.body as { alunosSelecionados: string[] };
  
        if (!personalTrainerId) throw new Error('Usuário não autenticado.');
        if (!Array.isArray(alunosSelecionados)) throw new Error('A lista de alunos selecionados é inválida.');
  
        const approvedStatuses: RenewalStatus[] = [RStatus.APPROVED, 'APPROVED' as any, RStatus.CYCLE_ASSIGNMENT_PENDING];
        const approvedList = await RenewalRequest
          .find({ personalTrainerId, status: { $in: approvedStatuses } })
          .session(session);
        if (!approvedList.length) {
          const err: any = new Error('Não há solicitação aprovada pendente para este personal.');
          err.status = 409; err.code = 'NO_APPROVED_REQUEST';
          throw err;
        }
  
        const planStatus = await PlanoService.getPersonalCurrentPlan(personalTrainerId);
        if (!planStatus || !planStatus.personalPlano || (planStatus as any).isExpired) {
          const err: any = new Error('Nenhum plano ativo foi encontrado. A renovação pode não ter sido concluída pelo administrador.');
          err.status = 409; err.code = 'NO_ACTIVE_PLAN'; throw err;
        }
  
        const { personalPlano, plano, tokensAvulsos } = planStatus as any;
        if (!plano) {
          const err: any = new Error('Detalhes do plano ativo não foram encontrados.');
          err.status = 409; err.code = 'PLAN_DETAILS_NOT_FOUND'; throw err;
        }
  
        const limiteTotal = (plano.limiteAlunos || 0) + (tokensAvulsos || 0);
        if (alunosSelecionados.length > limiteTotal) {
          const err: any = new Error(`Limite de vagas excedido. Seu limite total é de ${limiteTotal} (plano + tokens).`);
          err.status = 400; err.code = 'LIMIT_EXCEEDED'; throw err;
        }
  
        const personalObjectId = new mongoose.Types.ObjectId(personalTrainerId);
        const alunosSelecionadosIds = alunosSelecionados.map((id) => new mongoose.Types.ObjectId(id));
  
        await Aluno.updateMany(
          { trainerId: personalObjectId, status: 'active' },
          { $set: { status: 'inactive' }, $unset: { slotType: "", slotId: "", slotStartDate: "", slotEndDate: "" } },
          { session }
        );
  
        if (alunosSelecionados.length > 0) {
          await Aluno.updateMany(
            { _id: { $in: alunosSelecionadosIds }, trainerId: personalObjectId },
            { $set: { status: 'active', slotType: 'plan', slotId: personalPlano._id, slotStartDate: personalPlano.dataInicio, slotEndDate: personalPlano.dataVencimento } },
            { session }
          );
        }
  
        const result = await RenewalRequest.updateMany(
          { personalTrainerId, status: { $in: approvedStatuses } },
          { $set: { status: RStatus.FULFILLED, paymentDecisionAt: new Date(), cycleFinalizedAt: new Date() } },
          { session }
        );
  
        if (result.modifiedCount > 0) {
          type IdOnly = { _id: mongoose.Types.ObjectId };
          const closed = await RenewalRequest
            .find({ personalTrainerId, status: RStatus.FULFILLED })
            .sort({ updatedAt: -1 })
            .limit(result.modifiedCount)
            .select('_id')
            .lean<IdOnly[]>()
            .session(session);
  
          closedRequests = closed.map((r) => r._id.toString());
        }
      });
  
      res.json({
        mensagem: 'Ciclo de renovação finalizado e alunos atualizados com sucesso!',
        closedRequests,
        dados: { alunosMantidos: (req.body?.alunosSelecionados || []).length }
      });
    } catch (error: any) {
      if (error?.code) return res.status(error.status || 409).json({ mensagem: error.message, code: error.code });
      next(error);
    } finally {
      await session.endSession();
    }
});

export default router;
===== ./server/src/routes/profile.ts =====
// server/src/routes/profile.ts
import { Router, Request, Response, NextFunction } from 'express';
import PersonalTrainer, { IPersonalTrainer } from '../../models/PersonalTrainer.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA

const router = Router();

router.patch('/me', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect(); // <<< CHAMADA ADICIONADA
    const userId = req.user?.id;
    const { firstName, lastName } = req.body;

    if (!userId) {
        return res.status(401).json({ message: 'Não autorizado: ID do usuário não encontrado no token.' });
    }

    if (!firstName || !lastName) {
        return res.status(400).json({ message: 'Nome e Sobrenome são obrigatórios.' });
    }
    if (typeof firstName !== 'string' || typeof lastName !== 'string') {
         return res.status(400).json({ message: 'Nome e Sobrenome devem ser strings.' });
    }

    try {
        const nomeCompleto = `${firstName.trim()} ${lastName.trim()}`.trim();
        const updatedUser = await PersonalTrainer.findByIdAndUpdate(
            userId,
            { nome: nomeCompleto },
            { new: true, runValidators: true, select: '-passwordHash' }
        ).exec() as IPersonalTrainer | null; 

        if (!updatedUser || !updatedUser._id) {
            console.warn(`[SERVER] Usuário ${userId} não encontrado para atualização de perfil.`);
            return res.status(404).json({ message: 'Personal Trainer não encontrado.' });
        }

        const responseUser = {
            id: updatedUser._id.toString(),
            username: updatedUser.email,
            firstName: updatedUser.nome.split(' ')[0] || '',
            lastName: updatedUser.nome.split(' ').slice(1).join(' ') || '',
            email: updatedUser.email,
            role: updatedUser.role
        };

        console.log(`[SERVER] Perfil atualizado para usuário ${userId}: ${nomeCompleto}`);
        res.status(200).json({ message: 'Perfil atualizado com sucesso!', user: responseUser });

    } catch (error: any) {
        console.error(`[SERVER] Erro ao atualizar perfil para usuário ${userId}:`, error);
        if (error.name === 'ValidationError') {
            const messages = Object.values(error.errors).map((e: any) => e.message);
            return res.status(400).json({ message: messages.join(', ') });
        }
        next(error);
    }
});

export default router;
===== ./server/src/routes/publicContatosRoutes.ts =====
// server/src/routes/publicContatosRoutes.ts
import express, { Request, Response, NextFunction } from 'express';
import mongoose from 'mongoose';
import Contato from '../../models/Contato.js';
import PersonalTrainer from '../../models/PersonalTrainer.js';
import dbConnect from '../../lib/dbConnect.js'; // <<< IMPORTAÇÃO ADICIONADA

const router = express.Router();

console.log("--- [server/src/routes/publicContatosRoutes.ts] Ficheiro carregado ---");

// Rota: POST /api/public/contatos/registrar/:tokenPersonal
router.post('/registrar/:tokenPersonal', async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect(); // <<< CHAMADA ADICIONADA
  const { tokenPersonal } = req.params;
  const { nomeCompleto, email, telefone, dataNascimento, genero } = req.body;

  console.log(`[POST /registrar/${tokenPersonal}] Tentativa de registrar novo contato. Email: ${email}`);

  if (!tokenPersonal) {
    return res.status(400).json({ mensagem: "Token do personal não fornecido." });
  }

  if (!nomeCompleto || typeof nomeCompleto !== 'string' || nomeCompleto.trim().length < 3) {
    return res.status(400).json({ mensagem: "Nome completo é obrigatório e deve ter pelo menos 3 caracteres." });
  }
  if (!email || typeof email !== 'string' || !/.+\@.+\..+/.test(email)) {
    return res.status(400).json({ mensagem: "E-mail inválido." });
  }

  try {
    const personal = await PersonalTrainer.findOne({ tokenCadastroAluno: tokenPersonal }).select('nome _id');
    if (!personal) {
      console.warn(`[POST /registrar/${tokenPersonal}] Personal não encontrado com este token.`);
      return res.status(404).json({ mensagem: "Link de cadastro inválido ou personal não encontrado." });
    }

    const contatoExistente = await Contato.findOne({
        email: email.toLowerCase().trim(),
        personalId: personal._id,
        status: 'novo'
    });

    if (contatoExistente) {
        console.log(`[POST /registrar/${tokenPersonal}] Contato com email ${email} já existe para o personal ${personal._id} com status 'novo'.`);
        return res.status(200).json({ mensagem: `Você já demonstrou interesse. O personal ${personal.nome} entrará em contato.` });
    }

    const novoContato = new Contato({
      nomeCompleto: nomeCompleto.trim(),
      email: email.toLowerCase().trim(),
      telefone: telefone?.trim(),
      dataNascimento: dataNascimento ? new Date(dataNascimento) : undefined,
      genero,
      personalId: personal._id,
      status: 'novo',
      origemToken: tokenPersonal,
    });

    await novoContato.save();

    console.log(`[POST /registrar/${tokenPersonal}] Novo contato ID: ${novoContato._id} registrado para Personal ID: ${personal._id}.`);

    res.status(201).json({ mensagem: "Interesse registrado com sucesso! Em breve, seu personal entrará em contato." });

  } catch (error: any) {
    console.error(`[POST /registrar/${tokenPersonal}] Erro ao registrar contato:`, error);
    if (error.status === 409) {
        return res.status(409).json({ mensagem: error.message });
    }
    if (error.name === 'ValidationError') {
      const mensagens = Object.values(error.errors).map((el: any) => el.message);
      return res.status(400).json({ mensagem: mensagens.join(', ') });
    }
    next(error);
  }
});

export default router;
===== ./server/src/routes/sessionsRoutes.ts =====
// server/src/routes/sessionsRoutes.ts
import express, { Request, Response, NextFunction } from 'express';
import mongoose, { Types } from 'mongoose';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import { authenticateAlunoToken } from '../../middlewares/authenticateAlunoToken.js';
import Sessao, { ISessaoLean, ISessaoDocument, TipoCompromisso, TIPOS_COMPROMISSO, OpcaoPSE, DetalheAumentoCarga } from '../../models/Sessao.js';
import Aluno from '../../models/Aluno.js';
import Treino, { ITreino } from '../../models/Treino.js';
import dbConnect from '../../lib/dbConnect.js';

const router = express.Router();

// =======================================================
// ROTAS DO PERSONAL
// =======================================================
// (Rotas do personal omitidas por brevidade, permanecem inalteradas)
router.get('/', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    // ... código original inalterado ...
});
router.post('/', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    // ... código original inalterado ...
});
router.put('/:sessionId', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    // ... código original inalterado ...
});
router.delete('/:sessionId', authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    // ... código original inalterado ...
});


// =======================================================
// ROTAS DO ALUNO
// =======================================================

router.post('/aluno/concluir-dia', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const alunoId = req.aluno?.id;
    // <-- 1. MUDANÇA: Recebe 'dataInicio' do corpo da requisição -->
    const { rotinaId, diaDeTreinoId, pseAluno, comentarioAluno, duracaoSegundos, cargas, dataInicio } = req.body;

    if (!alunoId) return res.status(401).json({ message: "Aluno não autenticado." });
    if (!rotinaId || !diaDeTreinoId) return res.status(400).json({ message: "ID da rotina e do dia de treino são obrigatórios." });

    // <-- 2. MUDANÇA: Validação para o novo campo 'dataInicio' -->
    if (!dataInicio) {
        return res.status(400).json({ message: "A data de início do treino é obrigatória." });
    }
    const dataInicioValida = new Date(dataInicio);
    if (isNaN(dataInicioValida.getTime())) {
        return res.status(400).json({ message: "Formato de data de início inválido." });
    }


    const mongoTransactionSession = await mongoose.startSession();
    try {
        mongoTransactionSession.startTransaction();
        const rotina = await Treino.findOne({ _id: rotinaId, alunoId }).session(mongoTransactionSession);
        if (!rotina) {
            await mongoTransactionSession.abortTransaction();
            return res.status(404).json({ message: "Rotina não encontrada ou não pertence a este aluno." });
        }
        const diaDeTreino = rotina.diasDeTreino.id(diaDeTreinoId);
        if (!diaDeTreino) {
            await mongoTransactionSession.abortTransaction();
            return res.status(404).json({ message: "Dia de treino não encontrado nesta rotina." });
        }

        const diaConcluidoIndex = rotina.diasDeTreino.findIndex(d => d._id.toString() === diaDeTreinoId);

        if (diaConcluidoIndex > -1) {
            const [diaMovido] = rotina.diasDeTreino.splice(diaConcluidoIndex, 1);
            rotina.diasDeTreino.push(diaMovido);
            rotina.diasDeTreino.forEach((dia, index) => {
                dia.ordemNaRotina = index;
            });
        }

        // Buscar sessão anterior do mesmo aluno/rotina/dia para comparar cargas
        let aumentouCarga = false;
        let detalhesAumentoCarga: DetalheAumentoCarga[] = [];

        if (cargas && Object.keys(cargas).length > 0) {
            try {
                const sessaoAnterior = await Sessao.findOne({
                    alunoId: new Types.ObjectId(alunoId),
                    rotinaId: rotina._id,
                    diaDeTreinoId: diaDeTreino._id,
                    status: 'completed'
                })
                .sort({ concluidaEm: -1 })
                .session(mongoTransactionSession);

                if (sessaoAnterior && sessaoAnterior.cargasExecutadas) {
                    const cargasAnteriores = sessaoAnterior.cargasExecutadas;
                    
                    // Comparar cargas exercício por exercício
                    for (const [exercicioId, cargaAtual] of Object.entries(cargas)) {
                        // Lidar com Map ou objeto plano
                        let cargaAnterior: string | undefined;
                        if (cargasAnteriores instanceof Map) {
                            cargaAnterior = cargasAnteriores.get(exercicioId);
                        } else {
                            cargaAnterior = (cargasAnteriores as any)[exercicioId];
                        }
                        
                        // Considerar aumento apenas se havia carga anterior e a atual é maior
                        if (cargaAnterior && typeof cargaAnterior === 'string' && cargaAnterior.trim() && 
                            cargaAtual && typeof cargaAtual === 'string' && cargaAtual.trim()) {
                            const cargaAnteriorNum = parseFloat(cargaAnterior.replace(/[^\d.,]/g, '').replace(',', '.'));
                            const cargaAtualNum = parseFloat(cargaAtual.replace(/[^\d.,]/g, '').replace(',', '.'));
                            
                            if (!isNaN(cargaAnteriorNum) && !isNaN(cargaAtualNum) && cargaAtualNum > cargaAnteriorNum) {
                                aumentouCarga = true;
                                detalhesAumentoCarga.push({
                                    exercicioId,
                                    cargaAnterior: cargaAnterior,
                                    cargaAtual: cargaAtual
                                });
                            }
                        }
                    }
                }
            } catch (comparisonError) {
                console.warn('Erro ao comparar cargas:', comparisonError);
                // Continua sem interromper o fluxo principal
            }
        }

        const novaSessao = new Sessao({
            personalId: rotina.criadorId,
            alunoId: new Types.ObjectId(alunoId),
            sessionDate: dataInicioValida,
            concluidaEm: new Date(),
            status: 'completed',
            tipoCompromisso: 'treino',
            rotinaId: rotina._id,
            diaDeTreinoId: diaDeTreino._id,
            diaDeTreinoIdentificador: diaDeTreino.identificadorDia,
            pseAluno: pseAluno || null,
            comentarioAluno: comentarioAluno || null,
            duracaoSegundos: duracaoSegundos || 0,
            cargasExecutadas: cargas || {},
            aumentouCarga,
            detalhesAumentoCarga
        });
        await novaSessao.save({ session: mongoTransactionSession });
        
        rotina.sessoesRotinaConcluidas = (rotina.sessoesRotinaConcluidas || 0) + 1;
        await rotina.save({ session: mongoTransactionSession });
        
        await mongoTransactionSession.commitTransaction();
        res.status(201).json({ message: "Dia de treino concluído com sucesso!", _id: novaSessao._id, status: novaSessao.status, concluidaEm: novaSessao.concluidaEm });
    } catch (error) {
        if (mongoTransactionSession.inTransaction()) await mongoTransactionSession.abortTransaction();
        next(error);
    } finally {
        await mongoTransactionSession.endSession();
    }
});

router.patch('/:sessionId/feedback', authenticateAlunoToken, async (req: Request, res: Response, next: NextFunction) => {
    // ... código original inalterado ...
});

export default router;
===== ./server/src/routes/treinos.ts =====
// server/src/routes/treinos.ts
import express, { Request, Response, NextFunction } from "express";
import mongoose, { Types } from "mongoose";
import Treino, {
    IDiaDeTreinoPlain,
    IExercicioEmDiaDeTreinoPlain
} from "../../models/Treino.js";
import PastaTreino from '../../models/Pasta.js';
import { authenticateToken } from '../../middlewares/authenticateToken.js';
import dbConnect from '../../lib/dbConnect.js';

const router = express.Router();

router.get("/", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const criadorId = req.user?.id;
    if (!criadorId) return res.status(401).json({ mensagem: "Usuário não autenticado." });

    const query: any = { criadorId: new Types.ObjectId(criadorId) };

    if (req.query.tipo) {
      query.tipo = req.query.tipo;
    }

    const rotinas = await Treino.find(query)
        .populate({ path: 'alunoId', select: 'nome' })
        .populate({ path: 'pastaId', select: 'nome' })
        .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        })
        .sort({ tipo: 1, atualizadoEm: -1 });

    res.status(200).json(rotinas);
  } catch (error) {
    next(error);
  }
});

router.get("/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const criadorId = req.user?.id;
        
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return res.status(400).json({ mensagem: "ID da rotina inválido." });
        }
        if (!criadorId) {
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        }

        const rotina = await Treino.findOne({ _id: id, criadorId: new Types.ObjectId(criadorId) })
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
                path: 'diasDeTreino',
                populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
            });

        if (!rotina) {
            return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão." });
        }

        res.status(200).json(rotina);
    } catch (error) {
        next(error);
    }
});


router.post("/", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const criadorId = req.user?.id;
    if (!criadorId) return res.status(401).json({ mensagem: "Usuário não autenticado." });

    const dadosRotina = { ...req.body, criadorId: new Types.ObjectId(criadorId), isCopied: false };
    const novaRotina = new Treino(dadosRotina);
    await novaRotina.save();

    const rotinaPopulada = await Treino.findById(novaRotina._id)
        .populate({ path: 'alunoId', select: 'nome' })
        .populate({ path: 'pastaId', select: 'nome' })
        .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });

    res.status(201).json(rotinaPopulada);
  } catch (error) {
    next(error);
  }
});

router.post("/associar-modelo", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const { fichaModeloId, alunoId } = req.body;
        const criadorId = req.user?.id;

        if (!criadorId) return res.status(401).json({ mensagem: "Usuário não autenticado." });
        if (!mongoose.Types.ObjectId.isValid(fichaModeloId) || !mongoose.Types.ObjectId.isValid(alunoId)) {
            return res.status(400).json({ mensagem: "IDs inválidos fornecidos." });
        }
        const fichaModelo = await Treino.findOne({ _id: fichaModeloId, criadorId: new Types.ObjectId(criadorId), tipo: 'modelo' });
        if (!fichaModelo) return res.status(404).json({ mensagem: "Ficha modelo não encontrada ou você não tem permissão para usá-la." });

        const { _id, criadoEm, atualizadoEm, diasDeTreino, ...modeloRestante } = fichaModelo.toObject();
        const newFichaData = {
            ...modeloRestante,
            tipo: 'individual' as const,
            criadorId: new Types.ObjectId(criadorId),
            alunoId: new Types.ObjectId(alunoId),
            pastaId: null,
            titulo: modeloRestante.titulo,
            isCopied: true,
            diasDeTreino: diasDeTreino?.map((dia): IDiaDeTreinoPlain => ({
                identificadorDia: dia.identificadorDia,
                nomeSubFicha: dia.nomeSubFicha,
                ordemNaRotina: dia.ordemNaRotina,
                exerciciosDoDia: dia.exerciciosDoDia?.map((ex): IExercicioEmDiaDeTreinoPlain => {
                    const exercicioIdValue = typeof ex.exercicioId === 'object' && ex.exercicioId?._id
                        ? ex.exercicioId._id.toString() : ex.exercicioId.toString();
                    return {
                        exercicioId: new Types.ObjectId(exercicioIdValue),
                        series: ex.series,
                        repeticoes: ex.repeticoes,
                        carga: ex.carga,
                        descanso: ex.descanso, 
                        observacoes: ex.observacoes,
                        ordemNoDia: ex.ordemNoDia,
                        concluido: false
                    };
                }) ?? []
            })) ?? []
        };

        const novaFichaIndividual = new Treino(newFichaData);
        await novaFichaIndividual.save();
        const fichaPopulada = await Treino.findById(novaFichaIndividual._id)
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
                path: 'diasDeTreino',
                populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
            });

        res.status(201).json(fichaPopulada);
    } catch (error) {
        console.error("Erro ao associar modelo de treino ao aluno:", error);
        next(error);
    }
});

// <<< INÍCIO DA ROTA CORRIGIDA >>>
// Esta rota agora CRIA um novo modelo a partir de uma rotina existente, em vez de modificá-la.
router.post("/:id/tornar-modelo", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const criadorId = req.user?.id;

        if (!mongoose.Types.ObjectId.isValid(id)) {
            return res.status(400).json({ mensagem: "ID da rotina inválido." });
        }
        if (!criadorId) {
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        }

        // 1. Encontra a rotina original para copiar. Pode ser 'individual' ou 'modelo'.
        const rotinaOriginal = await Treino.findOne({ _id: id, criadorId: new Types.ObjectId(criadorId) });

        if (!rotinaOriginal) {
            return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão para copiá-la." });
        }

        // 2. Cria uma cópia profunda da rotina, removendo campos específicos.
        const { _id, criadoEm, atualizadoEm, alunoId, pastaId, ...restanteDaRotina } = rotinaOriginal.toObject();

        const novaRotinaModeloData = {
            ...restanteDaRotina,
            tipo: 'modelo' as const, // Define o tipo como 'modelo'
            alunoId: null, // Remove a associação com o aluno
            pastaId: null, // Remove a associação com pasta
            titulo: restanteDaRotina.titulo, // Mantém o título original
            isCopied: true, // Marca como uma cópia
            diasDeTreino: restanteDaRotina.diasDeTreino?.map((dia): IDiaDeTreinoPlain => ({
                identificadorDia: dia.identificadorDia,
                nomeSubFicha: dia.nomeSubFicha,
                ordemNaRotina: dia.ordemNaRotina,
                exerciciosDoDia: dia.exerciciosDoDia?.map((ex): IExercicioEmDiaDeTreinoPlain => {
                    const exercicioIdValue = typeof ex.exercicioId === 'object' && ex.exercicioId?._id
                        ? ex.exercicioId._id.toString() : ex.exercicioId.toString();
                    return {
                        exercicioId: new Types.ObjectId(exercicioIdValue),
                        series: ex.series,
                        repeticoes: ex.repeticoes,
                        carga: ex.carga,
                        descanso: ex.descanso,
                        observacoes: ex.observacoes,
                        ordemNoDia: ex.ordemNoDia,
                        concluido: false
                    };
                }) ?? []
            })) ?? []
        };

        // 3. Salva a nova rotina como um novo documento.
        const novaRotinaModelo = new Treino(novaRotinaModeloData);
        await novaRotinaModelo.save();

        // 4. Popula e retorna o NOVO modelo criado.
        const rotinaPopulada = await Treino.findById(novaRotinaModelo._id)
            .populate({ path: 'alunoId', select: 'nome' })
            .populate({ path: 'pastaId', select: 'nome' })
            .populate({
                path: 'diasDeTreino',
                populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
            });

        res.status(201).json(rotinaPopulada); // Usa 201 Created para indicar criação de novo recurso

    } catch (error) {
        console.error("Erro ao copiar rotina para modelo:", error);
        next(error);
    }
});
// <<< FIM DA ROTA CORRIGIDA >>>

router.put("/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
  await dbConnect();
  try {
    const { id } = req.params;
    const criadorId = req.user?.id;
    if (!mongoose.Types.ObjectId.isValid(id) || !criadorId) return res.status(400).json({ mensagem: "Requisição inválida." });

    const rotina = await Treino.findOneAndUpdate(
        { _id: id, criadorId: new Types.ObjectId(criadorId) },
        { $set: req.body },
        { new: true, runValidators: true }
    ).populate({ path: 'alunoId', select: 'nome' })
     .populate({ path: 'pastaId', select: 'nome' })
     .populate({
         path: 'diasDeTreino',
         populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
     });

    if (!rotina) return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão." });
    res.status(200).json(rotina);
  } catch (error) {
    next(error);
  }
});

router.put("/:id/pasta", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    const { id: rotinaId } = req.params;
    const { pastaId } = req.body;
    const criadorId = req.user?.id;

    if (!criadorId || !mongoose.Types.ObjectId.isValid(rotinaId)) return res.status(400).json({ mensagem: "ID da rotina inválido ou usuário não autenticado." });
    if (pastaId && !mongoose.Types.ObjectId.isValid(pastaId)) return res.status(400).json({ mensagem: "ID da pasta inválido." });

    try {
        if (pastaId) {
            const pastaDestino = await PastaTreino.findOne({ _id: pastaId, criadorId: criadorId });
            if (!pastaDestino) return res.status(404).json({ mensagem: "Pasta de destino não encontrada ou você não tem permissão para usá-la." });
        }
        const rotinaAtualizada = await Treino.findOneAndUpdate(
            { _id: rotinaId, criadorId: criadorId },
            { $set: { pastaId: pastaId ? new Types.ObjectId(pastaId) : null } },
            { new: true }
        ).populate('pastaId', 'nome')
         .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        });
        if (!rotinaAtualizada) return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão para movê-la." });
        res.status(200).json(rotinaAtualizada);
    } catch (error) {
        next(error);
    }
});

router.delete("/:id", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const { id } = req.params;
        const criadorId = req.user?.id;
        if (!mongoose.Types.ObjectId.isValid(id) || !criadorId) return res.status(400).json({ mensagem: "Requisição inválida." });
        const resultado = await Treino.findOneAndDelete({ _id: id, criadorId: new Types.ObjectId(criadorId) });
        if (!resultado) return res.status(404).json({ mensagem: "Rotina não encontrada ou você não tem permissão." });
        res.status(200).json({ mensagem: "Rotina excluída com sucesso." });
    } catch (error) {
        next(error);
    }
});

// GET /api/treinos/aluno/:alunoId - Lista as rotinas de um aluno específico (para o personal)
router.get("/aluno/:alunoId", authenticateToken, async (req: Request, res: Response, next: NextFunction) => {
    await dbConnect();
    try {
        const { alunoId } = req.params;
        const criadorId = req.user?.id;
        
        if (!mongoose.Types.ObjectId.isValid(alunoId)) {
            return res.status(400).json({ mensagem: "ID do aluno inválido." });
        }
        if (!criadorId) {
            return res.status(401).json({ mensagem: "Usuário não autenticado." });
        }

        // Buscar rotinas do aluno específico criadas pelo personal logado
        const rotinas = await Treino.find({ 
            alunoId: new Types.ObjectId(alunoId), 
            criadorId: new Types.ObjectId(criadorId),
            tipo: 'individual'
        })
        .populate({ path: 'alunoId', select: 'nome' })
        .populate({ path: 'pastaId', select: 'nome' })
        .populate({
            path: 'diasDeTreino',
            populate: { path: 'exerciciosDoDia.exercicioId', model: 'Exercicio', select: 'nome urlVideo' }
        })
        .sort({ atualizadoEm: -1 });

        // Transformar para o formato esperado pelo frontend
        const rotinasFormatadas = rotinas.map(rotina => ({
            _id: rotina._id,
            titulo: rotina.titulo,
            descricao: rotina.descricao,
            atualizadoEm: rotina.atualizadoEm
        }));

        res.status(200).json(rotinasFormatadas);
    } catch (error) {
        next(error);
    }
});

export default router;
===== ./server/utils/gridfs.ts =====
import mongoose from 'mongoose';
import type { GridFSBucket } from 'mongodb';

let bucket: GridFSBucket | null = null;

export function getPaymentProofBucket(): GridFSBucket {
  const db = mongoose.connection.db;
  if (!db) throw new Error('MongoDB não conectado.');
  // @ts-ignore - tipos do mongo via mongoose
  const { GridFSBucket } = mongoose.mongo;
  if (!bucket) bucket = new GridFSBucket(db, { bucketName: 'paymentProofs' });
  return bucket!;
}
===== ./shared/dist/schema.d.ts =====
import { z } from "zod";
export declare const insertStudentSchema: z.ZodObject<{
    nome: z.ZodString;
    email: z.ZodString;
    phone: z.ZodOptional<z.ZodString>;
    birthDate: z.ZodString;
    gender: z.ZodString;
    goal: z.ZodString;
    weight: z.ZodNumber;
    height: z.ZodNumber;
    startDate: z.ZodString;
    trainerId: z.ZodNumber;
    status: z.ZodOptional<z.ZodString>;
    notes: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    nome: string;
    email: string;
    birthDate: string;
    gender: string;
    goal: string;
    weight: number;
    height: number;
    startDate: string;
    trainerId: number;
    phone?: string | undefined;
    status?: string | undefined;
    notes?: string | undefined;
}, {
    nome: string;
    email: string;
    birthDate: string;
    gender: string;
    goal: string;
    weight: number;
    height: number;
    startDate: string;
    trainerId: number;
    phone?: string | undefined;
    status?: string | undefined;
    notes?: string | undefined;
}>;
export type InsertStudent = z.infer<typeof insertStudentSchema>;
export type Student = InsertStudent & {
    id: number;
};
export declare const insertUserSchema: z.ZodObject<{
    username: z.ZodString;
    password: z.ZodString;
    firstName: z.ZodString;
    lastName: z.ZodString;
    email: z.ZodString;
    role: z.ZodString;
}, "strip", z.ZodTypeAny, {
    email: string;
    username: string;
    password: string;
    firstName: string;
    lastName: string;
    role: string;
}, {
    email: string;
    username: string;
    password: string;
    firstName: string;
    lastName: string;
    role: string;
}>;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = InsertUser & {
    id: number;
};
export declare const insertExerciseSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    muscleGroup: z.ZodString;
    category: z.ZodString;
}, "strip", z.ZodTypeAny, {
    name: string;
    muscleGroup: string;
    category: string;
    description?: string | undefined;
}, {
    name: string;
    muscleGroup: string;
    category: string;
    description?: string | undefined;
}>;
export type InsertExercise = z.infer<typeof insertExerciseSchema>;
export type Exercise = InsertExercise & {
    id: number;
};
export declare const insertWorkoutPlanSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    trainerId: z.ZodNumber;
    status: z.ZodString;
}, "strip", z.ZodTypeAny, {
    trainerId: number;
    status: string;
    name: string;
    description?: string | undefined;
}, {
    trainerId: number;
    status: string;
    name: string;
    description?: string | undefined;
}>;
export type InsertWorkoutPlan = z.infer<typeof insertWorkoutPlanSchema>;
export type WorkoutPlan = InsertWorkoutPlan & {
    id: number;
};
export declare const insertWorkoutExerciseSchema: z.ZodObject<{
    workoutPlanId: z.ZodNumber;
    exerciseId: z.ZodNumber;
    sets: z.ZodNumber;
    reps: z.ZodNumber;
    rest: z.ZodNumber;
    notes: z.ZodOptional<z.ZodString>;
    order: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
}, "strip", z.ZodTypeAny, {
    workoutPlanId: number;
    exerciseId: number;
    sets: number;
    reps: number;
    rest: number;
    order: number;
    notes?: string | undefined;
}, {
    workoutPlanId: number;
    exerciseId: number;
    sets: number;
    reps: number;
    rest: number;
    notes?: string | undefined;
    order?: number | undefined;
}>;
export type InsertWorkoutExercise = z.infer<typeof insertWorkoutExerciseSchema>;
export type WorkoutExercise = InsertWorkoutExercise & {
    id: number;
};
export declare const insertStudentWorkoutSchema: z.ZodObject<{
    studentId: z.ZodNumber;
    workoutPlanId: z.ZodNumber;
    progress: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    workoutPlanId: number;
    studentId: number;
    progress?: number | undefined;
}, {
    workoutPlanId: number;
    studentId: number;
    progress?: number | undefined;
}>;
export type InsertStudentWorkout = z.infer<typeof insertStudentWorkoutSchema>;
export type StudentWorkout = InsertStudentWorkout & {
    id: number;
};
export declare const insertActivityLogSchema: z.ZodObject<{
    trainerId: z.ZodNumber;
    activityType: z.ZodString;
    details: z.ZodAny;
    timestamp: z.ZodDate;
}, "strip", z.ZodTypeAny, {
    trainerId: number;
    activityType: string;
    timestamp: Date;
    details?: any;
}, {
    trainerId: number;
    activityType: string;
    timestamp: Date;
    details?: any;
}>;
export type InsertActivityLog = z.infer<typeof insertActivityLogSchema>;
export type ActivityLog = InsertActivityLog & {
    id: number;
};
export declare const insertSessionSchema: z.ZodObject<{
    trainerId: z.ZodNumber;
    studentId: z.ZodNumber;
    sessionDate: z.ZodString;
    startTime: z.ZodString;
    endTime: z.ZodString;
    status: z.ZodString;
    notes: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    trainerId: number;
    status: string;
    studentId: number;
    sessionDate: string;
    startTime: string;
    endTime: string;
    notes?: string | undefined;
}, {
    trainerId: number;
    status: string;
    studentId: number;
    sessionDate: string;
    startTime: string;
    endTime: string;
    notes?: string | undefined;
}>;
export type InsertSession = z.infer<typeof insertSessionSchema>;
export type Session = InsertSession & {
    id: number;
};

===== ./shared/dist/schema.js =====
// src/shared/schema.ts
import { z } from "zod";
// Aluno (Student)
export const insertStudentSchema = z.object({
    nome: z.string(),
    email: z.string().email(),
    phone: z.string().optional(),
    birthDate: z.string(),
    gender: z.string(),
    goal: z.string(),
    weight: z.number(),
    height: z.number(),
    startDate: z.string(),
    trainerId: z.number(),
    status: z.string().optional(),
    notes: z.string().optional(),
});
// Usuário (User)
export const insertUserSchema = z.object({
    username: z.string(),
    password: z.string(),
    firstName: z.string(),
    lastName: z.string(),
    email: z.string().email(),
    role: z.string(),
});
// Exercício (Exercise)
export const insertExerciseSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    muscleGroup: z.string(),
    category: z.string(),
});
// Plano de treino (Workout Plan)
export const insertWorkoutPlanSchema = z.object({
    name: z.string(),
    description: z.string().optional(),
    trainerId: z.number(),
    status: z.string(),
});
// Exercício dentro de um plano (Workout Exercise)
export const insertWorkoutExerciseSchema = z.object({
    workoutPlanId: z.number(),
    exerciseId: z.number(),
    sets: z.number(),
    reps: z.number(),
    rest: z.number(),
    notes: z.string().optional(),
    // Adicionando um campo de ordem que seu storage.ts usa
    order: z.number().optional().default(0),
});
// Relacionamento aluno <-> treino (Student Workout)
export const insertStudentWorkoutSchema = z.object({
    studentId: z.number(),
    workoutPlanId: z.number(),
    progress: z.number().optional(),
});
// Registro de atividade (Activity Log)
export const insertActivityLogSchema = z.object({
    trainerId: z.number(),
    activityType: z.string(),
    details: z.any(),
    timestamp: z.date(),
});
// Sessão (Session)
export const insertSessionSchema = z.object({
    trainerId: z.number(),
    studentId: z.number(),
    sessionDate: z.string(),
    startTime: z.string(),
    endTime: z.string(),
    status: z.string(),
    notes: z.string().optional(),
});

===== ./shared/dist/types.d.ts =====
export interface Aluno {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
}
export interface Personal {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
}
export interface ExercicioFichaAluno {
    exercicioId: {
        _id: string;
        nome: string;
        grupoMuscular: string;
    };
    ordem: number;
    series: string;
    repeticoes: string;
    carga?: string;
    observacoes?: string;
}
export interface IFichaTreinoAluno {
    _id: string;
    alunoId: string;
    personalId: string;
    nome: string;
    descricao?: string;
    exercicios: ExercicioFichaAluno[];
    dataCriacao: string;
    dataAtualizacao: string;
}

===== ./shared/dist/types.js =====
// shared/types.ts
export {};
// Adicione outras interfaces compartilhadas aqui (Exercicio, FichaModelo, etc.)

===== ./shared/dist/types/personal.d.ts =====
export interface AlunoParaModal {
    _id: string;
    nome: string;
    email: string;
    status: 'active' | 'inactive';
    slotType?: 'plan' | 'token';
    slotId?: string;
    slotStartDate?: string | Date;
    slotEndDate?: string | Date;
}
export interface PersonalDetalhes {
    _id: string;
    nome: string;
    email: string;
    role: 'Personal Trainer' | 'Admin';
    tokenCadastroAluno?: string;
    statusAssinatura?: 'ativa' | 'inativa' | 'pendente_pagamento' | 'cancelada' | 'trial' | 'sem_assinatura';
    limiteAlunos?: number;
    dataInicioAssinatura?: string | Date;
    dataFimAssinatura?: string | Date;
    idAssinaturaGateway?: string;
    planoId?: string;
    createdAt: string | Date;
    updatedAt: string | Date;
    alunos?: AlunoParaModal[];
    plano?: {
        _id: string;
        nome: string;
        descricao?: string;
        limiteAlunos: number;
        preco: number;
        duracao: number;
        tipo: string;
    };
}
export interface PersonalListadoItem {
    _id: string;
    nome: string;
    email: string;
    role: 'Personal Trainer' | 'Admin';
    createdAt: string | Date;
    statusAssinatura?: string;
}

===== ./shared/dist/types/personal.js =====
// shared/types/personal.ts
export {};

===== ./shared/dist/types/planos.js =====
// shared/types/planos.ts
export {};

===== ./shared/dist/types/sessaoTypes.d.ts =====
export declare const TIPOS_COMPROMISSO: readonly ["avaliacao", "checkin", "treino_acompanhado", "outro"];
export type TipoCompromisso = typeof TIPOS_COMPROMISSO[number];
export interface CompromissoDataShareable {
    _id: string;
    sessionDate: string;
    tipoCompromisso: TipoCompromisso;
    notes?: string;
    status: "pending" | "confirmed" | "completed" | "cancelled";
    studentId: {
        _id: string;
        nome: string;
    } | string;
}

===== ./shared/dist/types/sessaoTypes.js =====
export const TIPOS_COMPROMISSO = ['avaliacao', 'checkin', 'treino_acompanhado', 'outro'];

===== ./shared/schema.ts =====
// src/shared/schema.ts

import { z } from "zod";

// Aluno (Student)
export const insertStudentSchema = z.object({
  nome: z.string(),
  email: z.string().email(),
  phone: z.string().optional(),
  birthDate: z.string(),
  gender: z.string(),
  goal: z.string(),
  weight: z.number(),
  height: z.number(),
  startDate: z.string(),
  trainerId: z.number(),
  status: z.string().optional(),
  notes: z.string().optional(),
});
export type InsertStudent = z.infer<typeof insertStudentSchema>;
// Adicionando o tipo 'Student' que inclui o ID
export type Student = InsertStudent & { id: number };


// Usuário (User)
export const insertUserSchema = z.object({
  username: z.string(),
  password: z.string(),
  firstName: z.string(),
  lastName: z.string(),
  email: z.string().email(),
  role: z.string(),
});
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = InsertUser & { id: number };


// Exercício (Exercise)
export const insertExerciseSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  muscleGroup: z.string(),
  category: z.string(),
});
export type InsertExercise = z.infer<typeof insertExerciseSchema>;
export type Exercise = InsertExercise & { id: number };


// Plano de treino (Workout Plan)
export const insertWorkoutPlanSchema = z.object({
  name: z.string(),
  description: z.string().optional(),
  trainerId: z.number(),
  status: z.string(),
});
export type InsertWorkoutPlan = z.infer<typeof insertWorkoutPlanSchema>;
export type WorkoutPlan = InsertWorkoutPlan & { id: number };


// Exercício dentro de um plano (Workout Exercise)
export const insertWorkoutExerciseSchema = z.object({
  workoutPlanId: z.number(),
  exerciseId: z.number(),
  sets: z.number(),
  reps: z.number(),
  rest: z.number(),
  notes: z.string().optional(),
  // Adicionando um campo de ordem que seu storage.ts usa
  order: z.number().optional().default(0),
});
export type InsertWorkoutExercise = z.infer<typeof insertWorkoutExerciseSchema>;
export type WorkoutExercise = InsertWorkoutExercise & { id: number };


// Relacionamento aluno <-> treino (Student Workout)
export const insertStudentWorkoutSchema = z.object({
  studentId: z.number(),
  workoutPlanId: z.number(),
  progress: z.number().optional(),
});
export type InsertStudentWorkout = z.infer<typeof insertStudentWorkoutSchema>;
export type StudentWorkout = InsertStudentWorkout & { id: number };


// Registro de atividade (Activity Log)
export const insertActivityLogSchema = z.object({
  trainerId: z.number(),
  activityType: z.string(),
  details: z.any(),
  timestamp: z.date(),
});
export type InsertActivityLog = z.infer<typeof insertActivityLogSchema>;
export type ActivityLog = InsertActivityLog & { id: number };


// Sessão (Session)
export const insertSessionSchema = z.object({
  trainerId: z.number(),
  studentId: z.number(),
  sessionDate: z.string(),
  startTime: z.string(),
  endTime: z.string(),
  status: z.string(),
  notes: z.string().optional(),
});
export type InsertSession = z.infer<typeof insertSessionSchema>;
export type Session = InsertSession & { id: number };
===== ./shared/types.ts =====
// shared/types.ts

// Interface básica para Aluno
// Adicione outras propriedades conforme necessário
export interface Aluno {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
    // Adicione outros campos do aluno aqui (ex: dataNascimento, telefone, etc.)
  }
  
  // Interface básica para Personal
  // Adicione outras propriedades conforme necessário
  export interface Personal {
    _id: string;
    firstName: string;
    lastName: string;
    email: string;
    // Adicione outros campos do personal aqui
  }
  
  // Interface para os detalhes de um exercício dentro da ficha de treino do aluno
  export interface ExercicioFichaAluno {
    exercicioId: { // Populated exercise details (assumindo que você popula)
      _id: string;
      nome: string;
      grupoMuscular: string;
      // Adicione outros campos do exercício que você popula
    };
    ordem: number;
    series: string;
    repeticoes: string;
    carga?: string;
    observacoes?: string;
  }
  
  // Interface para o documento da Ficha de Treino do Aluno
  export interface IFichaTreinoAluno {
    _id: string;
    alunoId: string; // Pode ser string se não for populado, ou Aluno se for populado
    personalId: string; // Pode ser string se não for populado, ou Personal se for populado
    nome: string;
    descricao?: string;
    exercicios: ExercicioFichaAluno[];
    dataCriacao: string; // Use string se for ISO date string, ou Date se converter
    dataAtualizacao: string; // Use string se for ISO date string, ou Date se converter
  }
  
  // Adicione outras interfaces compartilhadas aqui (Exercicio, FichaModelo, etc.)
  
===== ./shared/types/express/index.d.ts =====
// shared/types/express/index.d.ts
// Este arquivo estende os tipos globais do Express para o projeto inteiro.

// Payload para Personal e Admin, com todas as propriedades usadas no middleware
interface UserPayload {
    id: string;
    role: 'personal' | 'admin';
    firstName: string; 
    lastName: string;  
    email: string;     
}

// Payload para Aluno, com todas as propriedades usadas no middleware
interface AlunoPayload {
    id: string;
    role: 'aluno';
    nome: string;
    email: string; // <<< ADICIONE ESTA LINHA
    personalId?: string;
}

// Sobrescreve o namespace 'Express' para adicionar nossos tipos customizados ao objeto Request
declare namespace Express {
  export interface Request {
    user?: UserPayload;
    aluno?: AlunoPayload;
  }
}
===== ./shared/types/personal.ts =====
// shared/types/personal.ts

// <<< INÍCIO DA ALTERAÇÃO: Nova interface para os dados do aluno no modal >>>
export interface AlunoParaModal {
  _id: string;
  nome: string;
  email: string;
  status: 'active' | 'inactive';
  slotType?: 'plan' | 'token';
  slotId?: string;
  slotStartDate?: string | Date;
  slotEndDate?: string | Date;
}
// <<< FIM DA ALTERAÇÃO >>>

// Interface para os detalhes completos de um PersonalTrainer, como retornado pela API (sem campos sensíveis)
export interface PersonalDetalhes {
    _id: string;
    nome: string;
    email: string;
    role: 'Personal Trainer' | 'Admin'; // Roles permitidas
    tokenCadastroAluno?: string;
    statusAssinatura?: 'ativa' | 'inativa' | 'pendente_pagamento' | 'cancelada' | 'trial' | 'sem_assinatura';
    limiteAlunos?: number;
    dataInicioAssinatura?: string | Date; 
    dataFimAssinatura?: string | Date;
    idAssinaturaGateway?: string;
    planoId?: string;
    createdAt: string | Date;
    updatedAt: string | Date;
    // <<< INÍCIO DA ALTERAÇÃO: Adiciona a lista de alunos à interface >>>
    alunos?: AlunoParaModal[];
    // <<< FIM DA ALTERAÇÃO >>>
    plano?: {
        _id: string;
        nome: string;
        descricao?: string;
        limiteAlunos: number;
        preco: number;
        duracao: number;
        tipo: string;
    };
  }
    
  // Interface para os itens listados na tabela de personais (pode ser um subconjunto de PersonalDetalhes)
  export interface PersonalListadoItem {
    _id: string;
    nome: string;
    email: string;
    role: 'Personal Trainer' | 'Admin';
    createdAt: string | Date; 
    statusAssinatura?: string;
  }
===== ./shared/types/planos.ts =====
// shared/types/planos.ts

export interface Plano {
    _id: string;
    nome: string;
    descricao?: string;
    limiteAlunos: number;
    preco: number;
    duracao: number; // Duration in days
    tipo: 'free' | 'paid';
    ativo: boolean;
    createdAt: Date;
    updatedAt: Date;
}

export interface TokenAvulso {
    _id: string;
    personalTrainerId: string;
    quantidade: number;
    dataVencimento: Date;
    ativo: boolean;
    motivoAdicao?: string;
    adicionadoPorAdmin: string | PersonalTrainerBasicInfo;
    createdAt: Date;
    updatedAt: Date;
}

export interface PersonalPlano {
    _id: string;
    personalTrainerId: string;
    planoId: string | Plano;
    dataInicio: Date;
    dataVencimento: Date;
    ativo: boolean;
    atribuidoPorAdmin: string | PersonalTrainerBasicInfo;
    motivoAtribuicao?: string;
    createdAt: Date;
    updatedAt: Date;
}

export interface PersonalTrainerBasicInfo {
    _id: string;
    nome: string;
    email?: string;
}

export interface PersonalPlanStatus {
    plano: Plano | null;
    personalPlano: PersonalPlano | null;
    limiteAtual: number;
    alunosAtivos: number;
    tokensAvulsos: number;
    percentualUso?: number;
    podeAtivarMais?: boolean;
    vagasDisponiveis?: number;
}

export interface PersonalTrainerWithStatus {
    _id: string;
    nome: string;
    email: string;
    createdAt: Date;
    planoAtual: string;
    planoId: string | null;
    planoDisplay: string;
    alunosAtivos: number;
    limiteAlunos: number; // Total limit including base plan + active tokens
    percentualUso: number;
    hasActivePlan: boolean;
    isExpired: boolean; // New field to indicate if current plan is expired
    dataInicio: Date | null; // Plan start date (preserved even when expired)
    dataVencimento: Date | null; // Plan expiration date (preserved even when expired)
    planDetails: {
        id: string;
        nome: string;
        limiteAlunos: number;
        preco: number;
    } | null;
}

export interface PersonalStatusAdmin {
    personalInfo: PersonalTrainerBasicInfo;
    currentPlan: PersonalPlanStatus;
    activeTokens: TokenAvulso[];
    expiredTokens: TokenAvulso[];
    totalActiveTokens: number;
    activeStudents: number;
    totalLimit: number;
    planHistory: PersonalPlano[];
}

export interface StudentLimitStatus {
    canActivate: boolean;
    currentLimit: number;
    activeStudents: number;
    availableSlots: number;
}

// Form interfaces for admin operations
export interface AssignPlanForm {
    planoId: string;
    customDuration?: number;
    motivo?: string;
}

export interface AddTokensForm {
    quantidade: number;
    customDays?: number;
    motivo?: string;
}

// API Response types
export interface ApiResponse<T> {
    message?: string;
    data?: T;
    error?: string;
    code?: string;
}

export interface StudentLimitExceededResponse {
    message: string;
    code: 'STUDENT_LIMIT_EXCEEDED';
    data: {
        currentLimit: number;
        activeStudents: number;
        availableSlots: number;
        requestedQuantity?: number;
    };
}

export interface CleanupResult {
    message: string;
    plansDeactivated: number;
    tokensDeactivated: number;
}
===== ./shared/types/sessaoTypes.ts =====
export const TIPOS_COMPROMISSO = ['avaliacao', 'checkin', 'treino_acompanhado', 'outro'] as const;
export type TipoCompromisso = typeof TIPOS_COMPROMISSO[number];

// Outras interfaces de Sessao/Compromisso que o frontend precise
export interface CompromissoDataShareable { // Exemplo
  _id: string;
  sessionDate: string; 
  tipoCompromisso: TipoCompromisso;
  notes?: string;
  status: "pending" | "confirmed" | "completed" | "cancelled";
  studentId: { _id: string; nome: string; } | string; 
  // trainerId não precisa ser exposto ao frontend se ele já sabe quem é o trainer
}
===== ./tailwind.config.ts =====
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      // Enhanced Border Radius System
      borderRadius: {
        sm: "var(--radius-sm)",
        md: "var(--radius-md)",
        lg: "var(--radius-lg)",
        xl: "var(--radius-xl)",
        "2xl": "calc(var(--radius-xl) + 0.5rem)",
        "3xl": "calc(var(--radius-xl) + 1rem)",
      },
      
      // Enhanced Color System
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        success: {
          DEFAULT: "hsl(var(--success))",
          foreground: "hsl(var(--success-foreground))",
        },
        warning: {
          DEFAULT: "hsl(var(--warning))",
          foreground: "hsl(var(--warning-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      
      // Enhanced Shadow System
      boxShadow: {
        'sm': 'var(--shadow-sm)',
        'md': 'var(--shadow-md)',
        'lg': 'var(--shadow-lg)',
        'xl': 'var(--shadow-xl)',
        '2xl': 'var(--shadow-2xl)',
        'glass': '0 8px 32px 0 rgba(31, 38, 135, 0.15), inset 0 1px 0 0 rgba(255, 255, 255, 0.1)',
        'neumorphism': '6px 6px 12px rgba(0, 0, 0, 0.1), -6px -6px 12px rgba(255, 255, 255, 0.7)',
        'elevated': '0 4px 14px 0 rgba(0, 0, 0, 0.1), 0 2px 4px 0 rgba(0, 0, 0, 0.05)',
      },
      
      // Enhanced Spacing System (8px grid)
      spacing: {
        '18': '4.5rem',
        '88': '22rem',
        '128': '32rem',
        '144': '36rem',
      },
      
      // Enhanced Animation System
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        "fade-in": {
          "0%": { opacity: "0" },
          "100%": { opacity: "1" },
        },
        "slide-up": {
          "0%": { opacity: "0", transform: "translateY(10px)" },
          "100%": { opacity: "1", transform: "translateY(0)" },
        },
        "slide-down": {
          "0%": { opacity: "0", transform: "translateY(-10px)" },
          "100%": { opacity: "1", transform: "translateY(0)" },
        },
        "scale-in": {
          "0%": { opacity: "0", transform: "scale(0.95)" },
          "100%": { opacity: "1", transform: "scale(1)" },
        },
        "shimmer": {
          "0%": { transform: "translateX(-100%)" },
          "100%": { transform: "translateX(100%)" },
        },
        "pulse-glow": {
          "0%, 100%": { opacity: "1" },
          "50%": { opacity: "0.5" },
        },
      },
      
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "fade-in": "fade-in 0.3s ease-out",
        "slide-up": "slide-up 0.3s ease-out",
        "slide-down": "slide-down 0.3s ease-out",
        "scale-in": "scale-in 0.2s ease-out",
        "shimmer": "shimmer 2s infinite",
        "pulse-glow": "pulse-glow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      },
      
      // Enhanced Typography
      fontSize: {
        '2xs': ['0.625rem', { lineHeight: '0.75rem' }],
      },
      
      // Enhanced Backdrop Blur
      backdropBlur: {
        'xs': '2px',
      },
      
      // Enhanced Transitions
      transitionDuration: {
        '400': '400ms',
        '600': '600ms',
      },
      
      // Enhanced Z-Index Scale
      zIndex: {
        '60': '60',
        '70': '70',
        '80': '80',
        '90': '90',
        '100': '100',
      },
    },
  },
  plugins: [
    require("tailwindcss-animate"), 
    require("@tailwindcss/typography"),
  ],
} satisfies Config;

===== ./vite.config.ts =====
// /vite.config.ts (localizado na RAIZ do projeto)
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  root: 'client',

  plugins: [
    react(),
    VitePWA({
      // <<< INÍCIO DA ALTERAÇÃO >>>
      // Alterado para 'prompt' para permitir que a aplicação mostre um pop-up de atualização
      registerType: 'prompt', 
      // <<< FIM DA ALTERAÇÃO >>>
      injectRegister: 'auto',
      
      devOptions: {
        enabled: true,
      },
      
      workbox: {
        navigateFallback: '/index.html',
        navigateFallbackDenylist: [/^\/api\//],

        globPatterns: ['**/*.{js,css,html,ico,png,svg,json,woff,woff2,webp,jpg,jpeg}'],
        maximumFileSizeToCacheInBytes: 5 * 1024 * 1024,

        runtimeCaching: [
          {
            urlPattern: ({ url }) => url.pathname.startsWith('/api/'),
            handler: 'NetworkOnly', 
            options: {
              cacheName: 'api-cache',
              backgroundSync: {
                name: 'api-queue',
                options: {
                  maxRetentionTime: 24 * 60,
                },
              },
            },
          },
          {
            urlPattern: ({ url }) => url.origin === self.location.origin && !url.pathname.startsWith('/api/'),
            handler: 'NetworkFirst',
            options: {
              cacheName: 'app-assets',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 60 * 60 * 24 * 7, // 1 semana
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
              matchOptions: {
                ignoreVary: true,
              },
            },
          },
        ],
      },
      manifest: {
        name: 'DyFit',
        short_name: 'DyFit',
        description: 'Plataforma de gestão de treinos personalizada',
        theme_color: '#4f46e5',
        background_color: '#4f46e5',
        display: 'standalone',
        icons: [
          {
            src: '/pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: '/pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
          },
          {
            src: '/pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'any maskable',
          },
        ],
      },
    })
  ],
  
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'client/src'),
    },
  },
  
  server: {
    host: '0.0.0.0',
    port: 5173,
    allowedHosts: ['.gitpod.io'],
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      }
    }
  },

  build: {
    outDir: 'dist',
  }
});